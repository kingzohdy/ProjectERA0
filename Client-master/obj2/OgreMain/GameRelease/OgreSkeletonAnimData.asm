; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\OgreSkeletonAnimData.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5715
_DATA	ENDS
CONST	SEGMENT
$SG5715	DB	'bad allocation', 00H
	ORG $+1
_MAX_FLOAT DD	07f7fffffr			; 3.40282e+038
_ONE_PI	DD	040490fd0r			; 3.14159
_EPSILON DD	03727c5acr			; 1e-005
_RADS_PER_DEG DD 03c8efa35r			; 0.0174533
_DEGS_PER_RAD DD 042652ee1r			; 57.2958
$SG61136 DB	'SkeletonAnimData', 00H
CONST	ENDS
PUBLIC	??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MemoryDelegation::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::MemoryDelegation::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::MemoryDelegation::operator=
_TEXT	ENDS
PUBLIC	?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ	; Ogre::RuntimeClass::getBaseClass
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebaseobject.h
;	COMDAT ?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ PROC	; Ogre::RuntimeClass::getBaseClass, COMDAT
; _this$ = ecx

; 20   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 21   : 			return m_pBaseClass;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 22   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ ENDP	; Ogre::RuntimeClass::getBaseClass
_TEXT	ENDS
PUBLIC	?getClassName@RuntimeClass@Ogre@@QBEPBDXZ	; Ogre::RuntimeClass::getClassName
; Function compile flags: /Odtp
;	COMDAT ?getClassName@RuntimeClass@Ogre@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getClassName@RuntimeClass@Ogre@@QBEPBDXZ PROC		; Ogre::RuntimeClass::getClassName, COMDAT
; _this$ = ecx

; 25   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 26   : 			return m_pClassName; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 27   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getClassName@RuntimeClass@Ogre@@QBEPBDXZ ENDP		; Ogre::RuntimeClass::getClassName
_TEXT	ENDS
PUBLIC	?getVersion@RuntimeClass@Ogre@@QBEHXZ		; Ogre::RuntimeClass::getVersion
; Function compile flags: /Odtp
;	COMDAT ?getVersion@RuntimeClass@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getVersion@RuntimeClass@Ogre@@QBEHXZ PROC		; Ogre::RuntimeClass::getVersion, COMDAT
; _this$ = ecx

; 30   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 			return m_Version;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 32   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getVersion@RuntimeClass@Ogre@@QBEHXZ ENDP		; Ogre::RuntimeClass::getVersion
_TEXT	ENDS
PUBLIC	?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ ; Ogre::RuntimeClass::newObject
; Function compile flags: /Odtp
;	COMDAT ?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ PROC ; Ogre::RuntimeClass::newObject, COMDAT
; _this$ = ecx

; 35   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 36   : 			return (*m_pNewFunc)();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	ecx

; 37   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ ENDP ; Ogre::RuntimeClass::newObject
_TEXT	ENDS
PUBLIC	??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::RuntimeClass::operator=
; Function compile flags: /Odtp
;	COMDAT ??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::RuntimeClass::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::RuntimeClass::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::BaseObject::getRTTI
EXTRN	?m_RTTI@BaseObject@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::BaseObject::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::BaseObject::getRTTI, COMDAT
; _this$ = ecx

; 56   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 			return &m_RTTI;

	mov	eax, OFFSET ?m_RTTI@BaseObject@Ogre@@2VRuntimeClass@2@B ; Ogre::BaseObject::m_RTTI

; 58   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::BaseObject::getRTTI
_TEXT	ENDS
PUBLIC	?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z ; Ogre::BaseObject::isExactKindOf
; Function compile flags: /Odtp
;	COMDAT ?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_prtti$ = 8						; size = 4
?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z PROC ; Ogre::BaseObject::isExactKindOf, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			return (getRTTI() == prtti);

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	xor	ecx, ecx
	cmp	eax, DWORD PTR _prtti$[ebp]
	sete	cl
	mov	al, cl

; 63   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z ENDP ; Ogre::BaseObject::isExactKindOf
_TEXT	ENDS
PUBLIC	?release@BaseObject@Ogre@@UAEXXZ		; Ogre::BaseObject::release
; Function compile flags: /Odtp
;	COMDAT ?release@BaseObject@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?release@BaseObject@Ogre@@UAEXXZ PROC			; Ogre::BaseObject::release, COMDAT
; _this$ = ecx

; 68   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 			m_RefCount--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 70   : 			if(m_RefCount <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jg	SHORT $LN2@release

; 71   : 			{
; 72   : 				deleteThis();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
$LN2@release:

; 73   : 			}
; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@BaseObject@Ogre@@UAEXXZ ENDP			; Ogre::BaseObject::release
_TEXT	ENDS
PUBLIC	?addRef@BaseObject@Ogre@@UAEXXZ			; Ogre::BaseObject::addRef
; Function compile flags: /Odtp
;	COMDAT ?addRef@BaseObject@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?addRef@BaseObject@Ogre@@UAEXXZ PROC			; Ogre::BaseObject::addRef, COMDAT
; _this$ = ecx

; 77   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 			m_RefCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 79   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?addRef@BaseObject@Ogre@@UAEXXZ ENDP			; Ogre::BaseObject::addRef
_TEXT	ENDS
PUBLIC	?getRefCount@BaseObject@Ogre@@UAEHXZ		; Ogre::BaseObject::getRefCount
; Function compile flags: /Odtp
;	COMDAT ?getRefCount@BaseObject@Ogre@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRefCount@BaseObject@Ogre@@UAEHXZ PROC		; Ogre::BaseObject::getRefCount, COMDAT
; _this$ = ecx

; 82   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 			return m_RefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 84   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRefCount@BaseObject@Ogre@@UAEHXZ ENDP		; Ogre::BaseObject::getRefCount
_TEXT	ENDS
PUBLIC	?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::BaseObject::_serialize
; Function compile flags: /Odtp
;	COMDAT ?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
_version$ = 12						; size = 4
?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z PROC	; Ogre::BaseObject::_serialize, COMDAT
; _this$ = ecx

; 87   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z ENDP	; Ogre::BaseObject::_serialize
_TEXT	ENDS
PUBLIC	??_7BaseObject@Ogre@@6B@			; Ogre::BaseObject::`vftable'
PUBLIC	??0BaseObject@Ogre@@IAE@XZ			; Ogre::BaseObject::BaseObject
PUBLIC	??_R4BaseObject@Ogre@@6B@			; Ogre::BaseObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVBaseObject@Ogre@@@8			; Ogre::BaseObject `RTTI Type Descriptor'
PUBLIC	??_R3BaseObject@Ogre@@8				; Ogre::BaseObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2BaseObject@Ogre@@8				; Ogre::BaseObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@BaseObject@Ogre@@8		; Ogre::BaseObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@MemoryDelegation@Ogre@@8		; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AVMemoryDelegation@Ogre@@@8		; Ogre::MemoryDelegation `RTTI Type Descriptor'
PUBLIC	??_R3MemoryDelegation@Ogre@@8			; Ogre::MemoryDelegation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MemoryDelegation@Ogre@@8			; Ogre::MemoryDelegation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MemoryDelegation@Ogre@@8		; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EBaseObject@Ogre@@MAEPAXI@Z			; Ogre::BaseObject::`vector deleting destructor'
PUBLIC	?deleteThis@BaseObject@Ogre@@MAEXXZ		; Ogre::BaseObject::deleteThis
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R1A@?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MemoryDelegation@Ogre@@8 DD FLAT:??_R0?AVMemoryDelegation@Ogre@@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R2MemoryDelegation@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MemoryDelegation@Ogre@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R3MemoryDelegation@Ogre@@8 DD 00H			; Ogre::MemoryDelegation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMemoryDelegation@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMemoryDelegation@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MemoryDelegation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMemoryDelegation@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R13?0A@EA@MemoryDelegation@Ogre@@8 DD FLAT:??_R0?AVMemoryDelegation@Ogre@@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@BaseObject@Ogre@@8 DD FLAT:??_R0?AVBaseObject@Ogre@@@8 ; Ogre::BaseObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R2BaseObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8 ; Ogre::BaseObject::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R3BaseObject@Ogre@@8 DD 00H				; Ogre::BaseObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBaseObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVBaseObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::BaseObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBaseObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4BaseObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4BaseObject@Ogre@@6B@ DD 00H			; Ogre::BaseObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBaseObject@Ogre@@@8
	DD	FLAT:??_R3BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7BaseObject@Ogre@@6B@
CONST	SEGMENT
??_7BaseObject@Ogre@@6B@ DD FLAT:??_R4BaseObject@Ogre@@6B@ ; Ogre::BaseObject::`vftable'
	DD	FLAT:?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EBaseObject@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0BaseObject@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BaseObject@Ogre@@IAE@XZ PROC				; Ogre::BaseObject::BaseObject, COMDAT
; _this$ = ecx

; 92   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseObject@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 1

; 93   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BaseObject@Ogre@@IAE@XZ ENDP				; Ogre::BaseObject::BaseObject
_TEXT	ENDS
PUBLIC	??1BaseObject@Ogre@@MAE@XZ			; Ogre::BaseObject::~BaseObject
; Function compile flags: /Odtp
;	COMDAT ??1BaseObject@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1BaseObject@Ogre@@MAE@XZ PROC				; Ogre::BaseObject::~BaseObject, COMDAT
; _this$ = ecx

; 96   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseObject@Ogre@@6B@

; 97   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1BaseObject@Ogre@@MAE@XZ ENDP				; Ogre::BaseObject::~BaseObject
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deleteThis@BaseObject@Ogre@@MAEXXZ
_TEXT	SEGMENT
tv70 = -16						; size = 4
_this$ = -12						; size = 4
$T76202 = -8						; size = 4
$T76201 = -4						; size = 4
?deleteThis@BaseObject@Ogre@@MAEXXZ PROC		; Ogre::BaseObject::deleteThis, COMDAT
; _this$ = ecx

; 100  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 			delete this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T76202[ebp], eax
	mov	ecx, DWORD PTR $T76202[ebp]
	mov	DWORD PTR $T76201[ebp], ecx
	cmp	DWORD PTR $T76201[ebp], 0
	je	SHORT $LN3@deleteThis
	push	1
	mov	edx, DWORD PTR $T76201[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T76201[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN1@deleteThis
$LN3@deleteThis:
	mov	DWORD PTR tv70[ebp], 0
$LN1@deleteThis:

; 102  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?deleteThis@BaseObject@Ogre@@MAEXXZ ENDP		; Ogre::BaseObject::deleteThis
_TEXT	ENDS
PUBLIC	??0BaseObject@Ogre@@QAE@ABV01@@Z		; Ogre::BaseObject::BaseObject
; Function compile flags: /Odtp
;	COMDAT ??0BaseObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0BaseObject@Ogre@@QAE@ABV01@@Z PROC			; Ogre::BaseObject::BaseObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR ___that$[ebp], 0
	je	SHORT $LN3@BaseObject
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@BaseObject
$LN3@BaseObject:
	mov	DWORD PTR tv68[ebp], 0
$LN4@BaseObject:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7BaseObject@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BaseObject@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::BaseObject::BaseObject
_TEXT	ENDS
PUBLIC	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::BaseObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BaseObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BaseObject::operator=
_TEXT	ENDS
PUBLIC	??_GBaseObject@Ogre@@MAEPAXI@Z			; Ogre::BaseObject::`scalar deleting destructor'
EXTRN	??3MemoryDelegation@Ogre@@SAXPAXI@Z:PROC	; Ogre::MemoryDelegation::operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GBaseObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GBaseObject@Ogre@@MAEPAXI@Z PROC			; Ogre::BaseObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBaseObject@Ogre@@MAEPAXI@Z ENDP			; Ogre::BaseObject::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_VMemoryDelegation@Ogre@@SAXPAXI@Z:PROC	; Ogre::MemoryDelegation::operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_EBaseObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EBaseObject@Ogre@@MAEPAXI@Z PROC			; Ogre::BaseObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1BaseObject@Ogre@@MAE@XZ	; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	push	8
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EBaseObject@Ogre@@MAEPAXI@Z ENDP			; Ogre::BaseObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z	; Ogre::FixedString::handle2Ptr
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefixedstring.h
;	COMDAT ?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z
_TEXT	SEGMENT
_h$ = 8							; size = 4
?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z PROC		; Ogre::FixedString::handle2Ptr, COMDAT

; 22   : 		{

	push	ebp
	mov	ebp, esp

; 23   : 			return (const char *)h;

	mov	eax, DWORD PTR _h$[ebp]

; 24   : 		}

	pop	ebp
	ret	0
?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ENDP		; Ogre::FixedString::handle2Ptr
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@XZ			; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0FixedString@Ogre@@QAE@XZ PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 27   : 		FixedString() : m_StrHandle(NULL){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0FixedString@Ogre@@QAE@XZ ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PAX@Z			; Ogre::FixedString::FixedString
EXTRN	?addRef@FixedString@Ogre@@SAXPAX@Z:PROC		; Ogre::FixedString::addRef
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h$ = 8							; size = 4
??0FixedString@Ogre@@QAE@PAX@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 29   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [eax], ecx

; 30   : 			addRef(h);

	mov	edx, DWORD PTR _h$[ebp]
	push	edx
	call	?addRef@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::addRef
	add	esp, 4

; 31   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@PAX@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@ABV01@@Z		; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??0FixedString@Ogre@@QAE@ABV01@@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 34   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 35   : 			addRef(m_StrHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?addRef@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::addRef
	add	esp, 4

; 36   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PBD@Z			; Ogre::FixedString::FixedString
EXTRN	?insert@FixedString@Ogre@@SAPAXPBDH@Z:PROC	; Ogre::FixedString::insert
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstr$ = 8						; size = 4
??0FixedString@Ogre@@QAE@PBD@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 38   : 		FixedString(const char *pstr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 		{
; 40   : 			m_StrHandle = insert(pstr); 

	push	-1
	mov	eax, DWORD PTR _pstr$[ebp]
	push	eax
	call	?insert@FixedString@Ogre@@SAPAXPBDH@Z	; Ogre::FixedString::insert
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 41   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@PBD@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PBDI@Z			; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstr$ = 8						; size = 4
_len$ = 12						; size = 4
??0FixedString@Ogre@@QAE@PBDI@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 43   : 		FixedString(const char *pstr, size_t len)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 		{
; 45   : 			m_StrHandle = insert(pstr, (int)len); 

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pstr$[ebp]
	push	ecx
	call	?insert@FixedString@Ogre@@SAPAXPBDH@Z	; Ogre::FixedString::insert
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 46   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0FixedString@Ogre@@QAE@PBDI@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??1FixedString@Ogre@@QAE@XZ			; Ogre::FixedString::~FixedString
EXTRN	?release@FixedString@Ogre@@SAXPAX@Z:PROC	; Ogre::FixedString::release
; Function compile flags: /Odtp
;	COMDAT ??1FixedString@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1FixedString@Ogre@@QAE@XZ PROC			; Ogre::FixedString::~FixedString, COMDAT
; _this$ = ecx

; 49   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 			release(m_StrHandle); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?release@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::release
	add	esp, 4

; 51   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1FixedString@Ogre@@QAE@XZ ENDP			; Ogre::FixedString::~FixedString
_TEXT	ENDS
PUBLIC	??BFixedString@Ogre@@QBEPBDXZ			; Ogre::FixedString::operator char const *
; Function compile flags: /Odtp
;	COMDAT ??BFixedString@Ogre@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BFixedString@Ogre@@QBEPBDXZ PROC			; Ogre::FixedString::operator char const *, COMDAT
; _this$ = ecx

; 54   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 			return handle2Ptr(m_StrHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ; Ogre::FixedString::handle2Ptr
	add	esp, 4

; 56   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??BFixedString@Ogre@@QBEPBDXZ ENDP			; Ogre::FixedString::operator char const *
_TEXT	ENDS
PUBLIC	?getHandle@FixedString@Ogre@@QBEPAXXZ		; Ogre::FixedString::getHandle
; Function compile flags: /Odtp
;	COMDAT ?getHandle@FixedString@Ogre@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHandle@FixedString@Ogre@@QBEPAXXZ PROC		; Ogre::FixedString::getHandle, COMDAT
; _this$ = ecx

; 59   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 			return m_StrHandle;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 61   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getHandle@FixedString@Ogre@@QBEPAXXZ ENDP		; Ogre::FixedString::getHandle
_TEXT	ENDS
PUBLIC	?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ	; Ogre::Resource::getRTTI
EXTRN	?m_RTTI@Resource@Ogre@@2VRuntimeClass@2@B:BYTE	; Ogre::Resource::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreresource.h
;	COMDAT ?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::Resource::getRTTI, COMDAT
; _this$ = ecx

; 39   : 		DECLARE_RTTI_VIRTUAL(Resource)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@Resource@Ogre@@2VRuntimeClass@2@B ; Ogre::Resource::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::Resource::getRTTI
_TEXT	ENDS
PUBLIC	?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ ; Ogre::Resource::getResPath
; Function compile flags: /Odtp
;	COMDAT ?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ PROC	; Ogre::Resource::getResPath, COMDAT
; _this$ = ecx

; 44   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 			return m_ResPath;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8

; 46   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ ENDP	; Ogre::Resource::getResPath
_TEXT	ENDS
PUBLIC	?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z ; Ogre::Resource::setResPath
EXTRN	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z:PROC	; Ogre::FixedString::operator=
; Function compile flags: /Odtp
;	COMDAT ?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_path$ = 8						; size = 4
?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z PROC	; Ogre::Resource::setResPath, COMDAT
; _this$ = ecx

; 48   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 			m_ResPath = path;

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FixedString::operator=

; 50   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z ENDP	; Ogre::Resource::setResPath
_TEXT	ENDS
PUBLIC	??_7Resource@Ogre@@6B@				; Ogre::Resource::`vftable'
PUBLIC	??0Resource@Ogre@@IAE@XZ			; Ogre::Resource::Resource
PUBLIC	??_R4Resource@Ogre@@6B@				; Ogre::Resource::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVResource@Ogre@@@8			; Ogre::Resource `RTTI Type Descriptor'
PUBLIC	??_R3Resource@Ogre@@8				; Ogre::Resource::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Resource@Ogre@@8				; Ogre::Resource::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Resource@Ogre@@8			; Ogre::Resource::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EResource@Ogre@@MAEPAXI@Z			; Ogre::Resource::`vector deleting destructor'
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?release@Resource@Ogre@@UAEXXZ:PROC		; Ogre::Resource::release
EXTRN	?addRef@Resource@Ogre@@UAEXXZ:PROC		; Ogre::Resource::addRef
EXTRN	?getRefCount@Resource@Ogre@@UAEHXZ:PROC		; Ogre::Resource::getRefCount
;	COMDAT ??_R1A@?0A@EA@Resource@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Resource@Ogre@@8 DD FLAT:??_R0?AVResource@Ogre@@@8 ; Ogre::Resource::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Resource@Ogre@@8
rdata$r	SEGMENT
??_R2Resource@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Resource@Ogre@@8 ; Ogre::Resource::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3Resource@Ogre@@8
rdata$r	SEGMENT
??_R3Resource@Ogre@@8 DD 00H				; Ogre::Resource::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVResource@Ogre@@@8
_DATA	SEGMENT
??_R0?AVResource@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Resource `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVResource@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Resource@Ogre@@6B@
rdata$r	SEGMENT
??_R4Resource@Ogre@@6B@ DD 00H				; Ogre::Resource::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVResource@Ogre@@@8
	DD	FLAT:??_R3Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Resource@Ogre@@6B@
CONST	SEGMENT
??_7Resource@Ogre@@6B@ DD FLAT:??_R4Resource@Ogre@@6B@	; Ogre::Resource::`vftable'
	DD	FLAT:?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EResource@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Resource@Ogre@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@IAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@IAE@XZ$1
__ehfuncinfo$??0Resource@Ogre@@IAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Resource@Ogre@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Resource@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Resource@Ogre@@IAE@XZ PROC				; Ogre::Resource::Resource, COMDAT
; _this$ = ecx

; 72   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Resource@Ogre@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@IAE@XZ		; Ogre::BaseObject::BaseObject
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Resource@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::FixedString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 73   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Resource@Ogre@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0Resource@Ogre@@IAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??0Resource@Ogre@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Resource@Ogre@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Resource@Ogre@@IAE@XZ ENDP				; Ogre::Resource::Resource
PUBLIC	??1Resource@Ogre@@MAE@XZ			; Ogre::Resource::~Resource
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Resource@Ogre@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Resource@Ogre@@MAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Resource@Ogre@@MAE@XZ$1
__ehfuncinfo$??1Resource@Ogre@@MAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1Resource@Ogre@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1Resource@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Resource@Ogre@@MAE@XZ PROC				; Ogre::Resource::~Resource, COMDAT
; _this$ = ecx

; 76   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Resource@Ogre@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Resource@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 77   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Resource@Ogre@@MAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??1Resource@Ogre@@MAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??1Resource@Ogre@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Resource@Ogre@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Resource@Ogre@@MAE@XZ ENDP				; Ogre::Resource::~Resource
PUBLIC	??0Resource@Ogre@@QAE@ABV01@@Z			; Ogre::Resource::Resource
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Resource@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0Resource@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Resource@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Resource@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Resource@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Resource::Resource, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Resource@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7Resource@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0FixedString@Ogre@@QAE@ABV01@@Z	; Ogre::FixedString::FixedString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??0Resource@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Resource@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Resource@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Resource::Resource
PUBLIC	??4Resource@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Resource::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Resource@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Resource@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::Resource::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FixedString::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Resource@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::Resource::operator=
_TEXT	ENDS
PUBLIC	??_GResource@Ogre@@MAEPAXI@Z			; Ogre::Resource::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GResource@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GResource@Ogre@@MAEPAXI@Z PROC			; Ogre::Resource::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GResource@Ogre@@MAEPAXI@Z ENDP			; Ogre::Resource::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EResource@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EResource@Ogre@@MAEPAXI@Z PROC			; Ogre::Resource::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@2
	push	OFFSET ??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@2
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@2
$LN3@vector@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@2
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EResource@Ogre@@MAEPAXI@Z ENDP			; Ogre::Resource::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7DataStream@Ogre@@6B@			; Ogre::DataStream::`vftable'
PUBLIC	??0DataStream@Ogre@@QAE@XZ			; Ogre::DataStream::DataStream
PUBLIC	??_R4DataStream@Ogre@@6B@			; Ogre::DataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDataStream@Ogre@@@8			; Ogre::DataStream `RTTI Type Descriptor'
PUBLIC	??_R3DataStream@Ogre@@8				; Ogre::DataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DataStream@Ogre@@8				; Ogre::DataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DataStream@Ogre@@8		; Ogre::DataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDataStream@Ogre@@UAEPAXI@Z			; Ogre::DataStream::`vector deleting destructor'
PUBLIC	?size@DataStream@Ogre@@UBEIXZ			; Ogre::DataStream::size
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__purecall:PROC
EXTRN	?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::DataStream::readLine
EXTRN	?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:PROC ; Ogre::DataStream::getLine
EXTRN	?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:PROC ; Ogre::DataStream::getAsString
EXTRN	?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::DataStream::skipLine
;	COMDAT ??_R1A@?0A@EA@DataStream@Ogre@@8
; File i:\svnroot\client\ogremain\ogredatastream.h
rdata$r	SEGMENT
??_R1A@?0A@EA@DataStream@Ogre@@8 DD FLAT:??_R0?AVDataStream@Ogre@@@8 ; Ogre::DataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DataStream@Ogre@@8
rdata$r	SEGMENT
??_R2DataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8 ; Ogre::DataStream::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DataStream@Ogre@@8
rdata$r	SEGMENT
??_R3DataStream@Ogre@@8 DD 00H				; Ogre::DataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::DataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4DataStream@Ogre@@6B@ DD 00H			; Ogre::DataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDataStream@Ogre@@@8
	DD	FLAT:??_R3DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DataStream@Ogre@@6B@
CONST	SEGMENT
??_7DataStream@Ogre@@6B@ DD FLAT:??_R4DataStream@Ogre@@6B@ ; Ogre::DataStream::`vftable'
	DD	FLAT:??_EDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@XZ$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0DataStream@Ogre@@QAE@XZ PROC				; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx

; 68   : 		DataStream() : mSize(0) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@XZ ENDP				; Ogre::DataStream::DataStream
PUBLIC	??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ogre::DataStream::DataStream
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx

; 70   : 		DataStream(const String& name) : mName(name), mSize(0) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Ogre::DataStream::DataStream
PUBLIC	?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Ogre::DataStream::getName
; Function compile flags: /Odtp
;	COMDAT ?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Ogre::DataStream::getName, COMDAT
; _this$ = ecx

; 72   : 		const String& getName(void) { return mName; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Ogre::DataStream::getName
_TEXT	ENDS
PUBLIC	??1DataStream@Ogre@@UAE@XZ			; Ogre::DataStream::~DataStream
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1DataStream@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DataStream@Ogre@@UAE@XZ$0
__ehfuncinfo$??1DataStream@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1DataStream@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1DataStream@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1DataStream@Ogre@@UAE@XZ PROC				; Ogre::DataStream::~DataStream, COMDAT
; _this$ = ecx

; 73   : 		virtual ~DataStream() {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DataStream@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DataStream@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1DataStream@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1DataStream@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1DataStream@Ogre@@UAE@XZ ENDP				; Ogre::DataStream::~DataStream
; Function compile flags: /Odtp
;	COMDAT ?size@DataStream@Ogre@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@DataStream@Ogre@@UBEIXZ PROC			; Ogre::DataStream::size, COMDAT
; _this$ = ecx

; 157  : 		virtual size_t size(void) const { return mSize; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?size@DataStream@Ogre@@UBEIXZ ENDP			; Ogre::DataStream::size
_TEXT	ENDS
PUBLIC	??0DataStream@Ogre@@QAE@ABV01@@Z		; Ogre::DataStream::DataStream
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0DataStream@Ogre@@QAE@ABV01@@Z PROC			; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::DataStream::DataStream
PUBLIC	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::DataStream::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DataStream@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::DataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::DataStream::operator=
_TEXT	ENDS
PUBLIC	??_GDataStream@Ogre@@UAEPAXI@Z			; Ogre::DataStream::`scalar deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDataStream@Ogre@@UAEPAXI@Z PROC			; Ogre::DataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDataStream@Ogre@@UAEPAXI@Z ENDP			; Ogre::DataStream::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp
;	COMDAT ??_EDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDataStream@Ogre@@UAEPAXI@Z PROC			; Ogre::DataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@3
	push	OFFSET ??1DataStream@Ogre@@UAE@XZ	; Ogre::DataStream::~DataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@3
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@3
$LN3@vector@3:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@3:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDataStream@Ogre@@UAEPAXI@Z ENDP			; Ogre::DataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ		; Ogre::MemoryDataStream::getPtr
; Function compile flags: /Odtp
;	COMDAT ?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ PROC		; Ogre::MemoryDataStream::getPtr, COMDAT
; _this$ = ecx

; 267  : 		uchar* getPtr(void) { return mData; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ ENDP		; Ogre::MemoryDataStream::getPtr
_TEXT	ENDS
PUBLIC	?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ	; Ogre::MemoryDataStream::getCurrentPtr
; Function compile flags: /Odtp
;	COMDAT ?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ PROC	; Ogre::MemoryDataStream::getCurrentPtr, COMDAT
; _this$ = ecx

; 270  : 		uchar* getCurrentPtr(void) { return mPos; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ ENDP	; Ogre::MemoryDataStream::getCurrentPtr
_TEXT	ENDS
PUBLIC	?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ	; Ogre::MemoryDataStream::getMemoryImage
; Function compile flags: /Odtp
;	COMDAT ?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ PROC	; Ogre::MemoryDataStream::getMemoryImage, COMDAT
; _this$ = ecx

; 307  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 308  : 			return mData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 309  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ ENDP	; Ogre::MemoryDataStream::getMemoryImage
_TEXT	ENDS
PUBLIC	?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z ; Ogre::MemoryDataStream::setFreeOnClose
; Function compile flags: /Odtp
;	COMDAT ?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_freeOnClose$ = 8					; size = 4
?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z PROC ; Ogre::MemoryDataStream::setFreeOnClose, COMDAT
; _this$ = ecx

; 313  : 		void setFreeOnClose(void (*freeOnClose)(void *)) { mFreeOnClose = freeOnClose; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _freeOnClose$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z ENDP ; Ogre::MemoryDataStream::setFreeOnClose
_TEXT	ENDS
PUBLIC	??_7MemoryDataStream@Ogre@@6B@			; Ogre::MemoryDataStream::`vftable'
PUBLIC	??0MemoryDataStream@Ogre@@QAE@ABV01@@Z		; Ogre::MemoryDataStream::MemoryDataStream
PUBLIC	??_R4MemoryDataStream@Ogre@@6B@			; Ogre::MemoryDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMemoryDataStream@Ogre@@@8		; Ogre::MemoryDataStream `RTTI Type Descriptor'
PUBLIC	??_R3MemoryDataStream@Ogre@@8			; Ogre::MemoryDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MemoryDataStream@Ogre@@8			; Ogre::MemoryDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MemoryDataStream@Ogre@@8		; Ogre::MemoryDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EMemoryDataStream@Ogre@@UAEPAXI@Z		; Ogre::MemoryDataStream::`vector deleting destructor'
EXTRN	?read@MemoryDataStream@Ogre@@UAEIPAXI@Z:PROC	; Ogre::MemoryDataStream::read
EXTRN	?write@MemoryDataStream@Ogre@@UAEIPBXI@Z:PROC	; Ogre::MemoryDataStream::write
EXTRN	?readLine@MemoryDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::MemoryDataStream::readLine
EXTRN	?skipLine@MemoryDataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::MemoryDataStream::skipLine
EXTRN	?skip@MemoryDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::MemoryDataStream::skip
EXTRN	?seek@MemoryDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::MemoryDataStream::seek
EXTRN	?tell@MemoryDataStream@Ogre@@UBEIXZ:PROC	; Ogre::MemoryDataStream::tell
EXTRN	?eof@MemoryDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::MemoryDataStream::eof
EXTRN	?close@MemoryDataStream@Ogre@@UAEXXZ:PROC	; Ogre::MemoryDataStream::close
;	COMDAT ??_R1A@?0A@EA@MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MemoryDataStream@Ogre@@8 DD FLAT:??_R0?AVMemoryDataStream@Ogre@@@8 ; Ogre::MemoryDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2MemoryDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MemoryDataStream@Ogre@@8 ; Ogre::MemoryDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3MemoryDataStream@Ogre@@8 DD 00H			; Ogre::MemoryDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMemoryDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMemoryDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MemoryDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMemoryDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MemoryDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4MemoryDataStream@Ogre@@6B@ DD 00H			; Ogre::MemoryDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMemoryDataStream@Ogre@@@8
	DD	FLAT:??_R3MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7MemoryDataStream@Ogre@@6B@
CONST	SEGMENT
??_7MemoryDataStream@Ogre@@6B@ DD FLAT:??_R4MemoryDataStream@Ogre@@6B@ ; Ogre::MemoryDataStream::`vftable'
	DD	FLAT:??_EMemoryDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@MemoryDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@MemoryDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@MemoryDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@MemoryDataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@MemoryDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@MemoryDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@MemoryDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@MemoryDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@MemoryDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0MemoryDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::MemoryDataStream::MemoryDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7MemoryDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+44], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MemoryDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::MemoryDataStream::MemoryDataStream
PUBLIC	??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MemoryDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::MemoryDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+48], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::MemoryDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GMemoryDataStream@Ogre@@UAEPAXI@Z		; Ogre::MemoryDataStream::`scalar deleting destructor'
EXTRN	??1MemoryDataStream@Ogre@@UAE@XZ:PROC		; Ogre::MemoryDataStream::~MemoryDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GMemoryDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMemoryDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::MemoryDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GMemoryDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::MemoryDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EMemoryDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EMemoryDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::MemoryDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@4
	push	OFFSET ??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@4
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@4
$LN3@vector@4:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@4:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EMemoryDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::MemoryDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7FileStreamDataStream@Ogre@@6B@		; Ogre::FileStreamDataStream::`vftable'
PUBLIC	??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z	; Ogre::FileStreamDataStream::FileStreamDataStream
PUBLIC	??_R4FileStreamDataStream@Ogre@@6B@		; Ogre::FileStreamDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFileStreamDataStream@Ogre@@@8		; Ogre::FileStreamDataStream `RTTI Type Descriptor'
PUBLIC	??_R3FileStreamDataStream@Ogre@@8		; Ogre::FileStreamDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileStreamDataStream@Ogre@@8		; Ogre::FileStreamDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8	; Ogre::FileStreamDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EFileStreamDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileStreamDataStream::`vector deleting destructor'
EXTRN	?read@FileStreamDataStream@Ogre@@UAEIPAXI@Z:PROC ; Ogre::FileStreamDataStream::read
EXTRN	?write@FileStreamDataStream@Ogre@@UAEIPBXI@Z:PROC ; Ogre::FileStreamDataStream::write
EXTRN	?readLine@FileStreamDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::FileStreamDataStream::readLine
EXTRN	?skip@FileStreamDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::FileStreamDataStream::skip
EXTRN	?seek@FileStreamDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::FileStreamDataStream::seek
EXTRN	?tell@FileStreamDataStream@Ogre@@UBEIXZ:PROC	; Ogre::FileStreamDataStream::tell
EXTRN	?eof@FileStreamDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::FileStreamDataStream::eof
EXTRN	?close@FileStreamDataStream@Ogre@@UAEXXZ:PROC	; Ogre::FileStreamDataStream::close
EXTRN	?getMemoryImage@FileStreamDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::FileStreamDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8 DD FLAT:??_R0?AVFileStreamDataStream@Ogre@@@8 ; Ogre::FileStreamDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2FileStreamDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8 ; Ogre::FileStreamDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3FileStreamDataStream@Ogre@@8 DD 00H		; Ogre::FileStreamDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileStreamDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVFileStreamDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::FileStreamDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileStreamDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FileStreamDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4FileStreamDataStream@Ogre@@6B@ DD 00H		; Ogre::FileStreamDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFileStreamDataStream@Ogre@@@8
	DD	FLAT:??_R3FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7FileStreamDataStream@Ogre@@6B@
CONST	SEGMENT
??_7FileStreamDataStream@Ogre@@6B@ DD FLAT:??_R4FileStreamDataStream@Ogre@@6B@ ; Ogre::FileStreamDataStream::`vftable'
	DD	FLAT:??_EFileStreamDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@FileStreamDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@FileStreamDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@FileStreamDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@FileStreamDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@FileStreamDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@FileStreamDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@FileStreamDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@FileStreamDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@FileStreamDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::FileStreamDataStream::FileStreamDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7FileStreamDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+40]
	mov	BYTE PTR [edx+40], cl
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::FileStreamDataStream::FileStreamDataStream
PUBLIC	??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FileStreamDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::FileStreamDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+40]
	mov	BYTE PTR [ecx+40], al
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::FileStreamDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GFileStreamDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileStreamDataStream::`scalar deleting destructor'
EXTRN	??1FileStreamDataStream@Ogre@@UAE@XZ:PROC	; Ogre::FileStreamDataStream::~FileStreamDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GFileStreamDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFileStreamDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileStreamDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileStreamDataStream@Ogre@@UAE@XZ	; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFileStreamDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileStreamDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EFileStreamDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EFileStreamDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileStreamDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@5
	push	OFFSET ??1FileStreamDataStream@Ogre@@UAE@XZ ; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@5
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@5:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@5
$LN3@vector@5:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileStreamDataStream@Ogre@@UAE@XZ	; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@5:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@5:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EFileStreamDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileStreamDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7FileHandleDataStream@Ogre@@6B@		; Ogre::FileHandleDataStream::`vftable'
PUBLIC	??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z	; Ogre::FileHandleDataStream::FileHandleDataStream
PUBLIC	??_R4FileHandleDataStream@Ogre@@6B@		; Ogre::FileHandleDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFileHandleDataStream@Ogre@@@8		; Ogre::FileHandleDataStream `RTTI Type Descriptor'
PUBLIC	??_R3FileHandleDataStream@Ogre@@8		; Ogre::FileHandleDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileHandleDataStream@Ogre@@8		; Ogre::FileHandleDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8	; Ogre::FileHandleDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EFileHandleDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileHandleDataStream::`vector deleting destructor'
EXTRN	?read@FileHandleDataStream@Ogre@@UAEIPAXI@Z:PROC ; Ogre::FileHandleDataStream::read
EXTRN	?write@FileHandleDataStream@Ogre@@UAEIPBXI@Z:PROC ; Ogre::FileHandleDataStream::write
EXTRN	?skip@FileHandleDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::FileHandleDataStream::skip
EXTRN	?seek@FileHandleDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::FileHandleDataStream::seek
EXTRN	?tell@FileHandleDataStream@Ogre@@UBEIXZ:PROC	; Ogre::FileHandleDataStream::tell
EXTRN	?eof@FileHandleDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::FileHandleDataStream::eof
EXTRN	?close@FileHandleDataStream@Ogre@@UAEXXZ:PROC	; Ogre::FileHandleDataStream::close
EXTRN	?getMemoryImage@FileHandleDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::FileHandleDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8 DD FLAT:??_R0?AVFileHandleDataStream@Ogre@@@8 ; Ogre::FileHandleDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2FileHandleDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8 ; Ogre::FileHandleDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3FileHandleDataStream@Ogre@@8 DD 00H		; Ogre::FileHandleDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileHandleDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVFileHandleDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::FileHandleDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileHandleDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FileHandleDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4FileHandleDataStream@Ogre@@6B@ DD 00H		; Ogre::FileHandleDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFileHandleDataStream@Ogre@@@8
	DD	FLAT:??_R3FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7FileHandleDataStream@Ogre@@6B@
CONST	SEGMENT
??_7FileHandleDataStream@Ogre@@6B@ DD FLAT:??_R4FileHandleDataStream@Ogre@@6B@ ; Ogre::FileHandleDataStream::`vftable'
	DD	FLAT:??_EFileHandleDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@FileHandleDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@FileHandleDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@FileHandleDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@FileHandleDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@FileHandleDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@FileHandleDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@FileHandleDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@FileHandleDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::FileHandleDataStream::FileHandleDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7FileHandleDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::FileHandleDataStream::FileHandleDataStream
PUBLIC	??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FileHandleDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::FileHandleDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::FileHandleDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GFileHandleDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileHandleDataStream::`scalar deleting destructor'
EXTRN	??1FileHandleDataStream@Ogre@@UAE@XZ:PROC	; Ogre::FileHandleDataStream::~FileHandleDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GFileHandleDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFileHandleDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileHandleDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileHandleDataStream@Ogre@@UAE@XZ	; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFileHandleDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileHandleDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EFileHandleDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EFileHandleDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileHandleDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@6
	push	OFFSET ??1FileHandleDataStream@Ogre@@UAE@XZ ; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@6
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@6:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@6
$LN3@vector@6:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileHandleDataStream@Ogre@@UAE@XZ	; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@6:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@6:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EFileHandleDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileHandleDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7DataStreamObject@Ogre@@6B@			; Ogre::DataStreamObject::`vftable'
PUBLIC	??1DataStreamObject@Ogre@@MAE@XZ		; Ogre::DataStreamObject::~DataStreamObject
PUBLIC	??_R4DataStreamObject@Ogre@@6B@			; Ogre::DataStreamObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDataStreamObject@Ogre@@@8		; Ogre::DataStreamObject `RTTI Type Descriptor'
PUBLIC	??_R3DataStreamObject@Ogre@@8			; Ogre::DataStreamObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DataStreamObject@Ogre@@8			; Ogre::DataStreamObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DataStreamObject@Ogre@@8		; Ogre::DataStreamObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDataStreamObject@Ogre@@MAEPAXI@Z		; Ogre::DataStreamObject::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DataStreamObject@Ogre@@8 DD FLAT:??_R0?AVDataStreamObject@Ogre@@@8 ; Ogre::DataStreamObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R2DataStreamObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DataStreamObject@Ogre@@8 ; Ogre::DataStreamObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R3DataStreamObject@Ogre@@8 DD 00H			; Ogre::DataStreamObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDataStreamObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDataStreamObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::DataStreamObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDataStreamObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DataStreamObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4DataStreamObject@Ogre@@6B@ DD 00H			; Ogre::DataStreamObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDataStreamObject@Ogre@@@8
	DD	FLAT:??_R3DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DataStreamObject@Ogre@@6B@
CONST	SEGMENT
??_7DataStreamObject@Ogre@@6B@ DD FLAT:??_R4DataStreamObject@Ogre@@6B@ ; Ogre::DataStreamObject::`vftable'
	DD	FLAT:??_EDataStreamObject@Ogre@@MAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??1DataStreamObject@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DataStreamObject@Ogre@@MAE@XZ PROC			; Ogre::DataStreamObject::~DataStreamObject, COMDAT
; _this$ = ecx

; 445  : 		virtual ~DataStreamObject(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1DataStreamObject@Ogre@@MAE@XZ ENDP			; Ogre::DataStreamObject::~DataStreamObject
_TEXT	ENDS
PUBLIC	??0DataStreamObject@Ogre@@QAE@XZ		; Ogre::DataStreamObject::DataStreamObject
; Function compile flags: /Odtp
;	COMDAT ??0DataStreamObject@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DataStreamObject@Ogre@@QAE@XZ PROC			; Ogre::DataStreamObject::DataStreamObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DataStreamObject@Ogre@@QAE@XZ ENDP			; Ogre::DataStreamObject::DataStreamObject
_TEXT	ENDS
PUBLIC	??0DataStreamObject@Ogre@@QAE@ABV01@@Z		; Ogre::DataStreamObject::DataStreamObject
; Function compile flags: /Odtp
;	COMDAT ??0DataStreamObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0DataStreamObject@Ogre@@QAE@ABV01@@Z PROC		; Ogre::DataStreamObject::DataStreamObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0DataStreamObject@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::DataStreamObject::DataStreamObject
_TEXT	ENDS
PUBLIC	??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::DataStreamObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::DataStreamObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::DataStreamObject::operator=
_TEXT	ENDS
PUBLIC	??_GDataStreamObject@Ogre@@MAEPAXI@Z		; Ogre::DataStreamObject::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GDataStreamObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDataStreamObject@Ogre@@MAEPAXI@Z PROC		; Ogre::DataStreamObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@7
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDataStreamObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::DataStreamObject::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EDataStreamObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDataStreamObject@Ogre@@MAEPAXI@Z PROC		; Ogre::DataStreamObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@7
	push	OFFSET ??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@7
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@7:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@7
$LN3@vector@7:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@7
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@7:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@7:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDataStreamObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::DataStreamObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7ObjectDataStream@Ogre@@6B@			; Ogre::ObjectDataStream::`vftable'
PUBLIC	??0ObjectDataStream@Ogre@@QAE@ABV01@@Z		; Ogre::ObjectDataStream::ObjectDataStream
PUBLIC	??_R4ObjectDataStream@Ogre@@6B@			; Ogre::ObjectDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVObjectDataStream@Ogre@@@8		; Ogre::ObjectDataStream `RTTI Type Descriptor'
PUBLIC	??_R3ObjectDataStream@Ogre@@8			; Ogre::ObjectDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ObjectDataStream@Ogre@@8			; Ogre::ObjectDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ObjectDataStream@Ogre@@8		; Ogre::ObjectDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EObjectDataStream@Ogre@@UAEPAXI@Z		; Ogre::ObjectDataStream::`vector deleting destructor'
EXTRN	?read@ObjectDataStream@Ogre@@UAEIPAXI@Z:PROC	; Ogre::ObjectDataStream::read
EXTRN	?write@ObjectDataStream@Ogre@@UAEIPBXI@Z:PROC	; Ogre::ObjectDataStream::write
EXTRN	?skip@ObjectDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::ObjectDataStream::skip
EXTRN	?seek@ObjectDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::ObjectDataStream::seek
EXTRN	?tell@ObjectDataStream@Ogre@@UBEIXZ:PROC	; Ogre::ObjectDataStream::tell
EXTRN	?eof@ObjectDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::ObjectDataStream::eof
EXTRN	?size@ObjectDataStream@Ogre@@UBEIXZ:PROC	; Ogre::ObjectDataStream::size
EXTRN	?close@ObjectDataStream@Ogre@@UAEXXZ:PROC	; Ogre::ObjectDataStream::close
EXTRN	?getMemoryImage@ObjectDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::ObjectDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ObjectDataStream@Ogre@@8 DD FLAT:??_R0?AVObjectDataStream@Ogre@@@8 ; Ogre::ObjectDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2ObjectDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@ObjectDataStream@Ogre@@8 ; Ogre::ObjectDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3ObjectDataStream@Ogre@@8 DD 00H			; Ogre::ObjectDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVObjectDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVObjectDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::ObjectDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVObjectDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ObjectDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4ObjectDataStream@Ogre@@6B@ DD 00H			; Ogre::ObjectDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVObjectDataStream@Ogre@@@8
	DD	FLAT:??_R3ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7ObjectDataStream@Ogre@@6B@
CONST	SEGMENT
??_7ObjectDataStream@Ogre@@6B@ DD FLAT:??_R4ObjectDataStream@Ogre@@6B@ ; Ogre::ObjectDataStream::`vftable'
	DD	FLAT:??_EObjectDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@ObjectDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@ObjectDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@ObjectDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@ObjectDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@ObjectDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@ObjectDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@ObjectDataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@ObjectDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@ObjectDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0ObjectDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::ObjectDataStream::ObjectDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ObjectDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ObjectDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::ObjectDataStream::ObjectDataStream
PUBLIC	??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::ObjectDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::ObjectDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::ObjectDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GObjectDataStream@Ogre@@UAEPAXI@Z		; Ogre::ObjectDataStream::`scalar deleting destructor'
EXTRN	??1ObjectDataStream@Ogre@@UAE@XZ:PROC		; Ogre::ObjectDataStream::~ObjectDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GObjectDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GObjectDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::ObjectDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GObjectDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::ObjectDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EObjectDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EObjectDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::ObjectDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@8
	push	OFFSET ??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@8
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@8:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@8
$LN3@vector@8:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@8:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@8:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EObjectDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::ObjectDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7Archive@Ogre@@6B@				; Ogre::Archive::`vftable'
PUBLIC	??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z	; Ogre::Archive::Archive
PUBLIC	??_R4Archive@Ogre@@6B@				; Ogre::Archive::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVArchive@Ogre@@@8			; Ogre::Archive `RTTI Type Descriptor'
PUBLIC	??_R3Archive@Ogre@@8				; Ogre::Archive::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Archive@Ogre@@8				; Ogre::Archive::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Archive@Ogre@@8			; Ogre::Archive::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EArchive@Ogre@@UAEPAXI@Z			; Ogre::Archive::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@Archive@Ogre@@8
; File i:\svnroot\client\ogremain\ogrearchive.h
rdata$r	SEGMENT
??_R1A@?0A@EA@Archive@Ogre@@8 DD FLAT:??_R0?AVArchive@Ogre@@@8 ; Ogre::Archive::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Archive@Ogre@@8
rdata$r	SEGMENT
??_R2Archive@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Archive@Ogre@@8 ; Ogre::Archive::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Archive@Ogre@@8
rdata$r	SEGMENT
??_R3Archive@Ogre@@8 DD 00H				; Ogre::Archive::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVArchive@Ogre@@@8
_DATA	SEGMENT
??_R0?AVArchive@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Archive `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVArchive@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Archive@Ogre@@6B@
rdata$r	SEGMENT
??_R4Archive@Ogre@@6B@ DD 00H				; Ogre::Archive::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVArchive@Ogre@@@8
	DD	FLAT:??_R3Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Archive@Ogre@@6B@
CONST	SEGMENT
??_7Archive@Ogre@@6B@ DD FLAT:??_R4Archive@Ogre@@6B@	; Ogre::Archive::`vftable'
	DD	FLAT:??_EArchive@Ogre@@UAEPAXI@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstream$ = 8						; size = 4
_mode$ = 12						; size = 4
??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z PROC		; Ogre::Archive::Archive, COMDAT
; _this$ = ecx

; 22   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pstream$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 23   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z ENDP		; Ogre::Archive::Archive
_TEXT	ENDS
PUBLIC	??1Archive@Ogre@@UAE@XZ				; Ogre::Archive::~Archive
; Function compile flags: /Odtp
;	COMDAT ??1Archive@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Archive@Ogre@@UAE@XZ PROC				; Ogre::Archive::~Archive, COMDAT
; _this$ = ecx

; 26   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@

; 27   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1Archive@Ogre@@UAE@XZ ENDP				; Ogre::Archive::~Archive
_TEXT	ENDS
PUBLIC	?isLoading@Archive@Ogre@@QAE_NXZ		; Ogre::Archive::isLoading
; Function compile flags: /Odtp
;	COMDAT ?isLoading@Archive@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isLoading@Archive@Ogre@@QAE_NXZ PROC			; Ogre::Archive::isLoading, COMDAT
; _this$ = ecx

; 30   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 			return m_Mode==MODE_LOAD;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 1
	sete	cl
	mov	al, cl

; 32   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?isLoading@Archive@Ogre@@QAE_NXZ ENDP			; Ogre::Archive::isLoading
_TEXT	ENDS
PUBLIC	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z	; Ogre::Archive::serialize
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAD@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAD@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 108  : 		SERIALIZE_PRIMITIVE_FUNC(char)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAD@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAF@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAF@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 109  : 		SERIALIZE_PRIMITIVE_FUNC(short)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	2
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAF@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAH@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAH@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 110  : 		SERIALIZE_PRIMITIVE_FUNC(int)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAH@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_J@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_J@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 111  : 		SERIALIZE_PRIMITIVE_FUNC(int64)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	8
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_J@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAE@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAE@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 112  : 		SERIALIZE_PRIMITIVE_FUNC(uchar)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAE@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAG@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAG@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 113  : 		SERIALIZE_PRIMITIVE_FUNC(ushort)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	2
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAG@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAI@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAI@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 114  : 		SERIALIZE_PRIMITIVE_FUNC(uint)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAI@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_K@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_K@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 115  : 		SERIALIZE_PRIMITIVE_FUNC(uint64)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	8
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_K@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_N@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_N@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 116  : 		SERIALIZE_PRIMITIVE_FUNC(bool)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_N@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAM@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAM@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 117  : 		SERIALIZE_PRIMITIVE_FUNC(float)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAM@Z ENDP			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z PROC		; Ogre::Archive::serialize, COMDAT
; _this$ = ecx

; 155  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 			if(isLoading()) m_pStream->read(pbuf, len);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@serialize
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
	jmp	SHORT $LN1@serialize
$LN2@serialize:

; 157  : 			else m_pStream->write(pbuf, len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN1@serialize:

; 158  : 
; 159  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 160  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ENDP		; Ogre::Archive::serialize
_TEXT	ENDS
PUBLIC	?read@Archive@Ogre@@QAEXPAXI@Z			; Ogre::Archive::read
; Function compile flags: /Odtp
;	COMDAT ?read@Archive@Ogre@@QAEXPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?read@Archive@Ogre@@QAEXPAXI@Z PROC			; Ogre::Archive::read, COMDAT
; _this$ = ecx

; 163  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 			m_pStream->read(pbuf, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 165  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?read@Archive@Ogre@@QAEXPAXI@Z ENDP			; Ogre::Archive::read
_TEXT	ENDS
PUBLIC	?write@Archive@Ogre@@QAEXPBXI@Z			; Ogre::Archive::write
; Function compile flags: /Odtp
;	COMDAT ?write@Archive@Ogre@@QAEXPBXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?write@Archive@Ogre@@QAEXPBXI@Z PROC			; Ogre::Archive::write, COMDAT
; _this$ = ecx

; 168  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 			m_pStream->write(pbuf, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 170  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?write@Archive@Ogre@@QAEXPBXI@Z ENDP			; Ogre::Archive::write
_TEXT	ENDS
PUBLIC	??0Archive@Ogre@@QAE@ABV01@@Z			; Ogre::Archive::Archive
; Function compile flags: /Odtp
;	COMDAT ??0Archive@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Archive@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Archive::Archive, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Archive@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Archive::Archive
_TEXT	ENDS
PUBLIC	??4Archive@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Archive::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Archive@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Archive@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Archive::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Archive@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Archive::operator=
_TEXT	ENDS
PUBLIC	??_GArchive@Ogre@@UAEPAXI@Z			; Ogre::Archive::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GArchive@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GArchive@Ogre@@UAEPAXI@Z PROC			; Ogre::Archive::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Archive@Ogre@@UAE@XZ			; Ogre::Archive::~Archive
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@9
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@9:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GArchive@Ogre@@UAEPAXI@Z ENDP			; Ogre::Archive::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EArchive@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EArchive@Ogre@@UAEPAXI@Z PROC			; Ogre::Archive::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@9
	push	OFFSET ??1Archive@Ogre@@UAE@XZ		; Ogre::Archive::~Archive
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@9
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@9:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@9
$LN3@vector@9:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Archive@Ogre@@UAE@XZ			; Ogre::Archive::~Archive
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@9
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@9:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@9:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EArchive@Ogre@@UAEPAXI@Z ENDP			; Ogre::Archive::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	__real@00000000
PUBLIC	??0Quaternion@Ogre@@QAE@XZ			; Ogre::Quaternion::Quaternion
EXTRN	__fltused:DWORD
;	COMDAT __real@3f800000
; File i:\svnroot\client\ogremain\ogrequaternion.h
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0Quaternion@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Quaternion@Ogre@@QAE@XZ PROC				; Ogre::Quaternion::Quaternion, COMDAT
; _this$ = ecx

; 54   : 		Quaternion():x(0), y(0), z(0), w(1.0f){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Quaternion@Ogre@@QAE@XZ ENDP				; Ogre::Quaternion::Quaternion
_TEXT	ENDS
PUBLIC	??0Quaternion@Ogre@@QAE@MMMM@Z			; Ogre::Quaternion::Quaternion
; Function compile flags: /Odtp
;	COMDAT ??0Quaternion@Ogre@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
_w1$ = 20						; size = 4
??0Quaternion@Ogre@@QAE@MMMM@Z PROC			; Ogre::Quaternion::Quaternion, COMDAT
; _this$ = ecx

; 55   : 		Quaternion( float x1, float y1, float z1, float w1 ) : x(x1), y(y1), z(z1), w(w1){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _w1$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0Quaternion@Ogre@@QAE@MMMM@Z ENDP			; Ogre::Quaternion::Quaternion
_TEXT	ENDS
PUBLIC	??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Quaternion::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_quat$ = 8						; size = 4
??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::Quaternion::operator=, COMDAT
; _this$ = ecx

; 59   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 			x = quat.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 61   : 			y = quat.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 62   : 			z = quat.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 63   : 			w = quat.w;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+12]

; 64   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 65   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::Quaternion::operator=
_TEXT	ENDS
PUBLIC	??XQuaternion@Ogre@@QAEXM@Z			; Ogre::Quaternion::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XQuaternion@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??XQuaternion@Ogre@@QAEXM@Z PROC			; Ogre::Quaternion::operator*=, COMDAT
; _this$ = ecx

; 67   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 			x *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 69   : 			y *= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 70   : 			z *= s;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 71   : 			w *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 72   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XQuaternion@Ogre@@QAEXM@Z ENDP			; Ogre::Quaternion::operator*=
_TEXT	ENDS
PUBLIC	?norm@Quaternion@Ogre@@QAEMXZ			; Ogre::Quaternion::norm
; Function compile flags: /Odtp
;	COMDAT ?norm@Quaternion@Ogre@@QAEMXZ
_TEXT	SEGMENT
tv94 = -8						; size = 4
_this$ = -4						; size = 4
?norm@Quaternion@Ogre@@QAEMXZ PROC			; Ogre::Quaternion::norm, COMDAT
; _this$ = ecx

; 74   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 			return x*x+y*y+z*z+w*w;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv94[ebp]
	fld	DWORD PTR tv94[ebp]

; 76   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?norm@Quaternion@Ogre@@QAEMXZ ENDP			; Ogre::Quaternion::norm
_TEXT	ENDS
PUBLIC	?identity@Quaternion@Ogre@@QAEXXZ		; Ogre::Quaternion::identity
; Function compile flags: /Odtp
;	COMDAT ?identity@Quaternion@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?identity@Quaternion@Ogre@@QAEXXZ PROC			; Ogre::Quaternion::identity, COMDAT
; _this$ = ecx

; 78   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 			x = y = z = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx]

; 80   : 			w = 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax+12]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?identity@Quaternion@Ogre@@QAEXXZ ENDP			; Ogre::Quaternion::identity
_TEXT	ENDS
PUBLIC	?inverse@Quaternion@Ogre@@QAEXXZ		; Ogre::Quaternion::inverse
; Function compile flags: /Odtp
;	COMDAT ?inverse@Quaternion@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?inverse@Quaternion@Ogre@@QAEXXZ PROC			; Ogre::Quaternion::inverse, COMDAT
; _this$ = ecx

; 83   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 			x = -x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 85   : 			y = -y;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fchs
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 86   : 			z = -z;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fchs
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 87   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?inverse@Quaternion@Ogre@@QAEXXZ ENDP			; Ogre::Quaternion::inverse
_TEXT	ENDS
PUBLIC	?inverse@Quaternion@Ogre@@QBEXAAV12@@Z		; Ogre::Quaternion::inverse
; Function compile flags: /Odtp
;	COMDAT ?inverse@Quaternion@Ogre@@QBEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_quat$ = 8						; size = 4
?inverse@Quaternion@Ogre@@QBEXAAV12@@Z PROC		; Ogre::Quaternion::inverse, COMDAT
; _this$ = ecx

; 89   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 			quat.x = -x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [ecx]

; 91   : 			quat.y = -y;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fchs
	mov	eax, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [eax+4]

; 92   : 			quat.z = -z;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fchs
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx+8]

; 93   : 			quat.w = w;

	mov	eax, DWORD PTR _quat$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+12]

; 94   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?inverse@Quaternion@Ogre@@QBEXAAV12@@Z ENDP		; Ogre::Quaternion::inverse
_TEXT	ENDS
PUBLIC	?setElement@Quaternion@Ogre@@QAEXMMMM@Z		; Ogre::Quaternion::setElement
; Function compile flags: /Odtp
;	COMDAT ?setElement@Quaternion@Ogre@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
_w1$ = 20						; size = 4
?setElement@Quaternion@Ogre@@QAEXMMMM@Z PROC		; Ogre::Quaternion::setElement, COMDAT
; _this$ = ecx

; 96   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 97   : 			x = x1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]

; 98   : 			y = y1;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]

; 99   : 			z = z1;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]

; 100  : 			w = w1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _w1$[ebp]
	fstp	DWORD PTR [eax+12]

; 101  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?setElement@Quaternion@Ogre@@QAEXMMMM@Z ENDP		; Ogre::Quaternion::setElement
_TEXT	ENDS
PUBLIC	??9Quaternion@Ogre@@QBE_NABV01@@Z		; Ogre::Quaternion::operator!=
EXTRN	??8Quaternion@Ogre@@QBE_NABV01@@Z:PROC		; Ogre::Quaternion::operator==
; Function compile flags: /Odtp
;	COMDAT ??9Quaternion@Ogre@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_quat$ = 8						; size = 4
??9Quaternion@Ogre@@QBE_NABV01@@Z PROC			; Ogre::Quaternion::operator!=, COMDAT
; _this$ = ecx

; 105  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 106  : 			return !operator==(quat);

	mov	eax, DWORD PTR _quat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Quaternion@Ogre@@QBE_NABV01@@Z	; Ogre::Quaternion::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 107  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9Quaternion@Ogre@@QBE_NABV01@@Z ENDP			; Ogre::Quaternion::operator!=
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@XZ				; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
;	COMDAT ??0Vector3@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector3@Ogre@@QAE@XZ PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 49   : 		Vector3(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector3@Ogre@@QAE@XZ ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@ABV01@@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??0Vector3@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 50   : 		Vector3(const Vector3 &rhs)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		{
; 52   : 			x = rhs.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 53   : 			y = rhs.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 54   : 			z = rhs.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 55   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector3@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@MMM@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
??0Vector3@Ogre@@QAE@MMM@Z PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 56   : 		Vector3( float x1, float y1, float z1 ) : x(x1), y(y1), z(z1){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector3@Ogre@@QAE@MMM@Z ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@M@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector3@Ogre@@QAE@M@Z PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 57   : 		Vector3(float v) : x(v), y(v), z(v){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector3@Ogre@@QAE@M@Z ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@PAM@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@PAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector3@Ogre@@QAE@PAM@Z PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 58   : 		Vector3(float* v) : x(v[0]), y(v[1]), z(v[2]){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector3@Ogre@@QAE@PAM@Z ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??4Vector3@Ogre@@QAEABV01@ABV01@@Z		; Ogre::Vector3::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Vector3@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??4Vector3@Ogre@@QAEABV01@ABV01@@Z PROC			; Ogre::Vector3::operator=, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			x = vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 63   : 			y = vec.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 64   : 			z = vec.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 65   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 66   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4Vector3@Ogre@@QAEABV01@ABV01@@Z ENDP			; Ogre::Vector3::operator=
_TEXT	ENDS
PUBLIC	??YVector3@Ogre@@QAEXABV01@@Z			; Ogre::Vector3::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YVector3@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??YVector3@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector3::operator+=, COMDAT
; _this$ = ecx

; 68   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 			x += vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 70   : 			y += vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 71   : 			z += vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 72   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YVector3@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector3::operator+=
_TEXT	ENDS
PUBLIC	??ZVector3@Ogre@@QAEXABV01@@Z			; Ogre::Vector3::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZVector3@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??ZVector3@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector3::operator-=, COMDAT
; _this$ = ecx

; 74   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 			x -= vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 76   : 			y -= vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 77   : 			z -= vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 78   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZVector3@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector3::operator-=
_TEXT	ENDS
PUBLIC	??XVector3@Ogre@@QAEXM@Z			; Ogre::Vector3::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XVector3@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??XVector3@Ogre@@QAEXM@Z PROC				; Ogre::Vector3::operator*=, COMDAT
; _this$ = ecx

; 81   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 			x *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 83   : 			y *= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 84   : 			z *= s;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 85   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XVector3@Ogre@@QAEXM@Z ENDP				; Ogre::Vector3::operator*=
_TEXT	ENDS
PUBLIC	??XVector3@Ogre@@QAEXABV01@@Z			; Ogre::Vector3::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XVector3@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??XVector3@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector3::operator*=, COMDAT
; _this$ = ecx

; 88   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 89   : 			x *= vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 90   : 			y *= vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 91   : 			z *= vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vec$[ebp]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 92   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XVector3@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector3::operator*=
_TEXT	ENDS
PUBLIC	??_0Vector3@Ogre@@QAEXM@Z			; Ogre::Vector3::operator/=
; Function compile flags: /Odtp
;	COMDAT ??_0Vector3@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??_0Vector3@Ogre@@QAEXM@Z PROC				; Ogre::Vector3::operator/=, COMDAT
; _this$ = ecx

; 95   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 			x /= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fdiv	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 97   : 			y /= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fdiv	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 98   : 			z /= s;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fdiv	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 99   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??_0Vector3@Ogre@@QAEXM@Z ENDP				; Ogre::Vector3::operator/=
_TEXT	ENDS
PUBLIC	??BVector3@Ogre@@QAEPAMXZ			; Ogre::Vector3::operator float *
; Function compile flags: /Odtp
;	COMDAT ??BVector3@Ogre@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector3@Ogre@@QAEPAMXZ PROC				; Ogre::Vector3::operator float *, COMDAT
; _this$ = ecx

; 101  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 			return &x;

	mov	eax, DWORD PTR _this$[ebp]

; 103  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??BVector3@Ogre@@QAEPAMXZ ENDP				; Ogre::Vector3::operator float *
_TEXT	ENDS
PUBLIC	??BVector3@Ogre@@QBEPBMXZ			; Ogre::Vector3::operator float const *
; Function compile flags: /Odtp
;	COMDAT ??BVector3@Ogre@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector3@Ogre@@QBEPBMXZ PROC				; Ogre::Vector3::operator float const *, COMDAT
; _this$ = ecx

; 105  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 106  : 			return &x;

	mov	eax, DWORD PTR _this$[ebp]

; 107  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??BVector3@Ogre@@QBEPBMXZ ENDP				; Ogre::Vector3::operator float const *
_TEXT	ENDS
PUBLIC	??HVector3@Ogre@@QBE?AV01@XZ			; Ogre::Vector3::operator+
; Function compile flags: /Odtp
;	COMDAT ??HVector3@Ogre@@QBE?AV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??HVector3@Ogre@@QBE?AV01@XZ PROC			; Ogre::Vector3::operator+, COMDAT
; _this$ = ecx

; 109  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 111  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??HVector3@Ogre@@QBE?AV01@XZ ENDP			; Ogre::Vector3::operator+
_TEXT	ENDS
PUBLIC	??GVector3@Ogre@@QBE?AV01@XZ			; Ogre::Vector3::operator-
; Function compile flags: /Odtp
;	COMDAT ??GVector3@Ogre@@QBE?AV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??GVector3@Ogre@@QBE?AV01@XZ PROC			; Ogre::Vector3::operator-, COMDAT
; _this$ = ecx

; 113  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 			return Vector3(-x, -y, -z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 115  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??GVector3@Ogre@@QBE?AV01@XZ ENDP			; Ogre::Vector3::operator-
_TEXT	ENDS
PUBLIC	??8Vector3@Ogre@@QBE_NABV01@@Z			; Ogre::Vector3::operator==
; Function compile flags: /Odtp
;	COMDAT ??8Vector3@Ogre@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv77 = -8						; size = 4
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??8Vector3@Ogre@@QBE_NABV01@@Z PROC			; Ogre::Vector3::operator==, COMDAT
; _this$ = ecx

; 117  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 			return (x==vec.x && y==vec.y && z==vec.z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv77[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv77[ebp]

; 119  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector3@Ogre@@QBE_NABV01@@Z ENDP			; Ogre::Vector3::operator==
_TEXT	ENDS
PUBLIC	?setElement@Vector3@Ogre@@QAEXMMM@Z		; Ogre::Vector3::setElement
; Function compile flags: /Odtp
;	COMDAT ?setElement@Vector3@Ogre@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
?setElement@Vector3@Ogre@@QAEXMMM@Z PROC		; Ogre::Vector3::setElement, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 			x = x1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]

; 123  : 			y = y1;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]

; 124  : 			z = z1;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]

; 125  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setElement@Vector3@Ogre@@QAEXMMM@Z ENDP		; Ogre::Vector3::setElement
_TEXT	ENDS
PUBLIC	?setElement@Vector3@Ogre@@QAEXPAM@Z		; Ogre::Vector3::setElement
; Function compile flags: /Odtp
;	COMDAT ?setElement@Vector3@Ogre@@QAEXPAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?setElement@Vector3@Ogre@@QAEXPAM@Z PROC		; Ogre::Vector3::setElement, COMDAT
; _this$ = ecx

; 127  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 			x = p[0];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 129  : 			y = p[1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 130  : 			z = p[2];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 131  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setElement@Vector3@Ogre@@QAEXPAM@Z ENDP		; Ogre::Vector3::setElement
_TEXT	ENDS
PUBLIC	?Sqrt@Ogre@@YAMM@Z				; Ogre::Sqrt
PUBLIC	?length@Vector3@Ogre@@QBEMXZ			; Ogre::Vector3::length
; Function compile flags: /Odtp
;	COMDAT ?length@Vector3@Ogre@@QBEMXZ
_TEXT	SEGMENT
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?length@Vector3@Ogre@@QBEMXZ PROC			; Ogre::Vector3::length, COMDAT
; _this$ = ecx

; 133  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 			return (float)Sqrt(x*x+y*y+z*z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv88[ebp]
	fld	DWORD PTR tv88[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?Sqrt@Ogre@@YAMM@Z			; Ogre::Sqrt
	add	esp, 4

; 135  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@Vector3@Ogre@@QBEMXZ ENDP			; Ogre::Vector3::length
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
;	COMDAT ?Sqrt@Ogre@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?Sqrt@Ogre@@YAMM@Z PROC					; Ogre::Sqrt, COMDAT

; 59   : 	{

	push	ebp
	mov	ebp, esp

; 60   : 		return (float)sqrt(x);

	push	ecx
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4

; 61   : 	}

	pop	ebp
	ret	0
?Sqrt@Ogre@@YAMM@Z ENDP					; Ogre::Sqrt
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 534  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	fstp	DWORD PTR [esp]
	call	_sqrtf
	add	esp, 4
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 423  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?lengthSqr@Vector3@Ogre@@QBEMXZ			; Ogre::Vector3::lengthSqr
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
;	COMDAT ?lengthSqr@Vector3@Ogre@@QBEMXZ
_TEXT	SEGMENT
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?lengthSqr@Vector3@Ogre@@QBEMXZ PROC			; Ogre::Vector3::lengthSqr, COMDAT
; _this$ = ecx

; 137  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 			return (x*x+y*y+z*z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv88[ebp]
	fld	DWORD PTR tv88[ebp]

; 139  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?lengthSqr@Vector3@Ogre@@QBEMXZ ENDP			; Ogre::Vector3::lengthSqr
_TEXT	ENDS
PUBLIC	?getRTTI@BaseAnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::BaseAnimationData::getRTTI
EXTRN	?m_RTTI@BaseAnimationData@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::BaseAnimationData::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreanimationdata.h
;	COMDAT ?getRTTI@BaseAnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@BaseAnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::BaseAnimationData::getRTTI, COMDAT
; _this$ = ecx

; 41   : 		DECLARE_RTTI_VIRTUAL(BaseAnimationData)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@BaseAnimationData@Ogre@@2VRuntimeClass@2@B ; Ogre::BaseAnimationData::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@BaseAnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::BaseAnimationData::getRTTI
_TEXT	ENDS
PUBLIC	??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??_7BaseAnimationData@Ogre@@6B@			; Ogre::BaseAnimationData::`vftable'
PUBLIC	??0BaseAnimationData@Ogre@@QAE@XZ		; Ogre::BaseAnimationData::BaseAnimationData
PUBLIC	??_R4BaseAnimationData@Ogre@@6B@		; Ogre::BaseAnimationData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVBaseAnimationData@Ogre@@@8		; Ogre::BaseAnimationData `RTTI Type Descriptor'
PUBLIC	??_R3BaseAnimationData@Ogre@@8			; Ogre::BaseAnimationData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2BaseAnimationData@Ogre@@8			; Ogre::BaseAnimationData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@BaseAnimationData@Ogre@@8		; Ogre::BaseAnimationData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EBaseAnimationData@Ogre@@UAEPAXI@Z		; Ogre::BaseAnimationData::`vector deleting destructor'
EXTRN	?_serialize@BaseAnimationData@Ogre@@UAEXAAVArchive@2@H@Z:PROC ; Ogre::BaseAnimationData::_serialize
;	COMDAT ??_R1A@?0A@EA@BaseAnimationData@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@BaseAnimationData@Ogre@@8 DD FLAT:??_R0?AVBaseAnimationData@Ogre@@@8 ; Ogre::BaseAnimationData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3BaseAnimationData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2BaseAnimationData@Ogre@@8
rdata$r	SEGMENT
??_R2BaseAnimationData@Ogre@@8 DD FLAT:??_R1A@?0A@EA@BaseAnimationData@Ogre@@8 ; Ogre::BaseAnimationData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3BaseAnimationData@Ogre@@8
rdata$r	SEGMENT
??_R3BaseAnimationData@Ogre@@8 DD 00H			; Ogre::BaseAnimationData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2BaseAnimationData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBaseAnimationData@Ogre@@@8
_DATA	SEGMENT
??_R0?AVBaseAnimationData@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::BaseAnimationData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBaseAnimationData@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4BaseAnimationData@Ogre@@6B@
rdata$r	SEGMENT
??_R4BaseAnimationData@Ogre@@6B@ DD 00H			; Ogre::BaseAnimationData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBaseAnimationData@Ogre@@@8
	DD	FLAT:??_R3BaseAnimationData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7BaseAnimationData@Ogre@@6B@
CONST	SEGMENT
??_7BaseAnimationData@Ogre@@6B@ DD FLAT:??_R4BaseAnimationData@Ogre@@6B@ ; Ogre::BaseAnimationData::`vftable'
	DD	FLAT:?getRTTI@BaseAnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseAnimationData@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EBaseAnimationData@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0BaseAnimationData@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@XZ$2
__ehfuncinfo$??0BaseAnimationData@Ogre@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0BaseAnimationData@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0BaseAnimationData@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0BaseAnimationData@Ogre@@QAE@XZ PROC			; Ogre::BaseAnimationData::BaseAnimationData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0BaseAnimationData@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseAnimationData@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
__ehhandler$??0BaseAnimationData@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0BaseAnimationData@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0BaseAnimationData@Ogre@@QAE@XZ ENDP			; Ogre::BaseAnimationData::BaseAnimationData
PUBLIC	??1BaseAnimationData@Ogre@@UAE@XZ		; Ogre::BaseAnimationData::~BaseAnimationData
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1BaseAnimationData@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1BaseAnimationData@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1BaseAnimationData@Ogre@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1BaseAnimationData@Ogre@@UAE@XZ$2
__ehfuncinfo$??1BaseAnimationData@Ogre@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1BaseAnimationData@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1BaseAnimationData@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1BaseAnimationData@Ogre@@UAE@XZ PROC			; Ogre::BaseAnimationData::~BaseAnimationData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1BaseAnimationData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1BaseAnimationData@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__unwindfunclet$??1BaseAnimationData@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
__unwindfunclet$??1BaseAnimationData@Ogre@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
__ehhandler$??1BaseAnimationData@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1BaseAnimationData@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1BaseAnimationData@Ogre@@UAE@XZ ENDP			; Ogre::BaseAnimationData::~BaseAnimationData
PUBLIC	??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??0BaseAnimationData@Ogre@@QAE@ABV01@@Z		; Ogre::BaseAnimationData::BaseAnimationData
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z$2
__ehfuncinfo$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0BaseAnimationData@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0BaseAnimationData@Ogre@@QAE@ABV01@@Z PROC		; Ogre::BaseAnimationData::BaseAnimationData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7BaseAnimationData@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
__ehhandler$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0BaseAnimationData@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::BaseAnimationData::BaseAnimationData
PUBLIC	??4?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator=
PUBLIC	??4?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator=
PUBLIC	??4BaseAnimationData@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::BaseAnimationData::operator=
; Function compile flags: /Odtp
;	COMDAT ??4BaseAnimationData@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BaseAnimationData@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::BaseAnimationData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??4?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BaseAnimationData@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::BaseAnimationData::operator=
_TEXT	ENDS
PUBLIC	??_GBaseAnimationData@Ogre@@UAEPAXI@Z		; Ogre::BaseAnimationData::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GBaseAnimationData@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GBaseAnimationData@Ogre@@UAEPAXI@Z PROC		; Ogre::BaseAnimationData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseAnimationData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@10
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@10:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBaseAnimationData@Ogre@@UAEPAXI@Z ENDP		; Ogre::BaseAnimationData::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EBaseAnimationData@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EBaseAnimationData@Ogre@@UAEPAXI@Z PROC		; Ogre::BaseAnimationData::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@10
	push	OFFSET ??1BaseAnimationData@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	64					; 00000040H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@10
	push	64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@10:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@10
$LN3@vector@10:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseAnimationData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@10
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@10:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@10:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EBaseAnimationData@Ogre@@UAEPAXI@Z ENDP		; Ogre::BaseAnimationData::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@AnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::AnimationData::getRTTI
EXTRN	?m_RTTI@AnimationData@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::AnimationData::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@AnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@AnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::AnimationData::getRTTI, COMDAT
; _this$ = ecx

; 60   : 		DECLARE_RTTI(AnimationData)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@AnimationData@Ogre@@2VRuntimeClass@2@B ; Ogre::AnimationData::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@AnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::AnimationData::getRTTI
_TEXT	ENDS
PUBLIC	?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::AnimationData::newObject
EXTRN	??0AnimationData@Ogre@@QAE@XZ:PROC		; Ogre::AnimationData::AnimationData
EXTRN	??2MemoryDelegation@Ogre@@SAPAXI@Z:PROC		; Ogre::MemoryDelegation::operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T76565 = -20						; size = 4
$T76564 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ PROC ; Ogre::AnimationData::newObject, COMDAT

; 60   : 		DECLARE_RTTI(AnimationData)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	112					; 00000070H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T76565[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T76565[ebp], 0
	je	SHORT $LN3@newObject
	mov	ecx, DWORD PTR $T76565[ebp]
	call	??0AnimationData@Ogre@@QAE@XZ		; Ogre::AnimationData::AnimationData
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject
$LN3@newObject:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T76564[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T76564[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	112					; 00000070H
	mov	eax, DWORD PTR $T76565[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ ENDP ; Ogre::AnimationData::newObject
PUBLIC	??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::~vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	??_7AnimationData@Ogre@@6B@			; Ogre::AnimationData::`vftable'
PUBLIC	??0AnimationData@Ogre@@QAE@ABV01@@Z		; Ogre::AnimationData::AnimationData
PUBLIC	??_R4AnimationData@Ogre@@6B@			; Ogre::AnimationData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVAnimationData@Ogre@@@8			; Ogre::AnimationData `RTTI Type Descriptor'
PUBLIC	??_R3AnimationData@Ogre@@8			; Ogre::AnimationData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AnimationData@Ogre@@8			; Ogre::AnimationData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@AnimationData@Ogre@@8		; Ogre::AnimationData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EAnimationData@Ogre@@UAEPAXI@Z		; Ogre::AnimationData::`vector deleting destructor'
EXTRN	?_serialize@AnimationData@Ogre@@UAEXAAVArchive@2@H@Z:PROC ; Ogre::AnimationData::_serialize
EXTRN	?getType@AnimationData@Ogre@@UAE?AW4AnimationType@2@XZ:PROC ; Ogre::AnimationData::getType
;	COMDAT ??_R1A@?0A@EA@AnimationData@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AnimationData@Ogre@@8 DD FLAT:??_R0?AVAnimationData@Ogre@@@8 ; Ogre::AnimationData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AnimationData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2AnimationData@Ogre@@8
rdata$r	SEGMENT
??_R2AnimationData@Ogre@@8 DD FLAT:??_R1A@?0A@EA@AnimationData@Ogre@@8 ; Ogre::AnimationData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseAnimationData@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3AnimationData@Ogre@@8
rdata$r	SEGMENT
??_R3AnimationData@Ogre@@8 DD 00H			; Ogre::AnimationData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2AnimationData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAnimationData@Ogre@@@8
_DATA	SEGMENT
??_R0?AVAnimationData@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::AnimationData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAnimationData@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4AnimationData@Ogre@@6B@
rdata$r	SEGMENT
??_R4AnimationData@Ogre@@6B@ DD 00H			; Ogre::AnimationData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVAnimationData@Ogre@@@8
	DD	FLAT:??_R3AnimationData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7AnimationData@Ogre@@6B@
CONST	SEGMENT
??_7AnimationData@Ogre@@6B@ DD FLAT:??_R4AnimationData@Ogre@@6B@ ; Ogre::AnimationData::`vftable'
	DD	FLAT:?getRTTI@AnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@AnimationData@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EAnimationData@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getType@AnimationData@Ogre@@UAE?AW4AnimationType@2@XZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0AnimationData@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AnimationData@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0AnimationData@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0AnimationData@Ogre@@QAE@ABV01@@Z$2
__ehfuncinfo$??0AnimationData@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0AnimationData@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0AnimationData@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0AnimationData@Ogre@@QAE@ABV01@@Z PROC		; Ogre::AnimationData::AnimationData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AnimationData@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseAnimationData@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7AnimationData@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0AnimationData@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseAnimationData@Ogre@@UAE@XZ
__unwindfunclet$??0AnimationData@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
__unwindfunclet$??0AnimationData@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::~vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
__ehhandler$??0AnimationData@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AnimationData@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AnimationData@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::AnimationData::AnimationData
PUBLIC	??4?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator=
PUBLIC	??4?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator=
PUBLIC	??4AnimationData@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::AnimationData::operator=
; Function compile flags: /Odtp
;	COMDAT ??4AnimationData@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4AnimationData@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::AnimationData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BaseAnimationData@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??4?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 88					; 00000058H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??4?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4AnimationData@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::AnimationData::operator=
_TEXT	ENDS
PUBLIC	??_GAnimationData@Ogre@@UAEPAXI@Z		; Ogre::AnimationData::`scalar deleting destructor'
EXTRN	??1AnimationData@Ogre@@UAE@XZ:PROC		; Ogre::AnimationData::~AnimationData
; Function compile flags: /Odtp
;	COMDAT ??_GAnimationData@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GAnimationData@Ogre@@UAEPAXI@Z PROC			; Ogre::AnimationData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AnimationData@Ogre@@UAE@XZ		; Ogre::AnimationData::~AnimationData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@11
	push	112					; 00000070H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@11:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GAnimationData@Ogre@@UAEPAXI@Z ENDP			; Ogre::AnimationData::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EAnimationData@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EAnimationData@Ogre@@UAEPAXI@Z PROC			; Ogre::AnimationData::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@11
	push	OFFSET ??1AnimationData@Ogre@@UAE@XZ	; Ogre::AnimationData::~AnimationData
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	112					; 00000070H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@11
	push	112					; 00000070H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@11:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@11
$LN3@vector@11:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AnimationData@Ogre@@UAE@XZ		; Ogre::AnimationData::~AnimationData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@11
	push	112					; 00000070H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@11:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@11:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EAnimationData@Ogre@@UAEPAXI@Z ENDP			; Ogre::AnimationData::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@SkeletonAnimData@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::SkeletonAnimData::getRTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreskeletonanimdata.h
;	COMDAT ?getRTTI@SkeletonAnimData@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@SkeletonAnimData@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::SkeletonAnimData::getRTTI, COMDAT
; _this$ = ecx

; 13   : 		DECLARE_RTTI(SkeletonAnimData)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@SkeletonAnimData@Ogre@@2VRuntimeClass@2@B ; Ogre::SkeletonAnimData::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@SkeletonAnimData@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::SkeletonAnimData::getRTTI
_TEXT	ENDS
PUBLIC	??0SkeletonAnimData@Ogre@@QAE@XZ		; Ogre::SkeletonAnimData::SkeletonAnimData
PUBLIC	?newObject@SkeletonAnimData@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::SkeletonAnimData::newObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@SkeletonAnimData@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@SkeletonAnimData@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@SkeletonAnimData@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@SkeletonAnimData@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@SkeletonAnimData@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T76597 = -20						; size = 4
$T76596 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@SkeletonAnimData@Ogre@@SAPAVBaseObject@2@XZ PROC ; Ogre::SkeletonAnimData::newObject, COMDAT

; 13   : 		DECLARE_RTTI(SkeletonAnimData)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@SkeletonAnimData@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	88					; 00000058H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T76597[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T76597[ebp], 0
	je	SHORT $LN3@newObject@2
	mov	ecx, DWORD PTR $T76597[ebp]
	call	??0SkeletonAnimData@Ogre@@QAE@XZ	; Ogre::SkeletonAnimData::SkeletonAnimData
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@2
$LN3@newObject@2:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@2:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T76596[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T76596[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@SkeletonAnimData@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T76597[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@SkeletonAnimData@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@SkeletonAnimData@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@SkeletonAnimData@Ogre@@SAPAVBaseObject@2@XZ ENDP ; Ogre::SkeletonAnimData::newObject
PUBLIC	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
PUBLIC	?getNumTracks@SkeletonAnimData@Ogre@@QAEIXZ	; Ogre::SkeletonAnimData::getNumTracks
; Function compile flags: /Odtp
;	COMDAT ?getNumTracks@SkeletonAnimData@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumTracks@SkeletonAnimData@Ogre@@QAEIXZ PROC	; Ogre::SkeletonAnimData::getNumTracks, COMDAT
; _this$ = ecx

; 18   : 		size_t getNumTracks(){ return m_TrackArray.size(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	mov	esp, ebp
	pop	ebp
	ret	0
?getNumTracks@SkeletonAnimData@Ogre@@QAEIXZ ENDP	; Ogre::SkeletonAnimData::getNumTracks
_TEXT	ENDS
PUBLIC	??A?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAPAVBoneTrack@Ogre@@I@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator[]
PUBLIC	?getTrack@SkeletonAnimData@Ogre@@QAEPAVBoneTrack@2@I@Z ; Ogre::SkeletonAnimData::getTrack
; Function compile flags: /Odtp
;	COMDAT ?getTrack@SkeletonAnimData@Ogre@@QAEPAVBoneTrack@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?getTrack@SkeletonAnimData@Ogre@@QAEPAVBoneTrack@2@I@Z PROC ; Ogre::SkeletonAnimData::getTrack, COMDAT
; _this$ = ecx

; 19   : 		BoneTrack *getTrack( size_t i ){ return m_TrackArray[i]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??A?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAPAVBoneTrack@Ogre@@I@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	4
?getTrack@SkeletonAnimData@Ogre@@QAEPAVBoneTrack@2@I@Z ENDP ; Ogre::SkeletonAnimData::getTrack
_TEXT	ENDS
PUBLIC	?getType@SkeletonAnimData@Ogre@@UAE?AW4AnimationType@2@XZ ; Ogre::SkeletonAnimData::getType
; Function compile flags: /Odtp
;	COMDAT ?getType@SkeletonAnimData@Ogre@@UAE?AW4AnimationType@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getType@SkeletonAnimData@Ogre@@UAE?AW4AnimationType@2@XZ PROC ; Ogre::SkeletonAnimData::getType, COMDAT
; _this$ = ecx

; 22   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 23   : 			return ANIM_SKELETON;

	xor	eax, eax

; 24   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getType@SkeletonAnimData@Ogre@@UAE?AW4AnimationType@2@XZ ENDP ; Ogre::SkeletonAnimData::getType
_TEXT	ENDS
PUBLIC	??_7SkeletonAnimData@Ogre@@6B@			; Ogre::SkeletonAnimData::`vftable'
PUBLIC	??0SkeletonAnimData@Ogre@@QAE@ABV01@@Z		; Ogre::SkeletonAnimData::SkeletonAnimData
PUBLIC	??_R4SkeletonAnimData@Ogre@@6B@			; Ogre::SkeletonAnimData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSkeletonAnimData@Ogre@@@8		; Ogre::SkeletonAnimData `RTTI Type Descriptor'
PUBLIC	??_R3SkeletonAnimData@Ogre@@8			; Ogre::SkeletonAnimData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SkeletonAnimData@Ogre@@8			; Ogre::SkeletonAnimData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SkeletonAnimData@Ogre@@8		; Ogre::SkeletonAnimData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_serialize@SkeletonAnimData@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::SkeletonAnimData::_serialize
PUBLIC	??_ESkeletonAnimData@Ogre@@MAEPAXI@Z		; Ogre::SkeletonAnimData::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@SkeletonAnimData@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SkeletonAnimData@Ogre@@8 DD FLAT:??_R0?AVSkeletonAnimData@Ogre@@@8 ; Ogre::SkeletonAnimData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SkeletonAnimData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2SkeletonAnimData@Ogre@@8
rdata$r	SEGMENT
??_R2SkeletonAnimData@Ogre@@8 DD FLAT:??_R1A@?0A@EA@SkeletonAnimData@Ogre@@8 ; Ogre::SkeletonAnimData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseAnimationData@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3SkeletonAnimData@Ogre@@8
rdata$r	SEGMENT
??_R3SkeletonAnimData@Ogre@@8 DD 00H			; Ogre::SkeletonAnimData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2SkeletonAnimData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSkeletonAnimData@Ogre@@@8
_DATA	SEGMENT
??_R0?AVSkeletonAnimData@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::SkeletonAnimData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSkeletonAnimData@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SkeletonAnimData@Ogre@@6B@
rdata$r	SEGMENT
??_R4SkeletonAnimData@Ogre@@6B@ DD 00H			; Ogre::SkeletonAnimData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSkeletonAnimData@Ogre@@@8
	DD	FLAT:??_R3SkeletonAnimData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7SkeletonAnimData@Ogre@@6B@
CONST	SEGMENT
??_7SkeletonAnimData@Ogre@@6B@ DD FLAT:??_R4SkeletonAnimData@Ogre@@6B@ ; Ogre::SkeletonAnimData::`vftable'
	DD	FLAT:?getRTTI@SkeletonAnimData@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@SkeletonAnimData@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_ESkeletonAnimData@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getType@SkeletonAnimData@Ogre@@UAE?AW4AnimationType@2@XZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SkeletonAnimData@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SkeletonAnimData@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SkeletonAnimData@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0SkeletonAnimData@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SkeletonAnimData@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0SkeletonAnimData@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0SkeletonAnimData@Ogre@@QAE@ABV01@@Z PROC		; Ogre::SkeletonAnimData::SkeletonAnimData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SkeletonAnimData@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseAnimationData@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7SkeletonAnimData@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SkeletonAnimData@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseAnimationData@Ogre@@UAE@XZ
__unwindfunclet$??0SkeletonAnimData@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
__ehhandler$??0SkeletonAnimData@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SkeletonAnimData@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SkeletonAnimData@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::SkeletonAnimData::SkeletonAnimData
PUBLIC	??4SkeletonAnimData@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::SkeletonAnimData::operator=
; Function compile flags: /Odtp
;	COMDAT ??4SkeletonAnimData@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4SkeletonAnimData@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::SkeletonAnimData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BaseAnimationData@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??4?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4SkeletonAnimData@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::SkeletonAnimData::operator=
_TEXT	ENDS
PUBLIC	??1SkeletonAnimData@Ogre@@MAE@XZ		; Ogre::SkeletonAnimData::~SkeletonAnimData
PUBLIC	??_GSkeletonAnimData@Ogre@@MAEPAXI@Z		; Ogre::SkeletonAnimData::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GSkeletonAnimData@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSkeletonAnimData@Ogre@@MAEPAXI@Z PROC		; Ogre::SkeletonAnimData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SkeletonAnimData@Ogre@@MAE@XZ	; Ogre::SkeletonAnimData::~SkeletonAnimData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@12
	push	88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@12:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSkeletonAnimData@Ogre@@MAEPAXI@Z ENDP		; Ogre::SkeletonAnimData::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ESkeletonAnimData@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ESkeletonAnimData@Ogre@@MAEPAXI@Z PROC		; Ogre::SkeletonAnimData::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@12
	push	OFFSET ??1SkeletonAnimData@Ogre@@MAE@XZ	; Ogre::SkeletonAnimData::~SkeletonAnimData
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@12
	push	88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@12:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@12
$LN3@vector@12:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SkeletonAnimData@Ogre@@MAE@XZ	; Ogre::SkeletonAnimData::~SkeletonAnimData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@12
	push	88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@12:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@12:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ESkeletonAnimData@Ogre@@MAEPAXI@Z ENDP		; Ogre::SkeletonAnimData::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@BoneTrack@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::BoneTrack::getRTTI
EXTRN	?m_RTTI@BoneTrack@Ogre@@2VRuntimeClass@2@B:BYTE	; Ogre::BoneTrack::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreanimtrackbone.h
;	COMDAT ?getRTTI@BoneTrack@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@BoneTrack@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::BoneTrack::getRTTI, COMDAT
; _this$ = ecx

; 14   : 		DECLARE_RTTI(BoneTrack)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@BoneTrack@Ogre@@2VRuntimeClass@2@B ; Ogre::BoneTrack::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@BoneTrack@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::BoneTrack::getRTTI
_TEXT	ENDS
PUBLIC	??0BoneTrack@Ogre@@QAE@XZ			; Ogre::BoneTrack::BoneTrack
PUBLIC	?newObject@BoneTrack@Ogre@@SAPAVBaseObject@2@XZ	; Ogre::BoneTrack::newObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@BoneTrack@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@BoneTrack@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@BoneTrack@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@BoneTrack@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@BoneTrack@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T76634 = -20						; size = 4
$T76633 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@BoneTrack@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::BoneTrack::newObject, COMDAT

; 14   : 		DECLARE_RTTI(BoneTrack)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@BoneTrack@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	288					; 00000120H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T76634[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T76634[ebp], 0
	je	SHORT $LN3@newObject@3
	mov	ecx, DWORD PTR $T76634[ebp]
	call	??0BoneTrack@Ogre@@QAE@XZ
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@3
$LN3@newObject@3:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@3:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T76633[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T76633[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@BoneTrack@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	288					; 00000120H
	mov	eax, DWORD PTR $T76634[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@BoneTrack@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@BoneTrack@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@BoneTrack@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::BoneTrack::newObject
PUBLIC	??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ ; Ogre::KeyFrameArray<Ogre::Quaternion>::~KeyFrameArray<Ogre::Quaternion>
PUBLIC	??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ	; Ogre::KeyFrameArray<Ogre::Vector3>::~KeyFrameArray<Ogre::Vector3>
PUBLIC	??_7BoneTrack@Ogre@@6B@				; Ogre::BoneTrack::`vftable'
PUBLIC	??1BoneTrack@Ogre@@UAE@XZ			; Ogre::BoneTrack::~BoneTrack
PUBLIC	??_R4BoneTrack@Ogre@@6B@			; Ogre::BoneTrack::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVBoneTrack@Ogre@@@8			; Ogre::BoneTrack `RTTI Type Descriptor'
PUBLIC	??_R3BoneTrack@Ogre@@8				; Ogre::BoneTrack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2BoneTrack@Ogre@@8				; Ogre::BoneTrack::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@BoneTrack@Ogre@@8			; Ogre::BoneTrack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EBoneTrack@Ogre@@UAEPAXI@Z			; Ogre::BoneTrack::`vector deleting destructor'
EXTRN	?_serialize@BoneTrack@Ogre@@UAEXAAVArchive@2@H@Z:PROC ; Ogre::BoneTrack::_serialize
;	COMDAT ??_R1A@?0A@EA@BoneTrack@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@BoneTrack@Ogre@@8 DD FLAT:??_R0?AVBoneTrack@Ogre@@@8 ; Ogre::BoneTrack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3BoneTrack@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2BoneTrack@Ogre@@8
rdata$r	SEGMENT
??_R2BoneTrack@Ogre@@8 DD FLAT:??_R1A@?0A@EA@BoneTrack@Ogre@@8 ; Ogre::BoneTrack::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3BoneTrack@Ogre@@8
rdata$r	SEGMENT
??_R3BoneTrack@Ogre@@8 DD 00H				; Ogre::BoneTrack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2BoneTrack@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBoneTrack@Ogre@@@8
_DATA	SEGMENT
??_R0?AVBoneTrack@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::BoneTrack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBoneTrack@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4BoneTrack@Ogre@@6B@
rdata$r	SEGMENT
??_R4BoneTrack@Ogre@@6B@ DD 00H				; Ogre::BoneTrack::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBoneTrack@Ogre@@@8
	DD	FLAT:??_R3BoneTrack@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7BoneTrack@Ogre@@6B@
CONST	SEGMENT
??_7BoneTrack@Ogre@@6B@ DD FLAT:??_R4BoneTrack@Ogre@@6B@ ; Ogre::BoneTrack::`vftable'
	DD	FLAT:?getRTTI@BoneTrack@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BoneTrack@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EBoneTrack@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1BoneTrack@Ogre@@UAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1BoneTrack@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??1BoneTrack@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1BoneTrack@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1BoneTrack@Ogre@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1BoneTrack@Ogre@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1BoneTrack@Ogre@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1BoneTrack@Ogre@@UAE@XZ$4
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1BoneTrack@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1BoneTrack@Ogre@@UAE@XZ PROC				; Ogre::BoneTrack::~BoneTrack, COMDAT
; _this$ = ecx

; 17   : 		~BoneTrack(){}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1BoneTrack@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BoneTrack@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	call	??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1BoneTrack@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__unwindfunclet$??1BoneTrack@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__unwindfunclet$??1BoneTrack@Ogre@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ
__unwindfunclet$??1BoneTrack@Ogre@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ
__unwindfunclet$??1BoneTrack@Ogre@@UAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	jmp	??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ
__ehhandler$??1BoneTrack@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1BoneTrack@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1BoneTrack@Ogre@@UAE@XZ ENDP				; Ogre::BoneTrack::~BoneTrack
PUBLIC	??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ ; Ogre::KeyFrameArray<Ogre::Quaternion>::KeyFrameArray<Ogre::Quaternion>
PUBLIC	??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ	; Ogre::KeyFrameArray<Ogre::Vector3>::KeyFrameArray<Ogre::Vector3>
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0BoneTrack@Ogre@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0BoneTrack@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0BoneTrack@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0BoneTrack@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0BoneTrack@Ogre@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0BoneTrack@Ogre@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0BoneTrack@Ogre@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0BoneTrack@Ogre@@QAE@XZ$4
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0BoneTrack@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0BoneTrack@Ogre@@QAE@XZ PROC				; Ogre::BoneTrack::BoneTrack, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0BoneTrack@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BoneTrack@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::FixedString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ ; Ogre::KeyFrameArray<Ogre::Vector3>::KeyFrameArray<Ogre::Vector3>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ ; Ogre::KeyFrameArray<Ogre::Quaternion>::KeyFrameArray<Ogre::Quaternion>
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	call	??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ ; Ogre::KeyFrameArray<Ogre::Vector3>::KeyFrameArray<Ogre::Vector3>
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0BoneTrack@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__unwindfunclet$??0BoneTrack@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__unwindfunclet$??0BoneTrack@Ogre@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ
__unwindfunclet$??0BoneTrack@Ogre@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ
__unwindfunclet$??0BoneTrack@Ogre@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	jmp	??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ
__ehhandler$??0BoneTrack@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0BoneTrack@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0BoneTrack@Ogre@@QAE@XZ ENDP				; Ogre::BoneTrack::BoneTrack
PUBLIC	??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z ; Ogre::KeyFrameArray<Ogre::Quaternion>::KeyFrameArray<Ogre::Quaternion>
PUBLIC	??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z ; Ogre::KeyFrameArray<Ogre::Vector3>::KeyFrameArray<Ogre::Vector3>
PUBLIC	??0BoneTrack@Ogre@@QAE@ABV01@@Z			; Ogre::BoneTrack::BoneTrack
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0BoneTrack@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0BoneTrack@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0BoneTrack@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0BoneTrack@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0BoneTrack@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0BoneTrack@Ogre@@QAE@ABV01@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0BoneTrack@Ogre@@QAE@ABV01@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0BoneTrack@Ogre@@QAE@ABV01@@Z$4
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0BoneTrack@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0BoneTrack@Ogre@@QAE@ABV01@@Z PROC			; Ogre::BoneTrack::BoneTrack, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0BoneTrack@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7BoneTrack@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0FixedString@Ogre@@QAE@ABV01@@Z	; Ogre::FixedString::FixedString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 200				; 000000c8H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	call	??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0BoneTrack@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__unwindfunclet$??0BoneTrack@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__unwindfunclet$??0BoneTrack@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ
__unwindfunclet$??0BoneTrack@Ogre@@QAE@ABV01@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ
__unwindfunclet$??0BoneTrack@Ogre@@QAE@ABV01@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	jmp	??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ
__ehhandler$??0BoneTrack@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0BoneTrack@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0BoneTrack@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::BoneTrack::BoneTrack
PUBLIC	??4?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<Ogre::Quaternion>::operator=
PUBLIC	??4?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<Ogre::Vector3>::operator=
PUBLIC	??4BoneTrack@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::BoneTrack::operator=
; Function compile flags: /Odtp
;	COMDAT ??4BoneTrack@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BoneTrack@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BoneTrack::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FixedString::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??4?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<Ogre::Vector3>::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??4?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<Ogre::Quaternion>::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 200				; 000000c8H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	call	??4?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<Ogre::Vector3>::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BoneTrack@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BoneTrack::operator=
_TEXT	ENDS
PUBLIC	??_GBoneTrack@Ogre@@UAEPAXI@Z			; Ogre::BoneTrack::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GBoneTrack@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GBoneTrack@Ogre@@UAEPAXI@Z PROC			; Ogre::BoneTrack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BoneTrack@Ogre@@UAE@XZ		; Ogre::BoneTrack::~BoneTrack
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@13
	push	288					; 00000120H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@13:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBoneTrack@Ogre@@UAEPAXI@Z ENDP			; Ogre::BoneTrack::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EBoneTrack@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EBoneTrack@Ogre@@UAEPAXI@Z PROC			; Ogre::BoneTrack::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@13
	push	OFFSET ??1BoneTrack@Ogre@@UAE@XZ	; Ogre::BoneTrack::~BoneTrack
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	288					; 00000120H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@13
	push	288					; 00000120H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@13:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@13
$LN3@vector@13:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BoneTrack@Ogre@@UAE@XZ		; Ogre::BoneTrack::~BoneTrack
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@13
	push	288					; 00000120H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@13:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@13:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EBoneTrack@Ogre@@UAEPAXI@Z ENDP			; Ogre::BoneTrack::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1BaseKeyFrameArray@Ogre@@UAE@XZ		; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
PUBLIC	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
PUBLIC	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ$2
__ehfuncinfo$??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ PROC	; Ogre::KeyFrameArray<Ogre::Vector3>::~KeyFrameArray<Ogre::Vector3>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
__unwindfunclet$??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
__unwindfunclet$??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
__ehhandler$??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ ENDP	; Ogre::KeyFrameArray<Ogre::Vector3>::~KeyFrameArray<Ogre::Vector3>
PUBLIC	??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	??_7BaseKeyFrameArray@Ogre@@6B@			; Ogre::BaseKeyFrameArray::`vftable'
PUBLIC	??_R4BaseKeyFrameArray@Ogre@@6B@		; Ogre::BaseKeyFrameArray::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVBaseKeyFrameArray@Ogre@@@8		; Ogre::BaseKeyFrameArray `RTTI Type Descriptor'
PUBLIC	??_R3BaseKeyFrameArray@Ogre@@8			; Ogre::BaseKeyFrameArray::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2BaseKeyFrameArray@Ogre@@8			; Ogre::BaseKeyFrameArray::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@BaseKeyFrameArray@Ogre@@8		; Ogre::BaseKeyFrameArray::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_serialize@BaseKeyFrameArray@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::BaseKeyFrameArray::_serialize
EXTRN	??_EBaseKeyFrameArray@Ogre@@UAEPAXI@Z:PROC	; Ogre::BaseKeyFrameArray::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@BaseKeyFrameArray@Ogre@@8
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
rdata$r	SEGMENT
??_R1A@?0A@EA@BaseKeyFrameArray@Ogre@@8 DD FLAT:??_R0?AVBaseKeyFrameArray@Ogre@@@8 ; Ogre::BaseKeyFrameArray::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3BaseKeyFrameArray@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2BaseKeyFrameArray@Ogre@@8
rdata$r	SEGMENT
??_R2BaseKeyFrameArray@Ogre@@8 DD FLAT:??_R1A@?0A@EA@BaseKeyFrameArray@Ogre@@8 ; Ogre::BaseKeyFrameArray::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3BaseKeyFrameArray@Ogre@@8
rdata$r	SEGMENT
??_R3BaseKeyFrameArray@Ogre@@8 DD 00H			; Ogre::BaseKeyFrameArray::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2BaseKeyFrameArray@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBaseKeyFrameArray@Ogre@@@8
_DATA	SEGMENT
??_R0?AVBaseKeyFrameArray@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::BaseKeyFrameArray `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBaseKeyFrameArray@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4BaseKeyFrameArray@Ogre@@6B@
rdata$r	SEGMENT
??_R4BaseKeyFrameArray@Ogre@@6B@ DD 00H			; Ogre::BaseKeyFrameArray::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBaseKeyFrameArray@Ogre@@@8
	DD	FLAT:??_R3BaseKeyFrameArray@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7BaseKeyFrameArray@Ogre@@6B@
CONST	SEGMENT
??_7BaseKeyFrameArray@Ogre@@6B@ DD FLAT:??_R4BaseKeyFrameArray@Ogre@@6B@ ; Ogre::BaseKeyFrameArray::`vftable'
	DD	FLAT:?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseKeyFrameArray@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EBaseKeyFrameArray@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1BaseKeyFrameArray@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1BaseKeyFrameArray@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1BaseKeyFrameArray@Ogre@@UAE@XZ$1
__ehfuncinfo$??1BaseKeyFrameArray@Ogre@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1BaseKeyFrameArray@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1BaseKeyFrameArray@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1BaseKeyFrameArray@Ogre@@UAE@XZ PROC			; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray, COMDAT
; _this$ = ecx

; 57   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1BaseKeyFrameArray@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseKeyFrameArray@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 58   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1BaseKeyFrameArray@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??1BaseKeyFrameArray@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
__ehhandler$??1BaseKeyFrameArray@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1BaseKeyFrameArray@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1BaseKeyFrameArray@Ogre@@UAE@XZ ENDP			; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
PUBLIC	??$serializeRawArray@UAnimRange@BaseKeyFrameArray@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
;	COMDAT ?_serialize@BaseKeyFrameArray@Ogre@@UAEXAAVArchive@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
_version$ = 12						; size = 4
?_serialize@BaseKeyFrameArray@Ogre@@UAEXAAVArchive@2@H@Z PROC ; Ogre::BaseKeyFrameArray::_serialize, COMDAT
; _this$ = ecx

; 75   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 76   : 			ar.serializeRawArray(m_Ranges);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$serializeRawArray@UAnimRange@BaseKeyFrameArray@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::BaseKeyFrameArray::AnimRange>

; 77   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_serialize@BaseKeyFrameArray@Ogre@@UAEXAAVArchive@2@H@Z ENDP ; Ogre::BaseKeyFrameArray::_serialize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_GBaseKeyFrameArray@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GBaseKeyFrameArray@Ogre@@UAEPAXI@Z PROC		; Ogre::BaseKeyFrameArray::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@14
	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@14:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBaseKeyFrameArray@Ogre@@UAEPAXI@Z ENDP		; Ogre::BaseKeyFrameArray::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
PUBLIC	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ$2
__ehfuncinfo$??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ PROC	; Ogre::KeyFrameArray<Ogre::Quaternion>::~KeyFrameArray<Ogre::Quaternion>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
__unwindfunclet$??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
__unwindfunclet$??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
__ehhandler$??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ ENDP	; Ogre::KeyFrameArray<Ogre::Quaternion>::~KeyFrameArray<Ogre::Quaternion>
PUBLIC	??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
PUBLIC	??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
PUBLIC	??_7?$KeyFrameArray@VVector3@Ogre@@@Ogre@@6B@	; Ogre::KeyFrameArray<Ogre::Vector3>::`vftable'
PUBLIC	??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z		; Ogre::BaseKeyFrameArray::BaseKeyFrameArray
PUBLIC	??_R4?$KeyFrameArray@VVector3@Ogre@@@Ogre@@6B@	; Ogre::KeyFrameArray<Ogre::Vector3>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@8 ; Ogre::KeyFrameArray<Ogre::Vector3> `RTTI Type Descriptor'
PUBLIC	??_R3?$KeyFrameArray@VVector3@Ogre@@@Ogre@@8	; Ogre::KeyFrameArray<Ogre::Vector3>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$KeyFrameArray@VVector3@Ogre@@@Ogre@@8	; Ogre::KeyFrameArray<Ogre::Vector3>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@8 ; Ogre::KeyFrameArray<Ogre::Vector3>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_serialize@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::KeyFrameArray<Ogre::Vector3>::_serialize
PUBLIC	?getNumKey@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEIXZ ; Ogre::KeyFrameArray<Ogre::Vector3>::getNumKey
PUBLIC	?getValue@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEXHIPAX@Z ; Ogre::KeyFrameArray<Ogre::Vector3>::getValue
EXTRN	??_E?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEPAXI@Z:PROC ; Ogre::KeyFrameArray<Ogre::Vector3>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@8 ; Ogre::KeyFrameArray<Ogre::Vector3>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$KeyFrameArray@VVector3@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2?$KeyFrameArray@VVector3@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R2?$KeyFrameArray@VVector3@Ogre@@@Ogre@@8 DD FLAT:??_R1A@?0A@EA@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@8 ; Ogre::KeyFrameArray<Ogre::Vector3>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseKeyFrameArray@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3?$KeyFrameArray@VVector3@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R3?$KeyFrameArray@VVector3@Ogre@@@Ogre@@8 DD 00H	; Ogre::KeyFrameArray<Ogre::Vector3>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$KeyFrameArray@VVector3@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@8
_DATA	SEGMENT
??_R0?AV?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::KeyFrameArray<Ogre::Vector3> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$KeyFrameArray@VVector3@Ogre@@@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$KeyFrameArray@VVector3@Ogre@@@Ogre@@6B@
rdata$r	SEGMENT
??_R4?$KeyFrameArray@VVector3@Ogre@@@Ogre@@6B@ DD 00H	; Ogre::KeyFrameArray<Ogre::Vector3>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@8
	DD	FLAT:??_R3?$KeyFrameArray@VVector3@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7?$KeyFrameArray@VVector3@Ogre@@@Ogre@@6B@
CONST	SEGMENT
??_7?$KeyFrameArray@VVector3@Ogre@@@Ogre@@6B@ DD FLAT:??_R4?$KeyFrameArray@VVector3@Ogre@@@Ogre@@6B@ ; Ogre::KeyFrameArray<Ogre::Vector3>::`vftable'
	DD	FLAT:?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_E?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getNumKey@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEIXZ
	DD	FLAT:?getValue@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEXHIPAX@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z PROC ; Ogre::KeyFrameArray<Ogre::Vector3>::KeyFrameArray<Ogre::Vector3>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$KeyFrameArray@VVector3@Ogre@@@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR [ecx+84], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
__unwindfunclet$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
__unwindfunclet$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
__ehhandler$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABV01@@Z ENDP ; Ogre::KeyFrameArray<Ogre::Vector3>::KeyFrameArray<Ogre::Vector3>
PUBLIC	??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
PUBLIC	??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
PUBLIC	??_7?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@6B@ ; Ogre::KeyFrameArray<Ogre::Quaternion>::`vftable'
PUBLIC	??_R4?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@6B@ ; Ogre::KeyFrameArray<Ogre::Quaternion>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@8 ; Ogre::KeyFrameArray<Ogre::Quaternion> `RTTI Type Descriptor'
PUBLIC	??_R3?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@8	; Ogre::KeyFrameArray<Ogre::Quaternion>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@8	; Ogre::KeyFrameArray<Ogre::Quaternion>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@8 ; Ogre::KeyFrameArray<Ogre::Quaternion>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_serialize@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::KeyFrameArray<Ogre::Quaternion>::_serialize
PUBLIC	?getNumKey@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEIXZ ; Ogre::KeyFrameArray<Ogre::Quaternion>::getNumKey
PUBLIC	?getValue@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEXHIPAX@Z ; Ogre::KeyFrameArray<Ogre::Quaternion>::getValue
EXTRN	??_E?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEPAXI@Z:PROC ; Ogre::KeyFrameArray<Ogre::Quaternion>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@8 ; Ogre::KeyFrameArray<Ogre::Quaternion>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R2?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@8 DD FLAT:??_R1A@?0A@EA@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@8 ; Ogre::KeyFrameArray<Ogre::Quaternion>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseKeyFrameArray@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R3?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@8 DD 00H	; Ogre::KeyFrameArray<Ogre::Quaternion>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@8
_DATA	SEGMENT
??_R0?AV?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::KeyFrameArray<Ogre::Quaternion> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@6B@
rdata$r	SEGMENT
??_R4?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@6B@ DD 00H ; Ogre::KeyFrameArray<Ogre::Quaternion>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@8
	DD	FLAT:??_R3?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@6B@
CONST	SEGMENT
??_7?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@6B@ DD FLAT:??_R4?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@6B@ ; Ogre::KeyFrameArray<Ogre::Quaternion>::`vftable'
	DD	FLAT:?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_E?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getNumKey@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEIXZ
	DD	FLAT:?getValue@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEXHIPAX@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z PROC ; Ogre::KeyFrameArray<Ogre::Quaternion>::KeyFrameArray<Ogre::Quaternion>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR [ecx+84], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
__unwindfunclet$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
__unwindfunclet$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
__ehhandler$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@ABV01@@Z ENDP ; Ogre::KeyFrameArray<Ogre::Quaternion>::KeyFrameArray<Ogre::Quaternion>
; Function compile flags: /Odtp
;	COMDAT ??_G?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEPAXI@Z PROC ; Ogre::KeyFrameArray<Ogre::Vector3>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@15
	push	88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@15:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEPAXI@Z ENDP ; Ogre::KeyFrameArray<Ogre::Vector3>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z PROC		; Ogre::BaseKeyFrameArray::BaseKeyFrameArray, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7BaseKeyFrameArray@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
__ehhandler$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::BaseKeyFrameArray::BaseKeyFrameArray
; Function compile flags: /Odtp
;	COMDAT ??_G?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEPAXI@Z PROC ; Ogre::KeyFrameArray<Ogre::Quaternion>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@16
	push	88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@16:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEPAXI@Z ENDP ; Ogre::KeyFrameArray<Ogre::Quaternion>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
xdata$x	SEGMENT
__unwindtable$??0SkeletonAnimData@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SkeletonAnimData@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SkeletonAnimData@Ogre@@QAE@XZ$1
__ehfuncinfo$??0SkeletonAnimData@Ogre@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SkeletonAnimData@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreskeletonanimdata.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0SkeletonAnimData@Ogre@@QAE@XZ PROC			; Ogre::SkeletonAnimData::SkeletonAnimData
; _this$ = ecx

; 10   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SkeletonAnimData@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseAnimationData@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SkeletonAnimData@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 11   : 
; 12   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0SkeletonAnimData@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseAnimationData@Ogre@@UAE@XZ
__unwindfunclet$??0SkeletonAnimData@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
__ehhandler$??0SkeletonAnimData@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SkeletonAnimData@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SkeletonAnimData@Ogre@@QAE@XZ ENDP			; Ogre::SkeletonAnimData::SkeletonAnimData
xdata$x	SEGMENT
__unwindtable$??1SkeletonAnimData@Ogre@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1SkeletonAnimData@Ogre@@MAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1SkeletonAnimData@Ogre@@MAE@XZ$1
__ehfuncinfo$??1SkeletonAnimData@Ogre@@MAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1SkeletonAnimData@Ogre@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv95 = -32						; size = 4
_this$ = -28						; size = 4
$T76771 = -24						; size = 4
$T76770 = -20						; size = 4
_i$61144 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1SkeletonAnimData@Ogre@@MAE@XZ PROC			; Ogre::SkeletonAnimData::~SkeletonAnimData
; _this$ = ecx

; 15   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1SkeletonAnimData@Ogre@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SkeletonAnimData@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 16   : 		for(size_t i=0; i<m_TrackArray.size(); i++)

	mov	DWORD PTR _i$61144[ebp], 0
	jmp	SHORT $LN3@SkeletonAn
$LN2@SkeletonAn:
	mov	ecx, DWORD PTR _i$61144[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$61144[ebp], ecx
$LN3@SkeletonAn:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	cmp	DWORD PTR _i$61144[ebp], eax
	jae	SHORT $LN4@SkeletonAn

; 17   : 		{
; 18   : 			delete m_TrackArray[i];

	mov	edx, DWORD PTR _i$61144[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??A?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAPAVBoneTrack@Ogre@@I@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T76771[ebp], eax
	mov	ecx, DWORD PTR $T76771[ebp]
	mov	DWORD PTR $T76770[ebp], ecx
	cmp	DWORD PTR $T76770[ebp], 0
	je	SHORT $LN6@SkeletonAn
	push	1
	mov	edx, DWORD PTR $T76770[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T76770[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN7@SkeletonAn
$LN6@SkeletonAn:
	mov	DWORD PTR tv95[ebp], 0
$LN7@SkeletonAn:

; 19   : 		}

	jmp	SHORT $LN2@SkeletonAn
$LN4@SkeletonAn:

; 20   : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseAnimationData@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1SkeletonAnimData@Ogre@@MAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseAnimationData@Ogre@@UAE@XZ
__unwindfunclet$??1SkeletonAnimData@Ogre@@MAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
__ehhandler$??1SkeletonAnimData@Ogre@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1SkeletonAnimData@Ogre@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1SkeletonAnimData@Ogre@@MAE@XZ ENDP			; Ogre::SkeletonAnimData::~SkeletonAnimData
PUBLIC	??$?6VBoneTrack@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@Z ; Ogre::Archive::operator<<<Ogre::BoneTrack>
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
_version$ = 12						; size = 4
?_serialize@SkeletonAnimData@Ogre@@UAEXAAVArchive@2@H@Z PROC ; Ogre::SkeletonAnimData::_serialize
; _this$ = ecx

; 23   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 24   : 		BaseAnimationData::_serialize(ar, version);

	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_serialize@BaseAnimationData@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::BaseAnimationData::_serialize

; 25   : 
; 26   : 		ar << m_TrackArray;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$?6VBoneTrack@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@Z ; Ogre::Archive::operator<<<Ogre::BoneTrack>

; 27   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?_serialize@SkeletonAnimData@Ogre@@UAEXAAVArchive@2@H@Z ENDP ; Ogre::SkeletonAnimData::_serialize
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXABQAVBoneTrack@Ogre@@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::push_back
PUBLIC	?addBoneTrack@SkeletonAnimData@Ogre@@QAEXPAVBoneTrack@2@@Z ; Ogre::SkeletonAnimData::addBoneTrack
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ptrack$ = 8						; size = 4
?addBoneTrack@SkeletonAnimData@Ogre@@QAEXPAVBoneTrack@2@@Z PROC ; Ogre::SkeletonAnimData::addBoneTrack
; _this$ = ecx

; 30   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 		m_TrackArray.push_back(ptrack);

	lea	eax, DWORD PTR _ptrack$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	?push_back@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXABQAVBoneTrack@Ogre@@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::push_back

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?addBoneTrack@SkeletonAnimData@Ogre@@QAEXPAVBoneTrack@2@@Z ENDP ; Ogre::SkeletonAnimData::addBoneTrack
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	?_Tidy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >
PUBLIC	?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin
PUBLIC	?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
PUBLIC	?_Buy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Buy
PUBLIC	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
PUBLIC	??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T76785 = -36						; size = 8
$T76784 = -28						; size = 8
$T76783 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T76783[ebp], esp
	push	eax
	call	??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@14

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T76784[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T76785[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@14
__catch$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@14
	ret	0
$LN5@vector@14:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@14:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@14:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	?_Buy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Buy
PUBLIC	??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@XZ	; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T76814 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T76814[ebp], esp
	call	??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	?_Tidy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@1@0PAU23@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >
PUBLIC	?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin
PUBLIC	?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end
PUBLIC	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
PUBLIC	??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T76826 = -36						; size = 8
$T76825 = -28						; size = 8
$T76824 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T76824[ebp], esp
	push	eax
	call	??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@15

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T76825[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T76826[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@1@0PAU23@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@15
__catch$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@15
	ret	0
$LN5@vector@15:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@15:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@15:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	?deallocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@I@Z ; std::allocator<Ogre::TriggerDesc>::deallocate
PUBLIC	??$_Ucopy@PAUTriggerDesc@Ogre@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<Ogre::TriggerDesc *>
PUBLIC	?capacity@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::capacity
PUBLIC	?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Destroy
PUBLIC	??$unchecked_copy@PAUTriggerDesc@Ogre@@PAU12@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
PUBLIC	?clear@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$62805 = -8					; size = 4
__Ptr$62795 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@2

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@2

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::clear
	jmp	$LN9@operator@2
$LN8@operator@2:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@2

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUTriggerDesc@Ogre@@PAU12@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$62795[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$62795[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@2
$LN6@operator@2:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@2

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Ptr$62805[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$62805[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAUTriggerDesc@Ogre@@PAU12@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$62805[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUTriggerDesc@Ogre@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<Ogre::TriggerDesc *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@2
$LN4@operator@2:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@2

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@I@Z ; std::allocator<Ogre::TriggerDesc>::deallocate
$LN2@operator@2:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@2

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUTriggerDesc@Ogre@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<Ogre::TriggerDesc *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@2:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	?_Buy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Buy
PUBLIC	??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@XZ	; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T76854 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T76854[ebp], esp
	call	??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	?_Tidy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@1@0PAU23@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >
PUBLIC	?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin
PUBLIC	?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end
PUBLIC	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
PUBLIC	??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T76866 = -36						; size = 8
$T76865 = -28						; size = 8
$T76864 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T76864[ebp], esp
	push	eax
	call	??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@16

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T76865[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T76866[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@1@0PAU23@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@16
__catch$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@16
	ret	0
$LN5@vector@16:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@16:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@16:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	?deallocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@I@Z ; std::allocator<Ogre::SequenceDesc>::deallocate
PUBLIC	??$_Ucopy@PAUSequenceDesc@Ogre@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<Ogre::SequenceDesc *>
PUBLIC	?capacity@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::capacity
PUBLIC	?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Destroy
PUBLIC	??$unchecked_copy@PAUSequenceDesc@Ogre@@PAU12@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
PUBLIC	?clear@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$62964 = -8					; size = 4
__Ptr$62954 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@3

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@3

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::clear
	jmp	$LN9@operator@3
$LN8@operator@3:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@3

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUSequenceDesc@Ogre@@PAU12@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$62954[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$62954[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@3
$LN6@operator@3:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@3

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	shl	eax, 4
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$62964[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$62964[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUSequenceDesc@Ogre@@PAU12@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$62964[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUSequenceDesc@Ogre@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<Ogre::SequenceDesc *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@3
$LN4@operator@3:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@3

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@I@Z ; std::allocator<Ogre::SequenceDesc>::deallocate
$LN2@operator@3:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@3

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUSequenceDesc@Ogre@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<Ogre::SequenceDesc *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@3:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	?_Buy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Buy
PUBLIC	??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@XZ	; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T76894 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T76894[ebp], esp
	call	??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	?_Tidy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >
PUBLIC	?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
PUBLIC	?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
PUBLIC	??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T76906 = -36						; size = 8
$T76905 = -28						; size = 8
$T76904 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T76904[ebp], esp
	push	eax
	call	??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@17

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T76905[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T76906[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@17
__catch$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@17
	ret	0
$LN5@vector@17:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@17:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@17:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	?deallocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEXPAPAVBoneTrack@Ogre@@I@Z ; std::allocator<Ogre::BoneTrack *>::deallocate
PUBLIC	??$_Ucopy@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<Ogre::BoneTrack * *>
PUBLIC	?capacity@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
PUBLIC	?clear@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$63123 = -8					; size = 4
__Ptr$63113 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@4

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@4

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::clear
	jmp	$LN9@operator@4
$LN8@operator@4:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@4

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$63113[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$63113[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@4
$LN6@operator@4:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@4

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$63123[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$63123[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$63123[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<Ogre::BoneTrack * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@4
$LN4@operator@4:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@4

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEXPAPAVBoneTrack@Ogre@@I@Z ; std::allocator<Ogre::BoneTrack *>::deallocate
$LN2@operator@4:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@4

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<Ogre::BoneTrack * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@4:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
_TEXT	ENDS
EXTRN	__imp___invalid_parameter_noinfo:PROC
; Function compile flags: /Odtp
;	COMDAT ??A?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAPAVBoneTrack@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAPAVBoneTrack@Ogre@@I@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@5
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@5:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAPAVBoneTrack@Ogre@@I@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@ABQAVBoneTrack@Ogre@@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::insert
PUBLIC	?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
PUBLIC	?_Ufill@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ufill
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXABQAVBoneTrack@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T76940 = -24						; size = 8
$T76939 = -16						; size = 8
$T76938 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXABQAVBoneTrack@Ogre@@@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T76939[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T76938[ebp], ecx
	mov	DWORD PTR $T76938[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T76938[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T76938[ebp]
	push	edx
	lea	eax, DWORD PTR $T76940[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@ABQAVBoneTrack@Ogre@@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::insert
$LN3@push_back:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXABQAVBoneTrack@Ogre@@@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::~_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	?_Tidy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >
PUBLIC	?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin
PUBLIC	?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end
PUBLIC	?_Buy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Buy
PUBLIC	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
PUBLIC	??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ; std::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	??0?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::MaterialParamTrack *>::allocator<Ogre::MaterialParamTrack *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T76945 = -36						; size = 8
$T76944 = -28						; size = 8
$T76943 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T76943[ebp], esp
	push	eax
	call	??0?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::MaterialParamTrack *>::allocator<Ogre::MaterialParamTrack *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ; std::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@18

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T76944[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T76945[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@18
__catch$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@18
	ret	0
$LN5@vector@18:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@18:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@18:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::~vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::~vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	?deallocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEXPAPAVMaterialParamTrack@Ogre@@I@Z ; std::allocator<Ogre::MaterialParamTrack *>::deallocate
PUBLIC	??$_Ucopy@PAPAVMaterialParamTrack@Ogre@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<Ogre::MaterialParamTrack * *>
PUBLIC	?capacity@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
PUBLIC	?clear@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$63338 = -8					; size = 4
__Ptr$63328 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@6

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@6

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::clear
	jmp	$LN9@operator@6
$LN8@operator@6:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@6

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$63328[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$63328[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@6
$LN6@operator@6:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@6

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$63338[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$63338[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$63338[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVMaterialParamTrack@Ogre@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<Ogre::MaterialParamTrack * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@6
$LN4@operator@6:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@6

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEXPAPAVMaterialParamTrack@Ogre@@I@Z ; std::allocator<Ogre::MaterialParamTrack *>::deallocate
$LN2@operator@6:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@6

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVMaterialParamTrack@Ogre@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<Ogre::MaterialParamTrack * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@6:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator=
_TEXT	ENDS
PUBLIC	??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
PUBLIC	??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
PUBLIC	??0BaseKeyFrameArray@Ogre@@QAE@XZ		; Ogre::BaseKeyFrameArray::BaseKeyFrameArray
;	COMDAT xdata$x
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
xdata$x	SEGMENT
__unwindtable$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ$2
__ehfuncinfo$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ PROC	; Ogre::KeyFrameArray<Ogre::Vector3>::KeyFrameArray<Ogre::Vector3>, COMDAT
; _this$ = ecx

; 90   : 		KeyFrameArray() : m_Type(INTERPOL_LINEAR){}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseKeyFrameArray@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$KeyFrameArray@VVector3@Ogre@@@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
__unwindfunclet$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
__unwindfunclet$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
__ehhandler$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ ENDP	; Ogre::KeyFrameArray<Ogre::Vector3>::KeyFrameArray<Ogre::Vector3>
PUBLIC	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
; Function compile flags: /Odtp
;	COMDAT ?getNumKey@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumKey@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEIXZ PROC ; Ogre::KeyFrameArray<Ogre::Vector3>::getNumKey, COMDAT
; _this$ = ecx

; 94   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 			return m_Array.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size

; 96   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumKey@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEIXZ ENDP ; Ogre::KeyFrameArray<Ogre::Vector3>::getNumKey
_TEXT	ENDS
PUBLIC	?getValue@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEXHIAAVVector3@2@_N@Z ; Ogre::KeyFrameArray<Ogre::Vector3>::getValue
; Function compile flags: /Odtp
;	COMDAT ?getValue@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEXHIPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_seq$ = 8						; size = 4
_tick$ = 12						; size = 4
_pdata$ = 16						; size = 4
?getValue@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEXHIPAX@Z PROC ; Ogre::KeyFrameArray<Ogre::Vector3>::getValue, COMDAT
; _this$ = ecx

; 99   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 			return getValue(seq, tick, *(POSTYPE *)pdata);

	push	1
	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tick$[ebp]
	push	ecx
	mov	edx, DWORD PTR _seq$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getValue@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEXHIAAVVector3@2@_N@Z ; Ogre::KeyFrameArray<Ogre::Vector3>::getValue

; 101  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getValue@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEXHIPAX@Z ENDP ; Ogre::KeyFrameArray<Ogre::Vector3>::getValue
_TEXT	ENDS
PUBLIC	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
PUBLIC	?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::empty
PUBLIC	??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
PUBLIC	??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
PUBLIC	??$serializeRawType@W4InterpolType@Ogre@@@Archive@Ogre@@QAEXAAW4InterpolType@1@@Z ; Ogre::Archive::serializeRawType<enum Ogre::InterpolType>
; Function compile flags: /Odtp
;	COMDAT ?_serialize@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
_version$ = 12						; size = 4
?_serialize@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z PROC ; Ogre::KeyFrameArray<Ogre::Vector3>::_serialize, COMDAT
; _this$ = ecx

; 231  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 			ar.serializeRawType(m_Type);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$serializeRawType@W4InterpolType@Ogre@@@Archive@Ogre@@QAEXAAW4InterpolType@1@@Z ; Ogre::Archive::serializeRawType<enum Ogre::InterpolType>

; 233  : 			ar.serializeRawArray(m_Array);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>

; 234  : 			ar.serializeRawArray(m_CtrlPt);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>

; 235  : 
; 236  : 			if(!m_Array.empty() && int(m_Array[0].tick)<0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@serialize@2
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN1@serialize@2

; 237  : 			{
; 238  : 				m_Array[0].tick = 0;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	DWORD PTR [eax], 0
$LN1@serialize@2:

; 239  : 			}
; 240  : 
; 241  : 			BaseKeyFrameArray::_serialize(ar, version);

	mov	ecx, DWORD PTR _version$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ar$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_serialize@BaseKeyFrameArray@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::BaseKeyFrameArray::_serialize

; 242  : 			m_nPrindex	 = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], -1

; 243  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_serialize@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z ENDP ; Ogre::KeyFrameArray<Ogre::Vector3>::_serialize
_TEXT	ENDS
PUBLIC	??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator=
PUBLIC	??4?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator=
PUBLIC	??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??4?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEABV01@ABV01@@Z PROC ; Ogre::KeyFrameArray<Ogre::Vector3>::operator=, COMDAT
; _this$ = ecx

; 246  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 			m_Type = rhs.m_Type;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 248  : 			m_Array = rhs.m_Array;

	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator=

; 249  : 			m_Ranges = rhs.m_Ranges;

	mov	ecx, DWORD PTR _rhs$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator=

; 250  : 			m_CtrlPt = rhs.m_CtrlPt;

	mov	edx, DWORD PTR _rhs$[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator=

; 251  : 
; 252  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEABV01@ABV01@@Z ENDP ; Ogre::KeyFrameArray<Ogre::Vector3>::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
PUBLIC	?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> > >
PUBLIC	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::begin
PUBLIC	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::end
PUBLIC	?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Buy
PUBLIC	??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
PUBLIC	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T76994 = -36						; size = 8
$T76993 = -28						; size = 8
$T76992 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T76992[ebp], esp
	push	eax
	call	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@19

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T76993[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T76994[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@19
__catch$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@19
	ret	0
$LN5@vector@19:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@19:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@19:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
PUBLIC	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
PUBLIC	?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> > >
PUBLIC	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::begin
PUBLIC	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::end
PUBLIC	?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Buy
PUBLIC	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
PUBLIC	??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
PUBLIC	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T77022 = -36						; size = 8
$T77021 = -28						; size = 8
$T77020 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77020[ebp], esp
	push	eax
	call	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@20

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T77021[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T77022[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@20
__catch$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@20
	ret	0
$LN5@vector@20:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@20:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@20:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
PUBLIC	??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
PUBLIC	??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
;	COMDAT xdata$x
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
xdata$x	SEGMENT
__unwindtable$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ$2
__ehfuncinfo$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ PROC	; Ogre::KeyFrameArray<Ogre::Quaternion>::KeyFrameArray<Ogre::Quaternion>, COMDAT
; _this$ = ecx

; 90   : 		KeyFrameArray() : m_Type(INTERPOL_LINEAR){}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseKeyFrameArray@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
__unwindfunclet$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
__unwindfunclet$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
__ehhandler$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ ENDP	; Ogre::KeyFrameArray<Ogre::Quaternion>::KeyFrameArray<Ogre::Quaternion>
PUBLIC	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
; Function compile flags: /Odtp
;	COMDAT ?getNumKey@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumKey@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEIXZ PROC ; Ogre::KeyFrameArray<Ogre::Quaternion>::getNumKey, COMDAT
; _this$ = ecx

; 94   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 			return m_Array.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size

; 96   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumKey@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEIXZ ENDP ; Ogre::KeyFrameArray<Ogre::Quaternion>::getNumKey
_TEXT	ENDS
PUBLIC	?getValue@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEXHIAAVQuaternion@2@_N@Z ; Ogre::KeyFrameArray<Ogre::Quaternion>::getValue
; Function compile flags: /Odtp
;	COMDAT ?getValue@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEXHIPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_seq$ = 8						; size = 4
_tick$ = 12						; size = 4
_pdata$ = 16						; size = 4
?getValue@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEXHIPAX@Z PROC ; Ogre::KeyFrameArray<Ogre::Quaternion>::getValue, COMDAT
; _this$ = ecx

; 99   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 			return getValue(seq, tick, *(POSTYPE *)pdata);

	push	1
	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tick$[ebp]
	push	ecx
	mov	edx, DWORD PTR _seq$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getValue@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEXHIAAVQuaternion@2@_N@Z ; Ogre::KeyFrameArray<Ogre::Quaternion>::getValue

; 101  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getValue@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEXHIPAX@Z ENDP ; Ogre::KeyFrameArray<Ogre::Quaternion>::getValue
_TEXT	ENDS
PUBLIC	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
PUBLIC	?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::empty
PUBLIC	??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
PUBLIC	??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
; Function compile flags: /Odtp
;	COMDAT ?_serialize@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
_version$ = 12						; size = 4
?_serialize@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z PROC ; Ogre::KeyFrameArray<Ogre::Quaternion>::_serialize, COMDAT
; _this$ = ecx

; 231  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 			ar.serializeRawType(m_Type);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$serializeRawType@W4InterpolType@Ogre@@@Archive@Ogre@@QAEXAAW4InterpolType@1@@Z ; Ogre::Archive::serializeRawType<enum Ogre::InterpolType>

; 233  : 			ar.serializeRawArray(m_Array);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>

; 234  : 			ar.serializeRawArray(m_CtrlPt);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>

; 235  : 
; 236  : 			if(!m_Array.empty() && int(m_Array[0].tick)<0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@serialize@3
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN1@serialize@3

; 237  : 			{
; 238  : 				m_Array[0].tick = 0;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	DWORD PTR [eax], 0
$LN1@serialize@3:

; 239  : 			}
; 240  : 
; 241  : 			BaseKeyFrameArray::_serialize(ar, version);

	mov	ecx, DWORD PTR _version$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ar$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_serialize@BaseKeyFrameArray@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::BaseKeyFrameArray::_serialize

; 242  : 			m_nPrindex	 = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], -1

; 243  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_serialize@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z ENDP ; Ogre::KeyFrameArray<Ogre::Quaternion>::_serialize
_TEXT	ENDS
PUBLIC	??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator=
PUBLIC	??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??4?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEABV01@ABV01@@Z PROC ; Ogre::KeyFrameArray<Ogre::Quaternion>::operator=, COMDAT
; _this$ = ecx

; 246  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 			m_Type = rhs.m_Type;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 248  : 			m_Array = rhs.m_Array;

	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator=

; 249  : 			m_Ranges = rhs.m_Ranges;

	mov	ecx, DWORD PTR _rhs$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator=

; 250  : 			m_CtrlPt = rhs.m_CtrlPt;

	mov	edx, DWORD PTR _rhs$[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator=

; 251  : 
; 252  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEABV01@ABV01@@Z ENDP ; Ogre::KeyFrameArray<Ogre::Quaternion>::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
PUBLIC	?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> > >
PUBLIC	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::begin
PUBLIC	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::end
PUBLIC	?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Buy
PUBLIC	??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
PUBLIC	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T77069 = -36						; size = 8
$T77068 = -28						; size = 8
$T77067 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77067[ebp], esp
	push	eax
	call	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@21

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T77068[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T77069[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@21
__catch$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@21
	ret	0
$LN5@vector@21:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@21:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@21:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
PUBLIC	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
PUBLIC	?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> > >
PUBLIC	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::begin
PUBLIC	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::end
PUBLIC	?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Buy
PUBLIC	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
PUBLIC	??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
PUBLIC	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T77097 = -36						; size = 8
$T77096 = -28						; size = 8
$T77095 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77095[ebp], esp
	push	eax
	call	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@22

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T77096[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T77097[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@22
__catch$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@22
	ret	0
$LN5@vector@22:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@22:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@22:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
__ehhandler$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
__ehhandler$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
__ehhandler$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
__ehhandler$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::~_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
__ehhandler$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::~_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0BaseKeyFrameArray@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0BaseKeyFrameArray@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0BaseKeyFrameArray@Ogre@@QAE@XZ$1
__ehfuncinfo$??0BaseKeyFrameArray@Ogre@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0BaseKeyFrameArray@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0BaseKeyFrameArray@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0BaseKeyFrameArray@Ogre@@QAE@XZ PROC			; Ogre::BaseKeyFrameArray::BaseKeyFrameArray, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0BaseKeyFrameArray@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@IAE@XZ		; Ogre::BaseObject::BaseObject
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseKeyFrameArray@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0BaseKeyFrameArray@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0BaseKeyFrameArray@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
__ehhandler$??0BaseKeyFrameArray@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0BaseKeyFrameArray@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0BaseKeyFrameArray@Ogre@@QAE@XZ ENDP			; Ogre::BaseKeyFrameArray::BaseKeyFrameArray
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
__ehhandler$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
__ehhandler$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
__ehhandler$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
__ehhandler$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
PUBLIC	??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T77214 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77214[ebp], esp
	call	??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::deallocate
PUBLIC	??$_Ucopy@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<Ogre::BaseKeyFrameArray::AnimRange *>
PUBLIC	?capacity@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::capacity
PUBLIC	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy
PUBLIC	??$unchecked_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
PUBLIC	?clear@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$64876 = -8					; size = 4
__Ptr$64866 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@7

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@7

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::clear
	jmp	$LN9@operator@7
$LN8@operator@7:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@7

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$64866[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$64866[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@7
$LN6@operator@7:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@7

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Ptr$64876[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$64876[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$64876[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<Ogre::BaseKeyFrameArray::AnimRange *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@7
$LN4@operator@7:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@7

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::deallocate
$LN2@operator@7:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@7

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<Ogre::BaseKeyFrameArray::AnimRange *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@7:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocate
PUBLIC	?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Xlen
PUBLIC	?max_size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::deallocate
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T77234 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77234[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
__ehhandler$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	??1_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::~_Container_base_aux
PUBLIC	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
;	COMDAT ??1_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::~_Container_base_aux, COMDAT
; _this$ = ecx

; 402  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 		// Do nothing: ~_Container_base_aux_alloc_real() previously destroyed the aux object.
; 404  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::~_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity
$LN3@capacity:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::erase
PUBLIC	?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin
PUBLIC	?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T77271 = -40						; size = 8
$T77270 = -32						; size = 8
$T77269 = -24						; size = 8
$T77268 = -16						; size = 8
$T77267 = -8						; size = 8
?clear@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T77268[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77267[ebp], ecx
	mov	DWORD PTR $T77267[ebp+4], edx
	lea	eax, DWORD PTR $T77270[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77269[ebp], ecx
	mov	DWORD PTR $T77269[ebp+4], edx
	mov	eax, DWORD PTR $T77267[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T77267[ebp]
	push	ecx
	mov	edx, DWORD PTR $T77269[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T77269[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77271[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEPAUTriggerDesc@Ogre@@I@Z ; std::allocator<Ogre::TriggerDesc>::allocate
PUBLIC	?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Xlen
PUBLIC	?max_size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2
$LN2@Buy@2:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEPAUTriggerDesc@Ogre@@I@Z ; std::allocator<Ogre::TriggerDesc>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@I@Z ; std::allocator<Ogre::TriggerDesc>::deallocate
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T77280 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77280[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
__ehhandler$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@XZ PROC	; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@I@Z PROC ; std::allocator<Ogre::TriggerDesc>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@I@Z ENDP ; std::allocator<Ogre::TriggerDesc>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@2
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@2
$LN3@capacity@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@2:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 4

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::erase
PUBLIC	?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin
PUBLIC	?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T77319 = -40						; size = 8
$T77318 = -32						; size = 8
$T77317 = -24						; size = 8
$T77316 = -16						; size = 8
$T77315 = -8						; size = 8
?clear@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T77316[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77315[ebp], ecx
	mov	DWORD PTR $T77315[ebp+4], edx
	lea	eax, DWORD PTR $T77318[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77317[ebp], ecx
	mov	DWORD PTR $T77317[ebp+4], edx
	mov	eax, DWORD PTR $T77315[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T77315[ebp]
	push	ecx
	mov	edx, DWORD PTR $T77317[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T77317[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77319[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEPAUSequenceDesc@Ogre@@I@Z ; std::allocator<Ogre::SequenceDesc>::allocate
PUBLIC	?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Xlen
PUBLIC	?max_size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@3
$LN2@Buy@3:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEPAUSequenceDesc@Ogre@@I@Z ; std::allocator<Ogre::SequenceDesc>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@3:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@I@Z ; std::allocator<Ogre::SequenceDesc>::deallocate
$LN1@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T77328 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77328[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
__ehhandler$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@XZ PROC	; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@I@Z PROC ; std::allocator<Ogre::SequenceDesc>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@I@Z ENDP ; std::allocator<Ogre::SequenceDesc>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@3
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@3
$LN3@capacity@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@3:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator+
PUBLIC	?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator-
PUBLIC	?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@ABQAVBoneTrack@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T77366 = -20						; size = 8
$T77363 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@ABQAVBoneTrack@Ogre@@@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	lea	eax, DWORD PTR $T77363[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77366[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@ABQAVBoneTrack@Ogre@@@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T77373 = -40						; size = 8
$T77372 = -32						; size = 8
$T77371 = -24						; size = 8
$T77370 = -16						; size = 8
$T77369 = -8						; size = 8
?clear@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T77370[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77369[ebp], ecx
	mov	DWORD PTR $T77369[ebp+4], edx
	lea	eax, DWORD PTR $T77372[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77371[ebp], ecx
	mov	DWORD PTR $T77371[ebp+4], edx
	mov	eax, DWORD PTR $T77369[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T77369[ebp]
	push	ecx
	mov	edx, DWORD PTR $T77371[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T77371[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77373[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEPAPAVBoneTrack@Ogre@@I@Z ; std::allocator<Ogre::BoneTrack *>::allocate
PUBLIC	?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@4

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@4
	jmp	SHORT $LN3@Buy@4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@4
$LN2@Buy@4:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEPAPAVBoneTrack@Ogre@@I@Z ; std::allocator<Ogre::BoneTrack *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@4:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@4:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEXPAPAVBoneTrack@Ogre@@I@Z ; std::allocator<Ogre::BoneTrack *>::deallocate
$LN1@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV34@IABQAV34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV34@IABQAV34@@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV34@IABQAV34@@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T77384 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77384[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
__ehhandler$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@XZ PROC	; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEXPAPAVBoneTrack@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEXPAPAVBoneTrack@Ogre@@I@Z PROC ; std::allocator<Ogre::BoneTrack *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEXPAPAVBoneTrack@Ogre@@I@Z ENDP ; std::allocator<Ogre::BoneTrack *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@4
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@4
$LN3@capacity@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@4:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::erase
PUBLIC	?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin
PUBLIC	?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T77423 = -40						; size = 8
$T77422 = -32						; size = 8
$T77421 = -24						; size = 8
$T77420 = -16						; size = 8
$T77419 = -8						; size = 8
?clear@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T77420[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77419[ebp], ecx
	mov	DWORD PTR $T77419[ebp+4], edx
	lea	eax, DWORD PTR $T77422[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77421[ebp], ecx
	mov	DWORD PTR $T77421[ebp+4], edx
	mov	eax, DWORD PTR $T77419[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T77419[ebp]
	push	ecx
	mov	edx, DWORD PTR $T77421[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T77421[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77423[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEPAPAVMaterialParamTrack@Ogre@@I@Z ; std::allocator<Ogre::MaterialParamTrack *>::allocate
PUBLIC	?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@5

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@5
	jmp	SHORT $LN3@Buy@5
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@5
$LN2@Buy@5:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEPAPAVMaterialParamTrack@Ogre@@I@Z ; std::allocator<Ogre::MaterialParamTrack *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@5:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@5:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEXPAPAVMaterialParamTrack@Ogre@@I@Z ; std::allocator<Ogre::MaterialParamTrack *>::deallocate
$LN1@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T77432 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77432[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::MaterialParamTrack *>::allocator<Ogre::MaterialParamTrack *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::MaterialParamTrack *>::allocator<Ogre::MaterialParamTrack *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
__ehhandler$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::MaterialParamTrack *>::allocator<Ogre::MaterialParamTrack *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::MaterialParamTrack *>::allocator<Ogre::MaterialParamTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEXPAPAVMaterialParamTrack@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEXPAPAVMaterialParamTrack@Ogre@@I@Z PROC ; std::allocator<Ogre::MaterialParamTrack *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEXPAPAVMaterialParamTrack@Ogre@@I@Z ENDP ; std::allocator<Ogre::MaterialParamTrack *>::deallocate
_TEXT	ENDS
PUBLIC	??$KEYFRAME_HERMITE@VVector3@Ogre@@@Ogre@@YAXAAVVector3@0@MABV10@111@Z ; Ogre::KEYFRAME_HERMITE<Ogre::Vector3>
PUBLIC	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator[]
PUBLIC	??$KEYFRAME_LERP@VVector3@Ogre@@@Ogre@@YAXAAVVector3@0@MABV10@1@Z ; Ogre::KEYFRAME_LERP<Ogre::Vector3>
PUBLIC	??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
EXTRN	__imp__rand:PROC
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
;	COMDAT ?getValue@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEXHIAAVVector3@2@_N@Z
_TEXT	SEGMENT
tv531 = -84						; size = 8
tv529 = -76						; size = 4
tv470 = -72						; size = 8
tv468 = -64						; size = 4
_this$ = -60						; size = 4
_tick1$65336 = -56					; size = 4
_t$65340 = -52						; size = 4
_tick2$65337 = -48					; size = 4
_middle$65331 = -44					; size = 4
_tick1$65296 = -40					; size = 4
_t$65300 = -36						; size = 4
_tick2$65297 = -32					; size = 4
_i$65282 = -28						; size = 4
_start$ = -24						; size = 4
_end$ = -20						; size = 4
_dtick$ = -16						; size = 4
_size$ = -12						; size = 4
_ntotalkeys$ = -8					; size = 4
_nseq$ = -4						; size = 4
_seq$ = 8						; size = 4
_tick$ = 12						; size = 4
_data$ = 16						; size = 4
_loop$ = 20						; size = 1
?getValue@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEXHIAAVVector3@2@_N@Z PROC ; Ogre::KeyFrameArray<Ogre::Vector3>::getValue, COMDAT
; _this$ = ecx

; 104  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 			int size = (int)m_Array.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	mov	DWORD PTR _size$[ebp], eax

; 106  : 
; 107  : 			//assert(size > 0);
; 108  : 
; 109  : 			if (size == 0)

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN29@getValue

; 110  : 				return;

	jmp	$LN30@getValue
$LN29@getValue:

; 111  : 			
; 112  : 			data = m_Array[0].data;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 113  : 
; 114  : 			int start, end;
; 115  : 			int ntotalkeys = (int)m_Array.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	mov	DWORD PTR _ntotalkeys$[ebp], eax

; 116  : 			int nseq = (int)m_Ranges.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	DWORD PTR _nseq$[ebp], eax

; 117  : 
; 118  : 			if(nseq == 0)

	cmp	DWORD PTR _nseq$[ebp], 0
	jne	SHORT $LN28@getValue

; 119  : 			{
; 120  : 				start = 0;

	mov	DWORD PTR _start$[ebp], 0

; 121  : 				end = ntotalkeys-1;

	mov	eax, DWORD PTR _ntotalkeys$[ebp]
	sub	eax, 1
	mov	DWORD PTR _end$[ebp], eax

; 122  : 			}
; 123  : 			else

	jmp	SHORT $LN27@getValue
$LN28@getValue:

; 124  : 			{
; 125  : 				assert(seq>=0 && seq<nseq);
; 126  : 				start = m_Ranges[seq].begin;

	mov	ecx, DWORD PTR _seq$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _start$[ebp], edx

; 127  : 				end = m_Ranges[seq].end;

	mov	eax, DWORD PTR _seq$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _end$[ebp], ecx
$LN27@getValue:

; 128  : 				assert(start <= end);
; 129  : 			}
; 130  : 			
; 131  : 
; 132  : 			if(m_Type == INTERPOL_RANDOM)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 3
	jne	SHORT $LN26@getValue

; 133  : 			{
; 134  : 				int i = start;

	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _i$65282[ebp], eax

; 135  : 				if(end > start) i += rand()%(end-start);

	mov	ecx, DWORD PTR _end$[ebp]
	cmp	ecx, DWORD PTR _start$[ebp]
	jle	SHORT $LN25@getValue
	call	DWORD PTR __imp__rand
	mov	ecx, DWORD PTR _end$[ebp]
	sub	ecx, DWORD PTR _start$[ebp]
	cdq
	idiv	ecx
	add	edx, DWORD PTR _i$65282[ebp]
	mov	DWORD PTR _i$65282[ebp], edx
$LN25@getValue:

; 136  : 
; 137  : 				data = m_Array[i].data;

	mov	edx, DWORD PTR _i$65282[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 138  : 				return;

	jmp	$LN30@getValue
$LN26@getValue:

; 139  : 			}
; 140  : 			if(start >= size)

	mov	eax, DWORD PTR _start$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jl	SHORT $LN24@getValue

; 141  : 			{
; 142  : 				start = size -1;

	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _start$[ebp], ecx
$LN24@getValue:

; 143  : 			}
; 144  : 			if(end >= size)

	mov	edx, DWORD PTR _end$[ebp]
	cmp	edx, DWORD PTR _size$[ebp]
	jl	SHORT $LN23@getValue

; 145  : 			{
; 146  : 				end = size -1;

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 1
	mov	DWORD PTR _end$[ebp], eax
$LN23@getValue:

; 147  : 			}
; 148  : 			tick -= m_Array[start].tick;

	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	edx, DWORD PTR _tick$[ebp]
	sub	edx, DWORD PTR [eax]
	mov	DWORD PTR _tick$[ebp], edx

; 149  : 			uint dtick = (m_Array[end].tick - m_Array[start].tick + 1);

	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	edx, DWORD PTR [esi]
	sub	edx, DWORD PTR [eax]
	add	edx, 1
	mov	DWORD PTR _dtick$[ebp], edx

; 150  : 			if(dtick == 0) tick = m_Array[start].tick;

	jne	SHORT $LN22@getValue
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick$[ebp], ecx

; 151  : 			else

	jmp	SHORT $LN17@getValue
$LN22@getValue:

; 152  : 			{	
; 153  : 				if(loop) tick = m_Array[start].tick + (tick%dtick);

	movzx	edx, BYTE PTR _loop$[ebp]
	test	edx, edx
	je	SHORT $LN20@getValue
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	ecx, eax
	mov	eax, DWORD PTR _tick$[ebp]
	xor	edx, edx
	div	DWORD PTR _dtick$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _tick$[ebp], edx
	jmp	SHORT $LN17@getValue
$LN20@getValue:

; 154  : 				else if(dtick < tick) tick = m_Array[end].tick;

	mov	edx, DWORD PTR _dtick$[ebp]
	cmp	edx, DWORD PTR _tick$[ebp]
	jae	SHORT $LN18@getValue
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick$[ebp], ecx
	jmp	SHORT $LN17@getValue
$LN18@getValue:

; 155  : 				else tick = m_Array[start].tick + tick;

	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR _tick$[ebp]
	mov	DWORD PTR _tick$[ebp], eax
$LN17@getValue:

; 156  : 			}
; 157  : 
; 158  : 			if ( m_nPrindex >= start && m_nPrindex  < end )  

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	cmp	edx, DWORD PTR _start$[ebp]
	jl	$LN14@getValue
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	cmp	ecx, DWORD PTR _end$[ebp]
	jge	$LN14@getValue

; 159  : 			{
; 160  : 				if ( tick > m_Array[m_nPrindex + 1].tick && m_nPrindex + 2 <= end)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jbe	SHORT $LN15@getValue
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 2
	cmp	eax, DWORD PTR _end$[ebp]
	jg	SHORT $LN15@getValue

; 161  : 				{
; 162  : 					m_nPrindex++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], edx
$LN15@getValue:

; 163  : 				}
; 164  : 				if ( tick >= m_Array[m_nPrindex].tick && tick <= m_Array[m_nPrindex + 1].tick )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jb	$LN14@getValue
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	ja	$LN14@getValue

; 165  : 				{
; 166  : 					uint tick1 = m_Array[m_nPrindex].tick;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick1$65296[ebp], ecx

; 167  : 					uint tick2 = m_Array[m_nPrindex+1].tick;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick2$65297[ebp], ecx

; 168  : 					if( tick1 == tick2 )

	mov	edx, DWORD PTR _tick1$65296[ebp]
	cmp	edx, DWORD PTR _tick2$65297[ebp]
	jne	SHORT $LN13@getValue

; 169  : 					{
; 170  : 						return;

	jmp	$LN30@getValue
$LN13@getValue:

; 171  : 					}
; 172  : 					assert( tick1 < tick2);
; 173  : 
; 174  : 					float t = float( int(tick-tick1) / double(tick2-tick1) );

	mov	eax, DWORD PTR _tick$[ebp]
	sub	eax, DWORD PTR _tick1$65296[ebp]
	mov	DWORD PTR tv468[ebp], eax
	fild	DWORD PTR tv468[ebp]
	mov	ecx, DWORD PTR _tick2$65297[ebp]
	sub	ecx, DWORD PTR _tick1$65296[ebp]
	mov	DWORD PTR tv470[ebp], ecx
	mov	DWORD PTR tv470[ebp+4], 0
	fild	QWORD PTR tv470[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _t$65300[ebp]

; 175  : 					if(m_Type == INTERPOL_LINEAR) KEYFRAME_LERP( data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 1
	jne	SHORT $LN12@getValue
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$65300[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	??$KEYFRAME_LERP@VVector3@Ogre@@@Ogre@@YAXAAVVector3@0@MABV10@1@Z ; Ogre::KEYFRAME_LERP<Ogre::Vector3>
	add	esp, 16					; 00000010H
	jmp	SHORT $LN11@getValue
$LN12@getValue:

; 176  : 					else KEYFRAME_HERMITE(data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data, m_CtrlPt[m_nPrindex].out, m_CtrlPt[m_nPrindex + 1].in);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator[]
	add	eax, 12					; 0000000cH
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$65300[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	??$KEYFRAME_HERMITE@VVector3@Ogre@@@Ogre@@YAXAAVVector3@0@MABV10@111@Z ; Ogre::KEYFRAME_HERMITE<Ogre::Vector3>
	add	esp, 24					; 00000018H
$LN11@getValue:

; 177  : 					return;

	jmp	$LN30@getValue
$LN14@getValue:

; 178  : 				}
; 179  : 				//while ( m_nPrindex < end)
; 180  : 				//{
; 181  : 				//	if ( tick >= m_Array[m_nPrindex].tick && tick <= m_Array[m_nPrindex + 1].tick )
; 182  : 				//	{
; 183  : 				//		uint tick1 = m_Array[m_nPrindex].tick;
; 184  : 				//		uint tick2 = m_Array[m_nPrindex+1].tick;
; 185  : 				//		if( tick1 == tick2 )
; 186  : 				//		{
; 187  : 				//			return;
; 188  : 				//		}
; 189  : 				//		assert( tick1 < tick2);
; 190  : 
; 191  : 				//		float t = float( int(tick-tick1) / double(tick2-tick1) );
; 192  : 				//		if(m_Type == INTERPOL_LINEAR) KEYFRAME_LERP( data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data);
; 193  : 				//		else KEYFRAME_HERMITE(data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data, m_CtrlPt[m_nPrindex].out, m_CtrlPt[m_nPrindex + 1].in);
; 194  : 				//		return;
; 195  : 				//	}
; 196  : 				//	m_nPrindex++;
; 197  : 				//}
; 198  : 			}
; 199  : 			//char po[100];
; 200  : 			//sprintf(po,"start %d end %d\n",start,end);
; 201  : 			//OutputDebugString(po);
; 202  : 
; 203  : 			for(;;)
; 204  : 			{
; 205  : 				if( start >= end-1 ) break;

	mov	edx, DWORD PTR _end$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _start$[ebp], edx
	jl	SHORT $LN8@getValue
	jmp	SHORT $LN9@getValue
$LN8@getValue:

; 206  : 
; 207  : 				int middle = (start+end)/2;

	mov	eax, DWORD PTR _start$[ebp]
	add	eax, DWORD PTR _end$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _middle$65331[ebp], eax

; 208  : 				if( tick < m_Array[middle].tick ) end = middle;

	mov	eax, DWORD PTR _middle$65331[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN7@getValue
	mov	edx, DWORD PTR _middle$65331[ebp]
	mov	DWORD PTR _end$[ebp], edx
	jmp	SHORT $LN6@getValue
$LN7@getValue:

; 209  : 				else start = middle;

	mov	eax, DWORD PTR _middle$65331[ebp]
	mov	DWORD PTR _start$[ebp], eax
$LN6@getValue:

; 210  : 			}

	jmp	SHORT $LN14@getValue
$LN9@getValue:

; 211  : 
; 212  : 			if( start == end ) data = m_Array[start].data;

	mov	ecx, DWORD PTR _start$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	jne	SHORT $LN5@getValue
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 213  : 			else

	jmp	$LN4@getValue
$LN5@getValue:

; 214  : 			{
; 215  : 				uint tick1 = m_Array[start].tick;

	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick1$65336[ebp], ecx

; 216  : 				uint tick2 = m_Array[end].tick;

	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _tick2$65337[ebp], eax

; 217  : 				if( tick1 == tick2 )

	mov	ecx, DWORD PTR _tick1$65336[ebp]
	cmp	ecx, DWORD PTR _tick2$65337[ebp]
	jne	SHORT $LN3@getValue

; 218  : 				{
; 219  : 					return;

	jmp	$LN30@getValue
$LN3@getValue:

; 220  : 				}
; 221  : 				assert( tick1 < tick2);
; 222  : 
; 223  : 				float t = float( int(tick-tick1) / double(tick2-tick1) );

	mov	edx, DWORD PTR _tick$[ebp]
	sub	edx, DWORD PTR _tick1$65336[ebp]
	mov	DWORD PTR tv529[ebp], edx
	fild	DWORD PTR tv529[ebp]
	mov	eax, DWORD PTR _tick2$65337[ebp]
	sub	eax, DWORD PTR _tick1$65336[ebp]
	mov	DWORD PTR tv531[ebp], eax
	mov	DWORD PTR tv531[ebp+4], 0
	fild	QWORD PTR tv531[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _t$65340[ebp]

; 224  : 				if(m_Type == INTERPOL_LINEAR) KEYFRAME_LERP( data, t, m_Array[start].data, m_Array[end].data);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 1
	jne	SHORT $LN2@getValue
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$65340[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	??$KEYFRAME_LERP@VVector3@Ogre@@@Ogre@@YAXAAVVector3@0@MABV10@1@Z ; Ogre::KEYFRAME_LERP<Ogre::Vector3>
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@getValue
$LN2@getValue:

; 225  : 				else KEYFRAME_HERMITE(data, t, m_Array[start].data, m_Array[end].data, m_CtrlPt[start].out, m_CtrlPt[end].in);

	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator[]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$65340[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	??$KEYFRAME_HERMITE@VVector3@Ogre@@@Ogre@@YAXAAVVector3@0@MABV10@111@Z ; Ogre::KEYFRAME_HERMITE<Ogre::Vector3>
	add	esp, 24					; 00000018H
$LN1@getValue:

; 226  : 				m_nPrindex = start;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _start$[ebp]
	mov	DWORD PTR [ecx+84], edx
$LN4@getValue:
$LN30@getValue:

; 227  : 			}
; 228  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?getValue@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEXHIAAVVector3@2@_N@Z ENDP ; Ogre::KeyFrameArray<Ogre::Vector3>::getValue
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@8
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@8:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T77459 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77459[ebp], esp
	call	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
PUBLIC	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::deallocate
PUBLIC	??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
PUBLIC	?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::capacity
PUBLIC	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Destroy
PUBLIC	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
PUBLIC	?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$65364 = -8					; size = 4
__Ptr$65354 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@9

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@9

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::clear
	jmp	$LN9@operator@9
$LN8@operator@9:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@9

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$65354[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$65354[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@9
$LN6@operator@9:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@9

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	shl	eax, 4
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$65364[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$65364[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$65364[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@9
$LN4@operator@9:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@9

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::deallocate
$LN2@operator@9:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@9

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@9:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 4

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::empty, COMDAT
; _this$ = ecx

; 735  : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 736  : 		return (size() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 737  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::empty
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@10
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@10:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocate
PUBLIC	?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Xlen
PUBLIC	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@6

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@6
	jmp	SHORT $LN3@Buy@6
$LN4@Buy@6:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@6

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@6
$LN2@Buy@6:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@6:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@6:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@6

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::deallocate
$LN1@Tidy@6:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T77485 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77485[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
__ehhandler$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T77506 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77506[ebp], esp
	call	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
PUBLIC	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::deallocate
PUBLIC	??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
PUBLIC	?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::capacity
PUBLIC	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Destroy
PUBLIC	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
PUBLIC	?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$65427 = -8					; size = 4
__Ptr$65417 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@11

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@11

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::clear
	jmp	$LN9@operator@11
$LN8@operator@11:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@11

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$65417[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$65417[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@11
$LN6@operator@11:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@11

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$65427[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$65427[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$65427[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator@11
$LN4@operator@11:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@11

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::deallocate
$LN2@operator@11:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@operator@11

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
$LN9@operator@11:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocate
PUBLIC	?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Xlen
PUBLIC	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@7

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@7
	jmp	SHORT $LN3@Buy@7
$LN4@Buy@7:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@7

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@7
$LN2@Buy@7:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@7:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@7:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@7

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, ecx
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::deallocate
$LN1@Tidy@7:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T77528 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77528[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
__ehhandler$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
_TEXT	ENDS
PUBLIC	??$KEYFRAME_HERMITE@VQuaternion@Ogre@@@Ogre@@YAXAAVQuaternion@0@MABV10@111@Z ; Ogre::KEYFRAME_HERMITE<Ogre::Quaternion>
PUBLIC	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator[]
PUBLIC	?KEYFRAME_LERP@Ogre@@YAXAAVQuaternion@1@MABV21@1@Z ; Ogre::KEYFRAME_LERP
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
;	COMDAT ?getValue@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEXHIAAVQuaternion@2@_N@Z
_TEXT	SEGMENT
tv531 = -84						; size = 8
tv529 = -76						; size = 4
tv470 = -72						; size = 8
tv468 = -64						; size = 4
_this$ = -60						; size = 4
_tick1$65533 = -56					; size = 4
_t$65537 = -52						; size = 4
_tick2$65534 = -48					; size = 4
_middle$65528 = -44					; size = 4
_tick1$65493 = -40					; size = 4
_t$65497 = -36						; size = 4
_tick2$65494 = -32					; size = 4
_i$65479 = -28						; size = 4
_start$ = -24						; size = 4
_end$ = -20						; size = 4
_dtick$ = -16						; size = 4
_size$ = -12						; size = 4
_ntotalkeys$ = -8					; size = 4
_nseq$ = -4						; size = 4
_seq$ = 8						; size = 4
_tick$ = 12						; size = 4
_data$ = 16						; size = 4
_loop$ = 20						; size = 1
?getValue@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEXHIAAVQuaternion@2@_N@Z PROC ; Ogre::KeyFrameArray<Ogre::Quaternion>::getValue, COMDAT
; _this$ = ecx

; 104  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 			int size = (int)m_Array.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	mov	DWORD PTR _size$[ebp], eax

; 106  : 
; 107  : 			//assert(size > 0);
; 108  : 
; 109  : 			if (size == 0)

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN29@getValue@2

; 110  : 				return;

	jmp	$LN30@getValue@2
$LN29@getValue@2:

; 111  : 			
; 112  : 			data = m_Array[0].data;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	call	??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::Quaternion::operator=

; 113  : 
; 114  : 			int start, end;
; 115  : 			int ntotalkeys = (int)m_Array.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	mov	DWORD PTR _ntotalkeys$[ebp], eax

; 116  : 			int nseq = (int)m_Ranges.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	DWORD PTR _nseq$[ebp], eax

; 117  : 
; 118  : 			if(nseq == 0)

	cmp	DWORD PTR _nseq$[ebp], 0
	jne	SHORT $LN28@getValue@2

; 119  : 			{
; 120  : 				start = 0;

	mov	DWORD PTR _start$[ebp], 0

; 121  : 				end = ntotalkeys-1;

	mov	eax, DWORD PTR _ntotalkeys$[ebp]
	sub	eax, 1
	mov	DWORD PTR _end$[ebp], eax

; 122  : 			}
; 123  : 			else

	jmp	SHORT $LN27@getValue@2
$LN28@getValue@2:

; 124  : 			{
; 125  : 				assert(seq>=0 && seq<nseq);
; 126  : 				start = m_Ranges[seq].begin;

	mov	ecx, DWORD PTR _seq$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _start$[ebp], edx

; 127  : 				end = m_Ranges[seq].end;

	mov	eax, DWORD PTR _seq$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _end$[ebp], ecx
$LN27@getValue@2:

; 128  : 				assert(start <= end);
; 129  : 			}
; 130  : 			
; 131  : 
; 132  : 			if(m_Type == INTERPOL_RANDOM)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 3
	jne	SHORT $LN26@getValue@2

; 133  : 			{
; 134  : 				int i = start;

	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _i$65479[ebp], eax

; 135  : 				if(end > start) i += rand()%(end-start);

	mov	ecx, DWORD PTR _end$[ebp]
	cmp	ecx, DWORD PTR _start$[ebp]
	jle	SHORT $LN25@getValue@2
	call	DWORD PTR __imp__rand
	mov	ecx, DWORD PTR _end$[ebp]
	sub	ecx, DWORD PTR _start$[ebp]
	cdq
	idiv	ecx
	add	edx, DWORD PTR _i$65479[ebp]
	mov	DWORD PTR _i$65479[ebp], edx
$LN25@getValue@2:

; 136  : 
; 137  : 				data = m_Array[i].data;

	mov	edx, DWORD PTR _i$65479[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	call	??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::Quaternion::operator=

; 138  : 				return;

	jmp	$LN30@getValue@2
$LN26@getValue@2:

; 139  : 			}
; 140  : 			if(start >= size)

	mov	eax, DWORD PTR _start$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jl	SHORT $LN24@getValue@2

; 141  : 			{
; 142  : 				start = size -1;

	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _start$[ebp], ecx
$LN24@getValue@2:

; 143  : 			}
; 144  : 			if(end >= size)

	mov	edx, DWORD PTR _end$[ebp]
	cmp	edx, DWORD PTR _size$[ebp]
	jl	SHORT $LN23@getValue@2

; 145  : 			{
; 146  : 				end = size -1;

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 1
	mov	DWORD PTR _end$[ebp], eax
$LN23@getValue@2:

; 147  : 			}
; 148  : 			tick -= m_Array[start].tick;

	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	edx, DWORD PTR _tick$[ebp]
	sub	edx, DWORD PTR [eax]
	mov	DWORD PTR _tick$[ebp], edx

; 149  : 			uint dtick = (m_Array[end].tick - m_Array[start].tick + 1);

	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	edx, DWORD PTR [esi]
	sub	edx, DWORD PTR [eax]
	add	edx, 1
	mov	DWORD PTR _dtick$[ebp], edx

; 150  : 			if(dtick == 0) tick = m_Array[start].tick;

	jne	SHORT $LN22@getValue@2
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick$[ebp], ecx

; 151  : 			else

	jmp	SHORT $LN17@getValue@2
$LN22@getValue@2:

; 152  : 			{	
; 153  : 				if(loop) tick = m_Array[start].tick + (tick%dtick);

	movzx	edx, BYTE PTR _loop$[ebp]
	test	edx, edx
	je	SHORT $LN20@getValue@2
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	ecx, eax
	mov	eax, DWORD PTR _tick$[ebp]
	xor	edx, edx
	div	DWORD PTR _dtick$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _tick$[ebp], edx
	jmp	SHORT $LN17@getValue@2
$LN20@getValue@2:

; 154  : 				else if(dtick < tick) tick = m_Array[end].tick;

	mov	edx, DWORD PTR _dtick$[ebp]
	cmp	edx, DWORD PTR _tick$[ebp]
	jae	SHORT $LN18@getValue@2
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick$[ebp], ecx
	jmp	SHORT $LN17@getValue@2
$LN18@getValue@2:

; 155  : 				else tick = m_Array[start].tick + tick;

	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR _tick$[ebp]
	mov	DWORD PTR _tick$[ebp], eax
$LN17@getValue@2:

; 156  : 			}
; 157  : 
; 158  : 			if ( m_nPrindex >= start && m_nPrindex  < end )  

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	cmp	edx, DWORD PTR _start$[ebp]
	jl	$LN14@getValue@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	cmp	ecx, DWORD PTR _end$[ebp]
	jge	$LN14@getValue@2

; 159  : 			{
; 160  : 				if ( tick > m_Array[m_nPrindex + 1].tick && m_nPrindex + 2 <= end)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jbe	SHORT $LN15@getValue@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 2
	cmp	eax, DWORD PTR _end$[ebp]
	jg	SHORT $LN15@getValue@2

; 161  : 				{
; 162  : 					m_nPrindex++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], edx
$LN15@getValue@2:

; 163  : 				}
; 164  : 				if ( tick >= m_Array[m_nPrindex].tick && tick <= m_Array[m_nPrindex + 1].tick )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jb	$LN14@getValue@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	ja	$LN14@getValue@2

; 165  : 				{
; 166  : 					uint tick1 = m_Array[m_nPrindex].tick;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick1$65493[ebp], ecx

; 167  : 					uint tick2 = m_Array[m_nPrindex+1].tick;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick2$65494[ebp], ecx

; 168  : 					if( tick1 == tick2 )

	mov	edx, DWORD PTR _tick1$65493[ebp]
	cmp	edx, DWORD PTR _tick2$65494[ebp]
	jne	SHORT $LN13@getValue@2

; 169  : 					{
; 170  : 						return;

	jmp	$LN30@getValue@2
$LN13@getValue@2:

; 171  : 					}
; 172  : 					assert( tick1 < tick2);
; 173  : 
; 174  : 					float t = float( int(tick-tick1) / double(tick2-tick1) );

	mov	eax, DWORD PTR _tick$[ebp]
	sub	eax, DWORD PTR _tick1$65493[ebp]
	mov	DWORD PTR tv468[ebp], eax
	fild	DWORD PTR tv468[ebp]
	mov	ecx, DWORD PTR _tick2$65494[ebp]
	sub	ecx, DWORD PTR _tick1$65493[ebp]
	mov	DWORD PTR tv470[ebp], ecx
	mov	DWORD PTR tv470[ebp+4], 0
	fild	QWORD PTR tv470[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _t$65497[ebp]

; 175  : 					if(m_Type == INTERPOL_LINEAR) KEYFRAME_LERP( data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 1
	jne	SHORT $LN12@getValue@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$65497[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	?KEYFRAME_LERP@Ogre@@YAXAAVQuaternion@1@MABV21@1@Z ; Ogre::KEYFRAME_LERP
	add	esp, 16					; 00000010H
	jmp	SHORT $LN11@getValue@2
$LN12@getValue@2:

; 176  : 					else KEYFRAME_HERMITE(data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data, m_CtrlPt[m_nPrindex].out, m_CtrlPt[m_nPrindex + 1].in);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator[]
	add	eax, 16					; 00000010H
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$65497[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	??$KEYFRAME_HERMITE@VQuaternion@Ogre@@@Ogre@@YAXAAVQuaternion@0@MABV10@111@Z ; Ogre::KEYFRAME_HERMITE<Ogre::Quaternion>
	add	esp, 24					; 00000018H
$LN11@getValue@2:

; 177  : 					return;

	jmp	$LN30@getValue@2
$LN14@getValue@2:

; 178  : 				}
; 179  : 				//while ( m_nPrindex < end)
; 180  : 				//{
; 181  : 				//	if ( tick >= m_Array[m_nPrindex].tick && tick <= m_Array[m_nPrindex + 1].tick )
; 182  : 				//	{
; 183  : 				//		uint tick1 = m_Array[m_nPrindex].tick;
; 184  : 				//		uint tick2 = m_Array[m_nPrindex+1].tick;
; 185  : 				//		if( tick1 == tick2 )
; 186  : 				//		{
; 187  : 				//			return;
; 188  : 				//		}
; 189  : 				//		assert( tick1 < tick2);
; 190  : 
; 191  : 				//		float t = float( int(tick-tick1) / double(tick2-tick1) );
; 192  : 				//		if(m_Type == INTERPOL_LINEAR) KEYFRAME_LERP( data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data);
; 193  : 				//		else KEYFRAME_HERMITE(data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data, m_CtrlPt[m_nPrindex].out, m_CtrlPt[m_nPrindex + 1].in);
; 194  : 				//		return;
; 195  : 				//	}
; 196  : 				//	m_nPrindex++;
; 197  : 				//}
; 198  : 			}
; 199  : 			//char po[100];
; 200  : 			//sprintf(po,"start %d end %d\n",start,end);
; 201  : 			//OutputDebugString(po);
; 202  : 
; 203  : 			for(;;)
; 204  : 			{
; 205  : 				if( start >= end-1 ) break;

	mov	edx, DWORD PTR _end$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _start$[ebp], edx
	jl	SHORT $LN8@getValue@2
	jmp	SHORT $LN9@getValue@2
$LN8@getValue@2:

; 206  : 
; 207  : 				int middle = (start+end)/2;

	mov	eax, DWORD PTR _start$[ebp]
	add	eax, DWORD PTR _end$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _middle$65528[ebp], eax

; 208  : 				if( tick < m_Array[middle].tick ) end = middle;

	mov	eax, DWORD PTR _middle$65528[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN7@getValue@2
	mov	edx, DWORD PTR _middle$65528[ebp]
	mov	DWORD PTR _end$[ebp], edx
	jmp	SHORT $LN6@getValue@2
$LN7@getValue@2:

; 209  : 				else start = middle;

	mov	eax, DWORD PTR _middle$65528[ebp]
	mov	DWORD PTR _start$[ebp], eax
$LN6@getValue@2:

; 210  : 			}

	jmp	SHORT $LN14@getValue@2
$LN9@getValue@2:

; 211  : 
; 212  : 			if( start == end ) data = m_Array[start].data;

	mov	ecx, DWORD PTR _start$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	jne	SHORT $LN5@getValue@2
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	call	??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::Quaternion::operator=

; 213  : 			else

	jmp	$LN4@getValue@2
$LN5@getValue@2:

; 214  : 			{
; 215  : 				uint tick1 = m_Array[start].tick;

	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick1$65533[ebp], ecx

; 216  : 				uint tick2 = m_Array[end].tick;

	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _tick2$65534[ebp], eax

; 217  : 				if( tick1 == tick2 )

	mov	ecx, DWORD PTR _tick1$65533[ebp]
	cmp	ecx, DWORD PTR _tick2$65534[ebp]
	jne	SHORT $LN3@getValue@2

; 218  : 				{
; 219  : 					return;

	jmp	$LN30@getValue@2
$LN3@getValue@2:

; 220  : 				}
; 221  : 				assert( tick1 < tick2);
; 222  : 
; 223  : 				float t = float( int(tick-tick1) / double(tick2-tick1) );

	mov	edx, DWORD PTR _tick$[ebp]
	sub	edx, DWORD PTR _tick1$65533[ebp]
	mov	DWORD PTR tv529[ebp], edx
	fild	DWORD PTR tv529[ebp]
	mov	eax, DWORD PTR _tick2$65534[ebp]
	sub	eax, DWORD PTR _tick1$65533[ebp]
	mov	DWORD PTR tv531[ebp], eax
	mov	DWORD PTR tv531[ebp+4], 0
	fild	QWORD PTR tv531[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _t$65537[ebp]

; 224  : 				if(m_Type == INTERPOL_LINEAR) KEYFRAME_LERP( data, t, m_Array[start].data, m_Array[end].data);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 1
	jne	SHORT $LN2@getValue@2
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$65537[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	?KEYFRAME_LERP@Ogre@@YAXAAVQuaternion@1@MABV21@1@Z ; Ogre::KEYFRAME_LERP
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@getValue@2
$LN2@getValue@2:

; 225  : 				else KEYFRAME_HERMITE(data, t, m_Array[start].data, m_Array[end].data, m_CtrlPt[start].out, m_CtrlPt[end].in);

	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator[]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$65537[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	??$KEYFRAME_HERMITE@VQuaternion@Ogre@@@Ogre@@YAXAAVQuaternion@0@MABV10@111@Z ; Ogre::KEYFRAME_HERMITE<Ogre::Quaternion>
	add	esp, 24					; 00000018H
$LN1@getValue@2:

; 226  : 				m_nPrindex = start;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _start$[ebp]
	mov	DWORD PTR [ecx+84], edx
$LN4@getValue@2:
$LN30@getValue@2:

; 227  : 			}
; 228  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?getValue@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEXHIAAVQuaternion@2@_N@Z ENDP ; Ogre::KeyFrameArray<Ogre::Quaternion>::getValue
_TEXT	ENDS
EXTRN	?slerp@Quaternion@Ogre@@QAEXABV12@0M@Z:PROC	; Ogre::Quaternion::slerp
; Function compile flags: /Odtp
;	COMDAT ?KEYFRAME_LERP@Ogre@@YAXAAVQuaternion@1@MABV21@1@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_t$ = 12						; size = 4
_src1$ = 16						; size = 4
_src2$ = 20						; size = 4
?KEYFRAME_LERP@Ogre@@YAXAAVQuaternion@1@MABV21@1@Z PROC	; Ogre::KEYFRAME_LERP, COMDAT

; 29   : 	{

	push	ebp
	mov	ebp, esp

; 30   : 		dest.slerp( src1, src2, t );

	push	ecx
	fld	DWORD PTR _t$[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _src2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _dest$[ebp]
	call	?slerp@Quaternion@Ogre@@QAEXABV12@0M@Z	; Ogre::Quaternion::slerp

; 31   : 	}

	pop	ebp
	ret	0
?KEYFRAME_LERP@Ogre@@YAXAAVQuaternion@1@MABV21@1@Z ENDP	; Ogre::KEYFRAME_LERP
_TEXT	ENDS
PUBLIC	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T77553 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77553[ebp], esp
	call	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
PUBLIC	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::deallocate
PUBLIC	??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
PUBLIC	?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::capacity
PUBLIC	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Destroy
PUBLIC	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
PUBLIC	?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$65561 = -8					; size = 4
__Ptr$65551 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@12

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@12

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::clear
	jmp	$LN9@operator@12
$LN8@operator@12:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@12

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$65551[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$65551[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@12
$LN6@operator@12:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@12

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$65561[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$65561[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$65561[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator@12
$LN4@operator@12:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@12

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::deallocate
$LN2@operator@12:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@operator@12

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
$LN9@operator@12:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::empty, COMDAT
; _this$ = ecx

; 735  : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 736  : 		return (size() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 737  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::empty
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@13
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@13:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocate
PUBLIC	?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Xlen
PUBLIC	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@8

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@8
	jmp	SHORT $LN3@Buy@8
$LN4@Buy@8:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@8

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@8
$LN2@Buy@8:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@8:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@8:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@8

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, ecx
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::deallocate
$LN1@Tidy@8:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T77579 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77579[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
__ehhandler$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T77600 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77600[ebp], esp
	call	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
PUBLIC	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::deallocate
PUBLIC	??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
PUBLIC	?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::capacity
PUBLIC	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Destroy
PUBLIC	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
PUBLIC	?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$65624 = -8					; size = 4
__Ptr$65614 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@14

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@14

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::clear
	jmp	$LN9@operator@14
$LN8@operator@14:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@14

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$65614[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$65614[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@14
$LN6@operator@14:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@14

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	shl	eax, 5
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$65624[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$65624[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$65624[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@14
$LN4@operator@14:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@14

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 5
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::deallocate
$LN2@operator@14:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@14

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@14:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 5

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocate
PUBLIC	?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Xlen
PUBLIC	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@9

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@9
	jmp	SHORT $LN3@Buy@9
$LN4@Buy@9:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@9

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@9
$LN2@Buy@9:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@9:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@9:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@9

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 5
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::deallocate
$LN1@Tidy@9:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T77622 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77622[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
__ehhandler$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@5
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@5
$LN3@capacity@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@5:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::max_size
_TEXT	ENDS
PUBLIC	?erase@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::erase
PUBLIC	?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin
PUBLIC	?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T77653 = -40						; size = 8
$T77652 = -32						; size = 8
$T77651 = -24						; size = 8
$T77650 = -16						; size = 8
$T77649 = -8						; size = 8
?clear@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T77650[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77649[ebp], ecx
	mov	DWORD PTR $T77649[ebp+4], edx
	lea	eax, DWORD PTR $T77652[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77651[ebp], ecx
	mov	DWORD PTR $T77651[ebp+4], edx
	mov	eax, DWORD PTR $T77649[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T77649[ebp]
	push	ecx
	mov	edx, DWORD PTR $T77651[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T77651[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77653[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::clear
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T77659 = -80						; size = 28
$T77658 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T77659[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T77659[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77658[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T77658[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77659[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T77659[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Xlen
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1logic_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$1
__ehfuncinfo$??1logic_error@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1logic_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 31   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1logic_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??1logic_error@std@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1logic_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@17
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@17:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1length_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1length_error@std@@UAE@XZ$0
__ehfuncinfo$??1length_error@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1length_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1length_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1length_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1length_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1length_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@18
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@18:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
PUBLIC	??$?0UAnimRange@BaseKeyFrameArray@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BaseKeyFrameArray::AnimRange>
PUBLIC	??0_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::_Container_base_aux
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T77725 = -24						; size = 4
$T77724 = -20						; size = 4
$T77723 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UAnimRange@BaseKeyFrameArray@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BaseKeyFrameArray::AnimRange>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T77725[ebp], eax
	mov	ecx, DWORD PTR $T77725[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T77724[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T77724[ebp], 0
	je	SHORT $LN3@Container_
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T77724[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_
$LN3@Container_:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T77723[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T77723[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T77725[ebp]
	push	eax
	mov	ecx, DWORD PTR $T77724[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 58   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 60   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z PROC	; std::_Aux_cont::_Aux_cont, COMDAT
; _this$ = ecx

; 364  : 	explicit _Aux_cont(const _Container_base_aux * const _Pcont)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ENDP	; std::_Aux_cont::_Aux_cont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::_Container_base_aux, COMDAT
; _this$ = ecx

; 379  : 	_Container_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		{
; 381  : 		// Do nothing: _Container_base_aux_alloc_real() will construct the aux object.
; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@XZ PROC ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@XZ ENDP ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z PROC ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ENDP ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z PROC ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::BaseKeyFrameArray::AnimRange>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ENDP ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UTriggerDesc@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::TriggerDesc>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UTriggerDesc@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::TriggerDesc>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator!=
PUBLIC	?_Make_iter@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$65978 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUTriggerDesc@Ogre@@PAU12@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$65978[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$65978[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$65978[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T77763 = -80						; size = 28
$T77762 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T77763[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T77763[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77762[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T77762[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77763[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T77763[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Xlen
PUBLIC	??$?0UTriggerDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTriggerDesc@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TriggerDesc>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T77775 = -24						; size = 4
$T77774 = -20						; size = 4
$T77773 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UTriggerDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTriggerDesc@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TriggerDesc>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T77775[ebp], eax
	mov	ecx, DWORD PTR $T77775[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T77774[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T77774[ebp], 0
	je	SHORT $LN3@Container_@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T77774[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@2
$LN3@Container_@2:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@2:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T77773[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T77773[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T77775[ebp]
	push	eax
	mov	ecx, DWORD PTR $T77774[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
PUBLIC	??$_Allocate@UTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::TriggerDesc>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEPAUTriggerDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEPAUTriggerDesc@Ogre@@I@Z PROC ; std::allocator<Ogre::TriggerDesc>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::TriggerDesc>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEPAUTriggerDesc@Ogre@@I@Z ENDP ; std::allocator<Ogre::TriggerDesc>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@USequenceDesc@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::SequenceDesc>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@USequenceDesc@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::SequenceDesc>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator!=
PUBLIC	?_Make_iter@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$66022 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUSequenceDesc@Ogre@@PAU12@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$66022[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$66022[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$66022[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T77799 = -80						; size = 28
$T77798 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T77799[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T77799[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77798[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T77798[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77799[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T77799[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Xlen
PUBLIC	??$?0USequenceDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@USequenceDesc@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SequenceDesc>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T77811 = -24						; size = 4
$T77810 = -20						; size = 4
$T77809 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0USequenceDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@USequenceDesc@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SequenceDesc>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T77811[ebp], eax
	mov	ecx, DWORD PTR $T77811[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T77810[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T77810[ebp], 0
	je	SHORT $LN3@Container_@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T77810[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@3
$LN3@Container_@3:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@3:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T77809[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T77809[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T77811[ebp]
	push	eax
	mov	ecx, DWORD PTR $T77810[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
PUBLIC	??$_Allocate@USequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::SequenceDesc>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEPAUSequenceDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEPAUSequenceDesc@Ogre@@I@Z PROC ; std::allocator<Ogre::SequenceDesc>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@USequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::SequenceDesc>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEPAUSequenceDesc@Ogre@@I@Z ENDP ; std::allocator<Ogre::SequenceDesc>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVBoneTrack@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::BoneTrack *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVBoneTrack@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::BoneTrack *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$66062 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$66062[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$66062[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$66062[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@3:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::erase
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
PUBLIC	??$fill@PAPAVBoneTrack@Ogre@@PAV12@@std@@YAXPAPAVBoneTrack@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::BoneTrack * *,Ogre::BoneTrack *>
PUBLIC	??$_Umove@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Umove<Ogre::BoneTrack * *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$66097 = -44					; size = 4
__Oldend$66098 = -40					; size = 4
__Tmp$66087 = -36					; size = 4
__Ncopied$66074 = -32					; size = 4
__Newvec$66072 = -28					; size = 4
__Whereoff$66073 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Xlen
	jmp	$LN16@Insert_n
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEPAPAVBoneTrack@Ogre@@I@Z ; std::allocator<Ogre::BoneTrack *>::allocate
	mov	DWORD PTR __Newvec$66072[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$66073[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$66074[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$66073[ebp]
	mov	ecx, DWORD PTR __Newvec$66072[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$66074[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$66074[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$66072[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Umove<Ogre::BoneTrack * *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$66074[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$66074[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$66073[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$66072[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Umove<Ogre::BoneTrack * *>
	jmp	SHORT $LN19@Insert_n
__catch$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$66074[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$66073[ebp]
	mov	ecx, DWORD PTR __Newvec$66072[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$66072[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$66074[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$66073[ebp]
	mov	edx, DWORD PTR __Newvec$66072[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$66073[ebp]
	mov	ecx, DWORD PTR __Newvec$66072[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$66072[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEXPAPAVBoneTrack@Ogre@@I@Z ; std::allocator<Ogre::BoneTrack *>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z$1
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEXPAPAVBoneTrack@Ogre@@I@Z ; std::allocator<Ogre::BoneTrack *>::deallocate
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$66072[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$66072[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$66072[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$66087[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Umove<Ogre::BoneTrack * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$66087[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ufill
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$66087[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAPAVBoneTrack@Ogre@@PAV12@@std@@YAXPAPAVBoneTrack@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::BoneTrack * *,Ogre::BoneTrack *>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$66097[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$66098[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$66098[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$66098[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Umove<Ogre::BoneTrack * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$66098[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$66098[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$66097[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAPAVBoneTrack@Ogre@@PAV12@@std@@YAXPAPAVBoneTrack@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::BoneTrack * *,Ogre::BoneTrack *>
	add	esp, 12					; 0000000cH
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T77856 = -80						; size = 28
$T77855 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T77856[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T77856[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77855[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T77855[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77856[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@4:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T77856[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Xlen
PUBLIC	??$?0PAVBoneTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVBoneTrack@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BoneTrack *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T77868 = -24						; size = 4
$T77867 = -20						; size = 4
$T77866 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVBoneTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVBoneTrack@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BoneTrack *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T77868[ebp], eax
	mov	ecx, DWORD PTR $T77868[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T77867[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T77867[ebp], 0
	je	SHORT $LN3@Container_@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T77867[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@4
$LN3@Container_@4:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@4:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T77866[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T77866[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T77868[ebp]
	push	eax
	mov	ecx, DWORD PTR $T77867[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
PUBLIC	??$_Allocate@PAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::BoneTrack *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEPAPAVBoneTrack@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEPAPAVBoneTrack@Ogre@@I@Z PROC ; std::allocator<Ogre::BoneTrack *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::BoneTrack *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEPAPAVBoneTrack@Ogre@@I@Z ENDP ; std::allocator<Ogre::BoneTrack *>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::MaterialParamTrack *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::MaterialParamTrack *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$66149 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@4

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$66149[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$66149[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$66149[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@4:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T77892 = -80						; size = 28
$T77891 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T77892[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T77892[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77891[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T77891[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77892[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@5:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T77892[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Xlen
PUBLIC	??$?0PAVMaterialParamTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::MaterialParamTrack *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T77904 = -24						; size = 4
$T77903 = -20						; size = 4
$T77902 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVMaterialParamTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::MaterialParamTrack *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T77904[ebp], eax
	mov	ecx, DWORD PTR $T77904[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T77903[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T77903[ebp], 0
	je	SHORT $LN3@Container_@5
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T77903[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@5
$LN3@Container_@5:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@5:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T77902[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T77902[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T77904[ebp]
	push	eax
	mov	ecx, DWORD PTR $T77903[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	??$_Allocate@PAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::MaterialParamTrack *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEPAPAVMaterialParamTrack@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEPAPAVMaterialParamTrack@Ogre@@I@Z PROC ; std::allocator<Ogre::MaterialParamTrack *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::MaterialParamTrack *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEPAPAVMaterialParamTrack@Ogre@@I@Z ENDP ; std::allocator<Ogre::MaterialParamTrack *>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@6
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@6
$LN3@capacity@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@6:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::max_size
_TEXT	ENDS
PUBLIC	?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::erase
PUBLIC	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::begin
PUBLIC	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T77929 = -40						; size = 8
$T77928 = -32						; size = 8
$T77927 = -24						; size = 8
$T77926 = -16						; size = 8
$T77925 = -8						; size = 8
?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T77926[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77925[ebp], ecx
	mov	DWORD PTR $T77925[ebp+4], edx
	lea	eax, DWORD PTR $T77928[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77927[ebp], ecx
	mov	DWORD PTR $T77927[ebp+4], edx
	mov	eax, DWORD PTR $T77925[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T77925[ebp]
	push	ecx
	mov	edx, DWORD PTR $T77927[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T77927[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77929[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::clear
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Destroy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T77935 = -80						; size = 28
$T77934 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T77935[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T77935[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77934[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T77934[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77935[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@6:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T77935[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Xlen
PUBLIC	??$?0UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T77947 = -24						; size = 4
$T77946 = -20						; size = 4
$T77945 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T77947[ebp], eax
	mov	ecx, DWORD PTR $T77947[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T77946[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T77946[ebp], 0
	je	SHORT $LN3@Container_@6
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T77946[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@6
$LN3@Container_@6:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@6:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T77945[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T77945[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T77947[ebp]
	push	eax
	mov	ecx, DWORD PTR $T77946[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@XZ PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@XZ ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@7
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@7
$LN3@capacity@7:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@7:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@15
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@15:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator[]
_TEXT	ENDS
PUBLIC	?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::erase
PUBLIC	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::begin
PUBLIC	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T77978 = -40						; size = 8
$T77977 = -32						; size = 8
$T77976 = -24						; size = 8
$T77975 = -16						; size = 8
$T77974 = -8						; size = 8
?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T77975[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77974[ebp], ecx
	mov	DWORD PTR $T77974[ebp+4], edx
	lea	eax, DWORD PTR $T77977[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77976[ebp], ecx
	mov	DWORD PTR $T77976[ebp+4], edx
	mov	eax, DWORD PTR $T77974[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T77974[ebp]
	push	ecx
	mov	edx, DWORD PTR $T77976[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T77976[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77978[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::clear
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Destroy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T77984 = -80						; size = 28
$T77983 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T77984[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T77984[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77983[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T77983[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77984[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@7:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T77984[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Xlen
PUBLIC	??$?0UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T77996 = -24						; size = 4
$T77995 = -20						; size = 4
$T77994 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T77996[ebp], eax
	mov	ecx, DWORD PTR $T77996[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T77995[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T77995[ebp], 0
	je	SHORT $LN3@Container_@7
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T77995[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@7
$LN3@Container_@7:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@7:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T77994[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T77994[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T77996[ebp]
	push	eax
	mov	ecx, DWORD PTR $T77995[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@XZ PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAE@XZ ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@8
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@8
$LN3@capacity@8:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@8:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::max_size
_TEXT	ENDS
PUBLIC	?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::erase
PUBLIC	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::begin
PUBLIC	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T78025 = -40						; size = 8
$T78024 = -32						; size = 8
$T78023 = -24						; size = 8
$T78022 = -16						; size = 8
$T78021 = -8						; size = 8
?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T78022[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78021[ebp], ecx
	mov	DWORD PTR $T78021[ebp+4], edx
	lea	eax, DWORD PTR $T78024[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78023[ebp], ecx
	mov	DWORD PTR $T78023[ebp+4], edx
	mov	eax, DWORD PTR $T78021[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78021[ebp]
	push	ecx
	mov	edx, DWORD PTR $T78023[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78023[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78025[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::clear
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Destroy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T78031 = -80						; size = 28
$T78030 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T78031[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T78031[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78030[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T78030[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78031[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@8:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T78031[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Xlen
PUBLIC	??$?0UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T78043 = -24						; size = 4
$T78042 = -20						; size = 4
$T78041 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T78043[ebp], eax
	mov	ecx, DWORD PTR $T78043[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T78042[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T78042[ebp], 0
	je	SHORT $LN3@Container_@8
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T78042[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@8
$LN3@Container_@8:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@8:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T78041[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T78041[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T78043[ebp]
	push	eax
	mov	ecx, DWORD PTR $T78042[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@XZ PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@XZ ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@9
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@9
$LN3@capacity@9:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 5
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@9:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@16
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@16:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator[]
_TEXT	ENDS
PUBLIC	?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::erase
PUBLIC	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::begin
PUBLIC	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T78074 = -40						; size = 8
$T78073 = -32						; size = 8
$T78072 = -24						; size = 8
$T78071 = -16						; size = 8
$T78070 = -8						; size = 8
?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T78071[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78070[ebp], ecx
	mov	DWORD PTR $T78070[ebp+4], edx
	lea	eax, DWORD PTR $T78073[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78072[ebp], ecx
	mov	DWORD PTR $T78072[ebp+4], edx
	mov	eax, DWORD PTR $T78070[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78070[ebp]
	push	ecx
	mov	edx, DWORD PTR $T78072[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78072[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78074[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::clear
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Destroy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T78080 = -80						; size = 28
$T78079 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T78080[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T78080[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78079[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T78079[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78080[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@9:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T78080[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Xlen
PUBLIC	??$?0UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T78092 = -24						; size = 4
$T78091 = -20						; size = 4
$T78090 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T78092[ebp], eax
	mov	ecx, DWORD PTR $T78092[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T78091[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T78091[ebp], 0
	je	SHORT $LN3@Container_@9
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T78091[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@9
$LN3@Container_@9:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@9:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T78090[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T78090[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T78092[ebp]
	push	eax
	mov	ecx, DWORD PTR $T78091[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@XZ PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAE@XZ ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocate
_TEXT	ENDS
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
PUBLIC	??0?$_Ranit@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &>::_Ranit<Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU123@ABU123@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con
$LN1@Vector_con:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = ecx

; 452  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 454  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UTriggerDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Ranit<Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &>::_Ranit<Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UTriggerDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@2
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@2
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@2
$LN1@Vector_con@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@2:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@USequenceDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Ranit<Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &>::_Ranit<Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@USequenceDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@3
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@3
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@3
$LN1@Vector_con@3:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@3:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVBoneTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &>::_Ranit<Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVBoneTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@4
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@4
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@4
$LN1@Vector_con@4:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@4:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
_TEXT	ENDS
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
;	COMDAT ??G?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@17
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@17
$LN1@operator@17:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@17:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator-
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = ecx

; 462  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Other$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al

; 464  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 467  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 		return _Myaux != 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	al, cl

; 469  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator+
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVMaterialParamTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &>::_Ranit<Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVMaterialParamTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@5
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@5
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@5
$LN1@Vector_con@5:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@5:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@6
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@6
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@6
$LN1@Vector_con@6:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@6:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@7
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@7
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@7
$LN1@Vector_con@7:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@7:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@8
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@8
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@8
$LN1@Vector_con@8:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@8:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@9
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@9
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@9
$LN1@Vector_con@9:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@9:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &>::_Ranit<Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &>::_Ranit<Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTriggerDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UTriggerDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UTriggerDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &>::_Ranit<Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTriggerDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UTriggerDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &>::_Ranit<Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@USequenceDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@USequenceDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@USequenceDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &>::_Ranit<Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@USequenceDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@USequenceDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &>::_Ranit<Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVBoneTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVBoneTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVBoneTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &>::_Ranit<Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVBoneTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVBoneTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &>::_Ranit<Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParamTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVMaterialParamTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVMaterialParamTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &>::_Ranit<Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParamTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVMaterialParamTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &>::_Ranit<Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const &>
_TEXT	ENDS
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = ecx

; 448  : 	_Iterator_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTriggerDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTriggerDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTriggerDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@USequenceDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@USequenceDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@USequenceDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVBoneTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVBoneTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVBoneTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParamTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParamTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParamTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const &,std::_Iterator_base_aux>
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator!=
PUBLIC	?_Make_iter@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$66821 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@5

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$66821[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$66821[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$66821[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@5:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UTriggerDesc@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UTriggerDesc@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::TriggerDesc>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@2
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@2
$LN3@max_size@2:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UTriggerDesc@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::TriggerDesc>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@USequenceDesc@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@USequenceDesc@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::SequenceDesc>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 268435455	; 0fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@3
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@3
$LN3@max_size@3:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@3:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@USequenceDesc@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::SequenceDesc>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVBoneTrack@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVBoneTrack@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::BoneTrack *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@4
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@4
$LN3@max_size@4:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@4:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVBoneTrack@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::BoneTrack *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::MaterialParamTrack *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@5
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@5
$LN3@max_size@5:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@5:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::MaterialParamTrack *>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator!=
PUBLIC	?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$66887 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@6

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$66887[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$66887[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$66887[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@6:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 268435455	; 0fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@6
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@6
$LN3@max_size@6:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@6:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator!=
PUBLIC	?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$66909 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@7

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$66909[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$66909[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$66909[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@7:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 178956970	; 0aaaaaaaH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@7
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@7
$LN3@max_size@7:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@7:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator!=
PUBLIC	?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$66931 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@8

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$66931[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$66931[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$66931[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@8:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 214748364	; 0cccccccH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@8
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@8
$LN3@max_size@8:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@8:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator!=
PUBLIC	?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$66953 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@9

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$66953[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$66953[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$66953[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@9:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 134217727	; 07ffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@9
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@9
$LN3@max_size@9:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@9:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::max_size
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator!=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator+=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Make_iter
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@18
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@18
$LN1@operator@18:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@18:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@19
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@19
$LN1@operator@19:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@19:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator==
_TEXT	ENDS
PUBLIC	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@20
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@20:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@20
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@20
$LN1@operator@20:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@20:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator+=
_TEXT	ENDS
PUBLIC	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Iterator_base_aux::_Getmycont, COMDAT
; _this$ = ecx

; 457  : 		{	// Go through the aux object to get the container

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		return _Myaux ? _Myaux->_Getcont() : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN4@Getmycont
$LN3@Getmycont:
	mov	DWORD PTR tv67[ebp], 0
$LN4@Getmycont:
	mov	eax, DWORD PTR tv67[ebp]

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Aux_cont::_Getcont, COMDAT
; _this$ = ecx

; 368  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 		return _Mycontainer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@21
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@21
$LN1@operator@21:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@21:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@22
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@22
$LN1@operator@22:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@22:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator==
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@23
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@23
$LN1@operator@23:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@23:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@24
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@24
$LN1@operator@24:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@24:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@25
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@25
$LN1@operator@25:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@25:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@26
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@26
$LN1@operator@26:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@26:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@27
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@27
$LN1@operator@27:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@27:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator==
_TEXT	ENDS
PUBLIC	?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrearchive.h
;	COMDAT ??$serializeRawArray@UAnimRange@BaseKeyFrameArray@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = -4						; size = 4
_array$ = 8						; size = 4
??$serializeRawArray@UAnimRange@BaseKeyFrameArray@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@Z PROC ; Ogre::Archive::serializeRawArray<Ogre::BaseKeyFrameArray::AnimRange>, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 			uint num;
; 123  : 			if(isLoading())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@serializeR

; 124  : 			{
; 125  : 				read(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read

; 126  : 				array.resize(num);

	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _array$[ebp]
	call	?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize

; 127  : 				if(num > 0) read(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN3@serializeR
	mov	eax, DWORD PTR _num$[ebp]
	shl	eax, 3
	push	eax
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read
$LN3@serializeR:

; 128  : 			}
; 129  : 			else

	jmp	SHORT $LN2@serializeR
$LN4@serializeR:

; 130  : 			{
; 131  : 				num = (uint)array.size();

	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	DWORD PTR _num$[ebp], eax

; 132  : 				write(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write

; 133  : 				if(num > 0) write(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN2@serializeR
	mov	edx, DWORD PTR _num$[ebp]
	shl	edx, 3
	push	edx
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write
$LN2@serializeR:

; 134  : 			}
; 135  : 
; 136  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 137  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$serializeRawArray@UAnimRange@BaseKeyFrameArray@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@Z ENDP ; Ogre::Archive::serializeRawArray<Ogre::BaseKeyFrameArray::AnimRange>
_TEXT	ENDS
PUBLIC	?resize@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::resize
EXTRN	?writeObject@Archive@Ogre@@QAEXPAVBaseObject@2@@Z:PROC ; Ogre::Archive::writeObject
EXTRN	?readObject@Archive@Ogre@@QAEPAVBaseObject@2@XZ:PROC ; Ogre::Archive::readObject
; Function compile flags: /Odtp
;	COMDAT ??$?6VBoneTrack@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_i$67284 = -16						; size = 4
_pobj$67277 = -12					; size = 4
_i$67273 = -8						; size = 4
_num$ = -4						; size = 4
_array$ = 8						; size = 4
??$?6VBoneTrack@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@Z PROC ; Ogre::Archive::operator<<<Ogre::BoneTrack>, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			uint num;
; 63   : 
; 64   : 			if(isLoading())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@operator@28

; 65   : 			{
; 66   : 				read(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read

; 67   : 				array.resize(num);

	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _array$[ebp]
	call	?resize@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::resize

; 68   : 				for(uint i=0; i<num; i++)

	mov	DWORD PTR _i$67273[ebp], 0
	jmp	SHORT $LN9@operator@28
$LN8@operator@28:
	mov	eax, DWORD PTR _i$67273[ebp]
	add	eax, 1
	mov	DWORD PTR _i$67273[ebp], eax
$LN9@operator@28:
	mov	ecx, DWORD PTR _i$67273[ebp]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN7@operator@28

; 69   : 				{
; 70   : 					BaseObject *pobj = readObject();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readObject@Archive@Ogre@@QAEPAVBaseObject@2@XZ ; Ogre::Archive::readObject
	mov	DWORD PTR _pobj$67277[ebp], eax

; 71   : 					if(pobj == NULL) array[i] = NULL;

	cmp	DWORD PTR _pobj$67277[ebp], 0
	jne	SHORT $LN6@operator@28
	mov	edx, DWORD PTR _i$67273[ebp]
	push	edx
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAPAVBoneTrack@Ogre@@I@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator[]
	mov	DWORD PTR [eax], 0

; 72   : 					else

	jmp	SHORT $LN5@operator@28
$LN6@operator@28:

; 73   : 					{
; 74   : 						assert(IS_KIND_OF(T, pobj));
; 75   : 						array[i] = static_cast<T *>(pobj);

	mov	eax, DWORD PTR _i$67273[ebp]
	push	eax
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAPAVBoneTrack@Ogre@@I@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator[]
	mov	ecx, DWORD PTR _pobj$67277[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@operator@28:

; 76   : 					}
; 77   : 				}

	jmp	SHORT $LN8@operator@28
$LN7@operator@28:

; 78   : 			}
; 79   : 			else

	jmp	SHORT $LN4@operator@28
$LN10@operator@28:

; 80   : 			{
; 81   : 				num = (uint)array.size();

	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	mov	DWORD PTR _num$[ebp], eax

; 82   : 				write(&num, sizeof(num));

	push	4
	lea	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write

; 83   : 				for(uint i=0; i<num; i++)

	mov	DWORD PTR _i$67284[ebp], 0
	jmp	SHORT $LN3@operator@28
$LN2@operator@28:
	mov	eax, DWORD PTR _i$67284[ebp]
	add	eax, 1
	mov	DWORD PTR _i$67284[ebp], eax
$LN3@operator@28:
	mov	ecx, DWORD PTR _i$67284[ebp]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN4@operator@28

; 84   : 				{
; 85   : 					writeObject(array[i]);

	mov	edx, DWORD PTR _i$67284[ebp]
	push	edx
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAPAVBoneTrack@Ogre@@I@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeObject@Archive@Ogre@@QAEXPAVBaseObject@2@@Z ; Ogre::Archive::writeObject

; 86   : 				}

	jmp	SHORT $LN2@operator@28
$LN4@operator@28:

; 87   : 			}
; 88   : 
; 89   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 90   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$?6VBoneTrack@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@Z ENDP ; Ogre::Archive::operator<<<Ogre::BoneTrack>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@2@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@1@0PAU234@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@1@0PAU234@@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@2@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@1@0PAU234@@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@2@@stdext@@YAPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@1@0PAU23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@1@0PAU23@@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@2@@stdext@@YAPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@1@0PAU23@@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
PUBLIC	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
PUBLIC	??$_Iter_random@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTriggerDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
PUBLIC	??$_Ptr_cat@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTriggerDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUTriggerDesc@Ogre@@PAU12@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00@Z
_TEXT	SEGMENT
$T78346 = -3						; size = 1
$T78345 = -2						; size = 1
$T78344 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUTriggerDesc@Ogre@@PAU12@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00@Z PROC ; stdext::unchecked_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78344[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTriggerDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 8
	mov	BYTE PTR $T78345[ebp], al
	movzx	eax, BYTE PTR $T78344[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78345[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78346[ebp]
	push	ecx
	call	??$_Iter_random@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTriggerDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUTriggerDesc@Ogre@@PAU12@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00@Z ENDP ; stdext::unchecked_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUTriggerDesc@Ogre@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@PAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUTriggerDesc@Ogre@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@PAU23@00@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<Ogre::TriggerDesc *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUTriggerDesc@Ogre@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@PAU23@00@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<Ogre::TriggerDesc *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@2@@stdext@@YAPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@1@0PAU23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@1@0PAU23@@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@2@@stdext@@YAPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@1@0PAU23@@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
PUBLIC	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
PUBLIC	??$_Iter_random@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSequenceDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
PUBLIC	??$_Ptr_cat@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSequenceDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUSequenceDesc@Ogre@@PAU12@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00@Z
_TEXT	SEGMENT
$T78355 = -3						; size = 1
$T78354 = -2						; size = 1
$T78353 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUSequenceDesc@Ogre@@PAU12@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00@Z PROC ; stdext::unchecked_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78353[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSequenceDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 8
	mov	BYTE PTR $T78354[ebp], al
	movzx	eax, BYTE PTR $T78353[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78354[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78355[ebp]
	push	ecx
	call	??$_Iter_random@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSequenceDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUSequenceDesc@Ogre@@PAU12@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00@Z ENDP ; stdext::unchecked_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUSequenceDesc@Ogre@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@PAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUSequenceDesc@Ogre@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@PAU23@00@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<Ogre::SequenceDesc *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUSequenceDesc@Ogre@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@PAU23@00@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<Ogre::SequenceDesc *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@2@@stdext@@YAPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@2@@stdext@@YAPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
PUBLIC	??$_Iter_random@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@0@Z ; std::_Iter_random<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
PUBLIC	??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T78364 = -3						; size = 1
$T78363 = -2						; size = 1
$T78362 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78362[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 8
	mov	BYTE PTR $T78363[ebp], al
	movzx	eax, BYTE PTR $T78362[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78363[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78364[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@0@Z ; std::_Iter_random<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<Ogre::BoneTrack * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<Ogre::BoneTrack * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@2@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@2@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVMaterialParamTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParamTrack * *>
PUBLIC	??$_Iter_random@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParamTrack@Ogre@@0@Z ; std::_Iter_random<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
PUBLIC	??$_Ptr_cat@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParamTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T78373 = -3						; size = 1
$T78372 = -2						; size = 1
$T78371 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78371[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParamTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
	add	esp, 8
	mov	BYTE PTR $T78372[ebp], al
	movzx	eax, BYTE PTR $T78371[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78372[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78373[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParamTrack@Ogre@@0@Z ; std::_Iter_random<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParamTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParamTrack * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVMaterialParamTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVMaterialParamTrack@Ogre@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVMaterialParamTrack@Ogre@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<Ogre::MaterialParamTrack * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVMaterialParamTrack@Ogre@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrearchive.h
_TEXT	ENDS
;	COMDAT ??$serializeRawType@W4InterpolType@Ogre@@@Archive@Ogre@@QAEXAAW4InterpolType@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??$serializeRawType@W4InterpolType@Ogre@@@Archive@Ogre@@QAEXAAW4InterpolType@1@@Z PROC ; Ogre::Archive::serializeRawType<enum Ogre::InterpolType>, COMDAT
; _this$ = ecx

; 97   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 			serialize(&value, sizeof(T));

	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize

; 99   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$serializeRawType@W4InterpolType@Ogre@@@Archive@Ogre@@QAEXAAW4InterpolType@1@@Z ENDP ; Ogre::Archive::serializeRawType<enum Ogre::InterpolType>
_TEXT	ENDS
PUBLIC	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::resize
; Function compile flags: /Odtp
;	COMDAT ??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = -4						; size = 4
_array$ = 8						; size = 4
??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@Z PROC ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 			uint num;
; 123  : 			if(isLoading())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@serializeR@2

; 124  : 			{
; 125  : 				read(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read

; 126  : 				array.resize(num);

	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _array$[ebp]
	call	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::resize

; 127  : 				if(num > 0) read(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN3@serializeR@2
	mov	eax, DWORD PTR _num$[ebp]
	shl	eax, 4
	push	eax
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read
$LN3@serializeR@2:

; 128  : 			}
; 129  : 			else

	jmp	SHORT $LN2@serializeR@2
$LN4@serializeR@2:

; 130  : 			{
; 131  : 				num = (uint)array.size();

	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	mov	DWORD PTR _num$[ebp], eax

; 132  : 				write(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write

; 133  : 				if(num > 0) write(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN2@serializeR@2
	mov	edx, DWORD PTR _num$[ebp]
	shl	edx, 4
	push	edx
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write
$LN2@serializeR@2:

; 134  : 			}
; 135  : 
; 136  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 137  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@Z ENDP ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::resize
; Function compile flags: /Odtp
;	COMDAT ??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = -4						; size = 4
_array$ = 8						; size = 4
??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@Z PROC ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 			uint num;
; 123  : 			if(isLoading())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@serializeR@3

; 124  : 			{
; 125  : 				read(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read

; 126  : 				array.resize(num);

	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _array$[ebp]
	call	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::resize

; 127  : 				if(num > 0) read(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN3@serializeR@3
	mov	eax, DWORD PTR _num$[ebp]
	imul	eax, 24					; 00000018H
	push	eax
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read
$LN3@serializeR@3:

; 128  : 			}
; 129  : 			else

	jmp	SHORT $LN2@serializeR@3
$LN4@serializeR@3:

; 130  : 			{
; 131  : 				num = (uint)array.size();

	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	mov	DWORD PTR _num$[ebp], eax

; 132  : 				write(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write

; 133  : 				if(num > 0) write(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN2@serializeR@3
	mov	edx, DWORD PTR _num$[ebp]
	imul	edx, 24					; 00000018H
	push	edx
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write
$LN2@serializeR@3:

; 134  : 			}
; 135  : 
; 136  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 137  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@Z ENDP ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> > >
_TEXT	ENDS
PUBLIC	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::resize
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrearchive.h
;	COMDAT ??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = -4						; size = 4
_array$ = 8						; size = 4
??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@Z PROC ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 			uint num;
; 123  : 			if(isLoading())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@serializeR@4

; 124  : 			{
; 125  : 				read(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read

; 126  : 				array.resize(num);

	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _array$[ebp]
	call	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::resize

; 127  : 				if(num > 0) read(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN3@serializeR@4
	mov	eax, DWORD PTR _num$[ebp]
	imul	eax, 20					; 00000014H
	push	eax
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read
$LN3@serializeR@4:

; 128  : 			}
; 129  : 			else

	jmp	SHORT $LN2@serializeR@4
$LN4@serializeR@4:

; 130  : 			{
; 131  : 				num = (uint)array.size();

	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	mov	DWORD PTR _num$[ebp], eax

; 132  : 				write(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write

; 133  : 				if(num > 0) write(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN2@serializeR@4
	mov	edx, DWORD PTR _num$[ebp]
	imul	edx, 20					; 00000014H
	push	edx
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write
$LN2@serializeR@4:

; 134  : 			}
; 135  : 
; 136  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 137  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@Z ENDP ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::resize
; Function compile flags: /Odtp
;	COMDAT ??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = -4						; size = 4
_array$ = 8						; size = 4
??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@Z PROC ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 			uint num;
; 123  : 			if(isLoading())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@serializeR@5

; 124  : 			{
; 125  : 				read(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read

; 126  : 				array.resize(num);

	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _array$[ebp]
	call	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::resize

; 127  : 				if(num > 0) read(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN3@serializeR@5
	mov	eax, DWORD PTR _num$[ebp]
	shl	eax, 5
	push	eax
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read
$LN3@serializeR@5:

; 128  : 			}
; 129  : 			else

	jmp	SHORT $LN2@serializeR@5
$LN4@serializeR@5:

; 130  : 			{
; 131  : 				num = (uint)array.size();

	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	mov	DWORD PTR _num$[ebp], eax

; 132  : 				write(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write

; 133  : 				if(num > 0) write(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN2@serializeR@5
	mov	edx, DWORD PTR _num$[ebp]
	shl	edx, 5
	push	edx
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write
$LN2@serializeR@5:

; 134  : 			}
; 135  : 
; 136  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 137  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@Z ENDP ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
PUBLIC	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
PUBLIC	??$_Iter_random@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Iter_random<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
PUBLIC	??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T78398 = -3						; size = 1
$T78397 = -2						; size = 1
$T78396 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z PROC ; stdext::unchecked_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78396[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 8
	mov	BYTE PTR $T78397[ebp], al
	movzx	eax, BYTE PTR $T78396[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78397[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78398[ebp]
	push	ecx
	call	??$_Iter_random@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Iter_random<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ENDP ; stdext::unchecked_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@@Z
_TEXT	SEGMENT
$T78403 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTriggerDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 8
	mov	BYTE PTR $T78403[ebp], al
	movzx	edx, BYTE PTR $T78403[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@@Z
_TEXT	SEGMENT
$T78406 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSequenceDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 8
	mov	BYTE PTR $T78406[ebp], al
	movzx	edx, BYTE PTR $T78406[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@@Z
_TEXT	SEGMENT
$T78409 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 8
	mov	BYTE PTR $T78409[ebp], al
	movzx	edx, BYTE PTR $T78409[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T78413 = -2						; size = 1
$T78412 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T78412[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 8
	mov	BYTE PTR $T78413[ebp], al
	movzx	eax, BYTE PTR $T78412[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78413[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@@Z
_TEXT	SEGMENT
$T78416 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParamTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
	add	esp, 8
	mov	BYTE PTR $T78416[ebp], al
	movzx	edx, BYTE PTR $T78416[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >
_TEXT	ENDS
PUBLIC	?Lerp@Ogre@@YA?AVVector3@1@ABV21@0M@Z		; Ogre::Lerp
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
;	COMDAT ??$KEYFRAME_LERP@VVector3@Ogre@@@Ogre@@YAXAAVVector3@0@MABV10@1@Z
_TEXT	SEGMENT
$T78419 = -12						; size = 12
_dest$ = 8						; size = 4
_t$ = 12						; size = 4
_src1$ = 16						; size = 4
_src2$ = 20						; size = 4
??$KEYFRAME_LERP@VVector3@Ogre@@@Ogre@@YAXAAVVector3@0@MABV10@1@Z PROC ; Ogre::KEYFRAME_LERP<Ogre::Vector3>, COMDAT

; 24   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 25   : 		dest = Lerp(src1, src2, t);

	push	ecx
	fld	DWORD PTR _t$[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _src2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src1$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78419[ebp]
	push	edx
	call	?Lerp@Ogre@@YA?AVVector3@1@ABV21@0M@Z	; Ogre::Lerp
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _dest$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 26   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$KEYFRAME_LERP@VVector3@Ogre@@@Ogre@@YAXAAVVector3@0@MABV10@1@Z ENDP ; Ogre::KEYFRAME_LERP<Ogre::Vector3>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
_TEXT	ENDS
;	COMDAT ?Lerp@Ogre@@YA?AVVector3@1@ABV21@0M@Z
_TEXT	SEGMENT
tv147 = -12						; size = 4
tv142 = -8						; size = 4
tv137 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
_t$ = 20						; size = 4
?Lerp@Ogre@@YA?AVVector3@1@ABV21@0M@Z PROC		; Ogre::Lerp, COMDAT

; 258  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 259  : 		return Vector3(v1.x+(v2.x-v1.x)*t, v1.y+(v2.y-v1.y)*t,v1.z+(v2.z-v1.z)*t );

	mov	eax, DWORD PTR _v2$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _v1$[ebp]
	fsub	DWORD PTR [ecx+8]
	fmul	DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _v1$[ebp]
	fadd	DWORD PTR [edx+8]
	fstp	DWORD PTR tv137[ebp]
	fld	DWORD PTR tv137[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _v2$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _v1$[ebp]
	fsub	DWORD PTR [ecx+4]
	fmul	DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _v1$[ebp]
	fadd	DWORD PTR [edx+4]
	fstp	DWORD PTR tv142[ebp]
	fld	DWORD PTR tv142[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _v2$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _v1$[ebp]
	fsub	DWORD PTR [ecx]
	fmul	DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _v1$[ebp]
	fadd	DWORD PTR [edx]
	fstp	DWORD PTR tv147[ebp]
	fld	DWORD PTR tv147[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 260  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?Lerp@Ogre@@YA?AVVector3@1@ABV21@0M@Z ENDP		; Ogre::Lerp
_TEXT	ENDS
PUBLIC	??HOgre@@YA?AVVector3@0@ABV10@0@Z		; Ogre::operator+
PUBLIC	??DOgre@@YA?AVVector3@0@ABV10@M@Z		; Ogre::operator*
PUBLIC	__real@c000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@4000000000000000
;	COMDAT __real@c000000000000000
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
CONST	SEGMENT
__real@c000000000000000 DQ 0c000000000000000r	; -2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??$KEYFRAME_HERMITE@VVector3@Ogre@@@Ogre@@YAXAAVVector3@0@MABV10@111@Z
_TEXT	SEGMENT
$T78430 = -100						; size = 12
$T78429 = -88						; size = 12
$T78428 = -76						; size = 12
$T78427 = -64						; size = 12
$T78426 = -52						; size = 12
$T78425 = -40						; size = 12
$T78424 = -28						; size = 12
_h3$ = -16						; size = 4
_h4$ = -12						; size = 4
_h1$ = -8						; size = 4
_h2$ = -4						; size = 4
_dest$ = 8						; size = 4
_r$ = 12						; size = 4
_v1$ = 16						; size = 4
_v2$ = 20						; size = 4
_in$ = 24						; size = 4
_out$ = 28						; size = 4
??$KEYFRAME_HERMITE@VVector3@Ogre@@@Ogre@@YAXAAVVector3@0@MABV10@111@Z PROC ; Ogre::KEYFRAME_HERMITE<Ogre::Vector3>, COMDAT

; 35   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 36   : 		// basis functions
; 37   : 		float h1 = 2.0f*r*r*r - 3.0f*r*r + 1.0f;

	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4000000000000000
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4008000000000000
	fmul	DWORD PTR _r$[ebp]
	fsubp	ST(1), ST(0)
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	DWORD PTR _h1$[ebp]

; 38   : 		float h2 = -2.0f*r*r*r + 3.0f*r*r;

	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@c000000000000000
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4008000000000000
	fmul	DWORD PTR _r$[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _h2$[ebp]

; 39   : 		float h3 = r*r*r - 2.0f*r*r + r;

	fld	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4000000000000000
	fmul	DWORD PTR _r$[ebp]
	fsubp	ST(1), ST(0)
	fadd	DWORD PTR _r$[ebp]
	fstp	DWORD PTR _h3$[ebp]

; 40   : 		float h4 = r*r*r - r*r;

	fld	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _h4$[ebp]

; 41   : 
; 42   : 		// interpolation
; 43   : 		dest = v1*h1 + v2*h2 + in*h3 + out*h4;

	push	ecx
	fld	DWORD PTR _h4$[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78424[ebp]
	push	ecx
	call	??DOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	fld	DWORD PTR _h3$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78425[ebp]
	push	eax
	call	??DOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	fld	DWORD PTR _h2$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v2$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78426[ebp]
	push	edx
	call	??DOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	fld	DWORD PTR _h1$[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _v1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78427[ebp]
	push	ecx
	call	??DOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T78428[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T78429[ebp]
	push	eax
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T78430[ebp]
	push	ecx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _dest$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$KEYFRAME_HERMITE@VVector3@Ogre@@@Ogre@@YAXAAVVector3@0@MABV10@111@Z ENDP ; Ogre::KEYFRAME_HERMITE<Ogre::Vector3>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
_TEXT	ENDS
;	COMDAT ??HOgre@@YA?AVVector3@0@ABV10@0@Z
_TEXT	SEGMENT
tv92 = -12						; size = 4
tv89 = -8						; size = 4
tv86 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
??HOgre@@YA?AVVector3@0@ABV10@0@Z PROC			; Ogre::operator+, COMDAT

; 164  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 165  : 		return Vector3(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [edx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 166  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??HOgre@@YA?AVVector3@0@ABV10@0@Z ENDP			; Ogre::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??DOgre@@YA?AVVector3@0@ABV10@M@Z
_TEXT	SEGMENT
tv87 = -12						; size = 4
tv85 = -8						; size = 4
tv83 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_s$ = 16						; size = 4
??DOgre@@YA?AVVector3@0@ABV10@M@Z PROC			; Ogre::operator*, COMDAT

; 189  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 190  : 		return Vector3(v1.x*s, v1.y*s, v1.z*s);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv83[ebp]
	fld	DWORD PTR tv83[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv85[ebp]
	fld	DWORD PTR tv85[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv87[ebp]
	fld	DWORD PTR tv87[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 191  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??DOgre@@YA?AVVector3@0@ABV10@M@Z ENDP			; Ogre::operator*
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
PUBLIC	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
PUBLIC	??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
PUBLIC	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T78447 = -3						; size = 1
$T78446 = -2						; size = 1
$T78445 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z PROC ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78445[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T78446[ebp], al
	movzx	eax, BYTE PTR $T78445[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78446[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78447[ebp]
	push	ecx
	call	??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ENDP ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
PUBLIC	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
PUBLIC	??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
PUBLIC	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T78454 = -3						; size = 1
$T78453 = -2						; size = 1
$T78452 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z PROC ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78452[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T78453[ebp], al
	movzx	eax, BYTE PTR $T78452[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78453[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78454[ebp]
	push	ecx
	call	??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ENDP ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??HOgre@@YA?AVQuaternion@0@ABV10@0@Z		; Ogre::operator+
PUBLIC	??DOgre@@YA?AVQuaternion@0@ABV10@M@Z		; Ogre::operator*
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
;	COMDAT ??$KEYFRAME_HERMITE@VQuaternion@Ogre@@@Ogre@@YAXAAVQuaternion@0@MABV10@111@Z
_TEXT	SEGMENT
$T78465 = -128						; size = 16
$T78464 = -112						; size = 16
$T78463 = -96						; size = 16
$T78462 = -80						; size = 16
$T78461 = -64						; size = 16
$T78460 = -48						; size = 16
$T78459 = -32						; size = 16
_h3$ = -16						; size = 4
_h4$ = -12						; size = 4
_h1$ = -8						; size = 4
_h2$ = -4						; size = 4
_dest$ = 8						; size = 4
_r$ = 12						; size = 4
_v1$ = 16						; size = 4
_v2$ = 20						; size = 4
_in$ = 24						; size = 4
_out$ = 28						; size = 4
??$KEYFRAME_HERMITE@VQuaternion@Ogre@@@Ogre@@YAXAAVQuaternion@0@MABV10@111@Z PROC ; Ogre::KEYFRAME_HERMITE<Ogre::Quaternion>, COMDAT

; 35   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H

; 36   : 		// basis functions
; 37   : 		float h1 = 2.0f*r*r*r - 3.0f*r*r + 1.0f;

	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4000000000000000
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4008000000000000
	fmul	DWORD PTR _r$[ebp]
	fsubp	ST(1), ST(0)
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	DWORD PTR _h1$[ebp]

; 38   : 		float h2 = -2.0f*r*r*r + 3.0f*r*r;

	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@c000000000000000
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4008000000000000
	fmul	DWORD PTR _r$[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _h2$[ebp]

; 39   : 		float h3 = r*r*r - 2.0f*r*r + r;

	fld	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4000000000000000
	fmul	DWORD PTR _r$[ebp]
	fsubp	ST(1), ST(0)
	fadd	DWORD PTR _r$[ebp]
	fstp	DWORD PTR _h3$[ebp]

; 40   : 		float h4 = r*r*r - r*r;

	fld	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _h4$[ebp]

; 41   : 
; 42   : 		// interpolation
; 43   : 		dest = v1*h1 + v2*h2 + in*h3 + out*h4;

	push	ecx
	fld	DWORD PTR _h4$[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78459[ebp]
	push	ecx
	call	??DOgre@@YA?AVQuaternion@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	fld	DWORD PTR _h3$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78460[ebp]
	push	eax
	call	??DOgre@@YA?AVQuaternion@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	fld	DWORD PTR _h2$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v2$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78461[ebp]
	push	edx
	call	??DOgre@@YA?AVQuaternion@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	fld	DWORD PTR _h1$[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _v1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78462[ebp]
	push	ecx
	call	??DOgre@@YA?AVQuaternion@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T78463[ebp]
	push	edx
	call	??HOgre@@YA?AVQuaternion@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T78464[ebp]
	push	eax
	call	??HOgre@@YA?AVQuaternion@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T78465[ebp]
	push	ecx
	call	??HOgre@@YA?AVQuaternion@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _dest$[ebp]
	call	??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::Quaternion::operator=

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$KEYFRAME_HERMITE@VQuaternion@Ogre@@@Ogre@@YAXAAVQuaternion@0@MABV10@111@Z ENDP ; Ogre::KEYFRAME_HERMITE<Ogre::Quaternion>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrequaternion.h
_TEXT	ENDS
;	COMDAT ??DOgre@@YA?AVQuaternion@0@ABV10@M@Z
_TEXT	SEGMENT
tv95 = -16						; size = 4
tv93 = -12						; size = 4
tv91 = -8						; size = 4
tv89 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_q$ = 12						; size = 4
_s$ = 16						; size = 4
??DOgre@@YA?AVQuaternion@0@ABV10@M@Z PROC		; Ogre::operator*, COMDAT

; 143  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 144  : 		return Quaternion(q.x*s, q.y*s, q.z*s, q.w*s);

	mov	eax, DWORD PTR _q$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _q$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv91[ebp]
	fld	DWORD PTR tv91[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _q$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv93[ebp]
	fld	DWORD PTR tv93[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _q$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv95[ebp]
	fld	DWORD PTR tv95[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Quaternion@Ogre@@QAE@MMMM@Z		; Ogre::Quaternion::Quaternion
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 145  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??DOgre@@YA?AVQuaternion@0@ABV10@M@Z ENDP		; Ogre::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??HOgre@@YA?AVQuaternion@0@ABV10@0@Z
_TEXT	SEGMENT
tv134 = -16						; size = 4
tv131 = -12						; size = 4
tv128 = -8						; size = 4
tv93 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_q1$ = 12						; size = 4
_q2$ = 16						; size = 4
??HOgre@@YA?AVQuaternion@0@ABV10@0@Z PROC		; Ogre::operator+, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 149  : 		return Quaternion(q1.x+q2.x, q1.y+q2.y, q1.z+q2.z, q1.w+q2.w);

	mov	eax, DWORD PTR _q1$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _q2$[ebp]
	fadd	DWORD PTR [ecx+12]
	fstp	DWORD PTR tv93[ebp]
	fld	DWORD PTR tv93[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _q1$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _q2$[ebp]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR tv128[ebp]
	fld	DWORD PTR tv128[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _q1$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _q2$[ebp]
	fadd	DWORD PTR [edx+4]
	fstp	DWORD PTR tv131[ebp]
	fld	DWORD PTR tv131[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _q1$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _q2$[ebp]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR tv134[ebp]
	fld	DWORD PTR tv134[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Quaternion@Ogre@@QAE@MMMM@Z		; Ogre::Quaternion::Quaternion
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 150  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??HOgre@@YA?AVQuaternion@0@ABV10@0@Z ENDP		; Ogre::operator+
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
PUBLIC	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
PUBLIC	??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
PUBLIC	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T78474 = -3						; size = 1
$T78473 = -2						; size = 1
$T78472 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z PROC ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78472[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T78473[ebp], al
	movzx	eax, BYTE PTR $T78472[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78473[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78474[ebp]
	push	ecx
	call	??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ENDP ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
PUBLIC	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
PUBLIC	??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
PUBLIC	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T78481 = -3						; size = 1
$T78480 = -2						; size = 1
$T78479 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z PROC ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78479[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T78480[ebp], al
	movzx	eax, BYTE PTR $T78479[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78480[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78481[ebp]
	push	ecx
	call	??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ENDP ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@@Z
_TEXT	SEGMENT
$T78486 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 8
	mov	BYTE PTR $T78486[ebp], al
	movzx	edx, BYTE PTR $T78486[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UAnimRange@BaseKeyFrameArray@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UAnimRange@BaseKeyFrameArray@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BaseKeyFrameArray::AnimRange>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UAnimRange@BaseKeyFrameArray@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BaseKeyFrameArray::AnimRange>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Allocate@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@IPAU123@@Z
_TEXT	SEGMENT
$T78491 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@IPAU123@@Z PROC ; std::_Allocate<Ogre::BaseKeyFrameArray::AnimRange>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T78491[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T78491[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@IPAU123@@Z ENDP ; std::_Allocate<Ogre::BaseKeyFrameArray::AnimRange>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_alloc@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0
__ehfuncinfo$??1bad_alloc@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_alloc@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 381  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??1bad_alloc@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1bad_alloc@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@19
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@19:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0UTriggerDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTriggerDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UTriggerDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTriggerDesc@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TriggerDesc>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UTriggerDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTriggerDesc@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TriggerDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@IPAU12@@Z
_TEXT	SEGMENT
$T78516 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@IPAU12@@Z PROC ; std::_Allocate<Ogre::TriggerDesc>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T78516[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T78516[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@IPAU12@@Z ENDP ; std::_Allocate<Ogre::TriggerDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0USequenceDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@USequenceDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0USequenceDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@USequenceDesc@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SequenceDesc>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0USequenceDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@USequenceDesc@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SequenceDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@USequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@IPAU12@@Z
_TEXT	SEGMENT
$T78521 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@USequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@IPAU12@@Z PROC ; std::_Allocate<Ogre::SequenceDesc>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T78521[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T78521[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@USequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@IPAU12@@Z ENDP ; std::_Allocate<Ogre::SequenceDesc>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Umove<Ogre::BoneTrack * *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Umove<Ogre::BoneTrack * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVBoneTrack@Ogre@@PAV12@@std@@YAXPAPAVBoneTrack@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::BoneTrack * *,Ogre::BoneTrack *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAVBoneTrack@Ogre@@PAV12@@std@@YAXPAPAVBoneTrack@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVBoneTrack@Ogre@@PAV12@@std@@YAXPAPAVBoneTrack@Ogre@@0ABQAV12@@Z PROC ; std::fill<Ogre::BoneTrack * *,Ogre::BoneTrack *>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAPAVBoneTrack@Ogre@@PAV12@@std@@YAXPAPAVBoneTrack@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::BoneTrack * *,Ogre::BoneTrack *>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAPAVBoneTrack@Ogre@@PAV12@@std@@YAXPAPAVBoneTrack@Ogre@@0ABQAV12@@Z ENDP ; std::fill<Ogre::BoneTrack * *,Ogre::BoneTrack *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVBoneTrack@Ogre@@@Z ; std::_Move_cat<Ogre::BoneTrack * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T78530 = -3						; size = 1
$T78529 = -2						; size = 1
$T78528 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::BoneTrack * *,Ogre::BoneTrack * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78528[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVBoneTrack@Ogre@@@Z ; std::_Move_cat<Ogre::BoneTrack * *>
	add	esp, 4
	mov	BYTE PTR $T78529[ebp], al
	movzx	edx, BYTE PTR $T78528[ebp]
	push	edx
	movzx	eax, BYTE PTR $T78529[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78530[ebp]
	push	eax
	call	??$_Iter_random@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@0@Z ; std::_Iter_random<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAVBoneTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVBoneTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVBoneTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVBoneTrack@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BoneTrack *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVBoneTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVBoneTrack@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BoneTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T78535 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::BoneTrack *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T78535[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T78535[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::BoneTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVMaterialParamTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVMaterialParamTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::MaterialParamTrack *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVMaterialParamTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::MaterialParamTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T78540 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::MaterialParamTrack *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@5
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T78540[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T78540[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@5:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::MaterialParamTrack *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@@Z
_TEXT	SEGMENT
$T78543 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T78543[ebp], al
	movzx	edx, BYTE PTR $T78543[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IPAU123@@Z
_TEXT	SEGMENT
$T78548 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IPAU123@@Z PROC ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@6
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN2@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T78548[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T78548[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@6:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IPAU123@@Z ENDP ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@@Z
_TEXT	SEGMENT
$T78551 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T78551[ebp], al
	movzx	edx, BYTE PTR $T78551[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IPAU123@@Z
_TEXT	SEGMENT
$T78556 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IPAU123@@Z PROC ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@7

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@7
$LN3@Allocate@7:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T78556[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T78556[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@7:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IPAU123@@Z ENDP ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@@Z
_TEXT	SEGMENT
$T78559 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T78559[ebp], al
	movzx	edx, BYTE PTR $T78559[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IPAU123@@Z
_TEXT	SEGMENT
$T78564 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IPAU123@@Z PROC ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@8

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@8
$LN3@Allocate@8:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN2@Allocate@8

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T78564[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T78564[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@8:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 20					; 00000014H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@8:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IPAU123@@Z ENDP ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@@Z
_TEXT	SEGMENT
$T78567 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T78567[ebp], al
	movzx	edx, BYTE PTR $T78567[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IPAU123@@Z
_TEXT	SEGMENT
$T78572 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IPAU123@@Z PROC ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@9

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@9
$LN3@Allocate@9:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN2@Allocate@9

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T78572[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T78572[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@9:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@9:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IPAU123@@Z ENDP ; std::_Allocate<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z
_TEXT	SEGMENT
$T78575 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z PROC ; std::_Allocate<std::_Aux_cont>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@10

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@10
$LN3@Allocate@10:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@10

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T78575[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T78575[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@10:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@10:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Aux_cont>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
PUBLIC	?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXIUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T78587 = -8						; size = 8
__Newsize$ = 8						; size = 4
?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXI@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	xor	eax, eax
	mov	DWORD PTR $T78587[ebp], eax
	mov	DWORD PTR $T78587[ebp+4], eax
	mov	ecx, DWORD PTR $T78587[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T78587[ebp]
	push	edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXIUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize

; 714  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize
_TEXT	ENDS
PUBLIC	?resize@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXIPAVBoneTrack@Ogre@@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::resize
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?resize@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXI@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	push	0
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXIPAVBoneTrack@Ogre@@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::resize

; 714  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::resize
_TEXT	ENDS
PUBLIC	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::resize
PUBLIC	??0KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ ; Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T::KEYFRAME_T
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	sub	esp, 16					; 00000010H
	mov	ecx, esp
	call	??0KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::resize

; 714  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::resize
_TEXT	ENDS
PUBLIC	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::resize
PUBLIC	??0CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ ; Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T::CONTROL_POINT_T
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	sub	esp, 24					; 00000018H
	mov	ecx, esp
	call	??0CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::resize

; 714  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::resize
_TEXT	ENDS
PUBLIC	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::resize
PUBLIC	??0KEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ ; Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T::KEYFRAME_T
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T78598 = -20						; size = 20
__Newsize$ = 8						; size = 4
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	lea	ecx, DWORD PTR $T78598[ebp]
	call	??0KEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::resize

; 714  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::resize
_TEXT	ENDS
PUBLIC	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::resize
PUBLIC	??0CONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ ; Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T::CONTROL_POINT_T
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T78601 = -32						; size = 32
__Newsize$ = 8						; size = 4
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	lea	ecx, DWORD PTR $T78601[ebp]
	call	??0CONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	esi, eax
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::resize

; 714  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ PROC ; Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T::KEYFRAME_T, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ ENDP ; Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T::KEYFRAME_T
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ PROC ; Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T::CONTROL_POINT_T, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@XZ ENDP ; Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T::CONTROL_POINT_T
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0KEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0KEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ PROC ; Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T::KEYFRAME_T, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0Quaternion@Ogre@@QAE@XZ		; Ogre::Quaternion::Quaternion
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0KEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ ENDP ; Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T::KEYFRAME_T
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0CONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ PROC ; Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T::CONTROL_POINT_T, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Quaternion@Ogre@@QAE@XZ		; Ogre::Quaternion::Quaternion
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0Quaternion@Ogre@@QAE@XZ		; Ogre::Quaternion::Quaternion
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAE@XZ ENDP ; Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T::CONTROL_POINT_T
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+
PUBLIC	?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXIUAnimRange@BaseKeyFrameArray@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T78619 = -64						; size = 8
$T78618 = -56						; size = 8
$T78617 = -48						; size = 8
$T78616 = -40						; size = 8
$T78615 = -32						; size = 8
$T78614 = -24						; size = 8
$T78613 = -16						; size = 8
$T78612 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 8
?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXIUAnimRange@BaseKeyFrameArray@Ogre@@@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T78613[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78612[ebp], ecx
	mov	DWORD PTR $T78612[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T78612[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78612[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Insert_n
	jmp	SHORT $LN4@resize
$LN3@resize:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T78615[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T78614[ebp], edx
	mov	DWORD PTR $T78614[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78618[ebp]
	push	edx
	lea	eax, DWORD PTR $T78617[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78616[ebp], ecx
	mov	DWORD PTR $T78616[ebp+4], edx
	mov	eax, DWORD PTR $T78614[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78614[ebp]
	push	ecx
	mov	edx, DWORD PTR $T78616[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78616[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78619[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::erase
$LN4@resize:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXIUAnimRange@BaseKeyFrameArray@Ogre@@@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?resize@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXIPAVBoneTrack@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T78629 = -64						; size = 8
$T78628 = -56						; size = 8
$T78627 = -48						; size = 8
$T78626 = -40						; size = 8
$T78625 = -32						; size = 8
$T78624 = -24						; size = 8
$T78623 = -16						; size = 8
$T78622 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXIPAVBoneTrack@Ogre@@@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize@2

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T78623[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78622[ebp], ecx
	mov	DWORD PTR $T78622[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T78622[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78622[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@IABQAVBoneTrack@Ogre@@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Insert_n
	jmp	SHORT $LN4@resize@2
$LN3@resize@2:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@2

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T78625[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T78624[ebp], edx
	mov	DWORD PTR $T78624[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78628[ebp]
	push	edx
	lea	eax, DWORD PTR $T78627[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78626[ebp], ecx
	mov	DWORD PTR $T78626[ebp+4], edx
	mov	eax, DWORD PTR $T78624[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78624[ebp]
	push	ecx
	mov	edx, DWORD PTR $T78626[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78626[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78629[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::erase
$LN4@resize@2:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?resize@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXIPAVBoneTrack@Ogre@@@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::resize
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator+
PUBLIC	?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T78639 = -64						; size = 8
$T78638 = -56						; size = 8
$T78637 = -48						; size = 8
$T78636 = -40						; size = 8
$T78635 = -32						; size = 8
$T78634 = -24						; size = 8
$T78633 = -16						; size = 8
$T78632 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 16
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize@3

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T78633[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78632[ebp], ecx
	mov	DWORD PTR $T78632[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T78632[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78632[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Insert_n
	jmp	SHORT $LN4@resize@3
$LN3@resize@3:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@3

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T78635[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T78634[ebp], edx
	mov	DWORD PTR $T78634[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78638[ebp]
	push	edx
	lea	eax, DWORD PTR $T78637[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78636[ebp], ecx
	mov	DWORD PTR $T78636[ebp+4], edx
	mov	eax, DWORD PTR $T78634[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78634[ebp]
	push	ecx
	mov	edx, DWORD PTR $T78636[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78636[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78639[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::erase
$LN4@resize@3:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::resize
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator+
PUBLIC	?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T78649 = -64						; size = 8
$T78648 = -56						; size = 8
$T78647 = -48						; size = 8
$T78646 = -40						; size = 8
$T78645 = -32						; size = 8
$T78644 = -24						; size = 8
$T78643 = -16						; size = 8
$T78642 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 24
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize@4

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T78643[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78642[ebp], ecx
	mov	DWORD PTR $T78642[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T78642[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78642[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Insert_n
	jmp	SHORT $LN4@resize@4
$LN3@resize@4:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@4

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T78645[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T78644[ebp], edx
	mov	DWORD PTR $T78644[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78648[ebp]
	push	edx
	lea	eax, DWORD PTR $T78647[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78646[ebp], ecx
	mov	DWORD PTR $T78646[ebp+4], edx
	mov	eax, DWORD PTR $T78644[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78644[ebp]
	push	ecx
	mov	edx, DWORD PTR $T78646[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78646[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78649[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::erase
$LN4@resize@4:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::resize
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator+
PUBLIC	?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T78659 = -64						; size = 8
$T78658 = -56						; size = 8
$T78657 = -48						; size = 8
$T78656 = -40						; size = 8
$T78655 = -32						; size = 8
$T78654 = -24						; size = 8
$T78653 = -16						; size = 8
$T78652 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 20
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize@5

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T78653[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78652[ebp], ecx
	mov	DWORD PTR $T78652[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T78652[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78652[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Insert_n
	jmp	SHORT $LN4@resize@5
$LN3@resize@5:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@5

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T78655[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T78654[ebp], edx
	mov	DWORD PTR $T78654[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78658[ebp]
	push	edx
	lea	eax, DWORD PTR $T78657[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78656[ebp], ecx
	mov	DWORD PTR $T78656[ebp+4], edx
	mov	eax, DWORD PTR $T78654[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78654[ebp]
	push	ecx
	mov	edx, DWORD PTR $T78656[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78656[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78659[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::erase
$LN4@resize@5:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::resize
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator+
PUBLIC	?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T78669 = -64						; size = 8
$T78668 = -56						; size = 8
$T78667 = -48						; size = 8
$T78666 = -40						; size = 8
$T78665 = -32						; size = 8
$T78664 = -24						; size = 8
$T78663 = -16						; size = 8
$T78662 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 32
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize@6

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T78663[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78662[ebp], ecx
	mov	DWORD PTR $T78662[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T78662[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78662[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Insert_n
	jmp	SHORT $LN4@resize@6
$LN3@resize@6:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@6

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T78665[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T78664[ebp], edx
	mov	DWORD PTR $T78664[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78668[ebp]
	push	edx
	lea	eax, DWORD PTR $T78667[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78666[ebp], ecx
	mov	DWORD PTR $T78666[ebp+4], edx
	mov	eax, DWORD PTR $T78664[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78664[ebp]
	push	ecx
	mov	edx, DWORD PTR $T78666[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78666[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78669[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::erase
$LN4@resize@6:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::resize
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
PUBLIC	??$fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z ; std::fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>
PUBLIC	??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Umove<Ogre::BaseKeyFrameArray::AnimRange *>
PUBLIC	?_Ufill@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ufill
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -60						; size = 4
_this$ = -56						; size = 4
__Tmp$69852 = -52					; size = 8
__Oldend$69853 = -44					; size = 4
__Tmp$69842 = -40					; size = 8
__Ncopied$69829 = -32					; size = 4
__Newvec$69827 = -28					; size = 4
__Whereoff$69828 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Xlen
	jmp	$LN16@Insert_n@2
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@2:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocate
	mov	DWORD PTR __Newvec$69827[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR __Whereoff$69828[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$69829[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$69828[ebp]
	mov	ecx, DWORD PTR __Newvec$69827[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$69829[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$69829[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$69827[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Umove<Ogre::BaseKeyFrameArray::AnimRange *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$69829[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$69829[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$69828[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$69827[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Umove<Ogre::BaseKeyFrameArray::AnimRange *>
	jmp	SHORT $LN19@Insert_n@2
__catch$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$69829[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$69828[ebp]
	mov	ecx, DWORD PTR __Newvec$69827[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR __Newvec$69827[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$69829[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$69828[ebp]
	mov	edx, DWORD PTR __Newvec$69827[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	push	edx
	mov	eax, DWORD PTR __Whereoff$69828[ebp]
	mov	ecx, DWORD PTR __Newvec$69827[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$69827[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::deallocate
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$69827[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$69827[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$69827[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 3
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$69842[ebp], ecx
	mov	DWORD PTR __Tmp$69842[ebp+4], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Umove<Ogre::BaseKeyFrameArray::AnimRange *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$69842[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 3
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ufill
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	eax, DWORD PTR __Tmp$69842[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z ; std::fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$69852[ebp], eax
	mov	DWORD PTR __Tmp$69852[ebp+4], ecx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Oldend$69853[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Oldend$69853[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Oldend$69853[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Umove<Ogre::BaseKeyFrameArray::AnimRange *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$69853[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Oldend$69853[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$69852[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z ; std::fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Insert_n
PUBLIC	??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
PUBLIC	??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
PUBLIC	??0KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABU012@@Z ; Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T::KEYFRAME_T
PUBLIC	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
PUBLIC	?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Ufill
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -76						; size = 4
_this$ = -72						; size = 4
__Tmp$69895 = -68					; size = 16
__Oldend$69896 = -52					; size = 4
__Tmp$69885 = -48					; size = 16
__Ncopied$69872 = -32					; size = 4
__Newvec$69870 = -28					; size = 4
__Whereoff$69871 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 60					; 0000003cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@3
	jmp	$LN16@Insert_n@3
$LN14@Insert_n@3:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Xlen
	jmp	$LN16@Insert_n@3
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@3:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::allocate
	mov	DWORD PTR __Newvec$69870[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	mov	DWORD PTR __Whereoff$69871[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$69872[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$69871[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$69870[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$69872[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$69872[ebp], ecx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Newvec$69870[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$69872[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$69872[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Whereoff$69871[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$69870[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	jmp	SHORT $LN19@Insert_n@3
__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$69872[ebp], 1
	jle	SHORT $LN7@Insert_n@3

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$69871[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Newvec$69870[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$69870[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Destroy
$LN7@Insert_n@3:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$69872[ebp], 0
	jle	SHORT $LN6@Insert_n@3

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$69871[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$69870[ebp]
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR __Whereoff$69871[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$69870[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Destroy
$LN6@Insert_n@3:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$69870[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::deallocate
$LN5@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$69870[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$69870[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$69870[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@3
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 4
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$69885[ebp]
	call	??0KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABU012@@Z

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$69885[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 4
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Ufill
	jmp	SHORT $LN21@Insert_n@3
__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	push	edx
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$69885[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@3
$LN3@Insert_n@3:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$69895[ebp]
	call	??0KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABU012@@Z

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Oldend$69896[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Oldend$69896[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR __Oldend$69896[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$69896[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR __Oldend$69896[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$69895[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Insert_n
PUBLIC	??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
PUBLIC	??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
PUBLIC	??0CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABU012@@Z ; Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T::CONTROL_POINT_T
PUBLIC	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
PUBLIC	?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Ufill
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -92						; size = 4
_this$ = -88						; size = 4
__Tmp$69938 = -84					; size = 24
__Oldend$69939 = -60					; size = 4
__Tmp$69928 = -56					; size = 24
__Ncopied$69915 = -32					; size = 4
__Newvec$69913 = -28					; size = 4
__Whereoff$69914 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@4
	jmp	$LN16@Insert_n@4
$LN14@Insert_n@4:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@4

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Xlen
	jmp	$LN16@Insert_n@4
$LN12@Insert_n@4:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@4
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@4:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@4:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::allocate
	mov	DWORD PTR __Newvec$69913[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR __Whereoff$69914[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$69915[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Whereoff$69914[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Newvec$69913[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$69915[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$69915[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR __Newvec$69913[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>

; 1182 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$69915[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$69915[ebp], ecx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Whereoff$69914[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Newvec$69913[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	jmp	SHORT $LN19@Insert_n@4
__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$69915[ebp], 1
	jle	SHORT $LN7@Insert_n@4

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$69914[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Newvec$69913[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$69913[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Destroy
$LN7@Insert_n@4:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$69915[ebp], 0
	jle	SHORT $LN6@Insert_n@4

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	edx, DWORD PTR __Whereoff$69914[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Newvec$69913[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	add	edx, eax
	push	edx
	mov	ecx, DWORD PTR __Whereoff$69914[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Newvec$69913[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Destroy
$LN6@Insert_n@4:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$69913[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN5@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [ecx+12]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::deallocate
$LN5@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Newvec$69913[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Newvec$69913[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$69913[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@4
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@4

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$69928[ebp]
	call	??0CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABU012@@Z

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	ecx, DWORD PTR __Tmp$69928[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Ufill
	jmp	SHORT $LN21@Insert_n@4
__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	push	edx
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$69928[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@4
$LN3@Insert_n@4:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$69938[ebp]
	call	??0CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABU012@@Z

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Oldend$69939[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Oldend$69939[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR __Oldend$69939[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$69939[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR __Oldend$69939[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$69938[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@4:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Insert_n
PUBLIC	??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
PUBLIC	??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
PUBLIC	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
PUBLIC	?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Ufill
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -84						; size = 4
_this$ = -80						; size = 4
__Tmp$69981 = -76					; size = 20
__Oldend$69982 = -56					; size = 4
__Tmp$69971 = -52					; size = 20
__Ncopied$69958 = -32					; size = 4
__Newvec$69956 = -28					; size = 4
__Whereoff$69957 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@5
	jmp	$LN16@Insert_n@5
$LN14@Insert_n@5:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Xlen
	jmp	$LN16@Insert_n@5
$LN12@Insert_n@5:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@5
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@5:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@5:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::allocate
	mov	DWORD PTR __Newvec$69956[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR __Whereoff$69957[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$69958[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Whereoff$69957[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Newvec$69956[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$69958[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$69958[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR __Newvec$69956[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>

; 1182 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$69958[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$69958[ebp], ecx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Whereoff$69957[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	add	edx, DWORD PTR __Newvec$69956[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	jmp	SHORT $LN19@Insert_n@5
__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$69958[ebp], 1
	jle	SHORT $LN7@Insert_n@5

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$69957[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Newvec$69956[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$69956[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Destroy
$LN7@Insert_n@5:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$69958[ebp], 0
	jle	SHORT $LN6@Insert_n@5

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	edx, DWORD PTR __Whereoff$69957[ebp]
	imul	edx, 20					; 00000014H
	add	edx, DWORD PTR __Newvec$69956[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 20					; 00000014H
	add	edx, eax
	push	edx
	mov	ecx, DWORD PTR __Whereoff$69957[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Newvec$69956[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Destroy
$LN6@Insert_n@5:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$69956[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN5@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [ecx+12]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::deallocate
$LN5@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Newvec$69956[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Newvec$69956[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$69956[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@5
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@5

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$69971[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$69971[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$69971[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$69971[ebp+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR __Tmp$69971[ebp+16], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	ecx, DWORD PTR __Tmp$69971[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Ufill
	jmp	SHORT $LN21@Insert_n@5
__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	push	edx
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$69971[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@5
$LN3@Insert_n@5:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$69981[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$69981[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$69981[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$69981[ebp+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Tmp$69981[ebp+16], ecx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Oldend$69982[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Oldend$69982[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR __Oldend$69982[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$69982[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR __Oldend$69982[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$69981[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@5:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Insert_n
PUBLIC	??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
PUBLIC	??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
PUBLIC	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
PUBLIC	?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Ufill
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -108						; size = 4
_this$ = -104						; size = 4
__Tmp$70024 = -100					; size = 32
__Oldend$70025 = -68					; size = 4
__Tmp$70014 = -64					; size = 32
__Ncopied$70001 = -32					; size = 4
__Newvec$69999 = -28					; size = 4
__Whereoff$70000 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@6
	jmp	$LN16@Insert_n@6
$LN14@Insert_n@6:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@6

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Xlen
	jmp	$LN16@Insert_n@6
$LN12@Insert_n@6:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@6

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@6
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@6
$LN17@Insert_n@6:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@6:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@6

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@6:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::allocate
	mov	DWORD PTR __Newvec$69999[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 5
	mov	DWORD PTR __Whereoff$70000[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$70001[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$70000[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Newvec$69999[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$70001[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$70001[ebp], ecx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Newvec$69999[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$70001[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$70001[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Whereoff$70000[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Newvec$69999[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	jmp	SHORT $LN19@Insert_n@6
__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$70001[ebp], 1
	jle	SHORT $LN7@Insert_n@6

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$70000[ebp]
	shl	edx, 5
	add	edx, DWORD PTR __Newvec$69999[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$69999[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Destroy
$LN7@Insert_n@6:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$70001[ebp], 0
	jle	SHORT $LN6@Insert_n@6

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$70000[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Newvec$69999[ebp]
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 5
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR __Whereoff$70000[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Newvec$69999[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Destroy
$LN6@Insert_n@6:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$69999[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@Insert_n@6

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 5
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::deallocate
$LN5@Insert_n@6:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Newvec$69999[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Newvec$69999[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$69999[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@6
$LN10@Insert_n@6:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 5
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@6

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	esi, DWORD PTR __Val$[ebp]
	mov	ecx, 8
	lea	edi, DWORD PTR __Tmp$70014[ebp]
	rep movsd

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	ecx, DWORD PTR __Tmp$70014[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	sar	eax, 5
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Ufill
	jmp	SHORT $LN21@Insert_n@6
__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	push	ecx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	ecx, DWORD PTR __Tmp$70014[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, edx
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@6
$LN3@Insert_n@6:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	esi, DWORD PTR __Val$[ebp]
	mov	ecx, 8
	lea	edi, DWORD PTR __Tmp$70024[ebp]
	rep movsd

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$70025[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$70025[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR __Oldend$70025[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$70025[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR __Oldend$70025[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$70024[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@6:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Insert_n
PUBLIC	??Y?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator+
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator+
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator+
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABU012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABU012@@Z PROC ; Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T::KEYFRAME_T, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABU012@@Z ENDP ; Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T::KEYFRAME_T
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABU012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABU012@@Z PROC ; Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T::CONTROL_POINT_T, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABU012@@Z ENDP ; Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T::CONTROL_POINT_T
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU345@IABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU345@IABU345@@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU345@IABU345@@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ufill
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU345@IABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU345@IABU345@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Ptr$[ebp]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU345@IABU345@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Ufill
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU345@IABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU345@IABU345@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Ptr$[ebp]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU345@IABU345@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Ufill
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU345@IABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU345@IABU345@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Ptr$[ebp]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU345@IABU345@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Ufill
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU345@IABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU345@IABU345@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Ptr$[ebp]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU345@IABU345@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Ufill
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@29
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@29:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@29
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@29
$LN1@operator@29:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@29:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@30
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@30:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	esi, DWORD PTR __Off$[ebp]
	shl	esi, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@30
	mov	esi, DWORD PTR __Off$[ebp]
	shl	esi, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@30
$LN1@operator@30:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@30:

; 164  : 		_Myptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@31
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@31:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	esi, DWORD PTR __Off$[ebp]
	imul	esi, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@31
	mov	esi, DWORD PTR __Off$[ebp]
	imul	esi, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@31
$LN1@operator@31:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@31:

; 164  : 		_Myptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@32
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@32:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	esi, DWORD PTR __Off$[ebp]
	imul	esi, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@32
	mov	esi, DWORD PTR __Off$[ebp]
	imul	esi, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@32
$LN1@operator@32:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@32:

; 164  : 		_Myptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@33
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@33:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	esi, DWORD PTR __Off$[ebp]
	shl	esi, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@33
	mov	esi, DWORD PTR __Off$[ebp]
	shl	esi, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@33
$LN1@operator@33:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@33:

; 164  : 		_Myptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@2@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@5@@Z
_TEXT	SEGMENT
$T78832 = -2						; size = 1
$T78831 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@2@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@5@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78831[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 8
	mov	BYTE PTR $T78832[ebp], al
	movzx	eax, BYTE PTR $T78831[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78832[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@2@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@5@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::TriggerDesc const *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@AAPAUTriggerDesc@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@2@@stdext@@YAPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@4@@Z
_TEXT	SEGMENT
$T78836 = -2						; size = 1
$T78835 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@2@@stdext@@YAPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78835[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@AAPAUTriggerDesc@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *>
	add	esp, 8
	mov	BYTE PTR $T78836[ebp], al
	movzx	eax, BYTE PTR $T78835[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78836[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::TriggerDesc const *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@2@@stdext@@YAPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z PROC ; std::_Checked_base<Ogre::TriggerDesc *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z ENDP ; std::_Checked_base<Ogre::TriggerDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTriggerDesc@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTriggerDesc@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::TriggerDesc *,Ogre::TriggerDesc *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTriggerDesc@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTriggerDesc@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTriggerDesc@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::TriggerDesc *,Ogre::TriggerDesc *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTriggerDesc@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T78847 = -7						; size = 1
$T78846 = -6						; size = 1
$T78845 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Result$[ebp], edx

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T78845[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T78846[ebp], cl
	movzx	edx, BYTE PTR $T78845[ebp]
	push	edx
	movzx	eax, BYTE PTR $T78846[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78847[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T78851 = -2						; size = 1
$T78850 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78850[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTriggerDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 8
	mov	BYTE PTR $T78851[ebp], al
	movzx	eax, BYTE PTR $T78850[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78851[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SequenceDesc const *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@AAPAUSequenceDesc@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@2@@stdext@@YAPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@4@@Z
_TEXT	SEGMENT
$T78855 = -2						; size = 1
$T78854 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@2@@stdext@@YAPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78854[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@AAPAUSequenceDesc@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *>
	add	esp, 8
	mov	BYTE PTR $T78855[ebp], al
	movzx	eax, BYTE PTR $T78854[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78855[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SequenceDesc const *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@2@@stdext@@YAPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z PROC ; std::_Checked_base<Ogre::SequenceDesc *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z ENDP ; std::_Checked_base<Ogre::SequenceDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSequenceDesc@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSequenceDesc@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::SequenceDesc *,Ogre::SequenceDesc *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSequenceDesc@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSequenceDesc@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSequenceDesc@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::SequenceDesc *,Ogre::SequenceDesc *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSequenceDesc@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T78866 = -7						; size = 1
$T78865 = -6						; size = 1
$T78864 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	shl	eax, 4
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	ecx, ecx
	mov	BYTE PTR $T78864[ebp], cl
	xor	edx, edx
	mov	BYTE PTR $T78865[ebp], dl
	movzx	eax, BYTE PTR $T78864[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78865[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T78866[ebp]
	push	edx
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T78870 = -2						; size = 1
$T78869 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78869[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSequenceDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 8
	mov	BYTE PTR $T78870[ebp], al
	movzx	eax, BYTE PTR $T78869[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78870[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BoneTrack * const *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@AAPAPAVBoneTrack@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@2@@stdext@@YAPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@4@@Z
_TEXT	SEGMENT
$T78874 = -2						; size = 1
$T78873 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@2@@stdext@@YAPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78873[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@AAPAPAVBoneTrack@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *>
	add	esp, 8
	mov	BYTE PTR $T78874[ebp], al
	movzx	eax, BYTE PTR $T78873[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78874[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BoneTrack * const *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@2@@stdext@@YAPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::BoneTrack * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::BoneTrack * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::BoneTrack * *,Ogre::BoneTrack * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::BoneTrack * *,Ogre::BoneTrack * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T78886 = -2						; size = 1
$T78885 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78885[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 8
	mov	BYTE PTR $T78886[ebp], al
	movzx	eax, BYTE PTR $T78885[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78886[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@AAPAPAVMaterialParamTrack@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@2@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@4@@Z
_TEXT	SEGMENT
$T78890 = -2						; size = 1
$T78889 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@2@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78889[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@AAPAPAVMaterialParamTrack@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *>
	add	esp, 8
	mov	BYTE PTR $T78890[ebp], al
	movzx	eax, BYTE PTR $T78889[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78890[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@2@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::MaterialParamTrack * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::MaterialParamTrack * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParamTrack@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParamTrack@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParamTrack@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParamTrack@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParamTrack@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParamTrack@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVMaterialParamTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVMaterialParamTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@2

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@2:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVMaterialParamTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T78902 = -2						; size = 1
$T78901 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78901[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParamTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
	add	esp, 8
	mov	BYTE PTR $T78902[ebp], al
	movzx	eax, BYTE PTR $T78901[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78902[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParamTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParamTrack * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@5@@Z
_TEXT	SEGMENT
$T78906 = -2						; size = 1
$T78905 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@5@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78905[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T78906[ebp], al
	movzx	eax, BYTE PTR $T78905[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78906[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@5@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@5@@Z
_TEXT	SEGMENT
$T78910 = -2						; size = 1
$T78909 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@5@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78909[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T78910[ebp], al
	movzx	eax, BYTE PTR $T78909[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78910[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@5@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@5@@Z
_TEXT	SEGMENT
$T78914 = -2						; size = 1
$T78913 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@5@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78913[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T78914[ebp], al
	movzx	eax, BYTE PTR $T78913[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78914[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@5@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@5@@Z
_TEXT	SEGMENT
$T78918 = -2						; size = 1
$T78917 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@5@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78917[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T78918[ebp], al
	movzx	eax, BYTE PTR $T78917[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78918[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@5@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z PROC ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ENDP ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T78929 = -7						; size = 1
$T78928 = -6						; size = 1
$T78927 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Result$[ebp], edx

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T78927[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T78928[ebp], cl
	movzx	edx, BYTE PTR $T78927[ebp]
	push	edx
	movzx	eax, BYTE PTR $T78928[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78929[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T78933 = -2						; size = 1
$T78932 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78932[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 8
	mov	BYTE PTR $T78933[ebp], al
	movzx	eax, BYTE PTR $T78932[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78933[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@@Z ; std::allocator<Ogre::TriggerDesc>::destroy
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@@Z ; std::allocator<Ogre::TriggerDesc>::destroy
	jmp	SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@@Z ; std::allocator<Ogre::SequenceDesc>::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@2

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@@Z ; std::allocator<Ogre::SequenceDesc>::destroy
	jmp	SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@stdext@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@stdext@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T78954 = -7						; size = 1
$T78953 = -6						; size = 1
$T78952 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	shl	eax, 4
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	ecx, ecx
	mov	BYTE PTR $T78952[ebp], cl
	xor	edx, edx
	mov	BYTE PTR $T78953[ebp], dl
	movzx	eax, BYTE PTR $T78952[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78953[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T78954[ebp]
	push	edx
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T78958 = -2						; size = 1
$T78957 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78957[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T78958[ebp], al
	movzx	eax, BYTE PTR $T78957[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78958[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T78969 = -7						; size = 1
$T78968 = -6						; size = 1
$T78967 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T78967[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T78968[ebp], al
	movzx	ecx, BYTE PTR $T78967[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T78968[ebp]
	push	edx
	movzx	eax, BYTE PTR $T78969[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T78973 = -2						; size = 1
$T78972 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78972[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T78973[ebp], al
	movzx	eax, BYTE PTR $T78972[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78973[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T78984 = -7						; size = 1
$T78983 = -6						; size = 1
$T78982 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T78982[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T78983[ebp], al
	movzx	ecx, BYTE PTR $T78982[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T78983[ebp]
	push	edx
	movzx	eax, BYTE PTR $T78984[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T78988 = -2						; size = 1
$T78987 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78987[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T78988[ebp], al
	movzx	eax, BYTE PTR $T78987[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78988[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T78999 = -7						; size = 1
$T78998 = -6						; size = 1
$T78997 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 5
	shl	eax, 5
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	ecx, ecx
	mov	BYTE PTR $T78997[ebp], cl
	xor	edx, edx
	mov	BYTE PTR $T78998[ebp], dl
	movzx	eax, BYTE PTR $T78997[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78998[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T78999[ebp]
	push	edx
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T79003 = -2						; size = 1
$T79002 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T79002[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T79003[ebp], al
	movzx	eax, BYTE PTR $T79002[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T79003[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::destroy
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@3
$LN2@Destroy_ra@3:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@3:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@3

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::destroy
	jmp	SHORT $LN2@Destroy_ra@3
$LN4@Destroy_ra@3:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T79009 = -2						; size = 1
$T79008 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T79008[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVBoneTrack@Ogre@@@Z ; std::_Move_cat<Ogre::BoneTrack * *>
	add	esp, 4
	mov	BYTE PTR $T79009[ebp], al
	movzx	edx, BYTE PTR $T79008[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79009[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAVBoneTrack@Ogre@@PAV12@@std@@YAXPAPAVBoneTrack@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVBoneTrack@Ogre@@PAV12@@std@@YAXPAPAVBoneTrack@Ogre@@0ABQAV12@@Z PROC ; std::_Fill<Ogre::BoneTrack * *,Ogre::BoneTrack *>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill
$LN2@Fill:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill
$LN4@Fill:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAPAVBoneTrack@Ogre@@PAV12@@std@@YAXPAPAVBoneTrack@Ogre@@0ABQAV12@@Z ENDP ; std::_Fill<Ogre::BoneTrack * *,Ogre::BoneTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVBoneTrack@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVBoneTrack@Ogre@@@Z PROC ; std::_Move_cat<Ogre::BoneTrack * *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVBoneTrack@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::BoneTrack * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T79017 = -2						; size = 1
$T79016 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79016[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 8
	mov	BYTE PTR $T79017[ebp], al
	movzx	eax, BYTE PTR $T79016[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T79017[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::destroy
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@4
$LN2@Destroy_ra@4:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@4:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@4

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Destroy_ra@4
$LN4@Destroy_ra@4:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@5
$LN2@Destroy_ra@5:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@5:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@5

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Destroy_ra@5
$LN4@Destroy_ra@5:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@6
$LN2@Destroy_ra@6:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@6:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@6

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Destroy_ra@6
$LN4@Destroy_ra@6:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@7
$LN2@Destroy_ra@7:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@7:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@7

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Destroy_ra@7
$LN4@Destroy_ra@7:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Umove<Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Umove<Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z PROC ; std::fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z ENDP ; std::fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::_Move_cat<Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T79034 = -3						; size = 1
$T79033 = -2						; size = 1
$T79032 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T79032[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::_Move_cat<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	mov	BYTE PTR $T79033[ebp], al
	movzx	edx, BYTE PTR $T79032[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79033[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T79034[ebp]
	push	eax
	call	??$_Iter_random@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Iter_random<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z PROC ; std::fill<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z ENDP ; std::fill<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T79043 = -3						; size = 1
$T79042 = -2						; size = 1
$T79041 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T79041[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 4
	mov	BYTE PTR $T79042[ebp], al
	movzx	edx, BYTE PTR $T79041[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79042[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T79043[ebp]
	push	eax
	call	??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z PROC ; std::fill<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z ENDP ; std::fill<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T79052 = -3						; size = 1
$T79051 = -2						; size = 1
$T79050 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T79050[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 4
	mov	BYTE PTR $T79051[ebp], al
	movzx	edx, BYTE PTR $T79050[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79051[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T79052[ebp]
	push	eax
	call	??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z PROC ; std::fill<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z ENDP ; std::fill<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T79061 = -3						; size = 1
$T79060 = -2						; size = 1
$T79059 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T79059[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 4
	mov	BYTE PTR $T79060[ebp], al
	movzx	edx, BYTE PTR $T79059[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79060[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T79061[ebp]
	push	eax
	call	??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z PROC ; std::fill<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z ENDP ; std::fill<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T79070 = -3						; size = 1
$T79069 = -2						; size = 1
$T79068 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T79068[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 4
	mov	BYTE PTR $T79069[ebp], al
	movzx	edx, BYTE PTR $T79068[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79069[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T79070[ebp]
	push	eax
	call	??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T79074 = -2						; size = 1
$T79073 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79073[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 8
	mov	BYTE PTR $T79074[ebp], al
	movzx	eax, BYTE PTR $T79073[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T79074[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T79078 = -2						; size = 1
$T79077 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79077[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T79078[ebp], al
	movzx	eax, BYTE PTR $T79077[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T79078[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T79082 = -2						; size = 1
$T79081 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79081[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T79082[ebp], al
	movzx	eax, BYTE PTR $T79081[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T79082[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T79086 = -2						; size = 1
$T79085 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79085[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T79086[ebp], al
	movzx	eax, BYTE PTR $T79085[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T79086[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T79090 = -2						; size = 1
$T79089 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79089[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T79090[ebp], al
	movzx	eax, BYTE PTR $T79089[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T79090[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??$_Destroy@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::_Destroy<Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z PROC ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::_Destroy<Ogre::BaseKeyFrameArray::AnimRange>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ENDP ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UTriggerDesc@Ogre@@@std@@YAXPAUTriggerDesc@Ogre@@@Z ; std::_Destroy<Ogre::TriggerDesc>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@@Z PROC ; std::allocator<Ogre::TriggerDesc>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UTriggerDesc@Ogre@@@std@@YAXPAUTriggerDesc@Ogre@@@Z ; std::_Destroy<Ogre::TriggerDesc>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@@Z ENDP ; std::allocator<Ogre::TriggerDesc>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@USequenceDesc@Ogre@@@std@@YAXPAUSequenceDesc@Ogre@@@Z ; std::_Destroy<Ogre::SequenceDesc>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@@Z PROC ; std::allocator<Ogre::SequenceDesc>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@USequenceDesc@Ogre@@@std@@YAXPAUSequenceDesc@Ogre@@@Z ; std::_Destroy<Ogre::SequenceDesc>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@@Z ENDP ; std::allocator<Ogre::SequenceDesc>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::destroy
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU345@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU345@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::construct
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::destroy
	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@AAPAUTriggerDesc@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@AAPAUTriggerDesc@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@AAPAUTriggerDesc@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::TriggerDesc>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::TriggerDesc const *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@2
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::TriggerDesc>::construct
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@@Z ; std::allocator<Ogre::TriggerDesc>::destroy
	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::TriggerDesc const *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::TriggerDesc *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::TriggerDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@3
$LN2@Copy_opt@3:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 8
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@3:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@3

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Copy_opt@3
$LN1@Copy_opt@3:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@3
$LN5@Uninit_cop@3:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@3:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@3

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::TriggerDesc>::construct
	jmp	SHORT $LN5@Uninit_cop@3
$LN4@Uninit_cop@3:
	jmp	SHORT $LN10@Uninit_cop@3
__catch$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@3
$LN2@Uninit_cop@3:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@3:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@3

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@@Z ; std::allocator<Ogre::TriggerDesc>::destroy
	jmp	SHORT $LN2@Uninit_cop@3
$LN1@Uninit_cop@3:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@3:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@AAPAUSequenceDesc@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@AAPAUSequenceDesc@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@AAPAUSequenceDesc@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::SequenceDesc>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::SequenceDesc const *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@4
$LN5@Uninit_cop@4:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@4:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@4

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::SequenceDesc>::construct
	jmp	SHORT $LN5@Uninit_cop@4
$LN4@Uninit_cop@4:
	jmp	SHORT $LN10@Uninit_cop@4
__catch$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@4
$LN2@Uninit_cop@4:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@4:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@4

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@@Z ; std::allocator<Ogre::SequenceDesc>::destroy
	jmp	SHORT $LN2@Uninit_cop@4
$LN1@Uninit_cop@4:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@4:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::SequenceDesc const *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::SequenceDesc *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::SequenceDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@4
$LN2@Copy_opt@4:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@4:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@4

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN2@Copy_opt@4
$LN1@Copy_opt@4:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@5
$LN5@Uninit_cop@5:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@5:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@5

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::SequenceDesc>::construct
	jmp	SHORT $LN5@Uninit_cop@5
$LN4@Uninit_cop@5:
	jmp	SHORT $LN10@Uninit_cop@5
__catch$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@5
$LN2@Uninit_cop@5:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@5:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@5

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@@Z ; std::allocator<Ogre::SequenceDesc>::destroy
	jmp	SHORT $LN2@Uninit_cop@5
$LN1@Uninit_cop@5:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@5:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@AAPAPAVBoneTrack@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@AAPAPAVBoneTrack@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@AAPAPAVBoneTrack@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::BoneTrack * const *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@6

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@6:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::BoneTrack * const *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::BoneTrack * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::BoneTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@7

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@7:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@AAPAPAVMaterialParamTrack@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@AAPAPAVMaterialParamTrack@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@AAPAPAVMaterialParamTrack@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@8

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@8:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::MaterialParamTrack * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@9

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@9:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@10
$LN5@Uninit_cop@10:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@10:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@10

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::construct
	jmp	SHORT $LN5@Uninit_cop@10
$LN4@Uninit_cop@10:
	jmp	SHORT $LN10@Uninit_cop@10
__catch$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@10
$LN2@Uninit_cop@10:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@10:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@10

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@10
$LN1@Uninit_cop@10:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@10:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@10:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@11
$LN5@Uninit_cop@11:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@11:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@11

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::construct
	jmp	SHORT $LN5@Uninit_cop@11
$LN4@Uninit_cop@11:
	jmp	SHORT $LN10@Uninit_cop@11
__catch$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@11
$LN2@Uninit_cop@11:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@11:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@11

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@11
$LN1@Uninit_cop@11:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@11:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@11:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@12
$LN5@Uninit_cop@12:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@12:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@12

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::construct
	jmp	SHORT $LN5@Uninit_cop@12
$LN4@Uninit_cop@12:
	jmp	SHORT $LN10@Uninit_cop@12
__catch$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@12
$LN2@Uninit_cop@12:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@12:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@12

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@12
$LN1@Uninit_cop@12:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@12:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@12:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@13
$LN5@Uninit_cop@13:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@13:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@13

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::construct
	jmp	SHORT $LN5@Uninit_cop@13
$LN4@Uninit_cop@13:
	jmp	SHORT $LN10@Uninit_cop@13
__catch$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@13
$LN2@Uninit_cop@13:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@13:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@13

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@13
$LN1@Uninit_cop@13:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@13:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@13:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@5
$LN2@Copy_opt@5:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 8
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@5:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@5

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Copy_opt@5
$LN1@Copy_opt@5:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@14
$LN5@Uninit_cop@14:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@14:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@14

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU345@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::construct
	jmp	SHORT $LN5@Uninit_cop@14
$LN4@Uninit_cop@14:
	jmp	SHORT $LN10@Uninit_cop@14
__catch$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@14
$LN2@Uninit_cop@14:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@14:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@14

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::destroy
	jmp	SHORT $LN2@Uninit_cop@14
$LN1@Uninit_cop@14:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@14:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@14:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	??$_Fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *>
PUBLIC	??$_Iter_cat@PAPAVBoneTrack@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@@Z ; std::_Iter_cat<Ogre::BoneTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@stdext@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@@Z
_TEXT	SEGMENT
$T79318 = -2						; size = 1
$T79317 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@stdext@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@@Z PROC ; stdext::unchecked_fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79317[ebp], al
	movzx	ecx, BYTE PTR $T79317[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T79318[ebp]
	push	eax
	call	??$_Iter_cat@PAPAVBoneTrack@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@@Z ; std::_Iter_cat<Ogre::BoneTrack * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@stdext@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@@Z ENDP ; stdext::unchecked_fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??4KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z ; Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T::operator=
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@6
$LN2@Copy_opt@6:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@6:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@6

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	??4KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
	jmp	SHORT $LN2@Copy_opt@6
$LN1@Copy_opt@6:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@15
$LN5@Uninit_cop@15:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@15:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@15

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::construct
	jmp	SHORT $LN5@Uninit_cop@15
$LN4@Uninit_cop@15:
	jmp	SHORT $LN10@Uninit_cop@15
__catch$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@15
$LN2@Uninit_cop@15:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@15:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@15

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@15
$LN1@Uninit_cop@15:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@15:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@15:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??4CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z ; Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T::operator=
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@7
$LN2@Copy_opt@7:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@7:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@7

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	??4CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
	jmp	SHORT $LN2@Copy_opt@7
$LN1@Copy_opt@7:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@16
$LN5@Uninit_cop@16:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@16:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@16

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::construct
	jmp	SHORT $LN5@Uninit_cop@16
$LN4@Uninit_cop@16:
	jmp	SHORT $LN10@Uninit_cop@16
__catch$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@16
$LN2@Uninit_cop@16:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@16:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@16

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@16
$LN1@Uninit_cop@16:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@16:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@16:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??4KEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z ; Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T::operator=
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@8
$LN2@Copy_opt@8:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@8:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@8

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	??4KEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
	jmp	SHORT $LN2@Copy_opt@8
$LN1@Copy_opt@8:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@17
$LN5@Uninit_cop@17:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@17:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@17

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::construct
	jmp	SHORT $LN5@Uninit_cop@17
$LN4@Uninit_cop@17:
	jmp	SHORT $LN10@Uninit_cop@17
__catch$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@17
$LN2@Uninit_cop@17:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@17:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@17

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@17
$LN1@Uninit_cop@17:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@17:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@17:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??4CONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z ; Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T::operator=
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@9
$LN2@Copy_opt@9:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@9:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@9

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	??4CONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
	jmp	SHORT $LN2@Copy_opt@9
$LN1@Copy_opt@9:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@18
$LN5@Uninit_cop@18:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@18:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@18

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::construct
	jmp	SHORT $LN5@Uninit_cop@18
$LN4@Uninit_cop@18:
	jmp	SHORT $LN10@Uninit_cop@18
__catch$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@18
$LN2@Uninit_cop@18:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@18:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@18

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@18
$LN1@Uninit_cop@18:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@18:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@18:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Uninit_move@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Result$[ebp], edx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR __Result$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T79402 = -2						; size = 1
$T79401 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T79401[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::_Move_cat<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	mov	BYTE PTR $T79402[ebp], al
	movzx	edx, BYTE PTR $T79401[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79402[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z PROC ; std::_Fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@2
$LN2@Fill@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@2

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN2@Fill@2
$LN4@Fill@2:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z ENDP ; std::_Fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@@Z PROC ; std::_Move_cat<Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T79410 = -2						; size = 1
$T79409 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79409[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 8
	mov	BYTE PTR $T79410[ebp], al
	movzx	eax, BYTE PTR $T79409[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T79410[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T79414 = -2						; size = 1
$T79413 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T79413[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 4
	mov	BYTE PTR $T79414[ebp], al
	movzx	edx, BYTE PTR $T79413[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79414[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z PROC ; std::_Fill<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@3
$LN2@Fill@3:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@3:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@3

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??4KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
	jmp	SHORT $LN2@Fill@3
$LN4@Fill@3:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z ENDP ; std::_Fill<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z PROC ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T79422 = -2						; size = 1
$T79421 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79421[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T79422[ebp], al
	movzx	eax, BYTE PTR $T79421[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T79422[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T79426 = -2						; size = 1
$T79425 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T79425[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 4
	mov	BYTE PTR $T79426[ebp], al
	movzx	edx, BYTE PTR $T79425[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79426[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z PROC ; std::_Fill<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@4
$LN2@Fill@4:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@4:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@4

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??4CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
	jmp	SHORT $LN2@Fill@4
$LN4@Fill@4:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0ABU123@@Z ENDP ; std::_Fill<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z PROC ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T79434 = -2						; size = 1
$T79433 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79433[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T79434[ebp], al
	movzx	eax, BYTE PTR $T79433[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T79434[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T79438 = -2						; size = 1
$T79437 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T79437[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 4
	mov	BYTE PTR $T79438[ebp], al
	movzx	edx, BYTE PTR $T79437[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79438[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z PROC ; std::_Fill<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@5
$LN2@Fill@5:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@5:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@5

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??4KEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
	jmp	SHORT $LN2@Fill@5
$LN4@Fill@5:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z ENDP ; std::_Fill<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z PROC ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T79446 = -2						; size = 1
$T79445 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79445[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T79446[ebp], al
	movzx	eax, BYTE PTR $T79445[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T79446[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T79450 = -2						; size = 1
$T79449 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T79449[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 4
	mov	BYTE PTR $T79450[ebp], al
	movzx	edx, BYTE PTR $T79449[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79450[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z PROC ; std::_Fill<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@6
$LN2@Fill@6:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@6:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@6

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??4CONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
	jmp	SHORT $LN2@Fill@6
$LN4@Fill@6:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0ABU123@@Z ENDP ; std::_Fill<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z PROC ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T79458 = -2						; size = 1
$T79457 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79457[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T79458[ebp], al
	movzx	eax, BYTE PTR $T79457[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T79458[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU345@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::construct
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::destroy
	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@2
$LN5@Uninit_fil@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@2

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::construct
	jmp	SHORT $LN5@Uninit_fil@2
$LN4@Uninit_fil@2:
	jmp	SHORT $LN10@Uninit_fil@2
__catch$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@2
$LN2@Uninit_fil@2:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@2:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@2

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Uninit_fil@2
$LN1@Uninit_fil@2:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@2
	ret	0
$LN10@Uninit_fil@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@2:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@3
$LN5@Uninit_fil@3:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@3:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@3

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::construct
	jmp	SHORT $LN5@Uninit_fil@3
$LN4@Uninit_fil@3:
	jmp	SHORT $LN10@Uninit_fil@3
__catch$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@3
$LN2@Uninit_fil@3:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@3:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@3

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Uninit_fil@3
$LN1@Uninit_fil@3:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@3
	ret	0
$LN10@Uninit_fil@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@3:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@4
$LN5@Uninit_fil@4:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@4:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@4

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::construct
	jmp	SHORT $LN5@Uninit_fil@4
$LN4@Uninit_fil@4:
	jmp	SHORT $LN10@Uninit_fil@4
__catch$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@4
$LN2@Uninit_fil@4:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@4:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@4

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Uninit_fil@4
$LN1@Uninit_fil@4:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@4
	ret	0
$LN10@Uninit_fil@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@4:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@5
$LN5@Uninit_fil@5:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@5:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@5

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::construct
	jmp	SHORT $LN5@Uninit_fil@5
$LN4@Uninit_fil@5:
	jmp	SHORT $LN10@Uninit_fil@5
__catch$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@5
$LN2@Uninit_fil@5:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@5:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@5

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Uninit_fil@5
$LN1@Uninit_fil@5:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@5
	ret	0
$LN10@Uninit_fil@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@5:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z PROC ; std::_Destroy<Ogre::BaseKeyFrameArray::AnimRange>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ENDP ; std::_Destroy<Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UTriggerDesc@Ogre@@@std@@YAXPAUTriggerDesc@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UTriggerDesc@Ogre@@@std@@YAXPAUTriggerDesc@Ogre@@@Z PROC ; std::_Destroy<Ogre::TriggerDesc>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UTriggerDesc@Ogre@@@std@@YAXPAUTriggerDesc@Ogre@@@Z ENDP ; std::_Destroy<Ogre::TriggerDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@USequenceDesc@Ogre@@@std@@YAXPAUSequenceDesc@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@USequenceDesc@Ogre@@@std@@YAXPAUSequenceDesc@Ogre@@@Z PROC ; std::_Destroy<Ogre::SequenceDesc>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@USequenceDesc@Ogre@@@std@@YAXPAUSequenceDesc@Ogre@@@Z ENDP ; std::_Destroy<Ogre::SequenceDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z PROC ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ENDP ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z PROC ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@Z ENDP ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z PROC ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ENDP ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z PROC ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@Z ENDP ; std::_Destroy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z PROC ; Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z ENDP ; Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z PROC ; Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z ENDP ; Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4KEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4KEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z PROC ; Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::Quaternion::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4KEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z ENDP ; Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4CONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4CONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z PROC ; Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::Quaternion::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::Quaternion::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4CONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z ENDP ; Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T::operator=
_TEXT	ENDS
PUBLIC	??$_Construct@UAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU123@@Z ; std::_Construct<Ogre::BaseKeyFrameArray::AnimRange,Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU345@@Z PROC ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU123@@Z ; std::_Construct<Ogre::BaseKeyFrameArray::AnimRange,Ogre::BaseKeyFrameArray::AnimRange>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU345@@Z ENDP ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UTriggerDesc@Ogre@@U12@@std@@YAXPAUTriggerDesc@Ogre@@ABU12@@Z ; std::_Construct<Ogre::TriggerDesc,Ogre::TriggerDesc>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@ABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@ABU34@@Z PROC ; std::allocator<Ogre::TriggerDesc>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UTriggerDesc@Ogre@@U12@@std@@YAXPAUTriggerDesc@Ogre@@ABU12@@Z ; std::_Construct<Ogre::TriggerDesc,Ogre::TriggerDesc>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@ABU34@@Z ENDP ; std::allocator<Ogre::TriggerDesc>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@USequenceDesc@Ogre@@U12@@std@@YAXPAUSequenceDesc@Ogre@@ABU12@@Z ; std::_Construct<Ogre::SequenceDesc,Ogre::SequenceDesc>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@ABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@ABU34@@Z PROC ; std::allocator<Ogre::SequenceDesc>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@USequenceDesc@Ogre@@U12@@std@@YAXPAUSequenceDesc@Ogre@@ABU12@@Z ; std::_Construct<Ogre::SequenceDesc,Ogre::SequenceDesc>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@ABU34@@Z ENDP ; std::allocator<Ogre::SequenceDesc>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU345@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU345@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU345@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU345@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU345@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU345@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU345@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU345@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>::construct
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEPBUAnimRange@BaseKeyFrameArray@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Checked_iterator_base
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEPBUAnimRange@BaseKeyFrameArray@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEPBUTriggerDesc@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEPBUTriggerDesc@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEPBUSequenceDesc@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEPBUSequenceDesc@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEPBQAVBoneTrack@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEPBQAVBoneTrack@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEPBQAVMaterialParamTrack@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEPBQAVMaterialParamTrack@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAVBoneTrack@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVBoneTrack@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@@Z PROC ; std::_Iter_cat<Ogre::BoneTrack * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAVBoneTrack@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@@Z ENDP ; std::_Iter_cat<Ogre::BoneTrack * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T79592 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79592[ebp], al
	movzx	ecx, BYTE PTR $T79592[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T79599 = -7						; size = 1
$T79598 = -6						; size = 1
$T79597 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	shl	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T79597[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T79598[ebp], al
	movzx	ecx, BYTE PTR $T79597[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T79598[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79599[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T79606 = -7						; size = 1
$T79605 = -6						; size = 1
$T79604 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	shl	eax, 4
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T79604[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T79605[ebp], al
	movzx	ecx, BYTE PTR $T79604[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T79605[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79606[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T79613 = -7						; size = 1
$T79612 = -6						; size = 1
$T79611 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	imul	eax, 24					; 00000018H
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, eax
	mov	DWORD PTR __Result$[ebp], edx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79611[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T79612[ebp], cl
	movzx	edx, BYTE PTR $T79611[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79612[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T79613[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T79620 = -7						; size = 1
$T79619 = -6						; size = 1
$T79618 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	imul	eax, 20					; 00000014H
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, eax
	mov	DWORD PTR __Result$[ebp], edx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T79618[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T79619[ebp], cl
	movzx	edx, BYTE PTR $T79618[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79619[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T79620[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T79627 = -7						; size = 1
$T79626 = -6						; size = 1
$T79625 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 5
	shl	eax, 5
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T79625[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T79626[ebp], al
	movzx	ecx, BYTE PTR $T79625[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T79626[ebp]
	push	edx
	movzx	eax, BYTE PTR $T79627[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@UAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU123@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T79630 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU123@@Z PROC ; std::_Construct<Ogre::BaseKeyFrameArray::AnimRange,Ogre::BaseKeyFrameArray::AnimRange>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T79630[ebp], eax
	cmp	DWORD PTR $T79630[ebp], 0
	je	SHORT $LN3@Construct
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T79630[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T79630[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct
$LN3@Construct:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU123@@Z ENDP ; std::_Construct<Ogre::BaseKeyFrameArray::AnimRange,Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UTriggerDesc@Ogre@@U12@@std@@YAXPAUTriggerDesc@Ogre@@ABU12@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T79635 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UTriggerDesc@Ogre@@U12@@std@@YAXPAUTriggerDesc@Ogre@@ABU12@@Z PROC ; std::_Construct<Ogre::TriggerDesc,Ogre::TriggerDesc>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T79635[ebp], eax
	cmp	DWORD PTR $T79635[ebp], 0
	je	SHORT $LN3@Construct@2
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T79635[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T79635[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@2
$LN3@Construct@2:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@2:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UTriggerDesc@Ogre@@U12@@std@@YAXPAUTriggerDesc@Ogre@@ABU12@@Z ENDP ; std::_Construct<Ogre::TriggerDesc,Ogre::TriggerDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@USequenceDesc@Ogre@@U12@@std@@YAXPAUSequenceDesc@Ogre@@ABU12@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T79640 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@USequenceDesc@Ogre@@U12@@std@@YAXPAUSequenceDesc@Ogre@@ABU12@@Z PROC ; std::_Construct<Ogre::SequenceDesc,Ogre::SequenceDesc>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T79640[ebp], eax
	cmp	DWORD PTR $T79640[ebp], 0
	je	SHORT $LN3@Construct@3
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T79640[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T79640[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@3
$LN3@Construct@3:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@3:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@USequenceDesc@Ogre@@U12@@std@@YAXPAUSequenceDesc@Ogre@@ABU12@@Z ENDP ; std::_Construct<Ogre::SequenceDesc,Ogre::SequenceDesc>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z$0
__ehfuncinfo$??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z
_TEXT	SEGMENT
tv74 = -28						; size = 4
$T79646 = -24						; size = 4
$T79645 = -20						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z PROC ; std::_Construct<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T79646[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T79646[ebp], 0
	je	SHORT $LN3@Construct@4
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T79646[ebp]
	call	??0KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABU012@@Z
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@Construct@4
$LN3@Construct@4:
	mov	DWORD PTR tv74[ebp], 0
$LN4@Construct@4:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T79645[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T79646[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z ENDP ; std::_Construct<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z$0
__ehfuncinfo$??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z
_TEXT	SEGMENT
tv74 = -28						; size = 4
$T79659 = -24						; size = 4
$T79658 = -20						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z PROC ; std::_Construct<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	24					; 00000018H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T79659[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T79659[ebp], 0
	je	SHORT $LN3@Construct@5
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T79659[ebp]
	call	??0CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAE@ABU012@@Z
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@Construct@5
$LN3@Construct@5:
	mov	DWORD PTR tv74[ebp], 0
$LN4@Construct@5:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T79658[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T79659[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@ABU123@@Z ENDP ; std::_Construct<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T>
; Function compile flags: /Odtp
;	COMDAT ??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU123@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T79671 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU123@@Z PROC ; std::_Construct<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	20					; 00000014H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T79671[ebp], eax
	cmp	DWORD PTR $T79671[ebp], 0
	je	SHORT $LN3@Construct@6
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T79671[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T79671[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@6
$LN3@Construct@6:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@6:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU123@@Z ENDP ; std::_Construct<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU123@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T79676 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU123@@Z PROC ; std::_Construct<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	32					; 00000020H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T79676[ebp], eax
	cmp	DWORD PTR $T79676[ebp], 0
	je	SHORT $LN3@Construct@7
	mov	esi, DWORD PTR __Val$[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T79676[ebp]
	rep movsd
	mov	edx, DWORD PTR $T79676[ebp]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN1@Construct@7
$LN3@Construct@7:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@7:

; 53   : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@ABU123@@Z ENDP ; std::_Construct<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEPBUAnimRange@BaseKeyFrameArray@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEPBUAnimRange@BaseKeyFrameArray@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEPBUAnimRange@BaseKeyFrameArray@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEPBUTriggerDesc@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEPBUTriggerDesc@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEPBUTriggerDesc@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEPBUSequenceDesc@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEPBUSequenceDesc@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEPBUSequenceDesc@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEPBQAVBoneTrack@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEPBQAVBoneTrack@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEPBQAVBoneTrack@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEPBQAVMaterialParamTrack@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEPBQAVMaterialParamTrack@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEPBQAVMaterialParamTrack@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n
$LN2@Fill_n:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n
$LN4@Fill_n:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAVBoneTrack@Ogre@@IPAV12@@std@@YAXPAPAVBoneTrack@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::BoneTrack * *,unsigned int,Ogre::BoneTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@2:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@2

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Copy_backw@2
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@3:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@3

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	??4KEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
	jmp	SHORT $LN2@Copy_backw@3
$LN1@Copy_backw@3:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Vector3>::KEYFRAME_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@4:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@4

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 24					; 00000018H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	??4CONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
	jmp	SHORT $LN2@Copy_backw@4
$LN1@Copy_backw@4:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VVector3@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Vector3>::CONTROL_POINT_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@5:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@5

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	??4KEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
	jmp	SHORT $LN2@Copy_backw@5
$LN1@Copy_backw@5:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::KEYFRAME_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@6:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@6

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	??4CONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@QAEAAU012@ABU012@@Z
	jmp	SHORT $LN2@Copy_backw@6
$LN1@Copy_backw@6:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VQuaternion@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::Quaternion>::CONTROL_POINT_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
_TEXT	ENDS
;	COMDAT ??__ETWO_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__ETWO_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'TWO_PI'', COMDAT

; 10   : 	const float TWO_PI = ONE_PI*2;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _TWO_PI
	pop	ebp
	ret	0
??__ETWO_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'TWO_PI''
text$yc	ENDS
PUBLIC	__real@3fe0000000000000
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??__EHALF_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__EHALF_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'HALF_PI'', COMDAT

; 11   : 	const float	HALF_PI = ONE_PI*0.5f;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	DWORD PTR _HALF_PI
	pop	ebp
	ret	0
??__EHALF_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'HALF_PI''
text$yc	ENDS
EXTRN	??0RuntimeClass@Ogre@@QAE@PBDPBV01@HP6APAVBaseObject@1@XZ@Z:PROC ; Ogre::RuntimeClass::RuntimeClass
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreskeletonanimdata.cpp
;	COMDAT ??__E?m_RTTI@SkeletonAnimData@Ogre@@2VRuntimeClass@2@B@@YAXXZ
text$yc	SEGMENT
??__E?m_RTTI@SkeletonAnimData@Ogre@@2VRuntimeClass@2@B@@YAXXZ PROC ; `dynamic initializer for 'Ogre::SkeletonAnimData::m_RTTI'', COMDAT

; 7    : 	IMPLEMENT_RTTI(SkeletonAnimData, BaseAnimationData, 100)

	push	ebp
	mov	ebp, esp
	push	OFFSET ?newObject@SkeletonAnimData@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::SkeletonAnimData::newObject
	push	100					; 00000064H
	push	OFFSET ?m_RTTI@BaseAnimationData@Ogre@@2VRuntimeClass@2@B ; Ogre::BaseAnimationData::m_RTTI
	push	OFFSET $SG61136
	mov	ecx, OFFSET ?m_RTTI@SkeletonAnimData@Ogre@@2VRuntimeClass@2@B ; Ogre::SkeletonAnimData::m_RTTI
	call	??0RuntimeClass@Ogre@@QAE@PBDPBV01@HP6APAVBaseObject@1@XZ@Z ; Ogre::RuntimeClass::RuntimeClass
	pop	ebp
	ret	0
??__E?m_RTTI@SkeletonAnimData@Ogre@@2VRuntimeClass@2@B@@YAXXZ ENDP ; `dynamic initializer for 'Ogre::SkeletonAnimData::m_RTTI''
text$yc	ENDS
PUBLIC	?m_RTTI@SkeletonAnimData@Ogre@@2VRuntimeClass@2@B ; Ogre::SkeletonAnimData::m_RTTI
_BSS	SEGMENT
?m_RTTI@SkeletonAnimData@Ogre@@2VRuntimeClass@2@B DB 014H DUP (?) ; Ogre::SkeletonAnimData::m_RTTI
_TWO_PI	DD	01H DUP (?)
_HALF_PI DD	01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_TWO_PI$initializer$ DD FLAT:??__ETWO_PI@Ogre@@YAXXZ
_HALF_PI$initializer$ DD FLAT:??__EHALF_PI@Ogre@@YAXXZ
?m_RTTI$initializer$@SkeletonAnimData@Ogre@@2P6AXXZA DD FLAT:??__E?m_RTTI@SkeletonAnimData@Ogre@@2VRuntimeClass@2@B@@YAXXZ ; Ogre::SkeletonAnimData::m_RTTI$initializer$
CRT$XCU	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\OgreAnimationPlayer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5713
_DATA	ENDS
CONST	SEGMENT
$SG5713	DB	'bad allocation', 00H
	ORG $+1
_MAX_FLOAT DD	07f7fffffr			; 3.40282e+038
_ONE_PI	DD	040490fd0r			; 3.14159
_EPSILON DD	03727c5acr			; 1e-005
_RADS_PER_DEG DD 03c8efa35r			; 0.0174533
_DEGS_PER_RAD DD 042652ee1r			; 57.2958
CONST	ENDS
PUBLIC	??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MemoryDelegation::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::MemoryDelegation::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::MemoryDelegation::operator=
_TEXT	ENDS
PUBLIC	?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ	; Ogre::RuntimeClass::getBaseClass
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebaseobject.h
;	COMDAT ?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ PROC	; Ogre::RuntimeClass::getBaseClass, COMDAT
; _this$ = ecx

; 20   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 21   : 			return m_pBaseClass;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 22   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ ENDP	; Ogre::RuntimeClass::getBaseClass
_TEXT	ENDS
PUBLIC	?getClassName@RuntimeClass@Ogre@@QBEPBDXZ	; Ogre::RuntimeClass::getClassName
; Function compile flags: /Odtp
;	COMDAT ?getClassName@RuntimeClass@Ogre@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getClassName@RuntimeClass@Ogre@@QBEPBDXZ PROC		; Ogre::RuntimeClass::getClassName, COMDAT
; _this$ = ecx

; 25   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 26   : 			return m_pClassName; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 27   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getClassName@RuntimeClass@Ogre@@QBEPBDXZ ENDP		; Ogre::RuntimeClass::getClassName
_TEXT	ENDS
PUBLIC	?getVersion@RuntimeClass@Ogre@@QBEHXZ		; Ogre::RuntimeClass::getVersion
; Function compile flags: /Odtp
;	COMDAT ?getVersion@RuntimeClass@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getVersion@RuntimeClass@Ogre@@QBEHXZ PROC		; Ogre::RuntimeClass::getVersion, COMDAT
; _this$ = ecx

; 30   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 			return m_Version;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 32   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getVersion@RuntimeClass@Ogre@@QBEHXZ ENDP		; Ogre::RuntimeClass::getVersion
_TEXT	ENDS
PUBLIC	?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ ; Ogre::RuntimeClass::newObject
; Function compile flags: /Odtp
;	COMDAT ?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ PROC ; Ogre::RuntimeClass::newObject, COMDAT
; _this$ = ecx

; 35   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 36   : 			return (*m_pNewFunc)();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	ecx

; 37   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ ENDP ; Ogre::RuntimeClass::newObject
_TEXT	ENDS
PUBLIC	??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::RuntimeClass::operator=
; Function compile flags: /Odtp
;	COMDAT ??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::RuntimeClass::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::RuntimeClass::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::BaseObject::getRTTI
EXTRN	?m_RTTI@BaseObject@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::BaseObject::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::BaseObject::getRTTI, COMDAT
; _this$ = ecx

; 56   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 			return &m_RTTI;

	mov	eax, OFFSET ?m_RTTI@BaseObject@Ogre@@2VRuntimeClass@2@B ; Ogre::BaseObject::m_RTTI

; 58   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::BaseObject::getRTTI
_TEXT	ENDS
PUBLIC	?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z ; Ogre::BaseObject::isExactKindOf
; Function compile flags: /Odtp
;	COMDAT ?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_prtti$ = 8						; size = 4
?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z PROC ; Ogre::BaseObject::isExactKindOf, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			return (getRTTI() == prtti);

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	xor	ecx, ecx
	cmp	eax, DWORD PTR _prtti$[ebp]
	sete	cl
	mov	al, cl

; 63   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z ENDP ; Ogre::BaseObject::isExactKindOf
_TEXT	ENDS
PUBLIC	?release@BaseObject@Ogre@@UAEXXZ		; Ogre::BaseObject::release
; Function compile flags: /Odtp
;	COMDAT ?release@BaseObject@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?release@BaseObject@Ogre@@UAEXXZ PROC			; Ogre::BaseObject::release, COMDAT
; _this$ = ecx

; 68   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 			m_RefCount--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 70   : 			if(m_RefCount <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jg	SHORT $LN2@release

; 71   : 			{
; 72   : 				deleteThis();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
$LN2@release:

; 73   : 			}
; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@BaseObject@Ogre@@UAEXXZ ENDP			; Ogre::BaseObject::release
_TEXT	ENDS
PUBLIC	?addRef@BaseObject@Ogre@@UAEXXZ			; Ogre::BaseObject::addRef
; Function compile flags: /Odtp
;	COMDAT ?addRef@BaseObject@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?addRef@BaseObject@Ogre@@UAEXXZ PROC			; Ogre::BaseObject::addRef, COMDAT
; _this$ = ecx

; 77   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 			m_RefCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 79   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?addRef@BaseObject@Ogre@@UAEXXZ ENDP			; Ogre::BaseObject::addRef
_TEXT	ENDS
PUBLIC	?getRefCount@BaseObject@Ogre@@UAEHXZ		; Ogre::BaseObject::getRefCount
; Function compile flags: /Odtp
;	COMDAT ?getRefCount@BaseObject@Ogre@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRefCount@BaseObject@Ogre@@UAEHXZ PROC		; Ogre::BaseObject::getRefCount, COMDAT
; _this$ = ecx

; 82   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 			return m_RefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 84   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRefCount@BaseObject@Ogre@@UAEHXZ ENDP		; Ogre::BaseObject::getRefCount
_TEXT	ENDS
PUBLIC	?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::BaseObject::_serialize
; Function compile flags: /Odtp
;	COMDAT ?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
_version$ = 12						; size = 4
?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z PROC	; Ogre::BaseObject::_serialize, COMDAT
; _this$ = ecx

; 87   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z ENDP	; Ogre::BaseObject::_serialize
_TEXT	ENDS
PUBLIC	??_7BaseObject@Ogre@@6B@			; Ogre::BaseObject::`vftable'
PUBLIC	??0BaseObject@Ogre@@IAE@XZ			; Ogre::BaseObject::BaseObject
PUBLIC	??_R4BaseObject@Ogre@@6B@			; Ogre::BaseObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVBaseObject@Ogre@@@8			; Ogre::BaseObject `RTTI Type Descriptor'
PUBLIC	??_R3BaseObject@Ogre@@8				; Ogre::BaseObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2BaseObject@Ogre@@8				; Ogre::BaseObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@BaseObject@Ogre@@8		; Ogre::BaseObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@MemoryDelegation@Ogre@@8		; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AVMemoryDelegation@Ogre@@@8		; Ogre::MemoryDelegation `RTTI Type Descriptor'
PUBLIC	??_R3MemoryDelegation@Ogre@@8			; Ogre::MemoryDelegation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MemoryDelegation@Ogre@@8			; Ogre::MemoryDelegation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MemoryDelegation@Ogre@@8		; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EBaseObject@Ogre@@MAEPAXI@Z			; Ogre::BaseObject::`vector deleting destructor'
PUBLIC	?deleteThis@BaseObject@Ogre@@MAEXXZ		; Ogre::BaseObject::deleteThis
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R1A@?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MemoryDelegation@Ogre@@8 DD FLAT:??_R0?AVMemoryDelegation@Ogre@@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R2MemoryDelegation@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MemoryDelegation@Ogre@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R3MemoryDelegation@Ogre@@8 DD 00H			; Ogre::MemoryDelegation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMemoryDelegation@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMemoryDelegation@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MemoryDelegation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMemoryDelegation@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R13?0A@EA@MemoryDelegation@Ogre@@8 DD FLAT:??_R0?AVMemoryDelegation@Ogre@@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@BaseObject@Ogre@@8 DD FLAT:??_R0?AVBaseObject@Ogre@@@8 ; Ogre::BaseObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R2BaseObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8 ; Ogre::BaseObject::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R3BaseObject@Ogre@@8 DD 00H				; Ogre::BaseObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBaseObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVBaseObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::BaseObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBaseObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4BaseObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4BaseObject@Ogre@@6B@ DD 00H			; Ogre::BaseObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBaseObject@Ogre@@@8
	DD	FLAT:??_R3BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7BaseObject@Ogre@@6B@
CONST	SEGMENT
??_7BaseObject@Ogre@@6B@ DD FLAT:??_R4BaseObject@Ogre@@6B@ ; Ogre::BaseObject::`vftable'
	DD	FLAT:?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EBaseObject@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0BaseObject@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BaseObject@Ogre@@IAE@XZ PROC				; Ogre::BaseObject::BaseObject, COMDAT
; _this$ = ecx

; 92   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseObject@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 1

; 93   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BaseObject@Ogre@@IAE@XZ ENDP				; Ogre::BaseObject::BaseObject
_TEXT	ENDS
PUBLIC	??1BaseObject@Ogre@@MAE@XZ			; Ogre::BaseObject::~BaseObject
; Function compile flags: /Odtp
;	COMDAT ??1BaseObject@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1BaseObject@Ogre@@MAE@XZ PROC				; Ogre::BaseObject::~BaseObject, COMDAT
; _this$ = ecx

; 96   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseObject@Ogre@@6B@

; 97   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1BaseObject@Ogre@@MAE@XZ ENDP				; Ogre::BaseObject::~BaseObject
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deleteThis@BaseObject@Ogre@@MAEXXZ
_TEXT	SEGMENT
tv70 = -16						; size = 4
_this$ = -12						; size = 4
$T89517 = -8						; size = 4
$T89516 = -4						; size = 4
?deleteThis@BaseObject@Ogre@@MAEXXZ PROC		; Ogre::BaseObject::deleteThis, COMDAT
; _this$ = ecx

; 100  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 			delete this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T89517[ebp], eax
	mov	ecx, DWORD PTR $T89517[ebp]
	mov	DWORD PTR $T89516[ebp], ecx
	cmp	DWORD PTR $T89516[ebp], 0
	je	SHORT $LN3@deleteThis
	push	1
	mov	edx, DWORD PTR $T89516[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T89516[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN1@deleteThis
$LN3@deleteThis:
	mov	DWORD PTR tv70[ebp], 0
$LN1@deleteThis:

; 102  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?deleteThis@BaseObject@Ogre@@MAEXXZ ENDP		; Ogre::BaseObject::deleteThis
_TEXT	ENDS
PUBLIC	??0BaseObject@Ogre@@QAE@ABV01@@Z		; Ogre::BaseObject::BaseObject
; Function compile flags: /Odtp
;	COMDAT ??0BaseObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0BaseObject@Ogre@@QAE@ABV01@@Z PROC			; Ogre::BaseObject::BaseObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR ___that$[ebp], 0
	je	SHORT $LN3@BaseObject
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@BaseObject
$LN3@BaseObject:
	mov	DWORD PTR tv68[ebp], 0
$LN4@BaseObject:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7BaseObject@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BaseObject@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::BaseObject::BaseObject
_TEXT	ENDS
PUBLIC	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::BaseObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BaseObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BaseObject::operator=
_TEXT	ENDS
PUBLIC	??_GBaseObject@Ogre@@MAEPAXI@Z			; Ogre::BaseObject::`scalar deleting destructor'
EXTRN	??3MemoryDelegation@Ogre@@SAXPAXI@Z:PROC	; Ogre::MemoryDelegation::operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GBaseObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GBaseObject@Ogre@@MAEPAXI@Z PROC			; Ogre::BaseObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBaseObject@Ogre@@MAEPAXI@Z ENDP			; Ogre::BaseObject::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_VMemoryDelegation@Ogre@@SAXPAXI@Z:PROC	; Ogre::MemoryDelegation::operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_EBaseObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EBaseObject@Ogre@@MAEPAXI@Z PROC			; Ogre::BaseObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1BaseObject@Ogre@@MAE@XZ	; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	push	8
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EBaseObject@Ogre@@MAEPAXI@Z ENDP			; Ogre::BaseObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z	; Ogre::FixedString::handle2Ptr
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefixedstring.h
;	COMDAT ?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z
_TEXT	SEGMENT
_h$ = 8							; size = 4
?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z PROC		; Ogre::FixedString::handle2Ptr, COMDAT

; 22   : 		{

	push	ebp
	mov	ebp, esp

; 23   : 			return (const char *)h;

	mov	eax, DWORD PTR _h$[ebp]

; 24   : 		}

	pop	ebp
	ret	0
?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ENDP		; Ogre::FixedString::handle2Ptr
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@XZ			; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0FixedString@Ogre@@QAE@XZ PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 27   : 		FixedString() : m_StrHandle(NULL){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0FixedString@Ogre@@QAE@XZ ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PAX@Z			; Ogre::FixedString::FixedString
EXTRN	?addRef@FixedString@Ogre@@SAXPAX@Z:PROC		; Ogre::FixedString::addRef
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h$ = 8							; size = 4
??0FixedString@Ogre@@QAE@PAX@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 29   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [eax], ecx

; 30   : 			addRef(h);

	mov	edx, DWORD PTR _h$[ebp]
	push	edx
	call	?addRef@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::addRef
	add	esp, 4

; 31   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@PAX@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@ABV01@@Z		; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??0FixedString@Ogre@@QAE@ABV01@@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 34   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 35   : 			addRef(m_StrHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?addRef@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::addRef
	add	esp, 4

; 36   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PBD@Z			; Ogre::FixedString::FixedString
EXTRN	?insert@FixedString@Ogre@@SAPAXPBDH@Z:PROC	; Ogre::FixedString::insert
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstr$ = 8						; size = 4
??0FixedString@Ogre@@QAE@PBD@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 38   : 		FixedString(const char *pstr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 		{
; 40   : 			m_StrHandle = insert(pstr); 

	push	-1
	mov	eax, DWORD PTR _pstr$[ebp]
	push	eax
	call	?insert@FixedString@Ogre@@SAPAXPBDH@Z	; Ogre::FixedString::insert
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 41   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@PBD@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PBDI@Z			; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstr$ = 8						; size = 4
_len$ = 12						; size = 4
??0FixedString@Ogre@@QAE@PBDI@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 43   : 		FixedString(const char *pstr, size_t len)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 		{
; 45   : 			m_StrHandle = insert(pstr, (int)len); 

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pstr$[ebp]
	push	ecx
	call	?insert@FixedString@Ogre@@SAPAXPBDH@Z	; Ogre::FixedString::insert
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 46   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0FixedString@Ogre@@QAE@PBDI@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??1FixedString@Ogre@@QAE@XZ			; Ogre::FixedString::~FixedString
EXTRN	?release@FixedString@Ogre@@SAXPAX@Z:PROC	; Ogre::FixedString::release
; Function compile flags: /Odtp
;	COMDAT ??1FixedString@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1FixedString@Ogre@@QAE@XZ PROC			; Ogre::FixedString::~FixedString, COMDAT
; _this$ = ecx

; 49   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 			release(m_StrHandle); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?release@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::release
	add	esp, 4

; 51   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1FixedString@Ogre@@QAE@XZ ENDP			; Ogre::FixedString::~FixedString
_TEXT	ENDS
PUBLIC	??BFixedString@Ogre@@QBEPBDXZ			; Ogre::FixedString::operator char const *
; Function compile flags: /Odtp
;	COMDAT ??BFixedString@Ogre@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BFixedString@Ogre@@QBEPBDXZ PROC			; Ogre::FixedString::operator char const *, COMDAT
; _this$ = ecx

; 54   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 			return handle2Ptr(m_StrHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ; Ogre::FixedString::handle2Ptr
	add	esp, 4

; 56   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??BFixedString@Ogre@@QBEPBDXZ ENDP			; Ogre::FixedString::operator char const *
_TEXT	ENDS
PUBLIC	?getHandle@FixedString@Ogre@@QBEPAXXZ		; Ogre::FixedString::getHandle
; Function compile flags: /Odtp
;	COMDAT ?getHandle@FixedString@Ogre@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHandle@FixedString@Ogre@@QBEPAXXZ PROC		; Ogre::FixedString::getHandle, COMDAT
; _this$ = ecx

; 59   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 			return m_StrHandle;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 61   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getHandle@FixedString@Ogre@@QBEPAXXZ ENDP		; Ogre::FixedString::getHandle
_TEXT	ENDS
PUBLIC	?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ	; Ogre::Resource::getRTTI
EXTRN	?m_RTTI@Resource@Ogre@@2VRuntimeClass@2@B:BYTE	; Ogre::Resource::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreresource.h
;	COMDAT ?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::Resource::getRTTI, COMDAT
; _this$ = ecx

; 39   : 		DECLARE_RTTI_VIRTUAL(Resource)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@Resource@Ogre@@2VRuntimeClass@2@B ; Ogre::Resource::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::Resource::getRTTI
_TEXT	ENDS
PUBLIC	?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ ; Ogre::Resource::getResPath
; Function compile flags: /Odtp
;	COMDAT ?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ PROC	; Ogre::Resource::getResPath, COMDAT
; _this$ = ecx

; 44   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 			return m_ResPath;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8

; 46   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ ENDP	; Ogre::Resource::getResPath
_TEXT	ENDS
PUBLIC	?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z ; Ogre::Resource::setResPath
EXTRN	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z:PROC	; Ogre::FixedString::operator=
; Function compile flags: /Odtp
;	COMDAT ?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_path$ = 8						; size = 4
?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z PROC	; Ogre::Resource::setResPath, COMDAT
; _this$ = ecx

; 48   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 			m_ResPath = path;

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FixedString::operator=

; 50   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z ENDP	; Ogre::Resource::setResPath
_TEXT	ENDS
PUBLIC	??_7Resource@Ogre@@6B@				; Ogre::Resource::`vftable'
PUBLIC	??0Resource@Ogre@@IAE@XZ			; Ogre::Resource::Resource
PUBLIC	??_R4Resource@Ogre@@6B@				; Ogre::Resource::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVResource@Ogre@@@8			; Ogre::Resource `RTTI Type Descriptor'
PUBLIC	??_R3Resource@Ogre@@8				; Ogre::Resource::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Resource@Ogre@@8				; Ogre::Resource::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Resource@Ogre@@8			; Ogre::Resource::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EResource@Ogre@@MAEPAXI@Z			; Ogre::Resource::`vector deleting destructor'
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?release@Resource@Ogre@@UAEXXZ:PROC		; Ogre::Resource::release
EXTRN	?addRef@Resource@Ogre@@UAEXXZ:PROC		; Ogre::Resource::addRef
EXTRN	?getRefCount@Resource@Ogre@@UAEHXZ:PROC		; Ogre::Resource::getRefCount
;	COMDAT ??_R1A@?0A@EA@Resource@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Resource@Ogre@@8 DD FLAT:??_R0?AVResource@Ogre@@@8 ; Ogre::Resource::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Resource@Ogre@@8
rdata$r	SEGMENT
??_R2Resource@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Resource@Ogre@@8 ; Ogre::Resource::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3Resource@Ogre@@8
rdata$r	SEGMENT
??_R3Resource@Ogre@@8 DD 00H				; Ogre::Resource::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVResource@Ogre@@@8
_DATA	SEGMENT
??_R0?AVResource@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Resource `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVResource@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Resource@Ogre@@6B@
rdata$r	SEGMENT
??_R4Resource@Ogre@@6B@ DD 00H				; Ogre::Resource::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVResource@Ogre@@@8
	DD	FLAT:??_R3Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Resource@Ogre@@6B@
CONST	SEGMENT
??_7Resource@Ogre@@6B@ DD FLAT:??_R4Resource@Ogre@@6B@	; Ogre::Resource::`vftable'
	DD	FLAT:?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EResource@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Resource@Ogre@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@IAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@IAE@XZ$1
__ehfuncinfo$??0Resource@Ogre@@IAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Resource@Ogre@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Resource@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Resource@Ogre@@IAE@XZ PROC				; Ogre::Resource::Resource, COMDAT
; _this$ = ecx

; 72   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Resource@Ogre@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@IAE@XZ		; Ogre::BaseObject::BaseObject
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Resource@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::FixedString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 73   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Resource@Ogre@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0Resource@Ogre@@IAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??0Resource@Ogre@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Resource@Ogre@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Resource@Ogre@@IAE@XZ ENDP				; Ogre::Resource::Resource
PUBLIC	??1Resource@Ogre@@MAE@XZ			; Ogre::Resource::~Resource
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Resource@Ogre@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Resource@Ogre@@MAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Resource@Ogre@@MAE@XZ$1
__ehfuncinfo$??1Resource@Ogre@@MAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1Resource@Ogre@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1Resource@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Resource@Ogre@@MAE@XZ PROC				; Ogre::Resource::~Resource, COMDAT
; _this$ = ecx

; 76   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Resource@Ogre@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Resource@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 77   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Resource@Ogre@@MAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??1Resource@Ogre@@MAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??1Resource@Ogre@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Resource@Ogre@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Resource@Ogre@@MAE@XZ ENDP				; Ogre::Resource::~Resource
PUBLIC	??0Resource@Ogre@@QAE@ABV01@@Z			; Ogre::Resource::Resource
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Resource@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0Resource@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Resource@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Resource@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Resource@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Resource::Resource, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Resource@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7Resource@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0FixedString@Ogre@@QAE@ABV01@@Z	; Ogre::FixedString::FixedString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??0Resource@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Resource@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Resource@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Resource::Resource
PUBLIC	??4Resource@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Resource::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Resource@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Resource@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::Resource::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FixedString::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Resource@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::Resource::operator=
_TEXT	ENDS
PUBLIC	??_GResource@Ogre@@MAEPAXI@Z			; Ogre::Resource::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GResource@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GResource@Ogre@@MAEPAXI@Z PROC			; Ogre::Resource::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GResource@Ogre@@MAEPAXI@Z ENDP			; Ogre::Resource::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EResource@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EResource@Ogre@@MAEPAXI@Z PROC			; Ogre::Resource::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@2
	push	OFFSET ??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@2
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@2
$LN3@vector@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@2
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EResource@Ogre@@MAEPAXI@Z ENDP			; Ogre::Resource::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@BaseAnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::BaseAnimationData::getRTTI
EXTRN	?m_RTTI@BaseAnimationData@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::BaseAnimationData::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreanimationdata.h
;	COMDAT ?getRTTI@BaseAnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@BaseAnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::BaseAnimationData::getRTTI, COMDAT
; _this$ = ecx

; 41   : 		DECLARE_RTTI_VIRTUAL(BaseAnimationData)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@BaseAnimationData@Ogre@@2VRuntimeClass@2@B ; Ogre::BaseAnimationData::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@BaseAnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::BaseAnimationData::getRTTI
_TEXT	ENDS
PUBLIC	??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??_7BaseAnimationData@Ogre@@6B@			; Ogre::BaseAnimationData::`vftable'
PUBLIC	??0BaseAnimationData@Ogre@@QAE@XZ		; Ogre::BaseAnimationData::BaseAnimationData
PUBLIC	??_R4BaseAnimationData@Ogre@@6B@		; Ogre::BaseAnimationData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVBaseAnimationData@Ogre@@@8		; Ogre::BaseAnimationData `RTTI Type Descriptor'
PUBLIC	??_R3BaseAnimationData@Ogre@@8			; Ogre::BaseAnimationData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2BaseAnimationData@Ogre@@8			; Ogre::BaseAnimationData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@BaseAnimationData@Ogre@@8		; Ogre::BaseAnimationData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EBaseAnimationData@Ogre@@UAEPAXI@Z		; Ogre::BaseAnimationData::`vector deleting destructor'
EXTRN	?_serialize@BaseAnimationData@Ogre@@UAEXAAVArchive@2@H@Z:PROC ; Ogre::BaseAnimationData::_serialize
EXTRN	__purecall:PROC
;	COMDAT ??_R1A@?0A@EA@BaseAnimationData@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@BaseAnimationData@Ogre@@8 DD FLAT:??_R0?AVBaseAnimationData@Ogre@@@8 ; Ogre::BaseAnimationData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3BaseAnimationData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2BaseAnimationData@Ogre@@8
rdata$r	SEGMENT
??_R2BaseAnimationData@Ogre@@8 DD FLAT:??_R1A@?0A@EA@BaseAnimationData@Ogre@@8 ; Ogre::BaseAnimationData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3BaseAnimationData@Ogre@@8
rdata$r	SEGMENT
??_R3BaseAnimationData@Ogre@@8 DD 00H			; Ogre::BaseAnimationData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2BaseAnimationData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBaseAnimationData@Ogre@@@8
_DATA	SEGMENT
??_R0?AVBaseAnimationData@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::BaseAnimationData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBaseAnimationData@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4BaseAnimationData@Ogre@@6B@
rdata$r	SEGMENT
??_R4BaseAnimationData@Ogre@@6B@ DD 00H			; Ogre::BaseAnimationData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBaseAnimationData@Ogre@@@8
	DD	FLAT:??_R3BaseAnimationData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7BaseAnimationData@Ogre@@6B@
CONST	SEGMENT
??_7BaseAnimationData@Ogre@@6B@ DD FLAT:??_R4BaseAnimationData@Ogre@@6B@ ; Ogre::BaseAnimationData::`vftable'
	DD	FLAT:?getRTTI@BaseAnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseAnimationData@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EBaseAnimationData@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0BaseAnimationData@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@XZ$2
__ehfuncinfo$??0BaseAnimationData@Ogre@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0BaseAnimationData@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0BaseAnimationData@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0BaseAnimationData@Ogre@@QAE@XZ PROC			; Ogre::BaseAnimationData::BaseAnimationData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0BaseAnimationData@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseAnimationData@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
__ehhandler$??0BaseAnimationData@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0BaseAnimationData@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0BaseAnimationData@Ogre@@QAE@XZ ENDP			; Ogre::BaseAnimationData::BaseAnimationData
PUBLIC	??1BaseAnimationData@Ogre@@UAE@XZ		; Ogre::BaseAnimationData::~BaseAnimationData
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1BaseAnimationData@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1BaseAnimationData@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1BaseAnimationData@Ogre@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1BaseAnimationData@Ogre@@UAE@XZ$2
__ehfuncinfo$??1BaseAnimationData@Ogre@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1BaseAnimationData@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1BaseAnimationData@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1BaseAnimationData@Ogre@@UAE@XZ PROC			; Ogre::BaseAnimationData::~BaseAnimationData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1BaseAnimationData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1BaseAnimationData@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__unwindfunclet$??1BaseAnimationData@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
__unwindfunclet$??1BaseAnimationData@Ogre@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
__ehhandler$??1BaseAnimationData@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1BaseAnimationData@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1BaseAnimationData@Ogre@@UAE@XZ ENDP			; Ogre::BaseAnimationData::~BaseAnimationData
PUBLIC	??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??0BaseAnimationData@Ogre@@QAE@ABV01@@Z		; Ogre::BaseAnimationData::BaseAnimationData
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z$2
__ehfuncinfo$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0BaseAnimationData@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0BaseAnimationData@Ogre@@QAE@ABV01@@Z PROC		; Ogre::BaseAnimationData::BaseAnimationData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7BaseAnimationData@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
__unwindfunclet$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
__ehhandler$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0BaseAnimationData@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0BaseAnimationData@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::BaseAnimationData::BaseAnimationData
PUBLIC	??4?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator=
PUBLIC	??4?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator=
PUBLIC	??4BaseAnimationData@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::BaseAnimationData::operator=
; Function compile flags: /Odtp
;	COMDAT ??4BaseAnimationData@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BaseAnimationData@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::BaseAnimationData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??4?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BaseAnimationData@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::BaseAnimationData::operator=
_TEXT	ENDS
PUBLIC	??_GBaseAnimationData@Ogre@@UAEPAXI@Z		; Ogre::BaseAnimationData::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GBaseAnimationData@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GBaseAnimationData@Ogre@@UAEPAXI@Z PROC		; Ogre::BaseAnimationData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseAnimationData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBaseAnimationData@Ogre@@UAEPAXI@Z ENDP		; Ogre::BaseAnimationData::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EBaseAnimationData@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EBaseAnimationData@Ogre@@UAEPAXI@Z PROC		; Ogre::BaseAnimationData::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@3
	push	OFFSET ??1BaseAnimationData@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	64					; 00000040H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@3
	push	64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@3
$LN3@vector@3:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseAnimationData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@3
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@3:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EBaseAnimationData@Ogre@@UAEPAXI@Z ENDP		; Ogre::BaseAnimationData::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@AnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::AnimationData::getRTTI
EXTRN	?m_RTTI@AnimationData@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::AnimationData::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@AnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@AnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::AnimationData::getRTTI, COMDAT
; _this$ = ecx

; 60   : 		DECLARE_RTTI(AnimationData)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@AnimationData@Ogre@@2VRuntimeClass@2@B ; Ogre::AnimationData::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@AnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::AnimationData::getRTTI
_TEXT	ENDS
PUBLIC	?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::AnimationData::newObject
EXTRN	??0AnimationData@Ogre@@QAE@XZ:PROC		; Ogre::AnimationData::AnimationData
EXTRN	??2MemoryDelegation@Ogre@@SAPAXI@Z:PROC		; Ogre::MemoryDelegation::operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T89641 = -20						; size = 4
$T89640 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ PROC ; Ogre::AnimationData::newObject, COMDAT

; 60   : 		DECLARE_RTTI(AnimationData)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	112					; 00000070H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T89641[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T89641[ebp], 0
	je	SHORT $LN3@newObject
	mov	ecx, DWORD PTR $T89641[ebp]
	call	??0AnimationData@Ogre@@QAE@XZ		; Ogre::AnimationData::AnimationData
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject
$LN3@newObject:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T89640[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T89640[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	112					; 00000070H
	mov	eax, DWORD PTR $T89641[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@AnimationData@Ogre@@SAPAVBaseObject@2@XZ ENDP ; Ogre::AnimationData::newObject
PUBLIC	??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::~vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	??_7AnimationData@Ogre@@6B@			; Ogre::AnimationData::`vftable'
PUBLIC	??0AnimationData@Ogre@@QAE@ABV01@@Z		; Ogre::AnimationData::AnimationData
PUBLIC	??_R4AnimationData@Ogre@@6B@			; Ogre::AnimationData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVAnimationData@Ogre@@@8			; Ogre::AnimationData `RTTI Type Descriptor'
PUBLIC	??_R3AnimationData@Ogre@@8			; Ogre::AnimationData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AnimationData@Ogre@@8			; Ogre::AnimationData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@AnimationData@Ogre@@8		; Ogre::AnimationData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EAnimationData@Ogre@@UAEPAXI@Z		; Ogre::AnimationData::`vector deleting destructor'
EXTRN	?_serialize@AnimationData@Ogre@@UAEXAAVArchive@2@H@Z:PROC ; Ogre::AnimationData::_serialize
EXTRN	?getType@AnimationData@Ogre@@UAE?AW4AnimationType@2@XZ:PROC ; Ogre::AnimationData::getType
;	COMDAT ??_R1A@?0A@EA@AnimationData@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AnimationData@Ogre@@8 DD FLAT:??_R0?AVAnimationData@Ogre@@@8 ; Ogre::AnimationData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AnimationData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2AnimationData@Ogre@@8
rdata$r	SEGMENT
??_R2AnimationData@Ogre@@8 DD FLAT:??_R1A@?0A@EA@AnimationData@Ogre@@8 ; Ogre::AnimationData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseAnimationData@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3AnimationData@Ogre@@8
rdata$r	SEGMENT
??_R3AnimationData@Ogre@@8 DD 00H			; Ogre::AnimationData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2AnimationData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAnimationData@Ogre@@@8
_DATA	SEGMENT
??_R0?AVAnimationData@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::AnimationData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAnimationData@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4AnimationData@Ogre@@6B@
rdata$r	SEGMENT
??_R4AnimationData@Ogre@@6B@ DD 00H			; Ogre::AnimationData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVAnimationData@Ogre@@@8
	DD	FLAT:??_R3AnimationData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7AnimationData@Ogre@@6B@
CONST	SEGMENT
??_7AnimationData@Ogre@@6B@ DD FLAT:??_R4AnimationData@Ogre@@6B@ ; Ogre::AnimationData::`vftable'
	DD	FLAT:?getRTTI@AnimationData@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@AnimationData@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EAnimationData@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getType@AnimationData@Ogre@@UAE?AW4AnimationType@2@XZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0AnimationData@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AnimationData@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0AnimationData@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0AnimationData@Ogre@@QAE@ABV01@@Z$2
__ehfuncinfo$??0AnimationData@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0AnimationData@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0AnimationData@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0AnimationData@Ogre@@QAE@ABV01@@Z PROC		; Ogre::AnimationData::AnimationData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AnimationData@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseAnimationData@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7AnimationData@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0AnimationData@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseAnimationData@Ogre@@UAE@XZ
__unwindfunclet$??0AnimationData@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
__unwindfunclet$??0AnimationData@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::~vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
__ehhandler$??0AnimationData@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AnimationData@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AnimationData@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::AnimationData::AnimationData
PUBLIC	??4?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator=
PUBLIC	??4?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator=
PUBLIC	??4AnimationData@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::AnimationData::operator=
; Function compile flags: /Odtp
;	COMDAT ??4AnimationData@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4AnimationData@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::AnimationData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BaseAnimationData@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??4?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 88					; 00000058H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??4?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4AnimationData@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::AnimationData::operator=
_TEXT	ENDS
PUBLIC	??_GAnimationData@Ogre@@UAEPAXI@Z		; Ogre::AnimationData::`scalar deleting destructor'
EXTRN	??1AnimationData@Ogre@@UAE@XZ:PROC		; Ogre::AnimationData::~AnimationData
; Function compile flags: /Odtp
;	COMDAT ??_GAnimationData@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GAnimationData@Ogre@@UAEPAXI@Z PROC			; Ogre::AnimationData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AnimationData@Ogre@@UAE@XZ		; Ogre::AnimationData::~AnimationData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	push	112					; 00000070H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GAnimationData@Ogre@@UAEPAXI@Z ENDP			; Ogre::AnimationData::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EAnimationData@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EAnimationData@Ogre@@UAEPAXI@Z PROC			; Ogre::AnimationData::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@4
	push	OFFSET ??1AnimationData@Ogre@@UAE@XZ	; Ogre::AnimationData::~AnimationData
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	112					; 00000070H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@4
	push	112					; 00000070H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@4
$LN3@vector@4:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AnimationData@Ogre@@UAE@XZ		; Ogre::AnimationData::~AnimationData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@4
	push	112					; 00000070H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@4:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EAnimationData@Ogre@@UAEPAXI@Z ENDP			; Ogre::AnimationData::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::~vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
PUBLIC	??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
PUBLIC	??0AnimationPlayer@Ogre@@QAE@ABV01@@Z		; Ogre::AnimationPlayer::AnimationPlayer
EXTRN	__fltused:DWORD
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0AnimationPlayer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AnimationPlayer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0AnimationPlayer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0AnimationPlayer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0AnimationPlayer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0AnimationPlayer@Ogre@@QAE@ABV01@@Z PROC		; Ogre::AnimationPlayer::AnimationPlayer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AnimationPlayer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+24]
	fstp	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [ecx+28]
	fstp	DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0AnimationPlayer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::~vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
__ehhandler$??0AnimationPlayer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AnimationPlayer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AnimationPlayer@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::AnimationPlayer::AnimationPlayer
PUBLIC	??4?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator=
PUBLIC	??4AnimationPlayer@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::AnimationPlayer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4AnimationPlayer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4AnimationPlayer@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::AnimationPlayer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+24]
	fstp	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [ecx+28]
	fstp	DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4AnimationPlayer@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::AnimationPlayer::operator=
_TEXT	ENDS
PUBLIC	??_7DataStream@Ogre@@6B@			; Ogre::DataStream::`vftable'
PUBLIC	??0DataStream@Ogre@@QAE@XZ			; Ogre::DataStream::DataStream
PUBLIC	??_R4DataStream@Ogre@@6B@			; Ogre::DataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDataStream@Ogre@@@8			; Ogre::DataStream `RTTI Type Descriptor'
PUBLIC	??_R3DataStream@Ogre@@8				; Ogre::DataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DataStream@Ogre@@8				; Ogre::DataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DataStream@Ogre@@8		; Ogre::DataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDataStream@Ogre@@UAEPAXI@Z			; Ogre::DataStream::`vector deleting destructor'
PUBLIC	?size@DataStream@Ogre@@UBEIXZ			; Ogre::DataStream::size
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::DataStream::readLine
EXTRN	?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:PROC ; Ogre::DataStream::getLine
EXTRN	?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:PROC ; Ogre::DataStream::getAsString
EXTRN	?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::DataStream::skipLine
;	COMDAT ??_R1A@?0A@EA@DataStream@Ogre@@8
; File i:\svnroot\client\ogremain\ogredatastream.h
rdata$r	SEGMENT
??_R1A@?0A@EA@DataStream@Ogre@@8 DD FLAT:??_R0?AVDataStream@Ogre@@@8 ; Ogre::DataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DataStream@Ogre@@8
rdata$r	SEGMENT
??_R2DataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8 ; Ogre::DataStream::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DataStream@Ogre@@8
rdata$r	SEGMENT
??_R3DataStream@Ogre@@8 DD 00H				; Ogre::DataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::DataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4DataStream@Ogre@@6B@ DD 00H			; Ogre::DataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDataStream@Ogre@@@8
	DD	FLAT:??_R3DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DataStream@Ogre@@6B@
CONST	SEGMENT
??_7DataStream@Ogre@@6B@ DD FLAT:??_R4DataStream@Ogre@@6B@ ; Ogre::DataStream::`vftable'
	DD	FLAT:??_EDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@XZ$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0DataStream@Ogre@@QAE@XZ PROC				; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx

; 68   : 		DataStream() : mSize(0) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@XZ ENDP				; Ogre::DataStream::DataStream
PUBLIC	??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ogre::DataStream::DataStream
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx

; 70   : 		DataStream(const String& name) : mName(name), mSize(0) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Ogre::DataStream::DataStream
PUBLIC	?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Ogre::DataStream::getName
; Function compile flags: /Odtp
;	COMDAT ?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Ogre::DataStream::getName, COMDAT
; _this$ = ecx

; 72   : 		const String& getName(void) { return mName; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Ogre::DataStream::getName
_TEXT	ENDS
PUBLIC	??1DataStream@Ogre@@UAE@XZ			; Ogre::DataStream::~DataStream
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1DataStream@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DataStream@Ogre@@UAE@XZ$0
__ehfuncinfo$??1DataStream@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1DataStream@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1DataStream@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1DataStream@Ogre@@UAE@XZ PROC				; Ogre::DataStream::~DataStream, COMDAT
; _this$ = ecx

; 73   : 		virtual ~DataStream() {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DataStream@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DataStream@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1DataStream@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1DataStream@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1DataStream@Ogre@@UAE@XZ ENDP				; Ogre::DataStream::~DataStream
; Function compile flags: /Odtp
;	COMDAT ?size@DataStream@Ogre@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@DataStream@Ogre@@UBEIXZ PROC			; Ogre::DataStream::size, COMDAT
; _this$ = ecx

; 157  : 		virtual size_t size(void) const { return mSize; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?size@DataStream@Ogre@@UBEIXZ ENDP			; Ogre::DataStream::size
_TEXT	ENDS
PUBLIC	??0DataStream@Ogre@@QAE@ABV01@@Z		; Ogre::DataStream::DataStream
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0DataStream@Ogre@@QAE@ABV01@@Z PROC			; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::DataStream::DataStream
PUBLIC	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::DataStream::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DataStream@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::DataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::DataStream::operator=
_TEXT	ENDS
PUBLIC	??_GDataStream@Ogre@@UAEPAXI@Z			; Ogre::DataStream::`scalar deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDataStream@Ogre@@UAEPAXI@Z PROC			; Ogre::DataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDataStream@Ogre@@UAEPAXI@Z ENDP			; Ogre::DataStream::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp
;	COMDAT ??_EDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDataStream@Ogre@@UAEPAXI@Z PROC			; Ogre::DataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@5
	push	OFFSET ??1DataStream@Ogre@@UAE@XZ	; Ogre::DataStream::~DataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@5
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@5:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@5
$LN3@vector@5:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@5:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@5:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDataStream@Ogre@@UAEPAXI@Z ENDP			; Ogre::DataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ		; Ogre::MemoryDataStream::getPtr
; Function compile flags: /Odtp
;	COMDAT ?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ PROC		; Ogre::MemoryDataStream::getPtr, COMDAT
; _this$ = ecx

; 267  : 		uchar* getPtr(void) { return mData; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ ENDP		; Ogre::MemoryDataStream::getPtr
_TEXT	ENDS
PUBLIC	?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ	; Ogre::MemoryDataStream::getCurrentPtr
; Function compile flags: /Odtp
;	COMDAT ?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ PROC	; Ogre::MemoryDataStream::getCurrentPtr, COMDAT
; _this$ = ecx

; 270  : 		uchar* getCurrentPtr(void) { return mPos; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ ENDP	; Ogre::MemoryDataStream::getCurrentPtr
_TEXT	ENDS
PUBLIC	?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ	; Ogre::MemoryDataStream::getMemoryImage
; Function compile flags: /Odtp
;	COMDAT ?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ PROC	; Ogre::MemoryDataStream::getMemoryImage, COMDAT
; _this$ = ecx

; 307  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 308  : 			return mData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 309  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ ENDP	; Ogre::MemoryDataStream::getMemoryImage
_TEXT	ENDS
PUBLIC	?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z ; Ogre::MemoryDataStream::setFreeOnClose
; Function compile flags: /Odtp
;	COMDAT ?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_freeOnClose$ = 8					; size = 4
?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z PROC ; Ogre::MemoryDataStream::setFreeOnClose, COMDAT
; _this$ = ecx

; 313  : 		void setFreeOnClose(void (*freeOnClose)(void *)) { mFreeOnClose = freeOnClose; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _freeOnClose$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z ENDP ; Ogre::MemoryDataStream::setFreeOnClose
_TEXT	ENDS
PUBLIC	??_7MemoryDataStream@Ogre@@6B@			; Ogre::MemoryDataStream::`vftable'
PUBLIC	??0MemoryDataStream@Ogre@@QAE@ABV01@@Z		; Ogre::MemoryDataStream::MemoryDataStream
PUBLIC	??_R4MemoryDataStream@Ogre@@6B@			; Ogre::MemoryDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMemoryDataStream@Ogre@@@8		; Ogre::MemoryDataStream `RTTI Type Descriptor'
PUBLIC	??_R3MemoryDataStream@Ogre@@8			; Ogre::MemoryDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MemoryDataStream@Ogre@@8			; Ogre::MemoryDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MemoryDataStream@Ogre@@8		; Ogre::MemoryDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EMemoryDataStream@Ogre@@UAEPAXI@Z		; Ogre::MemoryDataStream::`vector deleting destructor'
EXTRN	?read@MemoryDataStream@Ogre@@UAEIPAXI@Z:PROC	; Ogre::MemoryDataStream::read
EXTRN	?write@MemoryDataStream@Ogre@@UAEIPBXI@Z:PROC	; Ogre::MemoryDataStream::write
EXTRN	?readLine@MemoryDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::MemoryDataStream::readLine
EXTRN	?skipLine@MemoryDataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::MemoryDataStream::skipLine
EXTRN	?skip@MemoryDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::MemoryDataStream::skip
EXTRN	?seek@MemoryDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::MemoryDataStream::seek
EXTRN	?tell@MemoryDataStream@Ogre@@UBEIXZ:PROC	; Ogre::MemoryDataStream::tell
EXTRN	?eof@MemoryDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::MemoryDataStream::eof
EXTRN	?close@MemoryDataStream@Ogre@@UAEXXZ:PROC	; Ogre::MemoryDataStream::close
;	COMDAT ??_R1A@?0A@EA@MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MemoryDataStream@Ogre@@8 DD FLAT:??_R0?AVMemoryDataStream@Ogre@@@8 ; Ogre::MemoryDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2MemoryDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MemoryDataStream@Ogre@@8 ; Ogre::MemoryDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3MemoryDataStream@Ogre@@8 DD 00H			; Ogre::MemoryDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMemoryDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMemoryDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MemoryDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMemoryDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MemoryDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4MemoryDataStream@Ogre@@6B@ DD 00H			; Ogre::MemoryDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMemoryDataStream@Ogre@@@8
	DD	FLAT:??_R3MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7MemoryDataStream@Ogre@@6B@
CONST	SEGMENT
??_7MemoryDataStream@Ogre@@6B@ DD FLAT:??_R4MemoryDataStream@Ogre@@6B@ ; Ogre::MemoryDataStream::`vftable'
	DD	FLAT:??_EMemoryDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@MemoryDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@MemoryDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@MemoryDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@MemoryDataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@MemoryDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@MemoryDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@MemoryDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@MemoryDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@MemoryDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0MemoryDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::MemoryDataStream::MemoryDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7MemoryDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+44], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MemoryDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::MemoryDataStream::MemoryDataStream
PUBLIC	??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MemoryDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::MemoryDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+48], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::MemoryDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GMemoryDataStream@Ogre@@UAEPAXI@Z		; Ogre::MemoryDataStream::`scalar deleting destructor'
EXTRN	??1MemoryDataStream@Ogre@@UAE@XZ:PROC		; Ogre::MemoryDataStream::~MemoryDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GMemoryDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMemoryDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::MemoryDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GMemoryDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::MemoryDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EMemoryDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EMemoryDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::MemoryDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@6
	push	OFFSET ??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@6
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@6:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@6
$LN3@vector@6:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@6:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@6:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EMemoryDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::MemoryDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7FileStreamDataStream@Ogre@@6B@		; Ogre::FileStreamDataStream::`vftable'
PUBLIC	??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z	; Ogre::FileStreamDataStream::FileStreamDataStream
PUBLIC	??_R4FileStreamDataStream@Ogre@@6B@		; Ogre::FileStreamDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFileStreamDataStream@Ogre@@@8		; Ogre::FileStreamDataStream `RTTI Type Descriptor'
PUBLIC	??_R3FileStreamDataStream@Ogre@@8		; Ogre::FileStreamDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileStreamDataStream@Ogre@@8		; Ogre::FileStreamDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8	; Ogre::FileStreamDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EFileStreamDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileStreamDataStream::`vector deleting destructor'
EXTRN	?read@FileStreamDataStream@Ogre@@UAEIPAXI@Z:PROC ; Ogre::FileStreamDataStream::read
EXTRN	?write@FileStreamDataStream@Ogre@@UAEIPBXI@Z:PROC ; Ogre::FileStreamDataStream::write
EXTRN	?readLine@FileStreamDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::FileStreamDataStream::readLine
EXTRN	?skip@FileStreamDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::FileStreamDataStream::skip
EXTRN	?seek@FileStreamDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::FileStreamDataStream::seek
EXTRN	?tell@FileStreamDataStream@Ogre@@UBEIXZ:PROC	; Ogre::FileStreamDataStream::tell
EXTRN	?eof@FileStreamDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::FileStreamDataStream::eof
EXTRN	?close@FileStreamDataStream@Ogre@@UAEXXZ:PROC	; Ogre::FileStreamDataStream::close
EXTRN	?getMemoryImage@FileStreamDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::FileStreamDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8 DD FLAT:??_R0?AVFileStreamDataStream@Ogre@@@8 ; Ogre::FileStreamDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2FileStreamDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8 ; Ogre::FileStreamDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3FileStreamDataStream@Ogre@@8 DD 00H		; Ogre::FileStreamDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileStreamDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVFileStreamDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::FileStreamDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileStreamDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FileStreamDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4FileStreamDataStream@Ogre@@6B@ DD 00H		; Ogre::FileStreamDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFileStreamDataStream@Ogre@@@8
	DD	FLAT:??_R3FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7FileStreamDataStream@Ogre@@6B@
CONST	SEGMENT
??_7FileStreamDataStream@Ogre@@6B@ DD FLAT:??_R4FileStreamDataStream@Ogre@@6B@ ; Ogre::FileStreamDataStream::`vftable'
	DD	FLAT:??_EFileStreamDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@FileStreamDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@FileStreamDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@FileStreamDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@FileStreamDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@FileStreamDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@FileStreamDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@FileStreamDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@FileStreamDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@FileStreamDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::FileStreamDataStream::FileStreamDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7FileStreamDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+40]
	mov	BYTE PTR [edx+40], cl
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::FileStreamDataStream::FileStreamDataStream
PUBLIC	??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FileStreamDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::FileStreamDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+40]
	mov	BYTE PTR [ecx+40], al
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::FileStreamDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GFileStreamDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileStreamDataStream::`scalar deleting destructor'
EXTRN	??1FileStreamDataStream@Ogre@@UAE@XZ:PROC	; Ogre::FileStreamDataStream::~FileStreamDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GFileStreamDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFileStreamDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileStreamDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileStreamDataStream@Ogre@@UAE@XZ	; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@7
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFileStreamDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileStreamDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EFileStreamDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EFileStreamDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileStreamDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@7
	push	OFFSET ??1FileStreamDataStream@Ogre@@UAE@XZ ; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@7
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@7:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@7
$LN3@vector@7:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileStreamDataStream@Ogre@@UAE@XZ	; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@7
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@7:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@7:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EFileStreamDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileStreamDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7FileHandleDataStream@Ogre@@6B@		; Ogre::FileHandleDataStream::`vftable'
PUBLIC	??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z	; Ogre::FileHandleDataStream::FileHandleDataStream
PUBLIC	??_R4FileHandleDataStream@Ogre@@6B@		; Ogre::FileHandleDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFileHandleDataStream@Ogre@@@8		; Ogre::FileHandleDataStream `RTTI Type Descriptor'
PUBLIC	??_R3FileHandleDataStream@Ogre@@8		; Ogre::FileHandleDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileHandleDataStream@Ogre@@8		; Ogre::FileHandleDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8	; Ogre::FileHandleDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EFileHandleDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileHandleDataStream::`vector deleting destructor'
EXTRN	?read@FileHandleDataStream@Ogre@@UAEIPAXI@Z:PROC ; Ogre::FileHandleDataStream::read
EXTRN	?write@FileHandleDataStream@Ogre@@UAEIPBXI@Z:PROC ; Ogre::FileHandleDataStream::write
EXTRN	?skip@FileHandleDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::FileHandleDataStream::skip
EXTRN	?seek@FileHandleDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::FileHandleDataStream::seek
EXTRN	?tell@FileHandleDataStream@Ogre@@UBEIXZ:PROC	; Ogre::FileHandleDataStream::tell
EXTRN	?eof@FileHandleDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::FileHandleDataStream::eof
EXTRN	?close@FileHandleDataStream@Ogre@@UAEXXZ:PROC	; Ogre::FileHandleDataStream::close
EXTRN	?getMemoryImage@FileHandleDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::FileHandleDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8 DD FLAT:??_R0?AVFileHandleDataStream@Ogre@@@8 ; Ogre::FileHandleDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2FileHandleDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8 ; Ogre::FileHandleDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3FileHandleDataStream@Ogre@@8 DD 00H		; Ogre::FileHandleDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileHandleDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVFileHandleDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::FileHandleDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileHandleDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FileHandleDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4FileHandleDataStream@Ogre@@6B@ DD 00H		; Ogre::FileHandleDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFileHandleDataStream@Ogre@@@8
	DD	FLAT:??_R3FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7FileHandleDataStream@Ogre@@6B@
CONST	SEGMENT
??_7FileHandleDataStream@Ogre@@6B@ DD FLAT:??_R4FileHandleDataStream@Ogre@@6B@ ; Ogre::FileHandleDataStream::`vftable'
	DD	FLAT:??_EFileHandleDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@FileHandleDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@FileHandleDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@FileHandleDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@FileHandleDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@FileHandleDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@FileHandleDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@FileHandleDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@FileHandleDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::FileHandleDataStream::FileHandleDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7FileHandleDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::FileHandleDataStream::FileHandleDataStream
PUBLIC	??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FileHandleDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::FileHandleDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::FileHandleDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GFileHandleDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileHandleDataStream::`scalar deleting destructor'
EXTRN	??1FileHandleDataStream@Ogre@@UAE@XZ:PROC	; Ogre::FileHandleDataStream::~FileHandleDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GFileHandleDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFileHandleDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileHandleDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileHandleDataStream@Ogre@@UAE@XZ	; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFileHandleDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileHandleDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EFileHandleDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EFileHandleDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileHandleDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@8
	push	OFFSET ??1FileHandleDataStream@Ogre@@UAE@XZ ; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@8
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@8:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@8
$LN3@vector@8:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileHandleDataStream@Ogre@@UAE@XZ	; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@8:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@8:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EFileHandleDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileHandleDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7DataStreamObject@Ogre@@6B@			; Ogre::DataStreamObject::`vftable'
PUBLIC	??1DataStreamObject@Ogre@@MAE@XZ		; Ogre::DataStreamObject::~DataStreamObject
PUBLIC	??_R4DataStreamObject@Ogre@@6B@			; Ogre::DataStreamObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDataStreamObject@Ogre@@@8		; Ogre::DataStreamObject `RTTI Type Descriptor'
PUBLIC	??_R3DataStreamObject@Ogre@@8			; Ogre::DataStreamObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DataStreamObject@Ogre@@8			; Ogre::DataStreamObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DataStreamObject@Ogre@@8		; Ogre::DataStreamObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDataStreamObject@Ogre@@MAEPAXI@Z		; Ogre::DataStreamObject::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DataStreamObject@Ogre@@8 DD FLAT:??_R0?AVDataStreamObject@Ogre@@@8 ; Ogre::DataStreamObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R2DataStreamObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DataStreamObject@Ogre@@8 ; Ogre::DataStreamObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R3DataStreamObject@Ogre@@8 DD 00H			; Ogre::DataStreamObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDataStreamObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDataStreamObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::DataStreamObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDataStreamObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DataStreamObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4DataStreamObject@Ogre@@6B@ DD 00H			; Ogre::DataStreamObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDataStreamObject@Ogre@@@8
	DD	FLAT:??_R3DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DataStreamObject@Ogre@@6B@
CONST	SEGMENT
??_7DataStreamObject@Ogre@@6B@ DD FLAT:??_R4DataStreamObject@Ogre@@6B@ ; Ogre::DataStreamObject::`vftable'
	DD	FLAT:??_EDataStreamObject@Ogre@@MAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??1DataStreamObject@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DataStreamObject@Ogre@@MAE@XZ PROC			; Ogre::DataStreamObject::~DataStreamObject, COMDAT
; _this$ = ecx

; 445  : 		virtual ~DataStreamObject(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1DataStreamObject@Ogre@@MAE@XZ ENDP			; Ogre::DataStreamObject::~DataStreamObject
_TEXT	ENDS
PUBLIC	??0DataStreamObject@Ogre@@QAE@XZ		; Ogre::DataStreamObject::DataStreamObject
; Function compile flags: /Odtp
;	COMDAT ??0DataStreamObject@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DataStreamObject@Ogre@@QAE@XZ PROC			; Ogre::DataStreamObject::DataStreamObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DataStreamObject@Ogre@@QAE@XZ ENDP			; Ogre::DataStreamObject::DataStreamObject
_TEXT	ENDS
PUBLIC	??0DataStreamObject@Ogre@@QAE@ABV01@@Z		; Ogre::DataStreamObject::DataStreamObject
; Function compile flags: /Odtp
;	COMDAT ??0DataStreamObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0DataStreamObject@Ogre@@QAE@ABV01@@Z PROC		; Ogre::DataStreamObject::DataStreamObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0DataStreamObject@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::DataStreamObject::DataStreamObject
_TEXT	ENDS
PUBLIC	??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::DataStreamObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::DataStreamObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::DataStreamObject::operator=
_TEXT	ENDS
PUBLIC	??_GDataStreamObject@Ogre@@MAEPAXI@Z		; Ogre::DataStreamObject::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GDataStreamObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDataStreamObject@Ogre@@MAEPAXI@Z PROC		; Ogre::DataStreamObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@9
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@9:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDataStreamObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::DataStreamObject::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EDataStreamObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDataStreamObject@Ogre@@MAEPAXI@Z PROC		; Ogre::DataStreamObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@9
	push	OFFSET ??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@9
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@9:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@9
$LN3@vector@9:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@9
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@9:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@9:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDataStreamObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::DataStreamObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7ObjectDataStream@Ogre@@6B@			; Ogre::ObjectDataStream::`vftable'
PUBLIC	??0ObjectDataStream@Ogre@@QAE@ABV01@@Z		; Ogre::ObjectDataStream::ObjectDataStream
PUBLIC	??_R4ObjectDataStream@Ogre@@6B@			; Ogre::ObjectDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVObjectDataStream@Ogre@@@8		; Ogre::ObjectDataStream `RTTI Type Descriptor'
PUBLIC	??_R3ObjectDataStream@Ogre@@8			; Ogre::ObjectDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ObjectDataStream@Ogre@@8			; Ogre::ObjectDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ObjectDataStream@Ogre@@8		; Ogre::ObjectDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EObjectDataStream@Ogre@@UAEPAXI@Z		; Ogre::ObjectDataStream::`vector deleting destructor'
EXTRN	?read@ObjectDataStream@Ogre@@UAEIPAXI@Z:PROC	; Ogre::ObjectDataStream::read
EXTRN	?write@ObjectDataStream@Ogre@@UAEIPBXI@Z:PROC	; Ogre::ObjectDataStream::write
EXTRN	?skip@ObjectDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::ObjectDataStream::skip
EXTRN	?seek@ObjectDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::ObjectDataStream::seek
EXTRN	?tell@ObjectDataStream@Ogre@@UBEIXZ:PROC	; Ogre::ObjectDataStream::tell
EXTRN	?eof@ObjectDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::ObjectDataStream::eof
EXTRN	?size@ObjectDataStream@Ogre@@UBEIXZ:PROC	; Ogre::ObjectDataStream::size
EXTRN	?close@ObjectDataStream@Ogre@@UAEXXZ:PROC	; Ogre::ObjectDataStream::close
EXTRN	?getMemoryImage@ObjectDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::ObjectDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ObjectDataStream@Ogre@@8 DD FLAT:??_R0?AVObjectDataStream@Ogre@@@8 ; Ogre::ObjectDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2ObjectDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@ObjectDataStream@Ogre@@8 ; Ogre::ObjectDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3ObjectDataStream@Ogre@@8 DD 00H			; Ogre::ObjectDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVObjectDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVObjectDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::ObjectDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVObjectDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ObjectDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4ObjectDataStream@Ogre@@6B@ DD 00H			; Ogre::ObjectDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVObjectDataStream@Ogre@@@8
	DD	FLAT:??_R3ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7ObjectDataStream@Ogre@@6B@
CONST	SEGMENT
??_7ObjectDataStream@Ogre@@6B@ DD FLAT:??_R4ObjectDataStream@Ogre@@6B@ ; Ogre::ObjectDataStream::`vftable'
	DD	FLAT:??_EObjectDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@ObjectDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@ObjectDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@ObjectDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@ObjectDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@ObjectDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@ObjectDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@ObjectDataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@ObjectDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@ObjectDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0ObjectDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::ObjectDataStream::ObjectDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ObjectDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ObjectDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::ObjectDataStream::ObjectDataStream
PUBLIC	??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::ObjectDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::ObjectDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::ObjectDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GObjectDataStream@Ogre@@UAEPAXI@Z		; Ogre::ObjectDataStream::`scalar deleting destructor'
EXTRN	??1ObjectDataStream@Ogre@@UAE@XZ:PROC		; Ogre::ObjectDataStream::~ObjectDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GObjectDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GObjectDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::ObjectDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@10
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@10:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GObjectDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::ObjectDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EObjectDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EObjectDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::ObjectDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@10
	push	OFFSET ??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@10
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@10:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@10
$LN3@vector@10:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@10
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@10:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@10:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EObjectDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::ObjectDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7Archive@Ogre@@6B@				; Ogre::Archive::`vftable'
PUBLIC	??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z	; Ogre::Archive::Archive
PUBLIC	??_R4Archive@Ogre@@6B@				; Ogre::Archive::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVArchive@Ogre@@@8			; Ogre::Archive `RTTI Type Descriptor'
PUBLIC	??_R3Archive@Ogre@@8				; Ogre::Archive::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Archive@Ogre@@8				; Ogre::Archive::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Archive@Ogre@@8			; Ogre::Archive::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EArchive@Ogre@@UAEPAXI@Z			; Ogre::Archive::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@Archive@Ogre@@8
; File i:\svnroot\client\ogremain\ogrearchive.h
rdata$r	SEGMENT
??_R1A@?0A@EA@Archive@Ogre@@8 DD FLAT:??_R0?AVArchive@Ogre@@@8 ; Ogre::Archive::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Archive@Ogre@@8
rdata$r	SEGMENT
??_R2Archive@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Archive@Ogre@@8 ; Ogre::Archive::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Archive@Ogre@@8
rdata$r	SEGMENT
??_R3Archive@Ogre@@8 DD 00H				; Ogre::Archive::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVArchive@Ogre@@@8
_DATA	SEGMENT
??_R0?AVArchive@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Archive `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVArchive@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Archive@Ogre@@6B@
rdata$r	SEGMENT
??_R4Archive@Ogre@@6B@ DD 00H				; Ogre::Archive::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVArchive@Ogre@@@8
	DD	FLAT:??_R3Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Archive@Ogre@@6B@
CONST	SEGMENT
??_7Archive@Ogre@@6B@ DD FLAT:??_R4Archive@Ogre@@6B@	; Ogre::Archive::`vftable'
	DD	FLAT:??_EArchive@Ogre@@UAEPAXI@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstream$ = 8						; size = 4
_mode$ = 12						; size = 4
??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z PROC		; Ogre::Archive::Archive, COMDAT
; _this$ = ecx

; 22   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pstream$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 23   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z ENDP		; Ogre::Archive::Archive
_TEXT	ENDS
PUBLIC	??1Archive@Ogre@@UAE@XZ				; Ogre::Archive::~Archive
; Function compile flags: /Odtp
;	COMDAT ??1Archive@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Archive@Ogre@@UAE@XZ PROC				; Ogre::Archive::~Archive, COMDAT
; _this$ = ecx

; 26   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@

; 27   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1Archive@Ogre@@UAE@XZ ENDP				; Ogre::Archive::~Archive
_TEXT	ENDS
PUBLIC	?isLoading@Archive@Ogre@@QAE_NXZ		; Ogre::Archive::isLoading
; Function compile flags: /Odtp
;	COMDAT ?isLoading@Archive@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isLoading@Archive@Ogre@@QAE_NXZ PROC			; Ogre::Archive::isLoading, COMDAT
; _this$ = ecx

; 30   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 			return m_Mode==MODE_LOAD;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 1
	sete	cl
	mov	al, cl

; 32   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?isLoading@Archive@Ogre@@QAE_NXZ ENDP			; Ogre::Archive::isLoading
_TEXT	ENDS
PUBLIC	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z	; Ogre::Archive::serialize
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAD@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAD@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 108  : 		SERIALIZE_PRIMITIVE_FUNC(char)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAD@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAF@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAF@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 109  : 		SERIALIZE_PRIMITIVE_FUNC(short)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	2
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAF@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAH@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAH@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 110  : 		SERIALIZE_PRIMITIVE_FUNC(int)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAH@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_J@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_J@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 111  : 		SERIALIZE_PRIMITIVE_FUNC(int64)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	8
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_J@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAE@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAE@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 112  : 		SERIALIZE_PRIMITIVE_FUNC(uchar)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAE@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAG@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAG@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 113  : 		SERIALIZE_PRIMITIVE_FUNC(ushort)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	2
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAG@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAI@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAI@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 114  : 		SERIALIZE_PRIMITIVE_FUNC(uint)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAI@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_K@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_K@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 115  : 		SERIALIZE_PRIMITIVE_FUNC(uint64)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	8
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_K@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_N@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_N@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 116  : 		SERIALIZE_PRIMITIVE_FUNC(bool)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_N@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAM@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAM@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 117  : 		SERIALIZE_PRIMITIVE_FUNC(float)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAM@Z ENDP			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z PROC		; Ogre::Archive::serialize, COMDAT
; _this$ = ecx

; 155  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 			if(isLoading()) m_pStream->read(pbuf, len);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@serialize
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
	jmp	SHORT $LN1@serialize
$LN2@serialize:

; 157  : 			else m_pStream->write(pbuf, len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN1@serialize:

; 158  : 
; 159  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 160  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ENDP		; Ogre::Archive::serialize
_TEXT	ENDS
PUBLIC	?read@Archive@Ogre@@QAEXPAXI@Z			; Ogre::Archive::read
; Function compile flags: /Odtp
;	COMDAT ?read@Archive@Ogre@@QAEXPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?read@Archive@Ogre@@QAEXPAXI@Z PROC			; Ogre::Archive::read, COMDAT
; _this$ = ecx

; 163  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 			m_pStream->read(pbuf, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 165  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?read@Archive@Ogre@@QAEXPAXI@Z ENDP			; Ogre::Archive::read
_TEXT	ENDS
PUBLIC	?write@Archive@Ogre@@QAEXPBXI@Z			; Ogre::Archive::write
; Function compile flags: /Odtp
;	COMDAT ?write@Archive@Ogre@@QAEXPBXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?write@Archive@Ogre@@QAEXPBXI@Z PROC			; Ogre::Archive::write, COMDAT
; _this$ = ecx

; 168  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 			m_pStream->write(pbuf, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 170  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?write@Archive@Ogre@@QAEXPBXI@Z ENDP			; Ogre::Archive::write
_TEXT	ENDS
PUBLIC	??0Archive@Ogre@@QAE@ABV01@@Z			; Ogre::Archive::Archive
; Function compile flags: /Odtp
;	COMDAT ??0Archive@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Archive@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Archive::Archive, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Archive@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Archive::Archive
_TEXT	ENDS
PUBLIC	??4Archive@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Archive::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Archive@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Archive@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Archive::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Archive@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Archive::operator=
_TEXT	ENDS
PUBLIC	??_GArchive@Ogre@@UAEPAXI@Z			; Ogre::Archive::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GArchive@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GArchive@Ogre@@UAEPAXI@Z PROC			; Ogre::Archive::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Archive@Ogre@@UAE@XZ			; Ogre::Archive::~Archive
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@11
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@11:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GArchive@Ogre@@UAEPAXI@Z ENDP			; Ogre::Archive::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EArchive@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EArchive@Ogre@@UAEPAXI@Z PROC			; Ogre::Archive::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@11
	push	OFFSET ??1Archive@Ogre@@UAE@XZ		; Ogre::Archive::~Archive
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@11
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@11:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@11
$LN3@vector@11:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Archive@Ogre@@UAE@XZ			; Ogre::Archive::~Archive
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@11
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@11:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@11:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EArchive@Ogre@@UAEPAXI@Z ENDP			; Ogre::Archive::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@XZ				; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
;	COMDAT ??0Vector3@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector3@Ogre@@QAE@XZ PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 49   : 		Vector3(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector3@Ogre@@QAE@XZ ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@ABV01@@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??0Vector3@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 50   : 		Vector3(const Vector3 &rhs)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		{
; 52   : 			x = rhs.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 53   : 			y = rhs.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 54   : 			z = rhs.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 55   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector3@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@MMM@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
??0Vector3@Ogre@@QAE@MMM@Z PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 56   : 		Vector3( float x1, float y1, float z1 ) : x(x1), y(y1), z(z1){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector3@Ogre@@QAE@MMM@Z ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@M@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector3@Ogre@@QAE@M@Z PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 57   : 		Vector3(float v) : x(v), y(v), z(v){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector3@Ogre@@QAE@M@Z ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@PAM@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@PAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector3@Ogre@@QAE@PAM@Z PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 58   : 		Vector3(float* v) : x(v[0]), y(v[1]), z(v[2]){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector3@Ogre@@QAE@PAM@Z ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??4Vector3@Ogre@@QAEABV01@ABV01@@Z		; Ogre::Vector3::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Vector3@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??4Vector3@Ogre@@QAEABV01@ABV01@@Z PROC			; Ogre::Vector3::operator=, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			x = vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 63   : 			y = vec.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 64   : 			z = vec.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 65   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 66   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4Vector3@Ogre@@QAEABV01@ABV01@@Z ENDP			; Ogre::Vector3::operator=
_TEXT	ENDS
PUBLIC	??YVector3@Ogre@@QAEXABV01@@Z			; Ogre::Vector3::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YVector3@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??YVector3@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector3::operator+=, COMDAT
; _this$ = ecx

; 68   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 			x += vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 70   : 			y += vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 71   : 			z += vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 72   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YVector3@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector3::operator+=
_TEXT	ENDS
PUBLIC	??ZVector3@Ogre@@QAEXABV01@@Z			; Ogre::Vector3::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZVector3@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??ZVector3@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector3::operator-=, COMDAT
; _this$ = ecx

; 74   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 			x -= vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 76   : 			y -= vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 77   : 			z -= vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 78   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZVector3@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector3::operator-=
_TEXT	ENDS
PUBLIC	??XVector3@Ogre@@QAEXM@Z			; Ogre::Vector3::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XVector3@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??XVector3@Ogre@@QAEXM@Z PROC				; Ogre::Vector3::operator*=, COMDAT
; _this$ = ecx

; 81   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 			x *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 83   : 			y *= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 84   : 			z *= s;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 85   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XVector3@Ogre@@QAEXM@Z ENDP				; Ogre::Vector3::operator*=
_TEXT	ENDS
PUBLIC	??XVector3@Ogre@@QAEXABV01@@Z			; Ogre::Vector3::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XVector3@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??XVector3@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector3::operator*=, COMDAT
; _this$ = ecx

; 88   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 89   : 			x *= vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 90   : 			y *= vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 91   : 			z *= vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vec$[ebp]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 92   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XVector3@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector3::operator*=
_TEXT	ENDS
PUBLIC	??_0Vector3@Ogre@@QAEXM@Z			; Ogre::Vector3::operator/=
; Function compile flags: /Odtp
;	COMDAT ??_0Vector3@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??_0Vector3@Ogre@@QAEXM@Z PROC				; Ogre::Vector3::operator/=, COMDAT
; _this$ = ecx

; 95   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 			x /= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fdiv	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 97   : 			y /= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fdiv	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 98   : 			z /= s;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fdiv	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 99   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??_0Vector3@Ogre@@QAEXM@Z ENDP				; Ogre::Vector3::operator/=
_TEXT	ENDS
PUBLIC	??BVector3@Ogre@@QAEPAMXZ			; Ogre::Vector3::operator float *
; Function compile flags: /Odtp
;	COMDAT ??BVector3@Ogre@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector3@Ogre@@QAEPAMXZ PROC				; Ogre::Vector3::operator float *, COMDAT
; _this$ = ecx

; 101  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 			return &x;

	mov	eax, DWORD PTR _this$[ebp]

; 103  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??BVector3@Ogre@@QAEPAMXZ ENDP				; Ogre::Vector3::operator float *
_TEXT	ENDS
PUBLIC	??BVector3@Ogre@@QBEPBMXZ			; Ogre::Vector3::operator float const *
; Function compile flags: /Odtp
;	COMDAT ??BVector3@Ogre@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector3@Ogre@@QBEPBMXZ PROC				; Ogre::Vector3::operator float const *, COMDAT
; _this$ = ecx

; 105  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 106  : 			return &x;

	mov	eax, DWORD PTR _this$[ebp]

; 107  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??BVector3@Ogre@@QBEPBMXZ ENDP				; Ogre::Vector3::operator float const *
_TEXT	ENDS
PUBLIC	??HVector3@Ogre@@QBE?AV01@XZ			; Ogre::Vector3::operator+
; Function compile flags: /Odtp
;	COMDAT ??HVector3@Ogre@@QBE?AV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??HVector3@Ogre@@QBE?AV01@XZ PROC			; Ogre::Vector3::operator+, COMDAT
; _this$ = ecx

; 109  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 111  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??HVector3@Ogre@@QBE?AV01@XZ ENDP			; Ogre::Vector3::operator+
_TEXT	ENDS
PUBLIC	??GVector3@Ogre@@QBE?AV01@XZ			; Ogre::Vector3::operator-
; Function compile flags: /Odtp
;	COMDAT ??GVector3@Ogre@@QBE?AV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??GVector3@Ogre@@QBE?AV01@XZ PROC			; Ogre::Vector3::operator-, COMDAT
; _this$ = ecx

; 113  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 			return Vector3(-x, -y, -z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 115  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??GVector3@Ogre@@QBE?AV01@XZ ENDP			; Ogre::Vector3::operator-
_TEXT	ENDS
PUBLIC	??8Vector3@Ogre@@QBE_NABV01@@Z			; Ogre::Vector3::operator==
; Function compile flags: /Odtp
;	COMDAT ??8Vector3@Ogre@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv77 = -8						; size = 4
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??8Vector3@Ogre@@QBE_NABV01@@Z PROC			; Ogre::Vector3::operator==, COMDAT
; _this$ = ecx

; 117  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 			return (x==vec.x && y==vec.y && z==vec.z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv77[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv77[ebp]

; 119  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector3@Ogre@@QBE_NABV01@@Z ENDP			; Ogre::Vector3::operator==
_TEXT	ENDS
PUBLIC	?setElement@Vector3@Ogre@@QAEXMMM@Z		; Ogre::Vector3::setElement
; Function compile flags: /Odtp
;	COMDAT ?setElement@Vector3@Ogre@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
?setElement@Vector3@Ogre@@QAEXMMM@Z PROC		; Ogre::Vector3::setElement, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 			x = x1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]

; 123  : 			y = y1;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]

; 124  : 			z = z1;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]

; 125  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setElement@Vector3@Ogre@@QAEXMMM@Z ENDP		; Ogre::Vector3::setElement
_TEXT	ENDS
PUBLIC	?setElement@Vector3@Ogre@@QAEXPAM@Z		; Ogre::Vector3::setElement
; Function compile flags: /Odtp
;	COMDAT ?setElement@Vector3@Ogre@@QAEXPAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?setElement@Vector3@Ogre@@QAEXPAM@Z PROC		; Ogre::Vector3::setElement, COMDAT
; _this$ = ecx

; 127  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 			x = p[0];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 129  : 			y = p[1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 130  : 			z = p[2];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 131  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setElement@Vector3@Ogre@@QAEXPAM@Z ENDP		; Ogre::Vector3::setElement
_TEXT	ENDS
PUBLIC	?Sqrt@Ogre@@YAMM@Z				; Ogre::Sqrt
PUBLIC	?length@Vector3@Ogre@@QBEMXZ			; Ogre::Vector3::length
; Function compile flags: /Odtp
;	COMDAT ?length@Vector3@Ogre@@QBEMXZ
_TEXT	SEGMENT
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?length@Vector3@Ogre@@QBEMXZ PROC			; Ogre::Vector3::length, COMDAT
; _this$ = ecx

; 133  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 			return (float)Sqrt(x*x+y*y+z*z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv88[ebp]
	fld	DWORD PTR tv88[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?Sqrt@Ogre@@YAMM@Z			; Ogre::Sqrt
	add	esp, 4

; 135  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@Vector3@Ogre@@QBEMXZ ENDP			; Ogre::Vector3::length
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
;	COMDAT ?Sqrt@Ogre@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?Sqrt@Ogre@@YAMM@Z PROC					; Ogre::Sqrt, COMDAT

; 59   : 	{

	push	ebp
	mov	ebp, esp

; 60   : 		return (float)sqrt(x);

	push	ecx
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4

; 61   : 	}

	pop	ebp
	ret	0
?Sqrt@Ogre@@YAMM@Z ENDP					; Ogre::Sqrt
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 534  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	fstp	DWORD PTR [esp]
	call	_sqrtf
	add	esp, 4
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 423  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?lengthSqr@Vector3@Ogre@@QBEMXZ			; Ogre::Vector3::lengthSqr
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
;	COMDAT ?lengthSqr@Vector3@Ogre@@QBEMXZ
_TEXT	SEGMENT
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?lengthSqr@Vector3@Ogre@@QBEMXZ PROC			; Ogre::Vector3::lengthSqr, COMDAT
; _this$ = ecx

; 137  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 			return (x*x+y*y+z*z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv88[ebp]
	fld	DWORD PTR tv88[ebp]

; 139  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?lengthSqr@Vector3@Ogre@@QBEMXZ ENDP			; Ogre::Vector3::lengthSqr
_TEXT	ENDS
PUBLIC	??0WorldPos@Ogre@@QAE@XZ			; Ogre::WorldPos::WorldPos
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreworldpos.h
;	COMDAT ??0WorldPos@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0WorldPos@Ogre@@QAE@XZ PROC				; Ogre::WorldPos::WorldPos, COMDAT
; _this$ = ecx

; 18   : 		WorldPos()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 19   : 		{
; 20   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0WorldPos@Ogre@@QAE@XZ ENDP				; Ogre::WorldPos::WorldPos
_TEXT	ENDS
PUBLIC	??0WorldPos@Ogre@@QAE@HHH@Z			; Ogre::WorldPos::WorldPos
; Function compile flags: /Odtp
;	COMDAT ??0WorldPos@Ogre@@QAE@HHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
??0WorldPos@Ogre@@QAE@HHH@Z PROC			; Ogre::WorldPos::WorldPos, COMDAT
; _this$ = ecx

; 23   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __x$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __z$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 24   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0WorldPos@Ogre@@QAE@HHH@Z ENDP			; Ogre::WorldPos::WorldPos
_TEXT	ENDS
PUBLIC	__real@4024000000000000
PUBLIC	??0WorldPos@Ogre@@QAE@ABVVector3@1@@Z		; Ogre::WorldPos::WorldPos
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0WorldPos@Ogre@@QAE@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??0WorldPos@Ogre@@QAE@ABVVector3@1@@Z PROC		; Ogre::WorldPos::WorldPos, COMDAT
; _this$ = ecx

; 26   : 		WorldPos( const Vector3 &vec )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 27   : 		{
; 28   : 			x = (WPOS_T)(vec.x * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 29   : 			y = (WPOS_T)(vec.y * UNIT);

	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 30   : 			z = (WPOS_T)(vec.z * UNIT);

	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 31   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0WorldPos@Ogre@@QAE@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::WorldPos
_TEXT	ENDS
PUBLIC	??4WorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator=
; Function compile flags: /Odtp
;	COMDAT ??4WorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??4WorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator=, COMDAT
; _this$ = ecx

; 34   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 			x = (WPOS_T)(vec.x * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 36   : 			y = (WPOS_T)(vec.y * UNIT);

	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 37   : 			z = (WPOS_T)(vec.z * UNIT);

	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 38   : 
; 39   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 40   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4WorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator=
_TEXT	ENDS
PUBLIC	??YWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??YWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator+=, COMDAT
; _this$ = ecx

; 43   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 			x += (WPOS_T)(vec.x * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 45   : 			y += (WPOS_T)(vec.y * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 46   : 			z += (WPOS_T)(vec.z * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 47   : 
; 48   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 49   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator+=
_TEXT	ENDS
PUBLIC	??YWorldPos@Ogre@@QAEABV01@ABV01@@Z		; Ogre::WorldPos::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YWorldPos@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
??YWorldPos@Ogre@@QAEABV01@ABV01@@Z PROC		; Ogre::WorldPos::operator+=, COMDAT
; _this$ = ecx

; 52   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 53   : 			x += pos.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx

; 54   : 			y += pos.y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _pos$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 55   : 			z += pos.z;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _pos$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 56   : 
; 57   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 58   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YWorldPos@Ogre@@QAEABV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator+=
_TEXT	ENDS
PUBLIC	??ZWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??ZWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator-=, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			x -= (WPOS_T)(vec.x * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 63   : 			y -= (WPOS_T)(vec.y * UNIT);

	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	sub	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 64   : 			z -= (WPOS_T)(vec.z * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 65   : 
; 66   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 67   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator-=
_TEXT	ENDS
PUBLIC	??ZWorldPos@Ogre@@QAEABV01@ABV01@@Z		; Ogre::WorldPos::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZWorldPos@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
??ZWorldPos@Ogre@@QAEABV01@ABV01@@Z PROC		; Ogre::WorldPos::operator-=, COMDAT
; _this$ = ecx

; 70   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 			x -= pos.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 72   : 			y -= pos.y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 73   : 			z -= pos.z;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 74   : 
; 75   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 76   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZWorldPos@Ogre@@QAEABV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator-=
_TEXT	ENDS
PUBLIC	??HWorldPos@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::WorldPos::operator+
; Function compile flags: /Odtp
;	COMDAT ??HWorldPos@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
??HWorldPos@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::WorldPos::operator+, COMDAT
; _this$ = ecx

; 79   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 			return WorldPos(x+pos.x, y+pos.y, z+pos.z);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _pos$[ebp]
	add	ecx, DWORD PTR [edx+8]
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pos$[ebp]
	add	ecx, DWORD PTR [edx+4]
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??HWorldPos@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator+
_TEXT	ENDS
PUBLIC	??GWorldPos@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::WorldPos::operator-
; Function compile flags: /Odtp
;	COMDAT ??GWorldPos@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
??GWorldPos@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::WorldPos::operator-, COMDAT
; _this$ = ecx

; 84   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 			return WorldPos(x-pos.x, y-pos.y, z-pos.z);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 86   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??GWorldPos@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator-
_TEXT	ENDS
PUBLIC	??HWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator+
; Function compile flags: /Odtp
;	COMDAT ??HWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
??HWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator+, COMDAT
; _this$ = ecx

; 89   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 			return WorldPos(x+(WPOS_T)(pos.x*UNIT), y+(WPOS_T)(pos.y*UNIT), z+(WPOS_T)(pos.z*UNIT));

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	push	eax
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	push	eax
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 91   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??HWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator+
_TEXT	ENDS
PUBLIC	??GWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator-
; Function compile flags: /Odtp
;	COMDAT ??GWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
??GWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator-, COMDAT
; _this$ = ecx

; 94   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 			return WorldPos(x-(WPOS_T)(pos.x*UNIT), y-(WPOS_T)(pos.y*UNIT), z-(WPOS_T)(pos.z*UNIT));

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, eax
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 96   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??GWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator-
_TEXT	ENDS
PUBLIC	??DWorldPos@Ogre@@QBE?AV01@H@Z			; Ogre::WorldPos::operator*
; Function compile flags: /Odtp
;	COMDAT ??DWorldPos@Ogre@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
??DWorldPos@Ogre@@QBE?AV01@H@Z PROC			; Ogre::WorldPos::operator*, COMDAT
; _this$ = ecx

; 99   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 			return WorldPos((WPOS_T)(x*s), (WPOS_T)(y*s), (WPOS_T)(z*s));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	imul	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	imul	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 101  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??DWorldPos@Ogre@@QBE?AV01@H@Z ENDP			; Ogre::WorldPos::operator*
_TEXT	ENDS
PUBLIC	??DWorldPos@Ogre@@QBE?AV01@M@Z			; Ogre::WorldPos::operator*
; Function compile flags: /Odtp
;	COMDAT ??DWorldPos@Ogre@@QBE?AV01@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
??DWorldPos@Ogre@@QBE?AV01@M@Z PROC			; Ogre::WorldPos::operator*, COMDAT
; _this$ = ecx

; 104  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 			return WorldPos((WPOS_T)(x*s), (WPOS_T)(y*s), (WPOS_T)(z*s));

	mov	eax, DWORD PTR _this$[ebp]
	fild	DWORD PTR [eax+8]
	fmul	DWORD PTR _s$[ebp]
	call	__ftol2_sse
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [ecx+4]
	fmul	DWORD PTR _s$[ebp]
	call	__ftol2_sse
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [edx]
	fmul	DWORD PTR _s$[ebp]
	call	__ftol2_sse
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 106  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??DWorldPos@Ogre@@QBE?AV01@M@Z ENDP			; Ogre::WorldPos::operator*
_TEXT	ENDS
PUBLIC	??KWorldPos@Ogre@@QBE?AV01@H@Z			; Ogre::WorldPos::operator/
; Function compile flags: /Odtp
;	COMDAT ??KWorldPos@Ogre@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
??KWorldPos@Ogre@@QBE?AV01@H@Z PROC			; Ogre::WorldPos::operator/, COMDAT
; _this$ = ecx

; 109  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 			return WorldPos((WPOS_T)(x/s), (WPOS_T)(y/s), (WPOS_T)(z/s));

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	cdq
	idiv	DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cdq
	idiv	DWORD PTR _s$[ebp]
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	idiv	DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 111  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??KWorldPos@Ogre@@QBE?AV01@H@Z ENDP			; Ogre::WorldPos::operator/
_TEXT	ENDS
PUBLIC	??8WorldPos@Ogre@@QBE_NABV01@@Z			; Ogre::WorldPos::operator==
; Function compile flags: /Odtp
;	COMDAT ??8WorldPos@Ogre@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??8WorldPos@Ogre@@QBE_NABV01@@Z PROC			; Ogre::WorldPos::operator==, COMDAT
; _this$ = ecx

; 114  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 			return x==rhs.x && y==rhs.y && z==rhs.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN3@operator@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator@2
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@operator@2
$LN3@operator@2:
	mov	DWORD PTR tv71[ebp], 0
$LN4@operator@2:
	mov	al, BYTE PTR tv71[ebp]

; 116  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8WorldPos@Ogre@@QBE_NABV01@@Z ENDP			; Ogre::WorldPos::operator==
_TEXT	ENDS
PUBLIC	??9WorldPos@Ogre@@QBE_NABV01@@Z			; Ogre::WorldPos::operator!=
; Function compile flags: /Odtp
;	COMDAT ??9WorldPos@Ogre@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??9WorldPos@Ogre@@QBE_NABV01@@Z PROC			; Ogre::WorldPos::operator!=, COMDAT
; _this$ = ecx

; 119  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 			return x!=rhs.x || y!=rhs.y || z!=rhs.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator@3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN3@operator@3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator@3
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN4@operator@3
$LN3@operator@3:
	mov	DWORD PTR tv71[ebp], 1
$LN4@operator@3:
	mov	al, BYTE PTR tv71[ebp]

; 121  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9WorldPos@Ogre@@QBE_NABV01@@Z ENDP			; Ogre::WorldPos::operator!=
_TEXT	ENDS
PUBLIC	?inverse@WorldPos@Ogre@@QAEXXZ			; Ogre::WorldPos::inverse
; Function compile flags: /Odtp
;	COMDAT ?inverse@WorldPos@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?inverse@WorldPos@Ogre@@QAEXXZ PROC			; Ogre::WorldPos::inverse, COMDAT
; _this$ = ecx

; 124  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 			x = -x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	neg	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 126  : 			y = -y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	neg	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 127  : 			z = -z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	neg	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 128  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?inverse@WorldPos@Ogre@@QAEXXZ ENDP			; Ogre::WorldPos::inverse
_TEXT	ENDS
PUBLIC	?normalize@WorldPos@Ogre@@QBE?AVVector3@2@XZ	; Ogre::WorldPos::normalize
; Function compile flags: /Odtp
;	COMDAT ?normalize@WorldPos@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
tv133 = -48						; size = 4
tv131 = -44						; size = 4
tv129 = -40						; size = 4
_this$ = -36						; size = 4
_fy$ = -32						; size = 8
_fz$ = -24						; size = 8
_len$ = -16						; size = 8
_fx$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?normalize@WorldPos@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::WorldPos::normalize, COMDAT
; _this$ = ecx

; 131  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 			double fx = double(x);

	mov	eax, DWORD PTR _this$[ebp]
	fild	DWORD PTR [eax]
	fstp	QWORD PTR _fx$[ebp]

; 133  : 			double fy = double(y);

	mov	ecx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [ecx+4]
	fstp	QWORD PTR _fy$[ebp]

; 134  : 			double fz = double(z);

	mov	edx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [edx+8]
	fstp	QWORD PTR _fz$[ebp]

; 135  : 			double len = sqrt( fx*fx + fy*fy + fz*fz );

	fld	QWORD PTR _fx$[ebp]
	fmul	QWORD PTR _fx$[ebp]
	fld	QWORD PTR _fy$[ebp]
	fmul	QWORD PTR _fy$[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _fz$[ebp]
	fmul	QWORD PTR _fz$[ebp]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR _len$[ebp]

; 136  : 
; 137  : 			return Vector3( float(fx/len), float(fy/len), float(fz/len) );

	fld	QWORD PTR _fz$[ebp]
	fdiv	QWORD PTR _len$[ebp]
	fstp	DWORD PTR tv129[ebp]
	fld	DWORD PTR tv129[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	QWORD PTR _fy$[ebp]
	fdiv	QWORD PTR _len$[ebp]
	fstp	DWORD PTR tv131[ebp]
	fld	DWORD PTR tv131[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	QWORD PTR _fx$[ebp]
	fdiv	QWORD PTR _len$[ebp]
	fstp	DWORD PTR tv133[ebp]
	fld	DWORD PTR tv133[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 138  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?normalize@WorldPos@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::WorldPos::normalize
_TEXT	ENDS
PUBLIC	?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z ; Ogre::WorldPos::subtract
PUBLIC	?toVector3@WorldPos@Ogre@@QBE?AVVector3@2@XZ	; Ogre::WorldPos::toVector3
EXTRN	?m_Origin@WorldPos@Ogre@@2V12@A:BYTE		; Ogre::WorldPos::m_Origin
; Function compile flags: /Odtp
;	COMDAT ?toVector3@WorldPos@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?toVector3@WorldPos@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::WorldPos::toVector3, COMDAT
; _this$ = ecx

; 141  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 			return subtract(m_Origin);

	push	OFFSET ?m_Origin@WorldPos@Ogre@@2V12@A	; Ogre::WorldPos::m_Origin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z ; Ogre::WorldPos::subtract
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 143  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?toVector3@WorldPos@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::WorldPos::toVector3
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z
_TEXT	SEGMENT
tv130 = -28						; size = 4
tv129 = -24						; size = 4
tv93 = -20						; size = 4
tv92 = -16						; size = 4
tv88 = -12						; size = 4
tv87 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z PROC	; Ogre::WorldPos::subtract, COMDAT
; _this$ = ecx

; 146  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 			return Vector3( float(double(x-pos.x)/UNIT), float(double(y-pos.y)/UNIT), float(double(z-pos.z)/UNIT) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv87[ebp], edx
	fild	DWORD PTR tv87[ebp]
	fdiv	QWORD PTR __real@4024000000000000
	fstp	DWORD PTR tv88[ebp]
	fld	DWORD PTR tv88[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv92[ebp], edx
	fild	DWORD PTR tv92[ebp]
	fdiv	QWORD PTR __real@4024000000000000
	fstp	DWORD PTR tv93[ebp]
	fld	DWORD PTR tv93[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv129[ebp], edx
	fild	DWORD PTR tv129[ebp]
	fdiv	QWORD PTR __real@4024000000000000
	fstp	DWORD PTR tv130[ebp]
	fld	DWORD PTR tv130[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 148  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z ENDP	; Ogre::WorldPos::subtract
_TEXT	ENDS
PUBLIC	?Flt2Fix@WorldPos@Ogre@@SAHM@Z			; Ogre::WorldPos::Flt2Fix
; Function compile flags: /Odtp
;	COMDAT ?Flt2Fix@WorldPos@Ogre@@SAHM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?Flt2Fix@WorldPos@Ogre@@SAHM@Z PROC			; Ogre::WorldPos::Flt2Fix, COMDAT

; 151  : 		{

	push	ebp
	mov	ebp, esp

; 152  : 			return (WPOS_T)(x*UNIT);

	fld	DWORD PTR _x$[ebp]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse

; 153  : 		}

	pop	ebp
	ret	0
?Flt2Fix@WorldPos@Ogre@@SAHM@Z ENDP			; Ogre::WorldPos::Flt2Fix
_TEXT	ENDS
PUBLIC	?Fix2Flt@WorldPos@Ogre@@SAMH@Z			; Ogre::WorldPos::Fix2Flt
; Function compile flags: /Odtp
;	COMDAT ?Fix2Flt@WorldPos@Ogre@@SAMH@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
_x$ = 8							; size = 4
?Fix2Flt@WorldPos@Ogre@@SAMH@Z PROC			; Ogre::WorldPos::Fix2Flt, COMDAT

; 156  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx

; 157  : 			return float(double(x)/UNIT);

	fild	DWORD PTR _x$[ebp]
	fdiv	QWORD PTR __real@4024000000000000
	fstp	DWORD PTR tv67[ebp]
	fld	DWORD PTR tv67[ebp]

; 158  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?Fix2Flt@WorldPos@Ogre@@SAMH@Z ENDP			; Ogre::WorldPos::Fix2Flt
_TEXT	ENDS
PUBLIC	??4WorldPos@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::WorldPos::operator=
; Function compile flags: /Odtp
;	COMDAT ??4WorldPos@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4WorldPos@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::WorldPos::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4WorldPos@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator=
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	__real@00000000
PUBLIC	??0Quaternion@Ogre@@QAE@XZ			; Ogre::Quaternion::Quaternion
;	COMDAT __real@3f800000
; File i:\svnroot\client\ogremain\ogrequaternion.h
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0Quaternion@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Quaternion@Ogre@@QAE@XZ PROC				; Ogre::Quaternion::Quaternion, COMDAT
; _this$ = ecx

; 54   : 		Quaternion():x(0), y(0), z(0), w(1.0f){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Quaternion@Ogre@@QAE@XZ ENDP				; Ogre::Quaternion::Quaternion
_TEXT	ENDS
PUBLIC	??0Quaternion@Ogre@@QAE@MMMM@Z			; Ogre::Quaternion::Quaternion
; Function compile flags: /Odtp
;	COMDAT ??0Quaternion@Ogre@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
_w1$ = 20						; size = 4
??0Quaternion@Ogre@@QAE@MMMM@Z PROC			; Ogre::Quaternion::Quaternion, COMDAT
; _this$ = ecx

; 55   : 		Quaternion( float x1, float y1, float z1, float w1 ) : x(x1), y(y1), z(z1), w(w1){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _w1$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0Quaternion@Ogre@@QAE@MMMM@Z ENDP			; Ogre::Quaternion::Quaternion
_TEXT	ENDS
PUBLIC	??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Quaternion::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_quat$ = 8						; size = 4
??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::Quaternion::operator=, COMDAT
; _this$ = ecx

; 59   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 			x = quat.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 61   : 			y = quat.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 62   : 			z = quat.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 63   : 			w = quat.w;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+12]

; 64   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 65   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::Quaternion::operator=
_TEXT	ENDS
PUBLIC	??XQuaternion@Ogre@@QAEXM@Z			; Ogre::Quaternion::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XQuaternion@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??XQuaternion@Ogre@@QAEXM@Z PROC			; Ogre::Quaternion::operator*=, COMDAT
; _this$ = ecx

; 67   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 			x *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 69   : 			y *= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 70   : 			z *= s;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 71   : 			w *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 72   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XQuaternion@Ogre@@QAEXM@Z ENDP			; Ogre::Quaternion::operator*=
_TEXT	ENDS
PUBLIC	?norm@Quaternion@Ogre@@QAEMXZ			; Ogre::Quaternion::norm
; Function compile flags: /Odtp
;	COMDAT ?norm@Quaternion@Ogre@@QAEMXZ
_TEXT	SEGMENT
tv94 = -8						; size = 4
_this$ = -4						; size = 4
?norm@Quaternion@Ogre@@QAEMXZ PROC			; Ogre::Quaternion::norm, COMDAT
; _this$ = ecx

; 74   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 			return x*x+y*y+z*z+w*w;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv94[ebp]
	fld	DWORD PTR tv94[ebp]

; 76   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?norm@Quaternion@Ogre@@QAEMXZ ENDP			; Ogre::Quaternion::norm
_TEXT	ENDS
PUBLIC	?identity@Quaternion@Ogre@@QAEXXZ		; Ogre::Quaternion::identity
; Function compile flags: /Odtp
;	COMDAT ?identity@Quaternion@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?identity@Quaternion@Ogre@@QAEXXZ PROC			; Ogre::Quaternion::identity, COMDAT
; _this$ = ecx

; 78   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 			x = y = z = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx]

; 80   : 			w = 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax+12]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?identity@Quaternion@Ogre@@QAEXXZ ENDP			; Ogre::Quaternion::identity
_TEXT	ENDS
PUBLIC	?inverse@Quaternion@Ogre@@QAEXXZ		; Ogre::Quaternion::inverse
; Function compile flags: /Odtp
;	COMDAT ?inverse@Quaternion@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?inverse@Quaternion@Ogre@@QAEXXZ PROC			; Ogre::Quaternion::inverse, COMDAT
; _this$ = ecx

; 83   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 			x = -x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 85   : 			y = -y;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fchs
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 86   : 			z = -z;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fchs
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 87   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?inverse@Quaternion@Ogre@@QAEXXZ ENDP			; Ogre::Quaternion::inverse
_TEXT	ENDS
PUBLIC	?inverse@Quaternion@Ogre@@QBEXAAV12@@Z		; Ogre::Quaternion::inverse
; Function compile flags: /Odtp
;	COMDAT ?inverse@Quaternion@Ogre@@QBEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_quat$ = 8						; size = 4
?inverse@Quaternion@Ogre@@QBEXAAV12@@Z PROC		; Ogre::Quaternion::inverse, COMDAT
; _this$ = ecx

; 89   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 			quat.x = -x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [ecx]

; 91   : 			quat.y = -y;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fchs
	mov	eax, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [eax+4]

; 92   : 			quat.z = -z;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fchs
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx+8]

; 93   : 			quat.w = w;

	mov	eax, DWORD PTR _quat$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+12]

; 94   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?inverse@Quaternion@Ogre@@QBEXAAV12@@Z ENDP		; Ogre::Quaternion::inverse
_TEXT	ENDS
PUBLIC	?setElement@Quaternion@Ogre@@QAEXMMMM@Z		; Ogre::Quaternion::setElement
; Function compile flags: /Odtp
;	COMDAT ?setElement@Quaternion@Ogre@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
_w1$ = 20						; size = 4
?setElement@Quaternion@Ogre@@QAEXMMMM@Z PROC		; Ogre::Quaternion::setElement, COMDAT
; _this$ = ecx

; 96   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 97   : 			x = x1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]

; 98   : 			y = y1;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]

; 99   : 			z = z1;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]

; 100  : 			w = w1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _w1$[ebp]
	fstp	DWORD PTR [eax+12]

; 101  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?setElement@Quaternion@Ogre@@QAEXMMMM@Z ENDP		; Ogre::Quaternion::setElement
_TEXT	ENDS
PUBLIC	??9Quaternion@Ogre@@QBE_NABV01@@Z		; Ogre::Quaternion::operator!=
EXTRN	??8Quaternion@Ogre@@QBE_NABV01@@Z:PROC		; Ogre::Quaternion::operator==
; Function compile flags: /Odtp
;	COMDAT ??9Quaternion@Ogre@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_quat$ = 8						; size = 4
??9Quaternion@Ogre@@QBE_NABV01@@Z PROC			; Ogre::Quaternion::operator!=, COMDAT
; _this$ = ecx

; 105  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 106  : 			return !operator==(quat);

	mov	eax, DWORD PTR _quat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Quaternion@Ogre@@QBE_NABV01@@Z	; Ogre::Quaternion::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 107  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9Quaternion@Ogre@@QBE_NABV01@@Z ENDP			; Ogre::Quaternion::operator!=
_TEXT	ENDS
PUBLIC	?getRow3@Matrix3@Ogre@@QBE?AVVector3@2@I@Z	; Ogre::Matrix3::getRow3
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrematrix3.h
;	COMDAT ?getRow3@Matrix3@Ogre@@QBE?AVVector3@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
?getRow3@Matrix3@Ogre@@QBE?AVVector3@2@I@Z PROC		; Ogre::Matrix3::getRow3, COMDAT
; _this$ = ecx

; 67   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 			return Vector3(m[i][0], m[i][1], m[i][2]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax+8]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+edx+4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+ecx]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 69   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getRow3@Matrix3@Ogre@@QBE?AVVector3@2@I@Z ENDP		; Ogre::Matrix3::getRow3
_TEXT	ENDS
PUBLIC	?identity@Matrix3@Ogre@@QAEXXZ			; Ogre::Matrix3::identity
; Function compile flags: /Odtp
;	COMDAT ?identity@Matrix3@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?identity@Matrix3@Ogre@@QAEXXZ PROC			; Ogre::Matrix3::identity, COMDAT
; _this$ = ecx

; 71   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 			_11=1.0f, _12=0.0f, _13=0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+8]

; 73   : 			_21=0.0f, _22=1.0f, _23=0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+20]

; 74   : 			_31=0.0f, _32=0.0f, _33=1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [edx+32]

; 75   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?identity@Matrix3@Ogre@@QAEXXZ ENDP			; Ogre::Matrix3::identity
_TEXT	ENDS
PUBLIC	?setRow@Matrix3@Ogre@@QAEXIMMM@Z		; Ogre::Matrix3::setRow
; Function compile flags: /Odtp
;	COMDAT ?setRow@Matrix3@Ogre@@QAEXIMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
?setRow@Matrix3@Ogre@@QAEXIMMM@Z PROC			; Ogre::Matrix3::setRow, COMDAT
; _this$ = ecx

; 77   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 			m[i][0] = x;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [ecx+eax]

; 79   : 			m[i][1] = y;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [eax+edx+4]

; 80   : 			m[i][2] = z;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z$[ebp]
	fstp	DWORD PTR [edx+ecx+8]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?setRow@Matrix3@Ogre@@QAEXIMMM@Z ENDP			; Ogre::Matrix3::setRow
_TEXT	ENDS
PUBLIC	?getColumn@Matrix3@Ogre@@QBE?AVVector3@2@I@Z	; Ogre::Matrix3::getColumn
; Function compile flags: /Odtp
;	COMDAT ?getColumn@Matrix3@Ogre@@QBE?AVVector3@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
?getColumn@Matrix3@Ogre@@QBE?AVVector3@2@I@Z PROC	; Ogre::Matrix3::getColumn, COMDAT
; _this$ = ecx

; 84   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 			return Vector3(m[0][i], m[1][i], m[2][i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax*4+24]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+edx*4+12]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+ecx*4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 86   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getColumn@Matrix3@Ogre@@QBE?AVVector3@2@I@Z ENDP	; Ogre::Matrix3::getColumn
_TEXT	ENDS
PUBLIC	?makeScaleMatrix@Matrix3@Ogre@@QAEXM@Z		; Ogre::Matrix3::makeScaleMatrix
EXTRN	?makeScaleMatrix@Matrix3@Ogre@@QAEXABVVector3@2@@Z:PROC ; Ogre::Matrix3::makeScaleMatrix
; Function compile flags: /Odtp
;	COMDAT ?makeScaleMatrix@Matrix3@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T89983 = -12						; size = 12
_s$ = 8							; size = 4
?makeScaleMatrix@Matrix3@Ogre@@QAEXM@Z PROC		; Ogre::Matrix3::makeScaleMatrix, COMDAT
; _this$ = ecx

; 93   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 94   : 			makeScaleMatrix(Vector3(s, s, s));

	push	ecx
	fld	DWORD PTR _s$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _s$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _s$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T89983[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?makeScaleMatrix@Matrix3@Ogre@@QAEXABVVector3@2@@Z ; Ogre::Matrix3::makeScaleMatrix

; 95   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?makeScaleMatrix@Matrix3@Ogre@@QAEXM@Z ENDP		; Ogre::Matrix3::makeScaleMatrix
_TEXT	ENDS
PUBLIC	??4Matrix3@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Matrix3::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Matrix3@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Matrix3@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Matrix3::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, 9
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4Matrix3@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Matrix3::operator=
_TEXT	ENDS
PUBLIC	??AMatrix4@Ogre@@QBEPBMI@Z			; Ogre::Matrix4::operator[]
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrematrix4.h
;	COMDAT ??AMatrix4@Ogre@@QBEPBMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_irow$ = 8						; size = 4
??AMatrix4@Ogre@@QBEPBMI@Z PROC				; Ogre::Matrix4::operator[], COMDAT
; _this$ = ecx

; 88   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 89   : 			return &m[irow][0];

	mov	eax, DWORD PTR _irow$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _this$[ebp]

; 90   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??AMatrix4@Ogre@@QBEPBMI@Z ENDP				; Ogre::Matrix4::operator[]
_TEXT	ENDS
PUBLIC	??AMatrix4@Ogre@@QAEPAMI@Z			; Ogre::Matrix4::operator[]
; Function compile flags: /Odtp
;	COMDAT ??AMatrix4@Ogre@@QAEPAMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_irow$ = 8						; size = 4
??AMatrix4@Ogre@@QAEPAMI@Z PROC				; Ogre::Matrix4::operator[], COMDAT
; _this$ = ecx

; 92   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 			return &m[irow][0];

	mov	eax, DWORD PTR _irow$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _this$[ebp]

; 94   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??AMatrix4@Ogre@@QAEPAMI@Z ENDP				; Ogre::Matrix4::operator[]
_TEXT	ENDS
PUBLIC	?makeScaleMatrix@Matrix4@Ogre@@QAEXM@Z		; Ogre::Matrix4::makeScaleMatrix
EXTRN	?makeScaleMatrix@Matrix4@Ogre@@QAEXABVVector3@2@@Z:PROC ; Ogre::Matrix4::makeScaleMatrix
; Function compile flags: /Odtp
;	COMDAT ?makeScaleMatrix@Matrix4@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T89992 = -12						; size = 12
_s$ = 8							; size = 4
?makeScaleMatrix@Matrix4@Ogre@@QAEXM@Z PROC		; Ogre::Matrix4::makeScaleMatrix, COMDAT
; _this$ = ecx

; 101  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 			makeScaleMatrix(Vector3(s, s, s));

	push	ecx
	fld	DWORD PTR _s$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _s$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _s$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T89992[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?makeScaleMatrix@Matrix4@Ogre@@QAEXABVVector3@2@@Z ; Ogre::Matrix4::makeScaleMatrix

; 103  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?makeScaleMatrix@Matrix4@Ogre@@QAEXM@Z ENDP		; Ogre::Matrix4::makeScaleMatrix
_TEXT	ENDS
PUBLIC	?setRow@Matrix4@Ogre@@QAEXIMMMM@Z		; Ogre::Matrix4::setRow
; Function compile flags: /Odtp
;	COMDAT ?setRow@Matrix4@Ogre@@QAEXIMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
_w$ = 24						; size = 4
?setRow@Matrix4@Ogre@@QAEXIMMMM@Z PROC			; Ogre::Matrix4::setRow, COMDAT
; _this$ = ecx

; 133  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 			m[i][0] = x;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [ecx+eax]

; 135  : 			m[i][1] = y;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [eax+edx+4]

; 136  : 			m[i][2] = z;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z$[ebp]
	fstp	DWORD PTR [edx+ecx+8]

; 137  : 			m[i][3] = w;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [ecx+eax+12]

; 138  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?setRow@Matrix4@Ogre@@QAEXIMMMM@Z ENDP			; Ogre::Matrix4::setRow
_TEXT	ENDS
PUBLIC	?setColumn@Matrix4@Ogre@@QAEXIMMMM@Z		; Ogre::Matrix4::setColumn
; Function compile flags: /Odtp
;	COMDAT ?setColumn@Matrix4@Ogre@@QAEXIMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
_w$ = 24						; size = 4
?setColumn@Matrix4@Ogre@@QAEXIMMMM@Z PROC		; Ogre::Matrix4::setColumn, COMDAT
; _this$ = ecx

; 140  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 			m[0][i] = x;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [ecx+eax*4]

; 142  : 			m[1][i] = y;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [eax+edx*4+16]

; 143  : 			m[2][i] = z;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z$[ebp]
	fstp	DWORD PTR [edx+ecx*4+32]

; 144  : 			m[3][i] = w;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [ecx+eax*4+48]

; 145  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?setColumn@Matrix4@Ogre@@QAEXIMMMM@Z ENDP		; Ogre::Matrix4::setColumn
_TEXT	ENDS
PUBLIC	?getRow3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z	; Ogre::Matrix4::getRow3
; Function compile flags: /Odtp
;	COMDAT ?getRow3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
?getRow3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z PROC		; Ogre::Matrix4::getRow3, COMDAT
; _this$ = ecx

; 147  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 			return Vector3(m[i][0], m[i][1], m[i][2]);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax+8]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+edx+4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+ecx]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 149  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getRow3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z ENDP		; Ogre::Matrix4::getRow3
_TEXT	ENDS
PUBLIC	?getColumn3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z	; Ogre::Matrix4::getColumn3
; Function compile flags: /Odtp
;	COMDAT ?getColumn3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
?getColumn3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z PROC	; Ogre::Matrix4::getColumn3, COMDAT
; _this$ = ecx

; 151  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 			return Vector3(m[0][i], m[1][i], m[2][i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax*4+32]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+edx*4+16]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+ecx*4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 153  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getColumn3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z ENDP	; Ogre::Matrix4::getColumn3
_TEXT	ENDS
PUBLIC	??0Vector4@Ogre@@QAE@MMMM@Z			; Ogre::Vector4::Vector4
PUBLIC	?getRow4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z	; Ogre::Matrix4::getRow4
; Function compile flags: /Odtp
;	COMDAT ?getRow4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
?getRow4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z PROC		; Ogre::Matrix4::getRow4, COMDAT
; _this$ = ecx

; 155  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 			return Vector4(m[i][0], m[i][1], m[i][2], m[i][3]);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax+12]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+edx+8]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+ecx+4]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector4@Ogre@@QAE@MMMM@Z		; Ogre::Vector4::Vector4
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 157  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getRow4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z ENDP		; Ogre::Matrix4::getRow4
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector4.h
_TEXT	ENDS
;	COMDAT ??0Vector4@Ogre@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
_w1$ = 20						; size = 4
??0Vector4@Ogre@@QAE@MMMM@Z PROC			; Ogre::Vector4::Vector4, COMDAT
; _this$ = ecx

; 44   : 		Vector4( float x1, float y1, float z1, float w1 ) : x(x1), y(y1), z(z1), w(w1){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _w1$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0Vector4@Ogre@@QAE@MMMM@Z ENDP			; Ogre::Vector4::Vector4
_TEXT	ENDS
PUBLIC	?getColumn4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z	; Ogre::Matrix4::getColumn4
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrematrix4.h
;	COMDAT ?getColumn4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
?getColumn4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z PROC	; Ogre::Matrix4::getColumn4, COMDAT
; _this$ = ecx

; 159  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 			return Vector4(m[0][i], m[1][i], m[2][i], m[3][i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax*4+48]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+edx*4+32]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+ecx*4+16]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax*4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector4@Ogre@@QAE@MMMM@Z		; Ogre::Vector4::Vector4
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getColumn4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z ENDP	; Ogre::Matrix4::getColumn4
_TEXT	ENDS
PUBLIC	?setTranslate@Matrix4@Ogre@@QAEXMMM@Z		; Ogre::Matrix4::setTranslate
; Function compile flags: /Odtp
;	COMDAT ?setTranslate@Matrix4@Ogre@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?setTranslate@Matrix4@Ogre@@QAEXMMM@Z PROC		; Ogre::Matrix4::setTranslate, COMDAT
; _this$ = ecx

; 163  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 			setRow( 3, x, y, z, 1.0f );

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _z$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [esp]
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRow@Matrix4@Ogre@@QAEXIMMMM@Z	; Ogre::Matrix4::setRow

; 165  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setTranslate@Matrix4@Ogre@@QAEXMMM@Z ENDP		; Ogre::Matrix4::setTranslate
_TEXT	ENDS
PUBLIC	?setTranslate@Matrix4@Ogre@@QAEXABVVector3@2@@Z	; Ogre::Matrix4::setTranslate
; Function compile flags: /Odtp
;	COMDAT ?setTranslate@Matrix4@Ogre@@QAEXABVVector3@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
?setTranslate@Matrix4@Ogre@@QAEXABVVector3@2@@Z PROC	; Ogre::Matrix4::setTranslate, COMDAT
; _this$ = ecx

; 167  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 168  : 			setTranslate( pos.x, pos.y, pos.z );

	mov	eax, DWORD PTR _pos$[ebp]
	push	ecx
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _pos$[ebp]
	push	ecx
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setTranslate@Matrix4@Ogre@@QAEXMMM@Z	; Ogre::Matrix4::setTranslate

; 169  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setTranslate@Matrix4@Ogre@@QAEXABVVector3@2@@Z ENDP	; Ogre::Matrix4::setTranslate
_TEXT	ENDS
PUBLIC	?getTranslate@Matrix4@Ogre@@QBE?AVVector3@2@XZ	; Ogre::Matrix4::getTranslate
; Function compile flags: /Odtp
;	COMDAT ?getTranslate@Matrix4@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getTranslate@Matrix4@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::Matrix4::getTranslate, COMDAT
; _this$ = ecx

; 171  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 			return getRow3(3);

	push	3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRow3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z ; Ogre::Matrix4::getRow3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 173  : 		};

	mov	esp, ebp
	pop	ebp
	ret	4
?getTranslate@Matrix4@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::Matrix4::getTranslate
_TEXT	ENDS
PUBLIC	?transformCoord@Matrix4@Ogre@@QBE?AVVector3@2@ABV32@@Z ; Ogre::Matrix4::transformCoord
; Function compile flags: /Odtp
;	COMDAT ?transformCoord@Matrix4@Ogre@@QBE?AVVector3@2@ABV32@@Z
_TEXT	SEGMENT
tv182 = -16						; size = 4
tv174 = -12						; size = 4
tv166 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_vec$ = 12						; size = 4
?transformCoord@Matrix4@Ogre@@QBE?AVVector3@2@ABV32@@Z PROC ; Ogre::Matrix4::transformCoord, COMDAT
; _this$ = ecx

; 233  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 		return Vector3( vec.x*_11 + vec.y*_21 + vec.z*_31 + _41,
; 235  : 			vec.x*_12 + vec.y*_22 + vec.z*_32 + _42,
; 236  : 			vec.x*_13 + vec.y*_23 + vec.z*_33 + _43 );

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+24]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+40]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+56]
	fstp	DWORD PTR tv166[ebp]
	fld	DWORD PTR tv166[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+20]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+36]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+52]
	fstp	DWORD PTR tv174[ebp]
	fld	DWORD PTR tv174[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+32]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+48]
	fstp	DWORD PTR tv182[ebp]
	fld	DWORD PTR tv182[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 237  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?transformCoord@Matrix4@Ogre@@QBE?AVVector3@2@ABV32@@Z ENDP ; Ogre::Matrix4::transformCoord
_TEXT	ENDS
PUBLIC	??0BoxBound@Ogre@@QAE@XZ			; Ogre::BoxBound::BoxBound
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebounding.h
;	COMDAT ??0BoxBound@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BoxBound@Ogre@@QAE@XZ PROC				; Ogre::BoxBound::BoxBound, COMDAT
; _this$ = ecx

; 14   : 		BoxBound() : m_isValid(false){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BoxBound@Ogre@@QAE@XZ ENDP				; Ogre::BoxBound::BoxBound
_TEXT	ENDS
PUBLIC	??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z		; Ogre::BoxBound::BoxBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_minpos$ = 8						; size = 4
_maxpos$ = 12						; size = 4
??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z PROC		; Ogre::BoxBound::BoxBound, COMDAT
; _this$ = ecx

; 15   : 		BoxBound(const Vector3 &minpos, const Vector3 &maxpos) : m_MinPos(minpos), m_MaxPos(maxpos), m_isValid(true){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _minpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _maxpos$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+24], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z ENDP		; Ogre::BoxBound::BoxBound
_TEXT	ENDS
PUBLIC	??0BoxBound@Ogre@@QAE@ABV01@@Z			; Ogre::BoxBound::BoxBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxBound@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??0BoxBound@Ogre@@QAE@ABV01@@Z PROC			; Ogre::BoxBound::BoxBound, COMDAT
; _this$ = ecx

; 16   : 		BoxBound(const BoxBound &rhs) : m_MinPos(rhs.m_MinPos), m_MaxPos(rhs.m_MaxPos), m_isValid(rhs.m_isValid){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _rhs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _rhs$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rhs$[ebp]
	mov	cl, BYTE PTR [eax+24]
	mov	BYTE PTR [edx+24], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BoxBound@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::BoxBound::BoxBound
_TEXT	ENDS
PUBLIC	??$Max@M@Ogre@@YAMABM0@Z			; Ogre::Max<float>
PUBLIC	??$Min@M@Ogre@@YAMABM0@Z			; Ogre::Min<float>
PUBLIC	??YBoxBound@Ogre@@QAEAAV01@ABVVector3@1@@Z	; Ogre::BoxBound::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YBoxBound@Ogre@@QAEAAV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Other$ = 8						; size = 4
??YBoxBound@Ogre@@QAEAAV01@ABVVector3@1@@Z PROC		; Ogre::BoxBound::operator+=, COMDAT
; _this$ = ecx

; 19   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 			if( m_isValid )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	test	ecx, ecx
	je	$LN2@operator@4

; 21   : 			{
; 22   : #if ASM_x86
; 23   : 				__asm
; 24   : 				{
; 25   : 						mov		eax,[Other]
; 26   : 						mov		ecx,[this]
; 27   : 
; 28   : 						movss	xmm3,[eax]Vector3.x
; 29   : 						movss	xmm4,[eax]Vector3.y
; 30   : 						movss	xmm5,[eax]Vector3.z
; 31   : 
; 32   : 						movss	xmm0,[ecx]BoxBound.m_MinPos.x
; 33   : 						movss	xmm1,[ecx]BoxBound.m_MinPos.y
; 34   : 						movss	xmm2,[ecx]BoxBound.m_MinPos.z
; 35   : 						minss	xmm0,xmm3
; 36   : 						minss	xmm1,xmm4
; 37   : 						minss	xmm2,xmm5
; 38   : 						movss	[ecx]BoxBound.m_MinPos.x,xmm0
; 39   : 						movss	[ecx]BoxBound.m_MinPos.y,xmm1
; 40   : 						movss	[ecx]BoxBound.m_MinPos.z,xmm2
; 41   : 
; 42   : 						movss	xmm0,[ecx]BoxBound.m_MaxPos.x
; 43   : 						movss	xmm1,[ecx]BoxBound.m_MaxPos.y
; 44   : 						movss	xmm2,[ecx]BoxBound.m_MaxPos.z
; 45   : 						maxss	xmm0,xmm3
; 46   : 						maxss	xmm1,xmm4
; 47   : 						maxss	xmm2,xmm5
; 48   : 						movss	[ecx]BoxBound.m_MaxPos.x,xmm0
; 49   : 						movss	[ecx]BoxBound.m_MaxPos.y,xmm1
; 50   : 						movss	[ecx]BoxBound.m_MaxPos.z,xmm2
; 51   : 				}
; 52   : #else
; 53   : 				m_MinPos.x = Min( m_MinPos.x, Other.x );

	mov	edx, DWORD PTR _Other$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 54   : 				m_MinPos.y = Min( m_MinPos.y, Other.y );

	mov	edx, DWORD PTR _Other$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+4]

; 55   : 				m_MinPos.z = Min( m_MinPos.z, Other.z );

	mov	edx, DWORD PTR _Other$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+8]

; 56   : 
; 57   : 				m_MaxPos.x = Max( m_MaxPos.x, Other.x );

	mov	edx, DWORD PTR _Other$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 58   : 				m_MaxPos.y = Max( m_MaxPos.y, Other.y );

	mov	edx, DWORD PTR _Other$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+16]

; 59   : 				m_MaxPos.z = Max( m_MaxPos.z, Other.z );

	mov	edx, DWORD PTR _Other$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+20]

; 60   : #endif
; 61   : 			}
; 62   : 			else

	jmp	SHORT $LN1@operator@4
$LN2@operator@4:

; 63   : 			{
; 64   : 				m_MinPos = m_MaxPos = Other;

	mov	edx, DWORD PTR _Other$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 65   : 				m_isValid = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 1
$LN1@operator@4:

; 66   : 			}
; 67   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 68   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YBoxBound@Ogre@@QAEAAV01@ABVVector3@1@@Z ENDP		; Ogre::BoxBound::operator+=
_TEXT	ENDS
PUBLIC	??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::BoxBound::operator=
PUBLIC	??YBoxBound@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::BoxBound::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YBoxBound@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Other$ = 8						; size = 4
??YBoxBound@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BoxBound::operator+=, COMDAT
; _this$ = ecx

; 71   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 			if( m_isValid && Other.m_isValid )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	test	ecx, ecx
	je	$LN3@operator@5
	mov	edx, DWORD PTR _Other$[ebp]
	movzx	eax, BYTE PTR [edx+24]
	test	eax, eax
	je	$LN3@operator@5

; 73   : 			{
; 74   : #if ASM_X86
; 75   : 				__asm
; 76   : 				{
; 77   : 						mov		eax,[Other]
; 78   : 						mov		ecx,[this]
; 79   : 
; 80   : 						movss	xmm0,[ecx]BoxBound.m_MinPos.x
; 81   : 						movss	xmm1,[ecx]BoxBound.m_MinPos.y
; 82   : 						movss	xmm2,[ecx]BoxBound.m_MinPos.z
; 83   : 						minss	xmm0,[eax]BoxBound.m_MinPos.x
; 84   : 						minss	xmm1,[eax]BoxBound.m_MinPos.y
; 85   : 						minss	xmm2,[eax]BoxBound.m_MinPos.z
; 86   : 						movss	[ecx]BoxBound.m_MinPos.x,xmm0
; 87   : 						movss	[ecx]BoxBound.m_MinPos.y,xmm1
; 88   : 						movss	[ecx]BoxBound.m_MinPos.z,xmm2
; 89   : 
; 90   : 						movss	xmm0,[ecx]BoxBound.m_MaxPos.x
; 91   : 						movss	xmm1,[ecx]BoxBound.m_MaxPos.y
; 92   : 						movss	xmm2,[ecx]BoxBound.m_MaxPos.z
; 93   : 						maxss	xmm0,[eax]BoxBound.m_MaxPos.x
; 94   : 						maxss	xmm1,[eax]BoxBound.m_MaxPos.y
; 95   : 						maxss	xmm2,[eax]BoxBound.m_MaxPos.z
; 96   : 						movss	[ecx]BoxBound.m_MaxPos.x,xmm0
; 97   : 						movss	[ecx]BoxBound.m_MaxPos.y,xmm1
; 98   : 						movss	[ecx]BoxBound.m_MaxPos.z,xmm2
; 99   : 				}
; 100  : #else
; 101  : 				m_MinPos.x = Min( m_MinPos.x, Other.m_MinPos.x );

	mov	ecx, DWORD PTR _Other$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax]

; 102  : 				m_MinPos.y = Min( m_MinPos.y, Other.m_MinPos.y );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 103  : 				m_MinPos.z = Min( m_MinPos.z, Other.m_MinPos.z );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+8]

; 104  : 
; 105  : 				m_MaxPos.x = Max( m_MaxPos.x, Other.m_MaxPos.x );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+12]

; 106  : 				m_MaxPos.y = Max( m_MaxPos.y, Other.m_MaxPos.y );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+16]

; 107  : 				m_MaxPos.z = Max( m_MaxPos.z, Other.m_MaxPos.z );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+20]
	jmp	SHORT $LN1@operator@5
$LN3@operator@5:

; 108  : #endif
; 109  : 			}
; 110  : 			else if( Other.m_isValid )

	mov	ecx, DWORD PTR _Other$[ebp]
	movzx	edx, BYTE PTR [ecx+24]
	test	edx, edx
	je	SHORT $LN1@operator@5

; 111  : 			{
; 112  : 				*this = Other;

	mov	eax, DWORD PTR _Other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z
$LN1@operator@5:

; 113  : 			}
; 114  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 115  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YBoxBound@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BoxBound::operator+=
_TEXT	ENDS
PUBLIC	?setRange@BoxBound@Ogre@@QAEXABVVector3@2@0@Z	; Ogre::BoxBound::setRange
; Function compile flags: /Odtp
;	COMDAT ?setRange@BoxBound@Ogre@@QAEXABVVector3@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_minpt$ = 8						; size = 4
_maxpt$ = 12						; size = 4
?setRange@BoxBound@Ogre@@QAEXABVVector3@2@0@Z PROC	; Ogre::BoxBound::setRange, COMDAT
; _this$ = ecx

; 118  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 119  : 			m_MinPos = minpt;

	mov	eax, DWORD PTR _minpt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 120  : 			m_MaxPos = maxpt;

	mov	ecx, DWORD PTR _maxpt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 121  : 			m_isValid = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+24], 1

; 122  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setRange@BoxBound@Ogre@@QAEXABVVector3@2@0@Z ENDP	; Ogre::BoxBound::setRange
_TEXT	ENDS
PUBLIC	??HOgre@@YA?AVVector3@0@ABV10@0@Z		; Ogre::operator+
PUBLIC	??GOgre@@YA?AVVector3@0@ABV10@0@Z		; Ogre::operator-
PUBLIC	?setCenterExtension@BoxBound@Ogre@@QAEXABVVector3@2@0@Z ; Ogre::BoxBound::setCenterExtension
; Function compile flags: /Odtp
;	COMDAT ?setCenterExtension@BoxBound@Ogre@@QAEXABVVector3@2@0@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T90030 = -24						; size = 12
$T90029 = -12						; size = 12
_center$ = 8						; size = 4
_exten$ = 12						; size = 4
?setCenterExtension@BoxBound@Ogre@@QAEXABVVector3@2@0@Z PROC ; Ogre::BoxBound::setCenterExtension, COMDAT
; _this$ = ecx

; 125  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 126  : 			m_MinPos = center-exten;

	mov	eax, DWORD PTR _exten$[ebp]
	push	eax
	mov	ecx, DWORD PTR _center$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T90029[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 127  : 			m_MaxPos = center+exten;

	mov	eax, DWORD PTR _exten$[ebp]
	push	eax
	mov	ecx, DWORD PTR _center$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T90030[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 128  : 			m_isValid = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 1

; 129  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setCenterExtension@BoxBound@Ogre@@QAEXABVVector3@2@0@Z ENDP ; Ogre::BoxBound::setCenterExtension
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
_TEXT	ENDS
;	COMDAT ??HOgre@@YA?AVVector3@0@ABV10@0@Z
_TEXT	SEGMENT
tv92 = -12						; size = 4
tv89 = -8						; size = 4
tv86 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
??HOgre@@YA?AVVector3@0@ABV10@0@Z PROC			; Ogre::operator+, COMDAT

; 164  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 165  : 		return Vector3(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [edx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 166  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??HOgre@@YA?AVVector3@0@ABV10@0@Z ENDP			; Ogre::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??GOgre@@YA?AVVector3@0@ABV10@0@Z
_TEXT	SEGMENT
tv92 = -12						; size = 4
tv89 = -8						; size = 4
tv86 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
??GOgre@@YA?AVVector3@0@ABV10@0@Z PROC			; Ogre::operator-, COMDAT

; 174  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 175  : 		return Vector3(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _v2$[ebp]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _v2$[ebp]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _v2$[ebp]
	fsub	DWORD PTR [edx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 176  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??GOgre@@YA?AVVector3@0@ABV10@0@Z ENDP			; Ogre::operator-
_TEXT	ENDS
PUBLIC	?expandBy@BoxBound@Ogre@@QBE?AV12@M@Z		; Ogre::BoxBound::expandBy
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebounding.h
;	COMDAT ?expandBy@BoxBound@Ogre@@QBE?AV12@M@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T90040 = -48						; size = 12
$T90039 = -36						; size = 12
$T90038 = -24						; size = 12
$T90037 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_w$ = 12						; size = 4
?expandBy@BoxBound@Ogre@@QBE?AV12@M@Z PROC		; Ogre::BoxBound::expandBy, COMDAT
; _this$ = ecx

; 134  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 135  : 			return BoxBound( m_MinPos - Vector3(w,w,w), m_MaxPos + Vector3(w,w,w) );

	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T90037[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T90038[ebp]
	push	ecx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T90039[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR $T90040[ebp]
	push	eax
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z	; Ogre::BoxBound::BoxBound
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 136  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?expandBy@BoxBound@Ogre@@QBE?AV12@M@Z ENDP		; Ogre::BoxBound::expandBy
_TEXT	ENDS
PUBLIC	??DOgre@@YA?AVVector3@0@ABV10@M@Z		; Ogre::operator*
PUBLIC	__real@3f000000
PUBLIC	?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ	; Ogre::BoxBound::getCenter
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T90043 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::BoxBound::getCenter, COMDAT
; _this$ = ecx

; 144  : 		Vector3 getCenter() const{ return (m_MinPos + m_MaxPos)*0.5f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fld	DWORD PTR __real@3f000000
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T90043[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??DOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::BoxBound::getCenter
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
_TEXT	ENDS
;	COMDAT ??DOgre@@YA?AVVector3@0@ABV10@M@Z
_TEXT	SEGMENT
tv87 = -12						; size = 4
tv85 = -8						; size = 4
tv83 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_s$ = 16						; size = 4
??DOgre@@YA?AVVector3@0@ABV10@M@Z PROC			; Ogre::operator*, COMDAT

; 189  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 190  : 		return Vector3(v1.x*s, v1.y*s, v1.z*s);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv83[ebp]
	fld	DWORD PTR tv83[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv85[ebp]
	fld	DWORD PTR tv85[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv87[ebp]
	fld	DWORD PTR tv87[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 191  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??DOgre@@YA?AVVector3@0@ABV10@M@Z ENDP			; Ogre::operator*
_TEXT	ENDS
PUBLIC	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ	; Ogre::BoxBound::getExtension
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebounding.h
;	COMDAT ?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T90050 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::BoxBound::getExtension, COMDAT
; _this$ = ecx

; 145  : 		Vector3 getExtension() const{ return (m_MaxPos - m_MinPos)*0.5f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fld	DWORD PTR __real@3f000000
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	lea	edx, DWORD PTR $T90050[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??DOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::BoxBound::getExtension
_TEXT	ENDS
PUBLIC	?getMinPos@BoxBound@Ogre@@QBEABVVector3@2@XZ	; Ogre::BoxBound::getMinPos
; Function compile flags: /Odtp
;	COMDAT ?getMinPos@BoxBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMinPos@BoxBound@Ogre@@QBEABVVector3@2@XZ PROC	; Ogre::BoxBound::getMinPos, COMDAT
; _this$ = ecx

; 146  : 		const Vector3 &getMinPos() const{ return m_MinPos; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?getMinPos@BoxBound@Ogre@@QBEABVVector3@2@XZ ENDP	; Ogre::BoxBound::getMinPos
_TEXT	ENDS
PUBLIC	?getMaxPos@BoxBound@Ogre@@QBEABVVector3@2@XZ	; Ogre::BoxBound::getMaxPos
; Function compile flags: /Odtp
;	COMDAT ?getMaxPos@BoxBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMaxPos@BoxBound@Ogre@@QBEABVVector3@2@XZ PROC	; Ogre::BoxBound::getMaxPos, COMDAT
; _this$ = ecx

; 147  : 		const Vector3 &getMaxPos() const{ return m_MaxPos; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	0
?getMaxPos@BoxBound@Ogre@@QBEABVVector3@2@XZ ENDP	; Ogre::BoxBound::getMaxPos
_TEXT	ENDS
PUBLIC	??$Abs@M@Ogre@@YAMABM@Z				; Ogre::Abs<float>
PUBLIC	?getRadiusInDirection@BoxBound@Ogre@@QBEMABVVector3@2@@Z ; Ogre::BoxBound::getRadiusInDirection
; Function compile flags: /Odtp
;	COMDAT ?getRadiusInDirection@BoxBound@Ogre@@QBEMABVVector3@2@@Z
_TEXT	SEGMENT
tv143 = -48						; size = 4
tv148 = -44						; size = 8
tv146 = -36						; size = 8
_this$ = -28						; size = 4
$T90059 = -24						; size = 4
$T90058 = -20						; size = 4
$T90057 = -16						; size = 4
_extent$ = -12						; size = 12
_dir$ = 8						; size = 4
?getRadiusInDirection@BoxBound@Ogre@@QBEMABVVector3@2@@Z PROC ; Ogre::BoxBound::getRadiusInDirection, COMDAT
; _this$ = ecx

; 150  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 151  : 			Vector3 extent = getExtension();

	lea	eax, DWORD PTR _extent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getExtension

; 152  : 			return Abs(dir.x*extent.x) + Abs(dir.y*extent.y) + Abs(dir.z*extent.z);

	mov	ecx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR _extent$[ebp]
	fstp	DWORD PTR $T90057[ebp]
	mov	edx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _extent$[ebp+4]
	fstp	DWORD PTR $T90058[ebp]
	mov	eax, DWORD PTR _dir$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR _extent$[ebp+8]
	fstp	DWORD PTR $T90059[ebp]
	lea	ecx, DWORD PTR $T90057[ebp]
	push	ecx
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	add	esp, 4
	lea	edx, DWORD PTR $T90058[ebp]
	push	edx
	fstp	QWORD PTR tv146[ebp]
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	add	esp, 4
	fadd	QWORD PTR tv146[ebp]
	lea	eax, DWORD PTR $T90059[ebp]
	push	eax
	fstp	QWORD PTR tv148[ebp]
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	add	esp, 4
	fadd	QWORD PTR tv148[ebp]
	fstp	DWORD PTR tv143[ebp]
	fld	DWORD PTR tv143[ebp]

; 153  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getRadiusInDirection@BoxBound@Ogre@@QBEMABVVector3@2@@Z ENDP ; Ogre::BoxBound::getRadiusInDirection
_TEXT	ENDS
PUBLIC	?isPointIn@BoxBound@Ogre@@QBE_NABVVector3@2@@Z	; Ogre::BoxBound::isPointIn
; Function compile flags: /Odtp
;	COMDAT ?isPointIn@BoxBound@Ogre@@QBE_NABVVector3@2@@Z
_TEXT	SEGMENT
tv94 = -8						; size = 4
_this$ = -4						; size = 4
_vPos$ = 8						; size = 4
?isPointIn@BoxBound@Ogre@@QBE_NABVVector3@2@@Z PROC	; Ogre::BoxBound::isPointIn, COMDAT
; _this$ = ecx

; 156  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 			return (vPos.x>m_MinPos.x && vPos.x<m_MaxPos.x 
; 158  : 				    &&vPos.y>m_MinPos.y && vPos.y<m_MaxPos.y
; 159  : 					&&vPos.z>m_MinPos.z && vPos.z<m_MaxPos.z );

	mov	eax, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointIn
	mov	edx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointIn
	mov	ecx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointIn
	mov	eax, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+16]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointIn
	mov	edx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointIn
	mov	ecx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointIn
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN4@isPointIn
$LN3@isPointIn:
	mov	DWORD PTR tv94[ebp], 0
$LN4@isPointIn:
	mov	al, BYTE PTR tv94[ebp]

; 160  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isPointIn@BoxBound@Ogre@@QBE_NABVVector3@2@@Z ENDP	; Ogre::BoxBound::isPointIn
_TEXT	ENDS
PUBLIC	?isPointInXZ@BoxBound@Ogre@@QBE_NABVVector3@2@@Z ; Ogre::BoxBound::isPointInXZ
; Function compile flags: /Odtp
;	COMDAT ?isPointInXZ@BoxBound@Ogre@@QBE_NABVVector3@2@@Z
_TEXT	SEGMENT
tv83 = -8						; size = 4
_this$ = -4						; size = 4
_vPos$ = 8						; size = 4
?isPointInXZ@BoxBound@Ogre@@QBE_NABVVector3@2@@Z PROC	; Ogre::BoxBound::isPointInXZ, COMDAT
; _this$ = ecx

; 163  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 			return (vPos.x>m_MinPos.x && vPos.x<m_MaxPos.x 
; 165  : 				&&vPos.z>m_MinPos.z && vPos.z<m_MaxPos.z );

	mov	eax, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointInX
	mov	edx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointInX
	mov	ecx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointInX
	mov	eax, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointInX
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN4@isPointInX
$LN3@isPointInX:
	mov	DWORD PTR tv83[ebp], 0
$LN4@isPointInX:
	mov	al, BYTE PTR tv83[ebp]

; 166  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isPointInXZ@BoxBound@Ogre@@QBE_NABVVector3@2@@Z ENDP	; Ogre::BoxBound::isPointInXZ
_TEXT	ENDS
PUBLIC	?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z	; Ogre::BoxBound::intersectBoxBound
; Function compile flags: /Odtp
;	COMDAT ?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z PROC	; Ogre::BoxBound::intersectBoxBound, COMDAT
; _this$ = ecx

; 169  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 			if( m_MinPos.x > other.m_MaxPos.x || other.m_MinPos.x > m_MaxPos.x )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _other$[ebp]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN5@intersectB
	mov	edx, DWORD PTR _other$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@intersectB
$LN5@intersectB:

; 171  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@intersectB
$LN6@intersectB:

; 172  : 			if( m_MinPos.y > other.m_MaxPos.y || other.m_MinPos.y > m_MaxPos.y )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _other$[ebp]
	fld	DWORD PTR [edx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN3@intersectB
	mov	eax, DWORD PTR _other$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@intersectB
$LN3@intersectB:

; 173  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@intersectB
$LN4@intersectB:

; 174  : 			if( m_MinPos.z > other.m_MaxPos.z || other.m_MinPos.z > m_MaxPos.z )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _other$[ebp]
	fld	DWORD PTR [eax+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@intersectB
	mov	ecx, DWORD PTR _other$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@intersectB
$LN1@intersectB:

; 175  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@intersectB
$LN2@intersectB:

; 176  : 			return true;

	mov	al, 1
$LN7@intersectB:

; 177  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z ENDP	; Ogre::BoxBound::intersectBoxBound
_TEXT	ENDS
PUBLIC	?isBoxBoundIn@BoxBound@Ogre@@QAE_NABV12@@Z	; Ogre::BoxBound::isBoxBoundIn
; Function compile flags: /Odtp
;	COMDAT ?isBoxBoundIn@BoxBound@Ogre@@QAE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_box$ = 8						; size = 4
?isBoxBoundIn@BoxBound@Ogre@@QAE_NABV12@@Z PROC		; Ogre::BoxBound::isBoxBoundIn, COMDAT
; _this$ = ecx

; 181  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 182  : 			if( box.m_MaxPos.x > m_MaxPos.x ||
; 183  : 				box.m_MinPos.x < m_MinPos.x )

	mov	eax, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN5@isBoxBound
	mov	edx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN6@isBoxBound
$LN5@isBoxBound:

; 184  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@isBoxBound
$LN6@isBoxBound:

; 185  : 			if( box.m_MaxPos.y > m_MaxPos.y ||
; 186  : 				box.m_MinPos.y < m_MinPos.y )

	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN3@isBoxBound
	mov	eax, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@isBoxBound
$LN3@isBoxBound:

; 187  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@isBoxBound
$LN4@isBoxBound:

; 188  : 			if( box.m_MaxPos.z > m_MaxPos.z ||
; 189  : 				box.m_MinPos.z < m_MinPos.z )

	mov	edx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@isBoxBound
	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@isBoxBound
$LN1@isBoxBound:

; 190  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@isBoxBound
$LN2@isBoxBound:

; 191  : 
; 192  : 			return true;

	mov	al, 1
$LN7@isBoxBound:

; 193  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isBoxBoundIn@BoxBound@Ogre@@QAE_NABV12@@Z ENDP		; Ogre::BoxBound::isBoxBoundIn
_TEXT	ENDS
PUBLIC	?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z		; Ogre::Abs
PUBLIC	?isBoxBoundOut@BoxBound@Ogre@@QBE_NABV12@@Z	; Ogre::BoxBound::isBoxBoundOut
; Function compile flags: /Odtp
;	COMDAT ?isBoxBoundOut@BoxBound@Ogre@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T90078 = -84						; size = 12
$T90077 = -72						; size = 12
$T90076 = -60						; size = 12
$T90075 = -48						; size = 12
$T90074 = -36						; size = 12
_vRadius$ = -24						; size = 12
_vDis$ = -12						; size = 12
_box$ = 8						; size = 4
?isBoxBoundOut@BoxBound@Ogre@@QBE_NABV12@@Z PROC	; Ogre::BoxBound::isBoxBoundOut, COMDAT
; _this$ = ecx

; 197  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 			Vector3 vDis = Abs(box.getCenter() - getCenter());

	lea	eax, DWORD PTR $T90074[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getCenter
	push	eax
	lea	ecx, DWORD PTR $T90075[ebp]
	push	ecx
	mov	ecx, DWORD PTR _box$[ebp]
	call	?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getCenter
	push	eax
	lea	edx, DWORD PTR $T90076[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR _vDis$[ebp]
	push	eax
	call	?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z	; Ogre::Abs
	add	esp, 8

; 199  : 			Vector3 vRadius = box.getExtension() + getExtension();

	lea	ecx, DWORD PTR $T90077[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getExtension
	push	eax
	lea	edx, DWORD PTR $T90078[ebp]
	push	edx
	mov	ecx, DWORD PTR _box$[ebp]
	call	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getExtension
	push	eax
	lea	eax, DWORD PTR _vRadius$[ebp]
	push	eax
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH

; 200  : 
; 201  : 			if( vDis.x > vRadius.x || vDis.y > vRadius.y || vDis.z > vRadius.z )

	fld	DWORD PTR _vDis$[ebp]
	fld	DWORD PTR _vRadius$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@isBoxBound@2
	fld	DWORD PTR _vDis$[ebp+4]
	fld	DWORD PTR _vRadius$[ebp+4]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@isBoxBound@2
	fld	DWORD PTR _vDis$[ebp+8]
	fld	DWORD PTR _vRadius$[ebp+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@isBoxBound@2
$LN1@isBoxBound@2:

; 202  : 				return true;

	mov	al, 1
	jmp	SHORT $LN3@isBoxBound@2
$LN2@isBoxBound@2:

; 203  : 
; 204  : 			return false;

	xor	al, al
$LN3@isBoxBound@2:

; 205  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isBoxBoundOut@BoxBound@Ogre@@QBE_NABV12@@Z ENDP	; Ogre::BoxBound::isBoxBoundOut
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
_TEXT	ENDS
;	COMDAT ?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z PROC			; Ogre::Abs, COMDAT

; 204  : 	{

	push	ebp
	mov	ebp, esp

; 205  : 		return Vector3( Abs(v.x), Abs(v.y), Abs(v.z) );

	mov	eax, DWORD PTR _v$[ebp]
	add	eax, 8
	push	eax
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 4
	push	ecx
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v$[ebp]
	push	edx
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 206  : 	}

	pop	ebp
	ret	0
?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z ENDP			; Ogre::Abs
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BoxBound::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+24]
	mov	BYTE PTR [edx+24], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BoxBound::operator=
_TEXT	ENDS
PUBLIC	??0SphereBound@Ogre@@QAE@XZ			; Ogre::SphereBound::SphereBound
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebounding.h
;	COMDAT ??0SphereBound@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SphereBound@Ogre@@QAE@XZ PROC			; Ogre::SphereBound::SphereBound, COMDAT
; _this$ = ecx

; 221  : 		SphereBound(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0SphereBound@Ogre@@QAE@XZ ENDP			; Ogre::SphereBound::SphereBound
_TEXT	ENDS
PUBLIC	?getCenter@SphereBound@Ogre@@QBEABVVector3@2@XZ	; Ogre::SphereBound::getCenter
; Function compile flags: /Odtp
;	COMDAT ?getCenter@SphereBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCenter@SphereBound@Ogre@@QBEABVVector3@2@XZ PROC	; Ogre::SphereBound::getCenter, COMDAT
; _this$ = ecx

; 229  : 		const Vector3 &getCenter() const{ return m_Center; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?getCenter@SphereBound@Ogre@@QBEABVVector3@2@XZ ENDP	; Ogre::SphereBound::getCenter
_TEXT	ENDS
PUBLIC	?getRadius@SphereBound@Ogre@@QBEMXZ		; Ogre::SphereBound::getRadius
; Function compile flags: /Odtp
;	COMDAT ?getRadius@SphereBound@Ogre@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRadius@SphereBound@Ogre@@QBEMXZ PROC		; Ogre::SphereBound::getRadius, COMDAT
; _this$ = ecx

; 230  : 		float   getRadius() const{ return m_Radius; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?getRadius@SphereBound@Ogre@@QBEMXZ ENDP		; Ogre::SphereBound::getRadius
_TEXT	ENDS
PUBLIC	?isPointIn@SphereBound@Ogre@@QBE_NABVVector3@2@@Z ; Ogre::SphereBound::isPointIn
; Function compile flags: /Odtp
;	COMDAT ?isPointIn@SphereBound@Ogre@@QBE_NABVVector3@2@@Z
_TEXT	SEGMENT
tv79 = -24						; size = 4
tv89 = -20						; size = 4
_this$ = -16						; size = 4
$T90091 = -12						; size = 12
_vPos$ = 8						; size = 4
?isPointIn@SphereBound@Ogre@@QBE_NABVVector3@2@@Z PROC	; Ogre::SphereBound::isPointIn, COMDAT
; _this$ = ecx

; 233  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 			return ( (vPos - m_Center).lengthSqr() < m_Radius * m_Radius );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vPos$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T90091[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	?lengthSqr@Vector3@Ogre@@QBEMXZ		; Ogre::Vector3::lengthSqr
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+12]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointIn@2
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN4@isPointIn@2
$LN3@isPointIn@2:
	mov	DWORD PTR tv79[ebp], 0
$LN4@isPointIn@2:
	mov	al, BYTE PTR tv79[ebp]

; 235  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isPointIn@SphereBound@Ogre@@QBE_NABVVector3@2@@Z ENDP	; Ogre::SphereBound::isPointIn
_TEXT	ENDS
PUBLIC	??0SphereBound@Ogre@@QAE@ABV01@@Z		; Ogre::SphereBound::SphereBound
; Function compile flags: /Odtp
;	COMDAT ??0SphereBound@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0SphereBound@Ogre@@QAE@ABV01@@Z PROC			; Ogre::SphereBound::SphereBound, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0SphereBound@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::SphereBound::SphereBound
_TEXT	ENDS
PUBLIC	??4SphereBound@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::SphereBound::operator=
; Function compile flags: /Odtp
;	COMDAT ??4SphereBound@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4SphereBound@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::SphereBound::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4SphereBound@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::SphereBound::operator=
_TEXT	ENDS
PUBLIC	??0BoxSphereBound@Ogre@@QAE@XZ			; Ogre::BoxSphereBound::BoxSphereBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxSphereBound@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BoxSphereBound@Ogre@@QAE@XZ PROC			; Ogre::BoxSphereBound::BoxSphereBound, COMDAT
; _this$ = ecx

; 252  : 		BoxSphereBound()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3

; 253  : 		{
; 254  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BoxSphereBound@Ogre@@QAE@XZ ENDP			; Ogre::BoxSphereBound::BoxSphereBound
_TEXT	ENDS
PUBLIC	?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z ; Ogre::BoxSphereBound::fromBoxBound
PUBLIC	??0BoxSphereBound@Ogre@@QAE@ABVBoxBound@1@@Z	; Ogre::BoxSphereBound::BoxSphereBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxSphereBound@Ogre@@QAE@ABVBoxBound@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_box$ = 8						; size = 4
??0BoxSphereBound@Ogre@@QAE@ABVBoxBound@1@@Z PROC	; Ogre::BoxSphereBound::BoxSphereBound, COMDAT
; _this$ = ecx

; 256  : 		BoxSphereBound(const BoxBound &box)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3

; 257  : 		{
; 258  : 			fromBoxBound(box);

	mov	eax, DWORD PTR _box$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z ; Ogre::BoxSphereBound::fromBoxBound

; 259  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BoxSphereBound@Ogre@@QAE@ABVBoxBound@1@@Z ENDP	; Ogre::BoxSphereBound::BoxSphereBound
_TEXT	ENDS
PUBLIC	?reset@BoxSphereBound@Ogre@@QAEXXZ		; Ogre::BoxSphereBound::reset
; Function compile flags: /Odtp
;	COMDAT ?reset@BoxSphereBound@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T90104 = -12						; size = 12
?reset@BoxSphereBound@Ogre@@QAEXXZ PROC			; Ogre::BoxSphereBound::reset, COMDAT
; _this$ = ecx

; 262  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 263  : 			m_Center = m_Extent = Vector3(0,0,0);

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T90104[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 264  : 			m_Radius = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+24]

; 265  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?reset@BoxSphereBound@Ogre@@QAEXXZ ENDP			; Ogre::BoxSphereBound::reset
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T90108 = -24						; size = 12
$T90107 = -12						; size = 12
_box$ = 8						; size = 4
?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z PROC ; Ogre::BoxSphereBound::fromBoxBound, COMDAT
; _this$ = ecx

; 268  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 269  : 			m_Center = box.getCenter();

	lea	eax, DWORD PTR $T90107[ebp]
	push	eax
	mov	ecx, DWORD PTR _box$[ebp]
	call	?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getCenter
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 270  : 			m_Extent = box.getExtension();

	lea	ecx, DWORD PTR $T90108[ebp]
	push	ecx
	mov	ecx, DWORD PTR _box$[ebp]
	call	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getExtension
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 271  : 
; 272  : 			m_Radius = m_Extent.length();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?length@Vector3@Ogre@@QBEMXZ		; Ogre::Vector3::length
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+24]

; 273  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z ENDP ; Ogre::BoxSphereBound::fromBoxBound
_TEXT	ENDS
PUBLIC	?getSphere@BoxSphereBound@Ogre@@QBE?AVSphereBound@2@XZ ; Ogre::BoxSphereBound::getSphere
; Function compile flags: /Odtp
;	COMDAT ?getSphere@BoxSphereBound@Ogre@@QBE?AVSphereBound@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_sphere$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?getSphere@BoxSphereBound@Ogre@@QBE?AVSphereBound@2@XZ PROC ; Ogre::BoxSphereBound::getSphere, COMDAT
; _this$ = ecx

; 276  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 			SphereBound sphere;

	lea	ecx, DWORD PTR _sphere$[ebp]
	call	??0SphereBound@Ogre@@QAE@XZ		; Ogre::SphereBound::SphereBound

; 278  : 			sphere.m_Center = m_Center;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sphere$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 279  : 			sphere.m_Radius = m_Radius;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+24]
	fstp	DWORD PTR _sphere$[ebp+12]

; 280  : 			return sphere;

	lea	edx, DWORD PTR _sphere$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0SphereBound@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 281  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getSphere@BoxSphereBound@Ogre@@QBE?AVSphereBound@2@XZ ENDP ; Ogre::BoxSphereBound::getSphere
_TEXT	ENDS
PUBLIC	?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ ; Ogre::BoxSphereBound::getBox
; Function compile flags: /Odtp
;	COMDAT ?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T90114 = -52						; size = 12
$T90113 = -40						; size = 12
_box$ = -28						; size = 28
___$ReturnUdt$ = 8					; size = 4
?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ PROC	; Ogre::BoxSphereBound::getBox, COMDAT
; _this$ = ecx

; 284  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 285  : 			BoxBound box;

	lea	ecx, DWORD PTR _box$[ebp]
	call	??0BoxBound@Ogre@@QAE@XZ		; Ogre::BoxBound::BoxBound

; 286  : 			box.m_MinPos = m_Center - m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T90113[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _box$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 287  : 			box.m_MaxPos = m_Center + m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T90114[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _box$[ebp+12]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 288  : 			box.m_isValid = true;

	mov	BYTE PTR _box$[ebp+24], 1

; 289  : 			return box;

	lea	eax, DWORD PTR _box$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxBound@Ogre@@QAE@ABV01@@Z		; Ogre::BoxBound::BoxBound
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 290  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ ENDP	; Ogre::BoxSphereBound::getBox
_TEXT	ENDS
PUBLIC	?getMin@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ	; Ogre::BoxSphereBound::getMin
; Function compile flags: /Odtp
;	COMDAT ?getMin@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getMin@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::BoxSphereBound::getMin, COMDAT
; _this$ = ecx

; 310  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 311  : 			return m_Center-m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 312  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getMin@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::BoxSphereBound::getMin
_TEXT	ENDS
PUBLIC	?getMax@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ	; Ogre::BoxSphereBound::getMax
; Function compile flags: /Odtp
;	COMDAT ?getMax@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getMax@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::BoxSphereBound::getMax, COMDAT
; _this$ = ecx

; 315  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 			return m_Center+m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 317  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getMax@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::BoxSphereBound::getMax
_TEXT	ENDS
PUBLIC	?getCenter@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ ; Ogre::BoxSphereBound::getCenter
; Function compile flags: /Odtp
;	COMDAT ?getCenter@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCenter@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ PROC	; Ogre::BoxSphereBound::getCenter, COMDAT
; _this$ = ecx

; 320  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 			return m_Center;

	mov	eax, DWORD PTR _this$[ebp]

; 322  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getCenter@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ ENDP	; Ogre::BoxSphereBound::getCenter
_TEXT	ENDS
PUBLIC	?getExtension@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ ; Ogre::BoxSphereBound::getExtension
; Function compile flags: /Odtp
;	COMDAT ?getExtension@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getExtension@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ PROC ; Ogre::BoxSphereBound::getExtension, COMDAT
; _this$ = ecx

; 325  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 326  : 			return m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH

; 327  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getExtension@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ ENDP ; Ogre::BoxSphereBound::getExtension
_TEXT	ENDS
PUBLIC	??KOgre@@YA?AVVector3@0@ABV10@M@Z		; Ogre::operator/
PUBLIC	__real@40000000
PUBLIC	?fromBox@BoxSphereBound@Ogre@@QAEXABVVector3@2@0@Z ; Ogre::BoxSphereBound::fromBox
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?fromBox@BoxSphereBound@Ogre@@QAEXABVVector3@2@0@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T90128 = -48						; size = 12
$T90127 = -36						; size = 12
$T90126 = -24						; size = 12
$T90125 = -12						; size = 12
_minpt$ = 8						; size = 4
_maxpt$ = 12						; size = 4
?fromBox@BoxSphereBound@Ogre@@QAEXABVVector3@2@0@Z PROC	; Ogre::BoxSphereBound::fromBox, COMDAT
; _this$ = ecx

; 330  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 			m_Center = (minpt + maxpt)/2.0f;

	push	ecx
	fld	DWORD PTR __real@40000000
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _maxpt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _minpt$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T90125[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T90126[ebp]
	push	eax
	call	??KOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator/
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 332  : 			m_Extent = (maxpt - minpt)/2.0f;

	push	ecx
	fld	DWORD PTR __real@40000000
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _minpt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxpt$[ebp]
	push	edx
	lea	eax, DWORD PTR $T90127[ebp]
	push	eax
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T90128[ebp]
	push	ecx
	call	??KOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator/
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 333  : 			m_Radius = m_Extent.length();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?length@Vector3@Ogre@@QBEMXZ		; Ogre::Vector3::length
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+24]

; 334  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?fromBox@BoxSphereBound@Ogre@@QAEXABVVector3@2@0@Z ENDP	; Ogre::BoxSphereBound::fromBox
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
_TEXT	ENDS
;	COMDAT ??KOgre@@YA?AVVector3@0@ABV10@M@Z
_TEXT	SEGMENT
tv87 = -12						; size = 4
tv85 = -8						; size = 4
tv83 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_s$ = 16						; size = 4
??KOgre@@YA?AVVector3@0@ABV10@M@Z PROC			; Ogre::operator/, COMDAT

; 199  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 200  : 		return Vector3(v1.x/s, v1.y/s, v1.z/s);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	fdiv	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv83[ebp]
	fld	DWORD PTR tv83[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx+4]
	fdiv	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv85[ebp]
	fld	DWORD PTR tv85[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx]
	fdiv	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv87[ebp]
	fld	DWORD PTR tv87[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 201  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??KOgre@@YA?AVVector3@0@ABV10@M@Z ENDP			; Ogre::operator/
_TEXT	ENDS
PUBLIC	?intersect@BoxSphereBound@Ogre@@QBE_NABV12@@Z	; Ogre::BoxSphereBound::intersect
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebounding.h
;	COMDAT ?intersect@BoxSphereBound@Ogre@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
_box1$ = -56						; size = 28
_box2$ = -28						; size = 28
_other$ = 8						; size = 4
?intersect@BoxSphereBound@Ogre@@QBE_NABV12@@Z PROC	; Ogre::BoxSphereBound::intersect, COMDAT
; _this$ = ecx

; 337  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 338  : 			BoxBound box1 = getBox();

	lea	eax, DWORD PTR _box1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ ; Ogre::BoxSphereBound::getBox

; 339  : 			BoxBound box2 = other.getBox();

	lea	ecx, DWORD PTR _box2$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _other$[ebp]
	call	?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ ; Ogre::BoxSphereBound::getBox

; 340  : 			return box1.intersectBoxBound(box2);

	lea	edx, DWORD PTR _box2$[ebp]
	push	edx
	lea	ecx, DWORD PTR _box1$[ebp]
	call	?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z ; Ogre::BoxBound::intersectBoxBound

; 341  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?intersect@BoxSphereBound@Ogre@@QBE_NABV12@@Z ENDP	; Ogre::BoxSphereBound::intersect
_TEXT	ENDS
PUBLIC	??0BoxSphereBound@Ogre@@QAE@ABV01@@Z		; Ogre::BoxSphereBound::BoxSphereBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxSphereBound@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0BoxSphereBound@Ogre@@QAE@ABV01@@Z PROC		; Ogre::BoxSphereBound::BoxSphereBound, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [eax+24]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BoxSphereBound@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::BoxSphereBound::BoxSphereBound
_TEXT	ENDS
PUBLIC	??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::BoxSphereBound::operator=
; Function compile flags: /Odtp
;	COMDAT ??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BoxSphereBound::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [eax+24]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BoxSphereBound::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@MovableObject@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::MovableObject::getRTTI
EXTRN	?m_RTTI@MovableObject@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::MovableObject::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremovableobject.h
;	COMDAT ?getRTTI@MovableObject@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@MovableObject@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::MovableObject::getRTTI, COMDAT
; _this$ = ecx

; 16   : 		DECLARE_RTTI_VIRTUAL(MovableObject)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@MovableObject@Ogre@@2VRuntimeClass@2@B ; Ogre::MovableObject::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@MovableObject@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::MovableObject::getRTTI
_TEXT	ENDS
PUBLIC	?enableUVMask@MovableObject@Ogre@@UAEX_N0@Z	; Ogre::MovableObject::enableUVMask
; Function compile flags: /Odtp
;	COMDAT ?enableUVMask@MovableObject@Ogre@@UAEX_N0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_enable$ = 8						; size = 1
_stdmtlUse$ = 12					; size = 1
?enableUVMask@MovableObject@Ogre@@UAEX_N0@Z PROC	; Ogre::MovableObject::enableUVMask, COMDAT
; _this$ = ecx

; 23   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 24   : 
; 25   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?enableUVMask@MovableObject@Ogre@@UAEX_N0@Z ENDP	; Ogre::MovableObject::enableUVMask
_TEXT	ENDS
PUBLIC	?setLiuGuangTexture@MovableObject@Ogre@@UAEXPAVTextureData@2@@Z ; Ogre::MovableObject::setLiuGuangTexture
; Function compile flags: /Odtp
;	COMDAT ?setLiuGuangTexture@MovableObject@Ogre@@UAEXPAVTextureData@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_texture$ = 8						; size = 4
?setLiuGuangTexture@MovableObject@Ogre@@UAEXPAVTextureData@2@@Z PROC ; Ogre::MovableObject::setLiuGuangTexture, COMDAT
; _this$ = ecx

; 28   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 29   : 
; 30   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLiuGuangTexture@MovableObject@Ogre@@UAEXPAVTextureData@2@@Z ENDP ; Ogre::MovableObject::setLiuGuangTexture
_TEXT	ENDS
PUBLIC	?setLiuGuangTexture@MovableObject@Ogre@@UAEXPBD@Z ; Ogre::MovableObject::setLiuGuangTexture
; Function compile flags: /Odtp
;	COMDAT ?setLiuGuangTexture@MovableObject@Ogre@@UAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?setLiuGuangTexture@MovableObject@Ogre@@UAEXPBD@Z PROC	; Ogre::MovableObject::setLiuGuangTexture, COMDAT
; _this$ = ecx

; 33   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 34   : 
; 35   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLiuGuangTexture@MovableObject@Ogre@@UAEXPBD@Z ENDP	; Ogre::MovableObject::setLiuGuangTexture
_TEXT	ENDS
PUBLIC	?SetForceShadowMapCull@MovableObject@Ogre@@UAEX_N@Z ; Ogre::MovableObject::SetForceShadowMapCull
; Function compile flags: /Odtp
;	COMDAT ?SetForceShadowMapCull@MovableObject@Ogre@@UAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cull$ = 8						; size = 1
?SetForceShadowMapCull@MovableObject@Ogre@@UAEX_N@Z PROC ; Ogre::MovableObject::SetForceShadowMapCull, COMDAT
; _this$ = ecx

; 39   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 40   : 			m_bForceShadowMapCull = cull;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _cull$[ebp]
	mov	BYTE PTR [eax+208], cl

; 41   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?SetForceShadowMapCull@MovableObject@Ogre@@UAEX_N@Z ENDP ; Ogre::MovableObject::SetForceShadowMapCull
_TEXT	ENDS
PUBLIC	?IsForceShadowMapCull@MovableObject@Ogre@@QAE_NXZ ; Ogre::MovableObject::IsForceShadowMapCull
; Function compile flags: /Odtp
;	COMDAT ?IsForceShadowMapCull@MovableObject@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsForceShadowMapCull@MovableObject@Ogre@@QAE_NXZ PROC	; Ogre::MovableObject::IsForceShadowMapCull, COMDAT
; _this$ = ecx

; 44   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 			return m_bForceShadowMapCull;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+208]

; 46   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?IsForceShadowMapCull@MovableObject@Ogre@@QAE_NXZ ENDP	; Ogre::MovableObject::IsForceShadowMapCull
_TEXT	ENDS
PUBLIC	?resetUpdate@MovableObject@Ogre@@UAEX_NI@Z	; Ogre::MovableObject::resetUpdate
; Function compile flags: /Odtp
;	COMDAT ?resetUpdate@MovableObject@Ogre@@UAEX_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pause$ = 8						; size = 1
_tick$ = 12						; size = 4
?resetUpdate@MovableObject@Ogre@@UAEX_NI@Z PROC		; Ogre::MovableObject::resetUpdate, COMDAT
; _this$ = ecx

; 50   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 			m_bPause = pause;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _pause$[ebp]
	mov	BYTE PTR [eax+184], cl

; 52   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?resetUpdate@MovableObject@Ogre@@UAEX_NI@Z ENDP		; Ogre::MovableObject::resetUpdate
_TEXT	ENDS
PUBLIC	?getWorldMatrix@MovableObject@Ogre@@QAEABVMatrix4@2@XZ ; Ogre::MovableObject::getWorldMatrix
PUBLIC	?getAnchorWorldMatrix@MovableObject@Ogre@@UAE?AVMatrix4@2@H@Z ; Ogre::MovableObject::getAnchorWorldMatrix
EXTRN	??0Matrix4@Ogre@@QAE@ABV01@@Z:PROC		; Ogre::Matrix4::Matrix4
; Function compile flags: /Odtp
;	COMDAT ?getAnchorWorldMatrix@MovableObject@Ogre@@UAE?AVMatrix4@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_id$ = 12						; size = 4
?getAnchorWorldMatrix@MovableObject@Ogre@@UAE?AVMatrix4@2@H@Z PROC ; Ogre::MovableObject::getAnchorWorldMatrix, COMDAT
; _this$ = ecx

; 57   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 58   : 			return getWorldMatrix();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorldMatrix@MovableObject@Ogre@@QAEABVMatrix4@2@XZ ; Ogre::MovableObject::getWorldMatrix
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Matrix4@Ogre@@QAE@ABV01@@Z		; Ogre::Matrix4::Matrix4
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 59   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getAnchorWorldMatrix@MovableObject@Ogre@@UAE?AVMatrix4@2@H@Z ENDP ; Ogre::MovableObject::getAnchorWorldMatrix
_TEXT	ENDS
PUBLIC	?setPosition@MovableObject@Ogre@@QAEXABVWorldPos@2@@Z ; Ogre::MovableObject::setPosition
; Function compile flags: /Odtp
;	COMDAT ?setPosition@MovableObject@Ogre@@QAEXABVWorldPos@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
?setPosition@MovableObject@Ogre@@QAEXABVWorldPos@2@@Z PROC ; Ogre::MovableObject::setPosition, COMDAT
; _this$ = ecx

; 65   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 			m_Position = pos;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 67   : 			invalidWorldCache();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 68   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setPosition@MovableObject@Ogre@@QAEXABVWorldPos@2@@Z ENDP ; Ogre::MovableObject::setPosition
_TEXT	ENDS
PUBLIC	?setScale@MovableObject@Ogre@@QAEXABVVector3@2@@Z ; Ogre::MovableObject::setScale
; Function compile flags: /Odtp
;	COMDAT ?setScale@MovableObject@Ogre@@QAEXABVVector3@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_scale$ = 8						; size = 4
?setScale@MovableObject@Ogre@@QAEXABVVector3@2@@Z PROC	; Ogre::MovableObject::setScale, COMDAT
; _this$ = ecx

; 70   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 			m_Scale = scale;

	mov	eax, DWORD PTR _scale$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 72   : 			invalidWorldCache();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 73   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setScale@MovableObject@Ogre@@QAEXABVVector3@2@@Z ENDP	; Ogre::MovableObject::setScale
_TEXT	ENDS
PUBLIC	?setRotation@MovableObject@Ogre@@QAEXABVQuaternion@2@@Z ; Ogre::MovableObject::setRotation
; Function compile flags: /Odtp
;	COMDAT ?setRotation@MovableObject@Ogre@@QAEXABVQuaternion@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rot$ = 8						; size = 4
?setRotation@MovableObject@Ogre@@QAEXABVQuaternion@2@@Z PROC ; Ogre::MovableObject::setRotation, COMDAT
; _this$ = ecx

; 75   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 76   : 			m_Rotation = rot;

	mov	eax, DWORD PTR _rot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::Quaternion::operator=

; 77   : 			invalidWorldCache();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 78   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setRotation@MovableObject@Ogre@@QAEXABVQuaternion@2@@Z ENDP ; Ogre::MovableObject::setRotation
_TEXT	ENDS
PUBLIC	?setRotation@MovableObject@Ogre@@QAEXMMM@Z	; Ogre::MovableObject::setRotation
EXTRN	?setEulerAngle@Quaternion@Ogre@@QAEXMMM@Z:PROC	; Ogre::Quaternion::setEulerAngle
; Function compile flags: /Odtp
;	COMDAT ?setRotation@MovableObject@Ogre@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_yaw$ = 8						; size = 4
_pitch$ = 12						; size = 4
_roll$ = 16						; size = 4
?setRotation@MovableObject@Ogre@@QAEXMMM@Z PROC		; Ogre::MovableObject::setRotation, COMDAT
; _this$ = ecx

; 80   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 			m_Rotation.setEulerAngle(yaw, pitch, roll);

	push	ecx
	fld	DWORD PTR _roll$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _pitch$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _yaw$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?setEulerAngle@Quaternion@Ogre@@QAEXMMM@Z ; Ogre::Quaternion::setEulerAngle

; 82   : 			invalidWorldCache();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 83   : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setRotation@MovableObject@Ogre@@QAEXMMM@Z ENDP		; Ogre::MovableObject::setRotation
_TEXT	ENDS
PUBLIC	?getPosition@MovableObject@Ogre@@QBEABVWorldPos@2@XZ ; Ogre::MovableObject::getPosition
; Function compile flags: /Odtp
;	COMDAT ?getPosition@MovableObject@Ogre@@QBEABVWorldPos@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPosition@MovableObject@Ogre@@QBEABVWorldPos@2@XZ PROC ; Ogre::MovableObject::getPosition, COMDAT
; _this$ = ecx

; 85   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 			return m_Position;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8

; 87   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPosition@MovableObject@Ogre@@QBEABVWorldPos@2@XZ ENDP ; Ogre::MovableObject::getPosition
_TEXT	ENDS
PUBLIC	?getScale@MovableObject@Ogre@@QBEABVVector3@2@XZ ; Ogre::MovableObject::getScale
; Function compile flags: /Odtp
;	COMDAT ?getScale@MovableObject@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getScale@MovableObject@Ogre@@QBEABVVector3@2@XZ PROC	; Ogre::MovableObject::getScale, COMDAT
; _this$ = ecx

; 89   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 			return m_Scale;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H

; 91   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getScale@MovableObject@Ogre@@QBEABVVector3@2@XZ ENDP	; Ogre::MovableObject::getScale
_TEXT	ENDS
PUBLIC	?getRotation@MovableObject@Ogre@@QBEABVQuaternion@2@XZ ; Ogre::MovableObject::getRotation
; Function compile flags: /Odtp
;	COMDAT ?getRotation@MovableObject@Ogre@@QBEABVQuaternion@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRotation@MovableObject@Ogre@@QBEABVQuaternion@2@XZ PROC ; Ogre::MovableObject::getRotation, COMDAT
; _this$ = ecx

; 93   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 94   : 			return m_Rotation;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H

; 95   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRotation@MovableObject@Ogre@@QBEABVQuaternion@2@XZ ENDP ; Ogre::MovableObject::getRotation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getWorldMatrix@MovableObject@Ogre@@QAEABVMatrix4@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWorldMatrix@MovableObject@Ogre@@QAEABVMatrix4@2@XZ PROC ; Ogre::MovableObject::getWorldMatrix, COMDAT
; _this$ = ecx

; 97   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 			if(m_bWorldCacheInvalid)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+180]
	test	ecx, ecx
	je	SHORT $LN1@getWorldMa

; 99   : 			{
; 100  : 				updateWorldCache();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+72]
	call	edx
$LN1@getWorldMa:

; 101  : 			}
; 102  : 
; 103  : 			return m_WorldTM;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H

; 104  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getWorldMatrix@MovableObject@Ogre@@QAEABVMatrix4@2@XZ ENDP ; Ogre::MovableObject::getWorldMatrix
_TEXT	ENDS
PUBLIC	?getWorldPosition@MovableObject@Ogre@@QAE?BVVector3@2@XZ ; Ogre::MovableObject::getWorldPosition
; Function compile flags: /Odtp
;	COMDAT ?getWorldPosition@MovableObject@Ogre@@QAE?BVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getWorldPosition@MovableObject@Ogre@@QAE?BVVector3@2@XZ PROC ; Ogre::MovableObject::getWorldPosition, COMDAT
; _this$ = ecx

; 106  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 			return getWorldMatrix().getTranslate();

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorldMatrix@MovableObject@Ogre@@QAEABVMatrix4@2@XZ ; Ogre::MovableObject::getWorldMatrix
	mov	ecx, eax
	call	?getTranslate@Matrix4@Ogre@@QBE?AVVector3@2@XZ ; Ogre::Matrix4::getTranslate
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 108  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getWorldPosition@MovableObject@Ogre@@QAE?BVVector3@2@XZ ENDP ; Ogre::MovableObject::getWorldPosition
_TEXT	ENDS
PUBLIC	?getWorldBounds@MovableObject@Ogre@@QAEABVBoxSphereBound@2@XZ ; Ogre::MovableObject::getWorldBounds
; Function compile flags: /Odtp
;	COMDAT ?getWorldBounds@MovableObject@Ogre@@QAEABVBoxSphereBound@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWorldBounds@MovableObject@Ogre@@QAEABVBoxSphereBound@2@XZ PROC ; Ogre::MovableObject::getWorldBounds, COMDAT
; _this$ = ecx

; 110  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 			if(m_bWorldCacheInvalid)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+180]
	test	ecx, ecx
	je	SHORT $LN1@getWorldBo

; 112  : 			{
; 113  : 				updateWorldCache();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+72]
	call	edx
$LN1@getWorldBo:

; 114  : 			}
; 115  : 
; 116  : 			return m_WorldBounds;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 140				; 0000008cH

; 117  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getWorldBounds@MovableObject@Ogre@@QAEABVBoxSphereBound@2@XZ ENDP ; Ogre::MovableObject::getWorldBounds
_TEXT	ENDS
PUBLIC	?show@MovableObject@Ogre@@QAEX_N@Z		; Ogre::MovableObject::show
; Function compile flags: /Odtp
;	COMDAT ?show@MovableObject@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_b$ = 8							; size = 1
?show@MovableObject@Ogre@@QAEX_N@Z PROC			; Ogre::MovableObject::show, COMDAT
; _this$ = ecx

; 119  : 		void show(bool b){m_bShow = b;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _b$[ebp]
	mov	BYTE PTR [eax+183], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?show@MovableObject@Ogre@@QAEX_N@Z ENDP			; Ogre::MovableObject::show
_TEXT	ENDS
PUBLIC	?isShow@MovableObject@Ogre@@QAE_NXZ		; Ogre::MovableObject::isShow
; Function compile flags: /Odtp
;	COMDAT ?isShow@MovableObject@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isShow@MovableObject@Ogre@@QAE_NXZ PROC		; Ogre::MovableObject::isShow, COMDAT
; _this$ = ecx

; 120  : 		bool isShow(){return m_bShow;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+183]
	mov	esp, ebp
	pop	ebp
	ret	0
?isShow@MovableObject@Ogre@@QAE_NXZ ENDP		; Ogre::MovableObject::isShow
_TEXT	ENDS
PUBLIC	?getScene@MovableObject@Ogre@@QAEPAVGameScene@2@XZ ; Ogre::MovableObject::getScene
; Function compile flags: /Odtp
;	COMDAT ?getScene@MovableObject@Ogre@@QAEPAVGameScene@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getScene@MovableObject@Ogre@@QAEPAVGameScene@2@XZ PROC	; Ogre::MovableObject::getScene, COMDAT
; _this$ = ecx

; 123  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 			return m_pScene;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]

; 125  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getScene@MovableObject@Ogre@@QAEPAVGameScene@2@XZ ENDP	; Ogre::MovableObject::getScene
_TEXT	ENDS
PUBLIC	?getSceneContainer@MovableObject@Ogre@@QAEPAXXZ	; Ogre::MovableObject::getSceneContainer
; Function compile flags: /Odtp
;	COMDAT ?getSceneContainer@MovableObject@Ogre@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSceneContainer@MovableObject@Ogre@@QAEPAXXZ PROC	; Ogre::MovableObject::getSceneContainer, COMDAT
; _this$ = ecx

; 128  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 			return m_pSceneContainer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]

; 130  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getSceneContainer@MovableObject@Ogre@@QAEPAXXZ ENDP	; Ogre::MovableObject::getSceneContainer
_TEXT	ENDS
PUBLIC	?setScene@MovableObject@Ogre@@QAEXPAVGameScene@2@@Z ; Ogre::MovableObject::setScene
; Function compile flags: /Odtp
;	COMDAT ?setScene@MovableObject@Ogre@@QAEXPAVGameScene@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pscene$ = 8						; size = 4
?setScene@MovableObject@Ogre@@QAEXPAVGameScene@2@@Z PROC ; Ogre::MovableObject::setScene, COMDAT
; _this$ = ecx

; 133  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 			m_pScene = pscene;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pscene$[ebp]
	mov	DWORD PTR [eax+192], ecx

; 135  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setScene@MovableObject@Ogre@@QAEXPAVGameScene@2@@Z ENDP ; Ogre::MovableObject::setScene
_TEXT	ENDS
PUBLIC	?setSceneContainer@MovableObject@Ogre@@QAEXPAX@Z ; Ogre::MovableObject::setSceneContainer
; Function compile flags: /Odtp
;	COMDAT ?setSceneContainer@MovableObject@Ogre@@QAEXPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?setSceneContainer@MovableObject@Ogre@@QAEXPAX@Z PROC	; Ogre::MovableObject::setSceneContainer, COMDAT
; _this$ = ecx

; 138  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 139  : 			m_pSceneContainer = p;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+196], ecx

; 140  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setSceneContainer@MovableObject@Ogre@@QAEXPAX@Z ENDP	; Ogre::MovableObject::setSceneContainer
_TEXT	ENDS
PUBLIC	?setPickParam@MovableObject@Ogre@@QAEXIPAV12@@Z	; Ogre::MovableObject::setPickParam
; Function compile flags: /Odtp
;	COMDAT ?setPickParam@MovableObject@Ogre@@QAEXIPAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_type$ = 8						; size = 4
_pick_owner$ = 12					; size = 4
?setPickParam@MovableObject@Ogre@@QAEXIPAV12@@Z PROC	; Ogre::MovableObject::setPickParam, COMDAT
; _this$ = ecx

; 143  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 144  : 			m_PickType = type;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+200], ecx

; 145  : 			m_pPickOwner = pick_owner;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pick_owner$[ebp]
	mov	DWORD PTR [edx+204], eax

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setPickParam@MovableObject@Ogre@@QAEXIPAV12@@Z ENDP	; Ogre::MovableObject::setPickParam
_TEXT	ENDS
PUBLIC	?getPickType@MovableObject@Ogre@@QAEIXZ		; Ogre::MovableObject::getPickType
; Function compile flags: /Odtp
;	COMDAT ?getPickType@MovableObject@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPickType@MovableObject@Ogre@@QAEIXZ PROC		; Ogre::MovableObject::getPickType, COMDAT
; _this$ = ecx

; 149  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 150  : 			return m_PickType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+200]

; 151  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPickType@MovableObject@Ogre@@QAEIXZ ENDP		; Ogre::MovableObject::getPickType
_TEXT	ENDS
PUBLIC	?getPickOwner@MovableObject@Ogre@@QAEPAV12@XZ	; Ogre::MovableObject::getPickOwner
; Function compile flags: /Odtp
;	COMDAT ?getPickOwner@MovableObject@Ogre@@QAEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPickOwner@MovableObject@Ogre@@QAEPAV12@XZ PROC	; Ogre::MovableObject::getPickOwner, COMDAT
; _this$ = ecx

; 154  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 			return m_pPickOwner;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+204]

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPickOwner@MovableObject@Ogre@@QAEPAV12@XZ ENDP	; Ogre::MovableObject::getPickOwner
_TEXT	ENDS
PUBLIC	?isSceneAttached@MovableObject@Ogre@@QAE_NXZ	; Ogre::MovableObject::isSceneAttached
; Function compile flags: /Odtp
;	COMDAT ?isSceneAttached@MovableObject@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isSceneAttached@MovableObject@Ogre@@QAE_NXZ PROC	; Ogre::MovableObject::isSceneAttached, COMDAT
; _this$ = ecx

; 159  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 			return m_bSceneAttached;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+182]

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?isSceneAttached@MovableObject@Ogre@@QAE_NXZ ENDP	; Ogre::MovableObject::isSceneAttached
_TEXT	ENDS
PUBLIC	?setFather@MovableObject@Ogre@@QAEXPAV12@@Z	; Ogre::MovableObject::setFather
; Function compile flags: /Odtp
;	COMDAT ?setFather@MovableObject@Ogre@@QAEXPAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pfather$ = 8						; size = 4
?setFather@MovableObject@Ogre@@QAEXPAV12@@Z PROC	; Ogre::MovableObject::setFather, COMDAT
; _this$ = ecx

; 164  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 			m_pFather = pfather;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pfather$[ebp]
	mov	DWORD PTR [eax+176], ecx

; 166  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setFather@MovableObject@Ogre@@QAEXPAV12@@Z ENDP	; Ogre::MovableObject::setFather
_TEXT	ENDS
PUBLIC	?getFather@MovableObject@Ogre@@QAEPAV12@XZ	; Ogre::MovableObject::getFather
; Function compile flags: /Odtp
;	COMDAT ?getFather@MovableObject@Ogre@@QAEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getFather@MovableObject@Ogre@@QAEPAV12@XZ PROC		; Ogre::MovableObject::getFather, COMDAT
; _this$ = ecx

; 169  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 			return m_pFather;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+176]

; 171  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getFather@MovableObject@Ogre@@QAEPAV12@XZ ENDP		; Ogre::MovableObject::getFather
_TEXT	ENDS
PUBLIC	?getSRTFather@MovableObject@Ogre@@QAEPAV12@XZ	; Ogre::MovableObject::getSRTFather
; Function compile flags: /Odtp
;	COMDAT ?getSRTFather@MovableObject@Ogre@@QAEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSRTFather@MovableObject@Ogre@@QAEPAV12@XZ PROC	; Ogre::MovableObject::getSRTFather, COMDAT
; _this$ = ecx

; 174  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 			return m_pSRTFather;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+168]

; 176  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getSRTFather@MovableObject@Ogre@@QAEPAV12@XZ ENDP	; Ogre::MovableObject::getSRTFather
_TEXT	ENDS
PUBLIC	?setTransparent@MovableObject@Ogre@@QAEXM@Z	; Ogre::MovableObject::setTransparent
; Function compile flags: /Odtp
;	COMDAT ?setTransparent@MovableObject@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_alpha$ = 8						; size = 4
?setTransparent@MovableObject@Ogre@@QAEXM@Z PROC	; Ogre::MovableObject::setTransparent, COMDAT
; _this$ = ecx

; 179  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 			m_Transparent = alpha;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _alpha$[ebp]
	fstp	DWORD PTR [eax+188]

; 181  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setTransparent@MovableObject@Ogre@@QAEXM@Z ENDP	; Ogre::MovableObject::setTransparent
_TEXT	ENDS
PUBLIC	?getLocalTransparent@MovableObject@Ogre@@QAEMXZ	; Ogre::MovableObject::getLocalTransparent
; Function compile flags: /Odtp
;	COMDAT ?getLocalTransparent@MovableObject@Ogre@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getLocalTransparent@MovableObject@Ogre@@QAEMXZ PROC	; Ogre::MovableObject::getLocalTransparent, COMDAT
; _this$ = ecx

; 184  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 			return m_Transparent;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+188]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getLocalTransparent@MovableObject@Ogre@@QAEMXZ ENDP	; Ogre::MovableObject::getLocalTransparent
_TEXT	ENDS
PUBLIC	?getTransparent@MovableObject@Ogre@@QAEMXZ	; Ogre::MovableObject::getTransparent
; Function compile flags: /Odtp
;	COMDAT ?getTransparent@MovableObject@Ogre@@QAEMXZ
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
?getTransparent@MovableObject@Ogre@@QAEMXZ PROC		; Ogre::MovableObject::getTransparent, COMDAT
; _this$ = ecx

; 189  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 190  : 			if(m_pFather) return m_pFather->getTransparent()*m_Transparent;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+176], 0
	je	SHORT $LN2@getTranspa
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+176]
	call	?getTransparent@MovableObject@Ogre@@QAEMXZ ; Ogre::MovableObject::getTransparent
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+188]
	fstp	DWORD PTR tv81[ebp]
	fld	DWORD PTR tv81[ebp]
	jmp	SHORT $LN1@getTranspa
	jmp	SHORT $LN1@getTranspa
$LN2@getTranspa:

; 191  : 			else return m_Transparent;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+188]
$LN1@getTranspa:

; 192  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getTransparent@MovableObject@Ogre@@QAEMXZ ENDP		; Ogre::MovableObject::getTransparent
_TEXT	ENDS
PUBLIC	??_7MovableObject@Ogre@@6B@			; Ogre::MovableObject::`vftable'
PUBLIC	??0MovableObject@Ogre@@QAE@ABV01@@Z		; Ogre::MovableObject::MovableObject
PUBLIC	??_R4MovableObject@Ogre@@6B@			; Ogre::MovableObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMovableObject@Ogre@@@8			; Ogre::MovableObject `RTTI Type Descriptor'
PUBLIC	??_R3MovableObject@Ogre@@8			; Ogre::MovableObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MovableObject@Ogre@@8			; Ogre::MovableObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MovableObject@Ogre@@8		; Ogre::MovableObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EMovableObject@Ogre@@UAEPAXI@Z		; Ogre::MovableObject::`vector deleting destructor'
EXTRN	?update@MovableObject@Ogre@@UAEXI@Z:PROC	; Ogre::MovableObject::update
EXTRN	?attachToScene@MovableObject@Ogre@@UAEXPAVGameScene@2@_N@Z:PROC ; Ogre::MovableObject::attachToScene
EXTRN	?detachFromScene@MovableObject@Ogre@@UAEXXZ:PROC ; Ogre::MovableObject::detachFromScene
EXTRN	?intersectRay@MovableObject@Ogre@@UAE_NW4IntersectType@2@ABVRay@2@PAM@Z:PROC ; Ogre::MovableObject::intersectRay
EXTRN	?invalidWorldCache@MovableObject@Ogre@@UAEXXZ:PROC ; Ogre::MovableObject::invalidWorldCache
EXTRN	?updateWorldCache@MovableObject@Ogre@@UAEXXZ:PROC ; Ogre::MovableObject::updateWorldCache
;	COMDAT ??_R1A@?0A@EA@MovableObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MovableObject@Ogre@@8 DD FLAT:??_R0?AVMovableObject@Ogre@@@8 ; Ogre::MovableObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MovableObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MovableObject@Ogre@@8
rdata$r	SEGMENT
??_R2MovableObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MovableObject@Ogre@@8 ; Ogre::MovableObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3MovableObject@Ogre@@8
rdata$r	SEGMENT
??_R3MovableObject@Ogre@@8 DD 00H			; Ogre::MovableObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2MovableObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMovableObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMovableObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MovableObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMovableObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MovableObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4MovableObject@Ogre@@6B@ DD 00H			; Ogre::MovableObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMovableObject@Ogre@@@8
	DD	FLAT:??_R3MovableObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7MovableObject@Ogre@@6B@
CONST	SEGMENT
??_7MovableObject@Ogre@@6B@ DD FLAT:??_R4MovableObject@Ogre@@6B@ ; Ogre::MovableObject::`vftable'
	DD	FLAT:?getRTTI@MovableObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EMovableObject@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?enableUVMask@MovableObject@Ogre@@UAEX_N0@Z
	DD	FLAT:?setLiuGuangTexture@MovableObject@Ogre@@UAEXPBD@Z
	DD	FLAT:?setLiuGuangTexture@MovableObject@Ogre@@UAEXPAVTextureData@2@@Z
	DD	FLAT:?SetForceShadowMapCull@MovableObject@Ogre@@UAEX_N@Z
	DD	FLAT:?update@MovableObject@Ogre@@UAEXI@Z
	DD	FLAT:?resetUpdate@MovableObject@Ogre@@UAEX_NI@Z
	DD	FLAT:?attachToScene@MovableObject@Ogre@@UAEXPAVGameScene@2@_N@Z
	DD	FLAT:?detachFromScene@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:?intersectRay@MovableObject@Ogre@@UAE_NW4IntersectType@2@ABVRay@2@PAM@Z
	DD	FLAT:?getAnchorWorldMatrix@MovableObject@Ogre@@UAE?AVMatrix4@2@H@Z
	DD	FLAT:?invalidWorldCache@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:?updateWorldCache@MovableObject@Ogre@@UAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0MovableObject@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MovableObject@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0MovableObject@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MovableObject@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0MovableObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0MovableObject@Ogre@@QAE@ABV01@@Z PROC		; Ogre::MovableObject::MovableObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MovableObject@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7MovableObject@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0Matrix4@Ogre@@QAE@ABV01@@Z		; Ogre::Matrix4::Matrix4
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0BoxBound@Ogre@@QAE@ABV01@@Z		; Ogre::BoxBound::BoxBound
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 140				; 0000008cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??0BoxSphereBound@Ogre@@QAE@ABV01@@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	DWORD PTR [edx+168], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	mov	DWORD PTR [edx+172], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	mov	DWORD PTR [edx+176], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+180]
	mov	BYTE PTR [edx+180], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+181]
	mov	BYTE PTR [edx+181], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+182]
	mov	BYTE PTR [edx+182], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+183]
	mov	BYTE PTR [edx+183], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+184]
	mov	BYTE PTR [edx+184], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [eax+188]
	fstp	DWORD PTR [edx+188]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+192]
	mov	DWORD PTR [ecx+192], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+196]
	mov	DWORD PTR [ecx+196], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+200]
	mov	DWORD PTR [ecx+200], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+204]
	mov	DWORD PTR [ecx+204], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+208]
	mov	BYTE PTR [ecx+208], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MovableObject@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__ehhandler$??0MovableObject@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0MovableObject@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MovableObject@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::MovableObject::MovableObject
PUBLIC	??4MovableObject@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MovableObject::operator=
EXTRN	??4Matrix4@Ogre@@QAEABV01@ABV01@@Z:PROC		; Ogre::Matrix4::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MovableObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MovableObject@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::MovableObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::Quaternion::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4Matrix4@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Matrix4::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 140				; 0000008cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+168]
	mov	DWORD PTR [ecx+168], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+172]
	mov	DWORD PTR [ecx+172], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+176]
	mov	DWORD PTR [ecx+176], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+180]
	mov	BYTE PTR [ecx+180], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+181]
	mov	BYTE PTR [ecx+181], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+182]
	mov	BYTE PTR [ecx+182], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+183]
	mov	BYTE PTR [ecx+183], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+184]
	mov	BYTE PTR [ecx+184], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+188]
	fstp	DWORD PTR [ecx+188]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+192]
	mov	DWORD PTR [eax+192], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	mov	DWORD PTR [eax+196], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	mov	DWORD PTR [eax+200], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	mov	DWORD PTR [eax+204], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+208]
	mov	BYTE PTR [eax+208], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MovableObject@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::MovableObject::operator=
_TEXT	ENDS
PUBLIC	??_GMovableObject@Ogre@@UAEPAXI@Z		; Ogre::MovableObject::`scalar deleting destructor'
EXTRN	??1MovableObject@Ogre@@UAE@XZ:PROC		; Ogre::MovableObject::~MovableObject
; Function compile flags: /Odtp
;	COMDAT ??_GMovableObject@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMovableObject@Ogre@@UAEPAXI@Z PROC			; Ogre::MovableObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MovableObject@Ogre@@UAE@XZ		; Ogre::MovableObject::~MovableObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@12
	push	212					; 000000d4H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@12:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GMovableObject@Ogre@@UAEPAXI@Z ENDP			; Ogre::MovableObject::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EMovableObject@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EMovableObject@Ogre@@UAEPAXI@Z PROC			; Ogre::MovableObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@12
	push	OFFSET ??1MovableObject@Ogre@@UAE@XZ	; Ogre::MovableObject::~MovableObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	212					; 000000d4H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@12
	push	212					; 000000d4H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@12:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@12
$LN3@vector@12:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MovableObject@Ogre@@UAE@XZ		; Ogre::MovableObject::~MovableObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@12
	push	212					; 000000d4H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@12:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@12:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EMovableObject@Ogre@@UAEPAXI@Z ENDP			; Ogre::MovableObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::VertexBuffer::getRTTI
EXTRN	?m_RTTI@VertexBuffer@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::VertexBuffer::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrerendertypes.h
;	COMDAT ?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::VertexBuffer::getRTTI, COMDAT
; _this$ = ecx

; 223  : 		DECLARE_RTTI_VIRTUAL(VertexBuffer)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@VertexBuffer@Ogre@@2VRuntimeClass@2@B ; Ogre::VertexBuffer::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::VertexBuffer::getRTTI
_TEXT	ENDS
PUBLIC	??_7VertexBuffer@Ogre@@6B@			; Ogre::VertexBuffer::`vftable'
PUBLIC	??0VertexBuffer@Ogre@@QAE@XZ			; Ogre::VertexBuffer::VertexBuffer
PUBLIC	??_R4VertexBuffer@Ogre@@6B@			; Ogre::VertexBuffer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVertexBuffer@Ogre@@@8			; Ogre::VertexBuffer `RTTI Type Descriptor'
PUBLIC	??_R3VertexBuffer@Ogre@@8			; Ogre::VertexBuffer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VertexBuffer@Ogre@@8			; Ogre::VertexBuffer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VertexBuffer@Ogre@@8		; Ogre::VertexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EVertexBuffer@Ogre@@UAEPAXI@Z		; Ogre::VertexBuffer::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@VertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VertexBuffer@Ogre@@8 DD FLAT:??_R0?AVVertexBuffer@Ogre@@@8 ; Ogre::VertexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2VertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R2VertexBuffer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@VertexBuffer@Ogre@@8 ; Ogre::VertexBuffer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3VertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R3VertexBuffer@Ogre@@8 DD 00H			; Ogre::VertexBuffer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2VertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVertexBuffer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVVertexBuffer@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::VertexBuffer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVertexBuffer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VertexBuffer@Ogre@@6B@
rdata$r	SEGMENT
??_R4VertexBuffer@Ogre@@6B@ DD 00H			; Ogre::VertexBuffer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVertexBuffer@Ogre@@@8
	DD	FLAT:??_R3VertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7VertexBuffer@Ogre@@6B@
CONST	SEGMENT
??_7VertexBuffer@Ogre@@6B@ DD FLAT:??_R4VertexBuffer@Ogre@@6B@ ; Ogre::VertexBuffer::`vftable'
	DD	FLAT:?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EVertexBuffer@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0VertexBuffer@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0VertexBuffer@Ogre@@QAE@XZ$0
__ehfuncinfo$??0VertexBuffer@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0VertexBuffer@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0VertexBuffer@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0VertexBuffer@Ogre@@QAE@XZ PROC			; Ogre::VertexBuffer::VertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0VertexBuffer@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VertexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0VertexBuffer@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0VertexBuffer@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0VertexBuffer@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0VertexBuffer@Ogre@@QAE@XZ ENDP			; Ogre::VertexBuffer::VertexBuffer
PUBLIC	??1VertexBuffer@Ogre@@UAE@XZ			; Ogre::VertexBuffer::~VertexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1VertexBuffer@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1VertexBuffer@Ogre@@UAE@XZ$0
__ehfuncinfo$??1VertexBuffer@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1VertexBuffer@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1VertexBuffer@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1VertexBuffer@Ogre@@UAE@XZ PROC			; Ogre::VertexBuffer::~VertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1VertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1VertexBuffer@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??1VertexBuffer@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1VertexBuffer@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1VertexBuffer@Ogre@@UAE@XZ ENDP			; Ogre::VertexBuffer::~VertexBuffer
PUBLIC	??0VertexBuffer@Ogre@@QAE@ABV01@@Z		; Ogre::VertexBuffer::VertexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0VertexBuffer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0VertexBuffer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0VertexBuffer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0VertexBuffer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0VertexBuffer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0VertexBuffer@Ogre@@QAE@ABV01@@Z PROC			; Ogre::VertexBuffer::VertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0VertexBuffer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7VertexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0VertexBuffer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0VertexBuffer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0VertexBuffer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0VertexBuffer@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::VertexBuffer::VertexBuffer
PUBLIC	??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::VertexBuffer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::VertexBuffer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::VertexBuffer::operator=
_TEXT	ENDS
PUBLIC	??_GVertexBuffer@Ogre@@UAEPAXI@Z		; Ogre::VertexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GVertexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVertexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::VertexBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@13
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@13:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVertexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::VertexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EVertexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EVertexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::VertexBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@13
	push	OFFSET ??1VertexBuffer@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@13
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@13:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@13
$LN3@vector@13:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@13
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@13:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@13:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EVertexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::VertexBuffer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::IndexBuffer::getRTTI
EXTRN	?m_RTTI@IndexBuffer@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::IndexBuffer::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::IndexBuffer::getRTTI, COMDAT
; _this$ = ecx

; 230  : 		DECLARE_RTTI_VIRTUAL(IndexBuffer)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@IndexBuffer@Ogre@@2VRuntimeClass@2@B ; Ogre::IndexBuffer::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::IndexBuffer::getRTTI
_TEXT	ENDS
PUBLIC	?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z	; Ogre::IndexBuffer::setVertexRange
; Function compile flags: /Odtp
;	COMDAT ?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_start$ = 8						; size = 4
_num$ = 12						; size = 4
?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z PROC		; Ogre::IndexBuffer::setVertexRange, COMDAT
; _this$ = ecx

; 235  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 236  : 			m_RefVertStart = start;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 237  : 			m_RefVertNum = num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _num$[ebp]
	mov	DWORD PTR [edx+20], eax

; 238  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z ENDP		; Ogre::IndexBuffer::setVertexRange
_TEXT	ENDS
PUBLIC	??_7IndexBuffer@Ogre@@6B@			; Ogre::IndexBuffer::`vftable'
PUBLIC	??0IndexBuffer@Ogre@@QAE@XZ			; Ogre::IndexBuffer::IndexBuffer
PUBLIC	??_R4IndexBuffer@Ogre@@6B@			; Ogre::IndexBuffer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVIndexBuffer@Ogre@@@8			; Ogre::IndexBuffer `RTTI Type Descriptor'
PUBLIC	??_R3IndexBuffer@Ogre@@8			; Ogre::IndexBuffer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IndexBuffer@Ogre@@8			; Ogre::IndexBuffer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IndexBuffer@Ogre@@8		; Ogre::IndexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EIndexBuffer@Ogre@@UAEPAXI@Z			; Ogre::IndexBuffer::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@IndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IndexBuffer@Ogre@@8 DD FLAT:??_R0?AVIndexBuffer@Ogre@@@8 ; Ogre::IndexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2IndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R2IndexBuffer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@IndexBuffer@Ogre@@8 ; Ogre::IndexBuffer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3IndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R3IndexBuffer@Ogre@@8 DD 00H				; Ogre::IndexBuffer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2IndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIndexBuffer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVIndexBuffer@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::IndexBuffer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIndexBuffer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4IndexBuffer@Ogre@@6B@
rdata$r	SEGMENT
??_R4IndexBuffer@Ogre@@6B@ DD 00H			; Ogre::IndexBuffer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIndexBuffer@Ogre@@@8
	DD	FLAT:??_R3IndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7IndexBuffer@Ogre@@6B@
CONST	SEGMENT
??_7IndexBuffer@Ogre@@6B@ DD FLAT:??_R4IndexBuffer@Ogre@@6B@ ; Ogre::IndexBuffer::`vftable'
	DD	FLAT:?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EIndexBuffer@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0IndexBuffer@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0IndexBuffer@Ogre@@QAE@XZ$0
__ehfuncinfo$??0IndexBuffer@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0IndexBuffer@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0IndexBuffer@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0IndexBuffer@Ogre@@QAE@XZ PROC			; Ogre::IndexBuffer::IndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0IndexBuffer@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7IndexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0IndexBuffer@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0IndexBuffer@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0IndexBuffer@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0IndexBuffer@Ogre@@QAE@XZ ENDP			; Ogre::IndexBuffer::IndexBuffer
PUBLIC	??1IndexBuffer@Ogre@@UAE@XZ			; Ogre::IndexBuffer::~IndexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1IndexBuffer@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1IndexBuffer@Ogre@@UAE@XZ$0
__ehfuncinfo$??1IndexBuffer@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1IndexBuffer@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1IndexBuffer@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1IndexBuffer@Ogre@@UAE@XZ PROC			; Ogre::IndexBuffer::~IndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1IndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1IndexBuffer@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??1IndexBuffer@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1IndexBuffer@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1IndexBuffer@Ogre@@UAE@XZ ENDP			; Ogre::IndexBuffer::~IndexBuffer
PUBLIC	??0IndexBuffer@Ogre@@QAE@ABV01@@Z		; Ogre::IndexBuffer::IndexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0IndexBuffer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0IndexBuffer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0IndexBuffer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0IndexBuffer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0IndexBuffer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0IndexBuffer@Ogre@@QAE@ABV01@@Z PROC			; Ogre::IndexBuffer::IndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0IndexBuffer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7IndexBuffer@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0IndexBuffer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0IndexBuffer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0IndexBuffer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0IndexBuffer@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::IndexBuffer::IndexBuffer
PUBLIC	??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::IndexBuffer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::IndexBuffer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::IndexBuffer::operator=
_TEXT	ENDS
PUBLIC	??_GIndexBuffer@Ogre@@UAEPAXI@Z			; Ogre::IndexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GIndexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIndexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::IndexBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1IndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@14
	push	24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@14:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GIndexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::IndexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EIndexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EIndexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::IndexBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@14
	push	OFFSET ??1IndexBuffer@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@14
	push	24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@14:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@14
$LN3@vector@14:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1IndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@14
	push	24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@14:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@14:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EIndexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::IndexBuffer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ	; Ogre::Texture::getRTTI
EXTRN	?m_RTTI@Texture@Ogre@@2VRuntimeClass@2@B:BYTE	; Ogre::Texture::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::Texture::getRTTI, COMDAT
; _this$ = ecx

; 248  : 		DECLARE_RTTI_VIRTUAL(Texture)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@Texture@Ogre@@2VRuntimeClass@2@B ; Ogre::Texture::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::Texture::getRTTI
_TEXT	ENDS
PUBLIC	??_7Texture@Ogre@@6B@				; Ogre::Texture::`vftable'
PUBLIC	??1Texture@Ogre@@MAE@XZ				; Ogre::Texture::~Texture
PUBLIC	??_R4Texture@Ogre@@6B@				; Ogre::Texture::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTexture@Ogre@@@8			; Ogre::Texture `RTTI Type Descriptor'
PUBLIC	??_R3Texture@Ogre@@8				; Ogre::Texture::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Texture@Ogre@@8				; Ogre::Texture::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Texture@Ogre@@8			; Ogre::Texture::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ETexture@Ogre@@MAEPAXI@Z			; Ogre::Texture::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@Texture@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Texture@Ogre@@8 DD FLAT:??_R0?AVTexture@Ogre@@@8 ; Ogre::Texture::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Texture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Texture@Ogre@@8
rdata$r	SEGMENT
??_R2Texture@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Texture@Ogre@@8 ; Ogre::Texture::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3Texture@Ogre@@8
rdata$r	SEGMENT
??_R3Texture@Ogre@@8 DD 00H				; Ogre::Texture::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2Texture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTexture@Ogre@@@8
_DATA	SEGMENT
??_R0?AVTexture@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Texture `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTexture@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Texture@Ogre@@6B@
rdata$r	SEGMENT
??_R4Texture@Ogre@@6B@ DD 00H				; Ogre::Texture::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTexture@Ogre@@@8
	DD	FLAT:??_R3Texture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Texture@Ogre@@6B@
CONST	SEGMENT
??_7Texture@Ogre@@6B@ DD FLAT:??_R4Texture@Ogre@@6B@	; Ogre::Texture::`vftable'
	DD	FLAT:?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_ETexture@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Texture@Ogre@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Texture@Ogre@@MAE@XZ$0
__ehfuncinfo$??1Texture@Ogre@@MAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1Texture@Ogre@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1Texture@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Texture@Ogre@@MAE@XZ PROC				; Ogre::Texture::~Texture, COMDAT
; _this$ = ecx

; 257  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Texture@Ogre@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Texture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 258  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Texture@Ogre@@MAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??1Texture@Ogre@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Texture@Ogre@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Texture@Ogre@@MAE@XZ ENDP				; Ogre::Texture::~Texture
PUBLIC	??0Texture@Ogre@@QAE@XZ				; Ogre::Texture::Texture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Texture@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Texture@Ogre@@QAE@XZ$0
__ehfuncinfo$??0Texture@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Texture@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Texture@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Texture@Ogre@@QAE@XZ PROC				; Ogre::Texture::Texture, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Texture@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Texture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Texture@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0Texture@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Texture@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Texture@Ogre@@QAE@XZ ENDP				; Ogre::Texture::Texture
PUBLIC	??0Texture@Ogre@@QAE@ABV01@@Z			; Ogre::Texture::Texture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Texture@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Texture@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0Texture@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Texture@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Texture@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Texture@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Texture::Texture, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Texture@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7Texture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Texture@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0Texture@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Texture@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Texture@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Texture::Texture
PUBLIC	??4Texture@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Texture::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Texture@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Texture@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Texture::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Texture@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Texture::operator=
_TEXT	ENDS
PUBLIC	??_GTexture@Ogre@@MAEPAXI@Z			; Ogre::Texture::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GTexture@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTexture@Ogre@@MAEPAXI@Z PROC			; Ogre::Texture::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@15
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@15:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTexture@Ogre@@MAEPAXI@Z ENDP			; Ogre::Texture::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ETexture@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ETexture@Ogre@@MAEPAXI@Z PROC			; Ogre::Texture::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@15
	push	OFFSET ??1Texture@Ogre@@MAE@XZ		; Ogre::Texture::~Texture
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@15
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@15:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@15
$LN3@vector@15:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@15
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@15:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@15:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ETexture@Ogre@@MAEPAXI@Z ENDP			; Ogre::Texture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@RenderableObject@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::RenderableObject::getRTTI
EXTRN	?m_RTTI@RenderableObject@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::RenderableObject::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrerenderableobject.h
;	COMDAT ?getRTTI@RenderableObject@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@RenderableObject@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::RenderableObject::getRTTI, COMDAT
; _this$ = ecx

; 23   : 		DECLARE_RTTI_VIRTUAL(RenderableObject)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@RenderableObject@Ogre@@2VRuntimeClass@2@B ; Ogre::RenderableObject::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@RenderableObject@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::RenderableObject::getRTTI
_TEXT	ENDS
PUBLIC	?enableUVMask@RenderableObject@Ogre@@UAEX_N0@Z	; Ogre::RenderableObject::enableUVMask
; Function compile flags: /Odtp
;	COMDAT ?enableUVMask@RenderableObject@Ogre@@UAEX_N0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_enable$ = 8						; size = 1
_stdmtlUse$ = 12					; size = 1
?enableUVMask@RenderableObject@Ogre@@UAEX_N0@Z PROC	; Ogre::RenderableObject::enableUVMask, COMDAT
; _this$ = ecx

; 27   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 28   : 
; 29   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?enableUVMask@RenderableObject@Ogre@@UAEX_N0@Z ENDP	; Ogre::RenderableObject::enableUVMask
_TEXT	ENDS
PUBLIC	?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPAVTextureData@2@@Z ; Ogre::RenderableObject::setLiuGuangTexture
; Function compile flags: /Odtp
;	COMDAT ?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPAVTextureData@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_texture$ = 8						; size = 4
?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPAVTextureData@2@@Z PROC ; Ogre::RenderableObject::setLiuGuangTexture, COMDAT
; _this$ = ecx

; 32   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 
; 34   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPAVTextureData@2@@Z ENDP ; Ogre::RenderableObject::setLiuGuangTexture
_TEXT	ENDS
PUBLIC	?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPBD@Z ; Ogre::RenderableObject::setLiuGuangTexture
; Function compile flags: /Odtp
;	COMDAT ?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPBD@Z PROC ; Ogre::RenderableObject::setLiuGuangTexture, COMDAT
; _this$ = ecx

; 37   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 
; 39   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPBD@Z ENDP ; Ogre::RenderableObject::setLiuGuangTexture
_TEXT	ENDS
PUBLIC	?setLayer@RenderableObject@Ogre@@UAEXW4RenderLayer@2@@Z ; Ogre::RenderableObject::setLayer
; Function compile flags: /Odtp
;	COMDAT ?setLayer@RenderableObject@Ogre@@UAEXW4RenderLayer@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_layer$ = 8						; size = 4
?setLayer@RenderableObject@Ogre@@UAEXW4RenderLayer@2@@Z PROC ; Ogre::RenderableObject::setLayer, COMDAT
; _this$ = ecx

; 47   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 			m_RenderLayer = layer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _layer$[ebp]
	mov	DWORD PTR [eax+264], ecx

; 49   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLayer@RenderableObject@Ogre@@UAEXW4RenderLayer@2@@Z ENDP ; Ogre::RenderableObject::setLayer
_TEXT	ENDS
PUBLIC	?BuildDecalMesh@RenderableObject@Ogre@@UAEXABVBoxBound@2@PAVVector3@2@PAGHHAAH3@Z ; Ogre::RenderableObject::BuildDecalMesh
; Function compile flags: /Odtp
;	COMDAT ?BuildDecalMesh@RenderableObject@Ogre@@UAEXABVBoxBound@2@PAVVector3@2@PAGHHAAH3@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_boxbound$ = 8						; size = 4
_pVB$ = 12						; size = 4
_pIB$ = 16						; size = 4
_nVertexBase$ = 20					; size = 4
_nFaceLimit$ = 24					; size = 4
_nVertexCount$ = 28					; size = 4
_nFaceCount$ = 32					; size = 4
?BuildDecalMesh@RenderableObject@Ogre@@UAEXABVBoxBound@2@PAVVector3@2@PAGHHAAH3@Z PROC ; Ogre::RenderableObject::BuildDecalMesh, COMDAT
; _this$ = ecx

; 54   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 			nVertexCount = 0;

	mov	eax, DWORD PTR _nVertexCount$[ebp]
	mov	DWORD PTR [eax], 0

; 56   : 			nFaceCount = 0;

	mov	ecx, DWORD PTR _nFaceCount$[ebp]
	mov	DWORD PTR [ecx], 0

; 57   : 		}

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?BuildDecalMesh@RenderableObject@Ogre@@UAEXABVBoxBound@2@PAVVector3@2@PAGHHAAH3@Z ENDP ; Ogre::RenderableObject::BuildDecalMesh
_TEXT	ENDS
PUBLIC	?getRenderUsageBits@RenderableObject@Ogre@@QAEIXZ ; Ogre::RenderableObject::getRenderUsageBits
; Function compile flags: /Odtp
;	COMDAT ?getRenderUsageBits@RenderableObject@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRenderUsageBits@RenderableObject@Ogre@@QAEIXZ PROC	; Ogre::RenderableObject::getRenderUsageBits, COMDAT
; _this$ = ecx

; 60   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 			return m_RenderUsageBits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+272]

; 62   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRenderUsageBits@RenderableObject@Ogre@@QAEIXZ ENDP	; Ogre::RenderableObject::getRenderUsageBits
_TEXT	ENDS
PUBLIC	?addRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z ; Ogre::RenderableObject::addRenderUsageBits
; Function compile flags: /Odtp
;	COMDAT ?addRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_usage$ = 8						; size = 4
?addRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z PROC ; Ogre::RenderableObject::addRenderUsageBits, COMDAT
; _this$ = ecx

; 65   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 			m_RenderUsageBits |= 1<<usage;

	mov	eax, 1
	mov	ecx, DWORD PTR _usage$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _this$[ebp]
	or	eax, DWORD PTR [ecx+272]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+272], eax

; 67   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?addRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z ENDP ; Ogre::RenderableObject::addRenderUsageBits
_TEXT	ENDS
PUBLIC	?clearRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z ; Ogre::RenderableObject::clearRenderUsageBits
; Function compile flags: /Odtp
;	COMDAT ?clearRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_usage$ = 8						; size = 4
?clearRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z PROC ; Ogre::RenderableObject::clearRenderUsageBits, COMDAT
; _this$ = ecx

; 70   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 			m_RenderUsageBits &= ~(1<<usage);

	mov	eax, 1
	mov	ecx, DWORD PTR _usage$[ebp]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+272]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+272], eax

; 72   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?clearRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z ENDP ; Ogre::RenderableObject::clearRenderUsageBits
_TEXT	ENDS
PUBLIC	?getRenderPassRequired@RenderableObject@Ogre@@UAEXAAURenderPassDesc@2@@Z ; Ogre::RenderableObject::getRenderPassRequired
; Function compile flags: /Odtp
;	COMDAT ?getRenderPassRequired@RenderableObject@Ogre@@UAEXAAURenderPassDesc@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_desc$ = 8						; size = 4
?getRenderPassRequired@RenderableObject@Ogre@@UAEXAAURenderPassDesc@2@@Z PROC ; Ogre::RenderableObject::getRenderPassRequired, COMDAT
; _this$ = ecx

; 75   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 76   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getRenderPassRequired@RenderableObject@Ogre@@UAEXAAURenderPassDesc@2@@Z ENDP ; Ogre::RenderableObject::getRenderPassRequired
_TEXT	ENDS
PUBLIC	?getUserType@RenderableObject@Ogre@@QAEIXZ	; Ogre::RenderableObject::getUserType
; Function compile flags: /Odtp
;	COMDAT ?getUserType@RenderableObject@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getUserType@RenderableObject@Ogre@@QAEIXZ PROC		; Ogre::RenderableObject::getUserType, COMDAT
; _this$ = ecx

; 79   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 			return m_UserType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+268]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getUserType@RenderableObject@Ogre@@QAEIXZ ENDP		; Ogre::RenderableObject::getUserType
_TEXT	ENDS
PUBLIC	?setUserType@RenderableObject@Ogre@@QAEXI@Z	; Ogre::RenderableObject::setUserType
; Function compile flags: /Odtp
;	COMDAT ?setUserType@RenderableObject@Ogre@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_type$ = 8						; size = 4
?setUserType@RenderableObject@Ogre@@QAEXI@Z PROC	; Ogre::RenderableObject::setUserType, COMDAT
; _this$ = ecx

; 84   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 			m_UserType = type;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+268], ecx

; 86   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setUserType@RenderableObject@Ogre@@QAEXI@Z ENDP	; Ogre::RenderableObject::setUserType
_TEXT	ENDS
PUBLIC	?setDrawbackScene@RenderableObject@Ogre@@QAEX_N@Z ; Ogre::RenderableObject::setDrawbackScene
; Function compile flags: /Odtp
;	COMDAT ?setDrawbackScene@RenderableObject@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_useDrawback$ = 8					; size = 1
?setDrawbackScene@RenderableObject@Ogre@@QAEX_N@Z PROC	; Ogre::RenderableObject::setDrawbackScene, COMDAT
; _this$ = ecx

; 89   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 			m_bUseDrawback = useDrawback;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _useDrawback$[ebp]
	mov	BYTE PTR [eax+233], cl

; 91   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setDrawbackScene@RenderableObject@Ogre@@QAEX_N@Z ENDP	; Ogre::RenderableObject::setDrawbackScene
_TEXT	ENDS
PUBLIC	?isDrawbackScene@RenderableObject@Ogre@@QAE_NXZ	; Ogre::RenderableObject::isDrawbackScene
; Function compile flags: /Odtp
;	COMDAT ?isDrawbackScene@RenderableObject@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isDrawbackScene@RenderableObject@Ogre@@QAE_NXZ PROC	; Ogre::RenderableObject::isDrawbackScene, COMDAT
; _this$ = ecx

; 94   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 			return m_bUseDrawback;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+233]

; 96   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?isDrawbackScene@RenderableObject@Ogre@@QAE_NXZ ENDP	; Ogre::RenderableObject::isDrawbackScene
_TEXT	ENDS
PUBLIC	?GetBoxBound@RenderableObject@Ogre@@QAEPAVBoxBound@2@XZ ; Ogre::RenderableObject::GetBoxBound
; Function compile flags: /Odtp
;	COMDAT ?GetBoxBound@RenderableObject@Ogre@@QAEPAVBoxBound@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBoxBound@RenderableObject@Ogre@@QAEPAVBoxBound@2@XZ PROC ; Ogre::RenderableObject::GetBoxBound, COMDAT
; _this$ = ecx

; 98   : 		BoxBound* GetBoxBound(){return &m_renderBoxBound;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 236				; 000000ecH
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBoxBound@RenderableObject@Ogre@@QAEPAVBoxBound@2@XZ ENDP ; Ogre::RenderableObject::GetBoxBound
_TEXT	ENDS
PUBLIC	??_7RenderableObject@Ogre@@6B@			; Ogre::RenderableObject::`vftable'
PUBLIC	??0RenderableObject@Ogre@@IAE@XZ		; Ogre::RenderableObject::RenderableObject
PUBLIC	??_R4RenderableObject@Ogre@@6B@			; Ogre::RenderableObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRenderableObject@Ogre@@@8		; Ogre::RenderableObject `RTTI Type Descriptor'
PUBLIC	??_R3RenderableObject@Ogre@@8			; Ogre::RenderableObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RenderableObject@Ogre@@8			; Ogre::RenderableObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RenderableObject@Ogre@@8		; Ogre::RenderableObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ERenderableObject@Ogre@@MAEPAXI@Z		; Ogre::RenderableObject::`vector deleting destructor'
EXTRN	??0MovableObject@Ogre@@QAE@XZ:PROC		; Ogre::MovableObject::MovableObject
EXTRN	?setCanSel@RenderableObject@Ogre@@UAEX_N@Z:PROC	; Ogre::RenderableObject::setCanSel
;	COMDAT ??_R1A@?0A@EA@RenderableObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RenderableObject@Ogre@@8 DD FLAT:??_R0?AVRenderableObject@Ogre@@@8 ; Ogre::RenderableObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RenderableObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2RenderableObject@Ogre@@8
rdata$r	SEGMENT
??_R2RenderableObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@RenderableObject@Ogre@@8 ; Ogre::RenderableObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@MovableObject@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3RenderableObject@Ogre@@8
rdata$r	SEGMENT
??_R3RenderableObject@Ogre@@8 DD 00H			; Ogre::RenderableObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2RenderableObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRenderableObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVRenderableObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::RenderableObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRenderableObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RenderableObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4RenderableObject@Ogre@@6B@ DD 00H			; Ogre::RenderableObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRenderableObject@Ogre@@@8
	DD	FLAT:??_R3RenderableObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7RenderableObject@Ogre@@6B@
CONST	SEGMENT
??_7RenderableObject@Ogre@@6B@ DD FLAT:??_R4RenderableObject@Ogre@@6B@ ; Ogre::RenderableObject::`vftable'
	DD	FLAT:?getRTTI@RenderableObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_ERenderableObject@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?enableUVMask@RenderableObject@Ogre@@UAEX_N0@Z
	DD	FLAT:?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPBD@Z
	DD	FLAT:?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPAVTextureData@2@@Z
	DD	FLAT:?SetForceShadowMapCull@MovableObject@Ogre@@UAEX_N@Z
	DD	FLAT:?update@MovableObject@Ogre@@UAEXI@Z
	DD	FLAT:?resetUpdate@MovableObject@Ogre@@UAEX_NI@Z
	DD	FLAT:?attachToScene@MovableObject@Ogre@@UAEXPAVGameScene@2@_N@Z
	DD	FLAT:?detachFromScene@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:?intersectRay@MovableObject@Ogre@@UAE_NW4IntersectType@2@ABVRay@2@PAM@Z
	DD	FLAT:?getAnchorWorldMatrix@MovableObject@Ogre@@UAE?AVMatrix4@2@H@Z
	DD	FLAT:?invalidWorldCache@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:?updateWorldCache@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:?setCanSel@RenderableObject@Ogre@@UAEX_N@Z
	DD	FLAT:?setLayer@RenderableObject@Ogre@@UAEXW4RenderLayer@2@@Z
	DD	FLAT:?BuildDecalMesh@RenderableObject@Ogre@@UAEXABVBoxBound@2@PAVVector3@2@PAGHHAAH3@Z
	DD	FLAT:?addRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z
	DD	FLAT:?clearRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z
	DD	FLAT:?getRenderPassRequired@RenderableObject@Ogre@@UAEXAAURenderPassDesc@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RenderableObject@Ogre@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RenderableObject@Ogre@@IAE@XZ$0
__ehfuncinfo$??0RenderableObject@Ogre@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RenderableObject@Ogre@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RenderableObject@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0RenderableObject@Ogre@@IAE@XZ PROC			; Ogre::RenderableObject::RenderableObject, COMDAT
; _this$ = ecx

; 112  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RenderableObject@Ogre@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0MovableObject@Ogre@@QAE@XZ		; Ogre::MovableObject::MovableObject
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RenderableObject@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 236				; 000000ecH
	call	??0BoxBound@Ogre@@QAE@XZ		; Ogre::BoxBound::BoxBound
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+264], 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+268], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+276], 0

; 113  : 			m_numpointlight	= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+212], 0

; 114  : 			m_RenderUsageBits = (1<<RU_UI)|(1<<RU_GENERAL);

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+272], 3

; 115  : 
; 116  : 			m_bBakeStaticLight = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+232], 0

; 117  : 			m_bUseDrawback = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+233], 0

; 118  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RenderableObject@Ogre@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1MovableObject@Ogre@@UAE@XZ		; Ogre::MovableObject::~MovableObject
__ehhandler$??0RenderableObject@Ogre@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RenderableObject@Ogre@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RenderableObject@Ogre@@IAE@XZ ENDP			; Ogre::RenderableObject::RenderableObject
PUBLIC	??1RenderableObject@Ogre@@MAE@XZ		; Ogre::RenderableObject::~RenderableObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1RenderableObject@Ogre@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1RenderableObject@Ogre@@MAE@XZ$0
__ehfuncinfo$??1RenderableObject@Ogre@@MAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1RenderableObject@Ogre@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1RenderableObject@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1RenderableObject@Ogre@@MAE@XZ PROC			; Ogre::RenderableObject::~RenderableObject, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1RenderableObject@Ogre@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RenderableObject@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 122  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MovableObject@Ogre@@UAE@XZ		; Ogre::MovableObject::~MovableObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1RenderableObject@Ogre@@MAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1MovableObject@Ogre@@UAE@XZ		; Ogre::MovableObject::~MovableObject
__ehhandler$??1RenderableObject@Ogre@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1RenderableObject@Ogre@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1RenderableObject@Ogre@@MAE@XZ ENDP			; Ogre::RenderableObject::~RenderableObject
PUBLIC	??0RenderableObject@Ogre@@QAE@ABV01@@Z		; Ogre::RenderableObject::RenderableObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RenderableObject@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RenderableObject@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0RenderableObject@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RenderableObject@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RenderableObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0RenderableObject@Ogre@@QAE@ABV01@@Z PROC		; Ogre::RenderableObject::RenderableObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RenderableObject@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0MovableObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7RenderableObject@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	mov	DWORD PTR [edx+212], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 216				; 000000d8H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 216				; 000000d8H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+232]
	mov	BYTE PTR [eax+232], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+233]
	mov	BYTE PTR [eax+233], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 236				; 000000ecH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 236				; 000000ecH
	call	??0BoxBound@Ogre@@QAE@ABV01@@Z		; Ogre::BoxBound::BoxBound
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+264]
	mov	DWORD PTR [ecx+264], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+268]
	mov	DWORD PTR [ecx+268], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+272]
	mov	DWORD PTR [ecx+272], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+276]
	mov	BYTE PTR [ecx+276], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RenderableObject@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1MovableObject@Ogre@@UAE@XZ		; Ogre::MovableObject::~MovableObject
__ehhandler$??0RenderableObject@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RenderableObject@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RenderableObject@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::RenderableObject::RenderableObject
PUBLIC	??4RenderableObject@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::RenderableObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4RenderableObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_$S1$61154 = -4						; size = 4
___that$ = 8						; size = 4
??4RenderableObject@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::RenderableObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4MovableObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+212]
	mov	DWORD PTR [ecx+212], eax
	mov	DWORD PTR _$S1$61154[ebp], 0
	jmp	SHORT $LN3@operator@6
$LN2@operator@6:
	mov	ecx, DWORD PTR _$S1$61154[ebp]
	add	ecx, 1
	mov	DWORD PTR _$S1$61154[ebp], ecx
$LN3@operator@6:
	cmp	DWORD PTR _$S1$61154[ebp], 4
	jae	SHORT $LN1@operator@6
	mov	edx, DWORD PTR _$S1$61154[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _$S1$61154[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+216]
	mov	DWORD PTR [eax+edx*4+216], ecx
	jmp	SHORT $LN2@operator@6
$LN1@operator@6:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+232]
	mov	BYTE PTR [edx+232], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+233]
	mov	BYTE PTR [edx+233], cl
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 236				; 000000ecH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 236				; 000000ecH
	call	??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+264]
	mov	DWORD PTR [eax+264], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	mov	DWORD PTR [eax+268], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	mov	DWORD PTR [eax+272], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+276]
	mov	BYTE PTR [eax+276], dl
	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4RenderableObject@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::RenderableObject::operator=
_TEXT	ENDS
PUBLIC	??_GRenderableObject@Ogre@@MAEPAXI@Z		; Ogre::RenderableObject::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GRenderableObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRenderableObject@Ogre@@MAEPAXI@Z PROC		; Ogre::RenderableObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RenderableObject@Ogre@@MAE@XZ	; Ogre::RenderableObject::~RenderableObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@16
	push	280					; 00000118H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@16:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRenderableObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::RenderableObject::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ERenderableObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ERenderableObject@Ogre@@MAEPAXI@Z PROC		; Ogre::RenderableObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@16
	push	OFFSET ??1RenderableObject@Ogre@@MAE@XZ	; Ogre::RenderableObject::~RenderableObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	280					; 00000118H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@16
	push	280					; 00000118H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@16:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@16
$LN3@vector@16:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RenderableObject@Ogre@@MAE@XZ	; Ogre::RenderableObject::~RenderableObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@16
	push	280					; 00000118H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@16:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@16:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ERenderableObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::RenderableObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??0ColourValue@Ogre@@QAE@MMMM@Z			; Ogre::ColourValue::ColourValue
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrecolourvalue.h
;	COMDAT ??0ColourValue@Ogre@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_red$ = 8						; size = 4
_green$ = 12						; size = 4
_blue$ = 16						; size = 4
_alpha$ = 20						; size = 4
??0ColourValue@Ogre@@QAE@MMMM@Z PROC			; Ogre::ColourValue::ColourValue, COMDAT
; _this$ = ecx

; 68   : 		{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _red$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _green$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _blue$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _alpha$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0ColourValue@Ogre@@QAE@MMMM@Z ENDP			; Ogre::ColourValue::ColourValue
_TEXT	ENDS
PUBLIC	?set@ColourValue@Ogre@@QAEXMMMM@Z		; Ogre::ColourValue::set
; Function compile flags: /Odtp
;	COMDAT ?set@ColourValue@Ogre@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_red$ = 8						; size = 4
_green$ = 12						; size = 4
_blue$ = 16						; size = 4
_alpha$ = 20						; size = 4
?set@ColourValue@Ogre@@QAEXMMMM@Z PROC			; Ogre::ColourValue::set, COMDAT
; _this$ = ecx

; 76   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   : 			r	= red;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _red$[ebp]
	fstp	DWORD PTR [eax]

; 78   : 			g	= green;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _green$[ebp]
	fstp	DWORD PTR [ecx+4]

; 79   : 			b	= blue;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _blue$[ebp]
	fstp	DWORD PTR [edx+8]

; 80   : 			a	= alpha;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _alpha$[ebp]
	fstp	DWORD PTR [eax+12]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?set@ColourValue@Ogre@@QAEXMMMM@Z ENDP			; Ogre::ColourValue::set
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	?saturate@ColourValue@Ogre@@QAEXXZ		; Ogre::ColourValue::saturate
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?saturate@ColourValue@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?saturate@ColourValue@Ogre@@QAEXXZ PROC			; Ogre::ColourValue::saturate, COMDAT
; _this$ = ecx

; 117  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 			if (r < 0)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN12@saturate

; 119  : 				r = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx]
	jmp	SHORT $LN10@saturate
$LN12@saturate:

; 120  : 			else if (r > 1)

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN10@saturate

; 121  : 				r = 1;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax]
$LN10@saturate:

; 122  : 
; 123  : 			if (g < 0)

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@saturate

; 124  : 				g = 0;

	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+4]
	jmp	SHORT $LN7@saturate
$LN9@saturate:

; 125  : 			else if (g > 1)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN7@saturate

; 126  : 				g = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [ecx+4]
$LN7@saturate:

; 127  : 
; 128  : 			if (b < 0)

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@saturate

; 129  : 				b = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+8]
	jmp	SHORT $LN4@saturate
$LN6@saturate:

; 130  : 			else if (b > 1)

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@saturate

; 131  : 				b = 1;

	mov	edx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [edx+8]
$LN4@saturate:

; 132  : 
; 133  : 			if (a < 0)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@saturate

; 134  : 				a = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+12]
	jmp	SHORT $LN1@saturate
$LN3@saturate:

; 135  : 			else if (a > 1)

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+12]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@saturate

; 136  : 				a = 1;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax+12]
$LN1@saturate:

; 137  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?saturate@ColourValue@Ogre@@QAEXXZ ENDP			; Ogre::ColourValue::saturate
_TEXT	ENDS
PUBLIC	?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ	; Ogre::ColourValue::saturateCopy
; Function compile flags: /Odtp
;	COMDAT ?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_ret$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ PROC	; Ogre::ColourValue::saturateCopy, COMDAT
; _this$ = ecx

; 142  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 			ColourValue ret = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ret$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _ret$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _ret$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _ret$[ebp+12], edx

; 144  : 			ret.saturate();

	lea	ecx, DWORD PTR _ret$[ebp]
	call	?saturate@ColourValue@Ogre@@QAEXXZ	; Ogre::ColourValue::saturate

; 145  : 			return ret;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _ret$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _ret$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _ret$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ ENDP	; Ogre::ColourValue::saturateCopy
_TEXT	ENDS
PUBLIC	??AColourValue@Ogre@@QBEMI@Z			; Ogre::ColourValue::operator[]
; Function compile flags: /Odtp
;	COMDAT ??AColourValue@Ogre@@QBEMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??AColourValue@Ogre@@QBEMI@Z PROC			; Ogre::ColourValue::operator[], COMDAT
; _this$ = ecx

; 150  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 151  : 			assert( i < 4 );
; 152  : 
; 153  : 			return *(&r+i);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+eax*4]

; 154  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??AColourValue@Ogre@@QBEMI@Z ENDP			; Ogre::ColourValue::operator[]
_TEXT	ENDS
PUBLIC	??AColourValue@Ogre@@QAEAAMI@Z			; Ogre::ColourValue::operator[]
; Function compile flags: /Odtp
;	COMDAT ??AColourValue@Ogre@@QAEAAMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??AColourValue@Ogre@@QAEAAMI@Z PROC			; Ogre::ColourValue::operator[], COMDAT
; _this$ = ecx

; 158  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 159  : 			assert( i < 4 );
; 160  : 
; 161  : 			return *(&r+i);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 162  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??AColourValue@Ogre@@QAEAAMI@Z ENDP			; Ogre::ColourValue::operator[]
_TEXT	ENDS
PUBLIC	?ptr@ColourValue@Ogre@@QAEPAMXZ			; Ogre::ColourValue::ptr
; Function compile flags: /Odtp
;	COMDAT ?ptr@ColourValue@Ogre@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ptr@ColourValue@Ogre@@QAEPAMXZ PROC			; Ogre::ColourValue::ptr, COMDAT
; _this$ = ecx

; 166  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 			return &r;

	mov	eax, DWORD PTR _this$[ebp]

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?ptr@ColourValue@Ogre@@QAEPAMXZ ENDP			; Ogre::ColourValue::ptr
_TEXT	ENDS
PUBLIC	?ptr@ColourValue@Ogre@@QBEPBMXZ			; Ogre::ColourValue::ptr
; Function compile flags: /Odtp
;	COMDAT ?ptr@ColourValue@Ogre@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ptr@ColourValue@Ogre@@QBEPBMXZ PROC			; Ogre::ColourValue::ptr, COMDAT
; _this$ = ecx

; 171  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 			return &r;

	mov	eax, DWORD PTR _this$[ebp]

; 173  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?ptr@ColourValue@Ogre@@QBEPBMXZ ENDP			; Ogre::ColourValue::ptr
_TEXT	ENDS
PUBLIC	??HColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator+
; Function compile flags: /Odtp
;	COMDAT ??HColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kSum$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rkVector$ = 12						; size = 4
??HColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator+, COMDAT
; _this$ = ecx

; 178  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 			ColourValue kSum;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kSum$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 180  : 
; 181  : 			kSum.r = r + rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR _kSum$[ebp]

; 182  : 			kSum.g = g + rkVector.g;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _kSum$[ebp+4]

; 183  : 			kSum.b = b + rkVector.b;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [edx+8]
	fstp	DWORD PTR _kSum$[ebp+8]

; 184  : 			kSum.a = a + rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kSum$[ebp+12]

; 185  : 
; 186  : 			return kSum;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kSum$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kSum$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kSum$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kSum$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 187  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??HColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator+
_TEXT	ENDS
PUBLIC	??GColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator-
; Function compile flags: /Odtp
;	COMDAT ??GColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kDiff$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rkVector$ = 12						; size = 4
??GColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator-, COMDAT
; _this$ = ecx

; 190  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 191  : 			ColourValue kDiff;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kDiff$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 192  : 
; 193  : 			kDiff.r = r - rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _kDiff$[ebp]

; 194  : 			kDiff.g = g - rkVector.g;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR _kDiff$[ebp+4]

; 195  : 			kDiff.b = b - rkVector.b;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [edx+8]
	fstp	DWORD PTR _kDiff$[ebp+8]

; 196  : 			kDiff.a = a - rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kDiff$[ebp+12]

; 197  : 
; 198  : 			return kDiff;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kDiff$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kDiff$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kDiff$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kDiff$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 199  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??GColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator-
_TEXT	ENDS
PUBLIC	??DColourValue@Ogre@@QBE?AV01@M@Z		; Ogre::ColourValue::operator*
; Function compile flags: /Odtp
;	COMDAT ??DColourValue@Ogre@@QBE?AV01@M@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kProd$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_fScalar$ = 12						; size = 4
??DColourValue@Ogre@@QBE?AV01@M@Z PROC			; Ogre::ColourValue::operator*, COMDAT
; _this$ = ecx

; 202  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 			ColourValue kProd;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kProd$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 204  : 
; 205  : 			kProd.r = fScalar*r;

	fld	DWORD PTR _fScalar$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR _kProd$[ebp]

; 206  : 			kProd.g = fScalar*g;

	fld	DWORD PTR _fScalar$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+4]
	fstp	DWORD PTR _kProd$[ebp+4]

; 207  : 			kProd.b = fScalar*b;

	fld	DWORD PTR _fScalar$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR _kProd$[ebp+8]

; 208  : 			kProd.a = fScalar*a;

	fld	DWORD PTR _fScalar$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+12]
	fstp	DWORD PTR _kProd$[ebp+12]

; 209  : 
; 210  : 			return kProd;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _kProd$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _kProd$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _kProd$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _kProd$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??DColourValue@Ogre@@QBE?AV01@M@Z ENDP			; Ogre::ColourValue::operator*
_TEXT	ENDS
PUBLIC	??DColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator*
; Function compile flags: /Odtp
;	COMDAT ??DColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kProd$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??DColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator*, COMDAT
; _this$ = ecx

; 214  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 215  : 			ColourValue kProd;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kProd$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 216  : 
; 217  : 			kProd.r = rhs.r * r;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR _kProd$[ebp]

; 218  : 			kProd.g = rhs.g * g;

	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR _kProd$[ebp+4]

; 219  : 			kProd.b = rhs.b * b;

	mov	ecx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR _kProd$[ebp+8]

; 220  : 			kProd.a = rhs.a * a;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kProd$[ebp+12]

; 221  : 
; 222  : 			return kProd;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kProd$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kProd$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kProd$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kProd$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 223  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??DColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator*
_TEXT	ENDS
PUBLIC	??KColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator/
; Function compile flags: /Odtp
;	COMDAT ??KColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kProd$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??KColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator/, COMDAT
; _this$ = ecx

; 226  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 227  : 			ColourValue kProd;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kProd$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 228  : 
; 229  : 			kProd.r = rhs.r / r;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx]
	fstp	DWORD PTR _kProd$[ebp]

; 230  : 			kProd.g = rhs.g / g;

	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [eax+4]
	fstp	DWORD PTR _kProd$[ebp+4]

; 231  : 			kProd.b = rhs.b / b;

	mov	ecx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [edx+8]
	fstp	DWORD PTR _kProd$[ebp+8]

; 232  : 			kProd.a = rhs.a / a;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kProd$[ebp+12]

; 233  : 
; 234  : 			return kProd;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kProd$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kProd$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kProd$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kProd$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 235  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??KColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator/
_TEXT	ENDS
PUBLIC	??KColourValue@Ogre@@QBE?AV01@M@Z		; Ogre::ColourValue::operator/
; Function compile flags: /Odtp
;	COMDAT ??KColourValue@Ogre@@QBE?AV01@M@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_kDiv$ = -20						; size = 16
_fInv$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_fScalar$ = 12						; size = 4
??KColourValue@Ogre@@QBE?AV01@M@Z PROC			; Ogre::ColourValue::operator/, COMDAT
; _this$ = ecx

; 238  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 			assert( fScalar != 0.0f );
; 240  : 
; 241  : 			ColourValue kDiv;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kDiv$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 242  : 
; 243  : 			float fInv = 1.0f / fScalar;

	fld	DWORD PTR _fScalar$[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _fInv$[ebp]

; 244  : 			kDiv.r = r * fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp]

; 245  : 			kDiv.g = g * fInv;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp+4]

; 246  : 			kDiv.b = b * fInv;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp+8]

; 247  : 			kDiv.a = a * fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp+12]

; 248  : 
; 249  : 			return kDiv;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _kDiv$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _kDiv$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _kDiv$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _kDiv$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 250  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??KColourValue@Ogre@@QBE?AV01@M@Z ENDP			; Ogre::ColourValue::operator/
_TEXT	ENDS
PUBLIC	??YColourValue@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::ColourValue::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YColourValue@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rkVector$ = 8						; size = 4
??YColourValue@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ColourValue::operator+=, COMDAT
; _this$ = ecx

; 266  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 267  : 			r += rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 268  : 			g += rkVector.g;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 269  : 			b += rkVector.b;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 270  : 			a += rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+12]

; 271  : 
; 272  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 273  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YColourValue@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator+=
_TEXT	ENDS
PUBLIC	??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::ColourValue::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rkVector$ = 8						; size = 4
??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ColourValue::operator-=, COMDAT
; _this$ = ecx

; 276  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 			r -= rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 278  : 			g -= rkVector.g;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 279  : 			b -= rkVector.b;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 280  : 			a -= rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+12]

; 281  : 
; 282  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 283  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator-=
_TEXT	ENDS
PUBLIC	??XColourValue@Ogre@@QAEAAV01@M@Z		; Ogre::ColourValue::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XColourValue@Ogre@@QAEAAV01@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fScalar$ = 8						; size = 4
??XColourValue@Ogre@@QAEAAV01@M@Z PROC			; Ogre::ColourValue::operator*=, COMDAT
; _this$ = ecx

; 286  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 287  : 			r *= fScalar;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 288  : 			g *= fScalar;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 289  : 			b *= fScalar;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 290  : 			a *= fScalar;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 291  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 292  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XColourValue@Ogre@@QAEAAV01@M@Z ENDP			; Ogre::ColourValue::operator*=
_TEXT	ENDS
PUBLIC	??_0ColourValue@Ogre@@QAEAAV01@M@Z		; Ogre::ColourValue::operator/=
; Function compile flags: /Odtp
;	COMDAT ??_0ColourValue@Ogre@@QAEAAV01@M@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fInv$ = -4						; size = 4
_fScalar$ = 8						; size = 4
??_0ColourValue@Ogre@@QAEAAV01@M@Z PROC			; Ogre::ColourValue::operator/=, COMDAT
; _this$ = ecx

; 295  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 296  : 			assert( fScalar != 0.0 );
; 297  : 
; 298  : 			float fInv = 1.0f / fScalar;

	fld	DWORD PTR _fScalar$[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _fInv$[ebp]

; 299  : 
; 300  : 			r *= fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _fInv$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 301  : 			g *= fInv;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _fInv$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 302  : 			b *= fInv;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _fInv$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 303  : 			a *= fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _fInv$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 304  : 
; 305  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 306  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??_0ColourValue@Ogre@@QAEAAV01@M@Z ENDP			; Ogre::ColourValue::operator/=
_TEXT	ENDS
PUBLIC	??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::ColourValue::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ColourValue::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator=
_TEXT	ENDS
PUBLIC	??_FColourValue@Ogre@@QAEXXZ			; Ogre::ColourValue::`default constructor closure'
; Function compile flags: /Odtp
;	COMDAT ??_FColourValue@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??_FColourValue@Ogre@@QAEXXZ PROC			; Ogre::ColourValue::`default constructor closure', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue
	mov	esp, ebp
	pop	ebp
	ret	0
??_FColourValue@Ogre@@QAEXXZ ENDP			; Ogre::ColourValue::`default constructor closure'
_TEXT	ENDS
PUBLIC	??0Vector2@Ogre@@QAE@XZ				; Ogre::Vector2::Vector2
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector2.h
;	COMDAT ??0Vector2@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector2@Ogre@@QAE@XZ PROC				; Ogre::Vector2::Vector2, COMDAT
; _this$ = ecx

; 50   : 		Vector2(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector2@Ogre@@QAE@XZ ENDP				; Ogre::Vector2::Vector2
_TEXT	ENDS
PUBLIC	??0Vector2@Ogre@@QAE@MM@Z			; Ogre::Vector2::Vector2
; Function compile flags: /Odtp
;	COMDAT ??0Vector2@Ogre@@QAE@MM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
??0Vector2@Ogre@@QAE@MM@Z PROC				; Ogre::Vector2::Vector2, COMDAT
; _this$ = ecx

; 51   : 		Vector2( float x1, float y1 ) : x(x1), y(y1){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Vector2@Ogre@@QAE@MM@Z ENDP				; Ogre::Vector2::Vector2
_TEXT	ENDS
PUBLIC	??0Vector2@Ogre@@QAE@M@Z			; Ogre::Vector2::Vector2
; Function compile flags: /Odtp
;	COMDAT ??0Vector2@Ogre@@QAE@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector2@Ogre@@QAE@M@Z PROC				; Ogre::Vector2::Vector2, COMDAT
; _this$ = ecx

; 52   : 		Vector2(float v) : x(v), y(v){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector2@Ogre@@QAE@M@Z ENDP				; Ogre::Vector2::Vector2
_TEXT	ENDS
PUBLIC	??4Vector2@Ogre@@QAEABV01@ABV01@@Z		; Ogre::Vector2::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Vector2@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??4Vector2@Ogre@@QAEABV01@ABV01@@Z PROC			; Ogre::Vector2::operator=, COMDAT
; _this$ = ecx

; 55   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 			x = vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 57   : 			y = vec.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 58   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 59   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4Vector2@Ogre@@QAEABV01@ABV01@@Z ENDP			; Ogre::Vector2::operator=
_TEXT	ENDS
PUBLIC	??YVector2@Ogre@@QAEXABV01@@Z			; Ogre::Vector2::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YVector2@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??YVector2@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector2::operator+=, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			x += vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 63   : 			y += vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 64   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YVector2@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector2::operator+=
_TEXT	ENDS
PUBLIC	??ZVector2@Ogre@@QAEXABV01@@Z			; Ogre::Vector2::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZVector2@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??ZVector2@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector2::operator-=, COMDAT
; _this$ = ecx

; 66   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 			x -= vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 68   : 			y -= vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 69   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZVector2@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector2::operator-=
_TEXT	ENDS
PUBLIC	??XVector2@Ogre@@QAEXM@Z			; Ogre::Vector2::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XVector2@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??XVector2@Ogre@@QAEXM@Z PROC				; Ogre::Vector2::operator*=, COMDAT
; _this$ = ecx

; 71   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 			x *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 73   : 			y *= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XVector2@Ogre@@QAEXM@Z ENDP				; Ogre::Vector2::operator*=
_TEXT	ENDS
PUBLIC	??_0Vector2@Ogre@@QAEXM@Z			; Ogre::Vector2::operator/=
; Function compile flags: /Odtp
;	COMDAT ??_0Vector2@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??_0Vector2@Ogre@@QAEXM@Z PROC				; Ogre::Vector2::operator/=, COMDAT
; _this$ = ecx

; 76   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   : 			x /= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fdiv	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 78   : 			y /= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fdiv	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 79   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??_0Vector2@Ogre@@QAEXM@Z ENDP				; Ogre::Vector2::operator/=
_TEXT	ENDS
PUBLIC	??8Vector2@Ogre@@QAE_NABV01@@Z			; Ogre::Vector2::operator==
; Function compile flags: /Odtp
;	COMDAT ??8Vector2@Ogre@@QAE_NABV01@@Z
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??8Vector2@Ogre@@QAE_NABV01@@Z PROC			; Ogre::Vector2::operator==, COMDAT
; _this$ = ecx

; 81   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 			return x==vec.x&&y==vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator@7
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator@7
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@operator@7
$LN3@operator@7:
	mov	DWORD PTR tv72[ebp], 0
$LN4@operator@7:
	mov	al, BYTE PTR tv72[ebp]

; 83   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector2@Ogre@@QAE_NABV01@@Z ENDP			; Ogre::Vector2::operator==
_TEXT	ENDS
PUBLIC	??9Vector2@Ogre@@QAE_NABV01@@Z			; Ogre::Vector2::operator!=
; Function compile flags: /Odtp
;	COMDAT ??9Vector2@Ogre@@QAE_NABV01@@Z
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??9Vector2@Ogre@@QAE_NABV01@@Z PROC			; Ogre::Vector2::operator!=, COMDAT
; _this$ = ecx

; 85   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 			return x!=vec.x||y!=vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator@8
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator@8
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@operator@8
$LN3@operator@8:
	mov	DWORD PTR tv72[ebp], 1
$LN4@operator@8:
	mov	al, BYTE PTR tv72[ebp]

; 87   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector2@Ogre@@QAE_NABV01@@Z ENDP			; Ogre::Vector2::operator!=
_TEXT	ENDS
PUBLIC	??BVector2@Ogre@@QAEPAMXZ			; Ogre::Vector2::operator float *
; Function compile flags: /Odtp
;	COMDAT ??BVector2@Ogre@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector2@Ogre@@QAEPAMXZ PROC				; Ogre::Vector2::operator float *, COMDAT
; _this$ = ecx

; 89   : 		operator float *(){ return &x; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector2@Ogre@@QAEPAMXZ ENDP				; Ogre::Vector2::operator float *
_TEXT	ENDS
PUBLIC	??BVector2@Ogre@@QBEPBMXZ			; Ogre::Vector2::operator float const *
; Function compile flags: /Odtp
;	COMDAT ??BVector2@Ogre@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector2@Ogre@@QBEPBMXZ PROC				; Ogre::Vector2::operator float const *, COMDAT
; _this$ = ecx

; 90   : 		operator const float *() const{ return &x; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector2@Ogre@@QBEPBMXZ ENDP				; Ogre::Vector2::operator float const *
_TEXT	ENDS
PUBLIC	??HVector2@Ogre@@QBE?AV01@XZ			; Ogre::Vector2::operator+
; Function compile flags: /Odtp
;	COMDAT ??HVector2@Ogre@@QBE?AV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??HVector2@Ogre@@QBE?AV01@XZ PROC			; Ogre::Vector2::operator+, COMDAT
; _this$ = ecx

; 91   : 		Vector2 operator +() const{ return *this; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??HVector2@Ogre@@QBE?AV01@XZ ENDP			; Ogre::Vector2::operator+
_TEXT	ENDS
PUBLIC	??GVector2@Ogre@@QBE?AV01@XZ			; Ogre::Vector2::operator-
; Function compile flags: /Odtp
;	COMDAT ??GVector2@Ogre@@QBE?AV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??GVector2@Ogre@@QBE?AV01@XZ PROC			; Ogre::Vector2::operator-, COMDAT
; _this$ = ecx

; 92   : 		Vector2 operator -() const{ return Vector2(-x,-y);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector2@Ogre@@QAE@MM@Z		; Ogre::Vector2::Vector2
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??GVector2@Ogre@@QBE?AV01@XZ ENDP			; Ogre::Vector2::operator-
_TEXT	ENDS
PUBLIC	?setElement@Vector2@Ogre@@QAEXMM@Z		; Ogre::Vector2::setElement
; Function compile flags: /Odtp
;	COMDAT ?setElement@Vector2@Ogre@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
?setElement@Vector2@Ogre@@QAEXMM@Z PROC			; Ogre::Vector2::setElement, COMDAT
; _this$ = ecx

; 95   : 		{ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 			x = x1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]

; 97   : 			y = y1;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]

; 98   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setElement@Vector2@Ogre@@QAEXMM@Z ENDP			; Ogre::Vector2::setElement
_TEXT	ENDS
PUBLIC	?length@Vector2@Ogre@@QBEMXZ			; Ogre::Vector2::length
; Function compile flags: /Odtp
;	COMDAT ?length@Vector2@Ogre@@QBEMXZ
_TEXT	SEGMENT
tv80 = -8						; size = 4
_this$ = -4						; size = 4
?length@Vector2@Ogre@@QBEMXZ PROC			; Ogre::Vector2::length, COMDAT
; _this$ = ecx

; 100  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 			return (float)sqrt(x*x + y*y);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv80[ebp]
	fld	DWORD PTR tv80[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4

; 102  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@Vector2@Ogre@@QBEMXZ ENDP			; Ogre::Vector2::length
_TEXT	ENDS
PUBLIC	?lengthSqr@Vector2@Ogre@@QBEMXZ			; Ogre::Vector2::lengthSqr
; Function compile flags: /Odtp
;	COMDAT ?lengthSqr@Vector2@Ogre@@QBEMXZ
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
?lengthSqr@Vector2@Ogre@@QBEMXZ PROC			; Ogre::Vector2::lengthSqr, COMDAT
; _this$ = ecx

; 104  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 			return x*x + y*y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv78[ebp]
	fld	DWORD PTR tv78[ebp]

; 106  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?lengthSqr@Vector2@Ogre@@QBEMXZ ENDP			; Ogre::Vector2::lengthSqr
_TEXT	ENDS
PUBLIC	??0?$TBox@H@Ogre@@QAE@XZ			; Ogre::TBox<int>::TBox<int>
PUBLIC	??0PixelBox@Ogre@@QAE@XZ			; Ogre::PixelBox::PixelBox
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrepixelformat.h
;	COMDAT ??0PixelBox@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0PixelBox@Ogre@@QAE@XZ PROC				; Ogre::PixelBox::PixelBox, COMDAT
; _this$ = ecx

; 183  : 		PixelBox() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$TBox@H@Ogre@@QAE@XZ		; Ogre::TBox<int>::TBox<int>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0PixelBox@Ogre@@QAE@XZ ENDP				; Ogre::PixelBox::PixelBox
_TEXT	ENDS
PUBLIC	?setConsecutive@PixelBox@Ogre@@QAEXXZ		; Ogre::PixelBox::setConsecutive
PUBLIC	??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z ; Ogre::PixelBox::PixelBox
; Function compile flags: /Odtp
;	COMDAT ??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_extents$ = 8						; size = 4
_pixelFormat$ = 12					; size = 4
_pixelData$ = 16					; size = 4
??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z PROC ; Ogre::PixelBox::PixelBox, COMDAT
; _this$ = ecx

; 193  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _extents$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pixelData$[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pixelFormat$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 194  : 			setConsecutive();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setConsecutive@PixelBox@Ogre@@QAEXXZ	; Ogre::PixelBox::setConsecutive

; 195  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z ENDP ; Ogre::PixelBox::PixelBox
_TEXT	ENDS
PUBLIC	??0?$TBox@H@Ogre@@QAE@HHHHHH@Z			; Ogre::TBox<int>::TBox<int>
PUBLIC	??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z	; Ogre::PixelBox::PixelBox
; Function compile flags: /Odtp
;	COMDAT ??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_depth$ = 16						; size = 4
_pixelFormat$ = 20					; size = 4
_pixelData$ = 24					; size = 4
??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z PROC	; Ogre::PixelBox::PixelBox, COMDAT
; _this$ = ecx

; 208  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$TBox@H@Ogre@@QAE@HHHHHH@Z		; Ogre::TBox<int>::TBox<int>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pixelData$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pixelFormat$[ebp]
	mov	DWORD PTR [edx+28], eax

; 209  : 			setConsecutive();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setConsecutive@PixelBox@Ogre@@QAEXXZ	; Ogre::PixelBox::setConsecutive

; 210  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z ENDP	; Ogre::PixelBox::PixelBox
_TEXT	ENDS
PUBLIC	?getHeight@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getHeight
PUBLIC	?getWidth@?$TBox@H@Ogre@@QBEHXZ			; Ogre::TBox<int>::getWidth
; Function compile flags: /Odtp
;	COMDAT ?setConsecutive@PixelBox@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?setConsecutive@PixelBox@Ogre@@QAEXXZ PROC		; Ogre::PixelBox::setConsecutive, COMDAT
; _this$ = ecx

; 232  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 			rowPitch = getWidth();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 234  : 			slicePitch = getWidth()*getHeight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getHeight@?$TBox@H@Ogre@@QBEHXZ	; Ogre::TBox<int>::getHeight
	imul	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], esi

; 235  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?setConsecutive@PixelBox@Ogre@@QAEXXZ ENDP		; Ogre::PixelBox::setConsecutive
_TEXT	ENDS
PUBLIC	?getRowSkip@PixelBox@Ogre@@QBEIXZ		; Ogre::PixelBox::getRowSkip
; Function compile flags: /Odtp
;	COMDAT ?getRowSkip@PixelBox@Ogre@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRowSkip@PixelBox@Ogre@@QBEIXZ PROC			; Ogre::PixelBox::getRowSkip, COMDAT
; _this$ = ecx

; 240  : 		size_t getRowSkip() const { return rowPitch - getWidth(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	sub	edx, eax
	mov	eax, edx
	mov	esp, ebp
	pop	ebp
	ret	0
?getRowSkip@PixelBox@Ogre@@QBEIXZ ENDP			; Ogre::PixelBox::getRowSkip
_TEXT	ENDS
PUBLIC	?getSliceSkip@PixelBox@Ogre@@QBEIXZ		; Ogre::PixelBox::getSliceSkip
; Function compile flags: /Odtp
;	COMDAT ?getSliceSkip@PixelBox@Ogre@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSliceSkip@PixelBox@Ogre@@QBEIXZ PROC		; Ogre::PixelBox::getSliceSkip, COMDAT
; _this$ = ecx

; 245  : 		size_t getSliceSkip() const { return slicePitch - (getHeight() * rowPitch); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getHeight@?$TBox@H@Ogre@@QBEHXZ	; Ogre::TBox<int>::getHeight
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	sub	ecx, eax
	mov	eax, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?getSliceSkip@PixelBox@Ogre@@QBEIXZ ENDP		; Ogre::PixelBox::getSliceSkip
_TEXT	ENDS
PUBLIC	?isConsecutive@PixelBox@Ogre@@QBE_NXZ		; Ogre::PixelBox::isConsecutive
; Function compile flags: /Odtp
;	COMDAT ?isConsecutive@PixelBox@Ogre@@QBE_NXZ
_TEXT	SEGMENT
tv87 = -8						; size = 4
_this$ = -4						; size = 4
?isConsecutive@PixelBox@Ogre@@QBE_NXZ PROC		; Ogre::PixelBox::isConsecutive, COMDAT
; _this$ = ecx

; 251  : 		{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 			return rowPitch == getWidth() && slicePitch == getWidth()*getHeight(); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], eax
	jne	SHORT $LN3@isConsecut
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getHeight@?$TBox@H@Ogre@@QBEHXZ	; Ogre::TBox<int>::getHeight
	imul	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], esi
	jne	SHORT $LN3@isConsecut
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN4@isConsecut
$LN3@isConsecut:
	mov	DWORD PTR tv87[ebp], 0
$LN4@isConsecut:
	mov	al, BYTE PTR tv87[ebp]

; 253  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?isConsecutive@PixelBox@Ogre@@QBE_NXZ ENDP		; Ogre::PixelBox::isConsecutive
_TEXT	ENDS
PUBLIC	??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::TBox<int>::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::TBox<int>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::TBox<int>::operator=
_TEXT	ENDS
PUBLIC	??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::PixelBox::operator=
; Function compile flags: /Odtp
;	COMDAT ??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::PixelBox::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, 10					; 0000000aH
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::PixelBox::operator=
_TEXT	ENDS
PUBLIC	??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::PixelUtil::operator=
; Function compile flags: /Odtp
;	COMDAT ??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::PixelUtil::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::PixelUtil::operator=
_TEXT	ENDS
PUBLIC	??4LockSection@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::LockSection::operator=
; Function compile flags: /Odtp
;	COMDAT ??4LockSection@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4LockSection@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::LockSection::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4LockSection@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::LockSection::operator=
_TEXT	ENDS
PUBLIC	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z	; Ogre::LockFunctor::LockFunctor
EXTRN	?Lock@LockSection@Ogre@@QAEXXZ:PROC		; Ogre::LockSection::Lock
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrelocker.h
;	COMDAT ??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSection$ = 8						; size = 4
??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z PROC	; Ogre::LockFunctor::LockFunctor, COMDAT
; _this$ = ecx

; 26   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax], ecx

; 27   : 			if(m_pSection == NULL) return;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN1@LockFuncto
	jmp	SHORT $LN2@LockFuncto
$LN1@LockFuncto:

; 28   : 			assert( m_pSection );
; 29   : 			m_pSection->Lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?Lock@LockSection@Ogre@@QAEXXZ		; Ogre::LockSection::Lock
$LN2@LockFuncto:

; 30   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ENDP	; Ogre::LockFunctor::LockFunctor
_TEXT	ENDS
PUBLIC	??1LockFunctor@Ogre@@QAE@XZ			; Ogre::LockFunctor::~LockFunctor
EXTRN	?Unlock@LockSection@Ogre@@QAEXXZ:PROC		; Ogre::LockSection::Unlock
; Function compile flags: /Odtp
;	COMDAT ??1LockFunctor@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1LockFunctor@Ogre@@QAE@XZ PROC			; Ogre::LockFunctor::~LockFunctor, COMDAT
; _this$ = ecx

; 33   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 34   : 			if( m_pSection )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@LockFuncto@2

; 35   : 			{
; 36   : 				m_pSection->Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?Unlock@LockSection@Ogre@@QAEXXZ	; Ogre::LockSection::Unlock
$LN2@LockFuncto@2:

; 37   : 			}			
; 38   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1LockFunctor@Ogre@@QAE@XZ ENDP			; Ogre::LockFunctor::~LockFunctor
_TEXT	ENDS
PUBLIC	??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::LockFunctor::operator=
; Function compile flags: /Odtp
;	COMDAT ??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::LockFunctor::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::LockFunctor::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::SurfaceData::getRTTI
EXTRN	?m_RTTI@SurfaceData@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::SurfaceData::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogretexture.h
;	COMDAT ?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::SurfaceData::getRTTI, COMDAT
; _this$ = ecx

; 32   : 		DECLARE_RTTI(SurfaceData)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@SurfaceData@Ogre@@2VRuntimeClass@2@B ; Ogre::SurfaceData::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::SurfaceData::getRTTI
_TEXT	ENDS
PUBLIC	?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::SurfaceData::newObject
EXTRN	??0SurfaceData@Ogre@@QAE@XZ:PROC		; Ogre::SurfaceData::SurfaceData
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T90509 = -20						; size = 4
$T90508 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::SurfaceData::newObject, COMDAT

; 32   : 		DECLARE_RTTI(SurfaceData)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	60					; 0000003cH
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T90509[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T90509[ebp], 0
	je	SHORT $LN3@newObject@2
	mov	ecx, DWORD PTR $T90509[ebp]
	call	??0SurfaceData@Ogre@@QAE@XZ		; Ogre::SurfaceData::SurfaceData
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@2
$LN3@newObject@2:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@2:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T90508[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T90508[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	60					; 0000003cH
	mov	eax, DWORD PTR $T90509[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::SurfaceData::newObject
PUBLIC	??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char> >::operator[]
PUBLIC	?getBits@SurfaceData@Ogre@@QAEPAXXZ		; Ogre::SurfaceData::getBits
; Function compile flags: /Odtp
;	COMDAT ?getBits@SurfaceData@Ogre@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBits@SurfaceData@Ogre@@QAEPAXXZ PROC		; Ogre::SurfaceData::getBits, COMDAT
; _this$ = ecx

; 38   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 			return &m_Pixels[0];

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char> >::operator[]

; 40   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getBits@SurfaceData@Ogre@@QAEPAXXZ ENDP		; Ogre::SurfaceData::getBits
_TEXT	ENDS
PUBLIC	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
PUBLIC	??1SurfaceData@Ogre@@UAE@XZ			; Ogre::SurfaceData::~SurfaceData
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1SurfaceData@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1SurfaceData@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1SurfaceData@Ogre@@UAE@XZ$1
__ehfuncinfo$??1SurfaceData@Ogre@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1SurfaceData@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1SurfaceData@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1SurfaceData@Ogre@@UAE@XZ PROC			; Ogre::SurfaceData::~SurfaceData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1SurfaceData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1SurfaceData@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??1SurfaceData@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
__ehhandler$??1SurfaceData@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1SurfaceData@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1SurfaceData@Ogre@@UAE@XZ ENDP			; Ogre::SurfaceData::~SurfaceData
PUBLIC	??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
PUBLIC	??_7SurfaceData@Ogre@@6B@			; Ogre::SurfaceData::`vftable'
PUBLIC	??0SurfaceData@Ogre@@QAE@ABV01@@Z		; Ogre::SurfaceData::SurfaceData
PUBLIC	??_R4SurfaceData@Ogre@@6B@			; Ogre::SurfaceData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSurfaceData@Ogre@@@8			; Ogre::SurfaceData `RTTI Type Descriptor'
PUBLIC	??_R3SurfaceData@Ogre@@8			; Ogre::SurfaceData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SurfaceData@Ogre@@8			; Ogre::SurfaceData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SurfaceData@Ogre@@8		; Ogre::SurfaceData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ESurfaceData@Ogre@@UAEPAXI@Z			; Ogre::SurfaceData::`vector deleting destructor'
EXTRN	?_serialize@SurfaceData@Ogre@@EAEXAAVArchive@2@H@Z:PROC ; Ogre::SurfaceData::_serialize
;	COMDAT ??_R1A@?0A@EA@SurfaceData@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SurfaceData@Ogre@@8 DD FLAT:??_R0?AVSurfaceData@Ogre@@@8 ; Ogre::SurfaceData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SurfaceData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2SurfaceData@Ogre@@8
rdata$r	SEGMENT
??_R2SurfaceData@Ogre@@8 DD FLAT:??_R1A@?0A@EA@SurfaceData@Ogre@@8 ; Ogre::SurfaceData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3SurfaceData@Ogre@@8
rdata$r	SEGMENT
??_R3SurfaceData@Ogre@@8 DD 00H				; Ogre::SurfaceData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2SurfaceData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSurfaceData@Ogre@@@8
_DATA	SEGMENT
??_R0?AVSurfaceData@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::SurfaceData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSurfaceData@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SurfaceData@Ogre@@6B@
rdata$r	SEGMENT
??_R4SurfaceData@Ogre@@6B@ DD 00H			; Ogre::SurfaceData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSurfaceData@Ogre@@@8
	DD	FLAT:??_R3SurfaceData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7SurfaceData@Ogre@@6B@
CONST	SEGMENT
??_7SurfaceData@Ogre@@6B@ DD FLAT:??_R4SurfaceData@Ogre@@6B@ ; Ogre::SurfaceData::`vftable'
	DD	FLAT:?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@SurfaceData@Ogre@@EAEXAAVArchive@2@H@Z
	DD	FLAT:??_ESurfaceData@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SurfaceData@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SurfaceData@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SurfaceData@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0SurfaceData@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SurfaceData@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0SurfaceData@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0SurfaceData@Ogre@@QAE@ABV01@@Z PROC			; Ogre::SurfaceData::SurfaceData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SurfaceData@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7SurfaceData@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SurfaceData@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0SurfaceData@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
__ehhandler$??0SurfaceData@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SurfaceData@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SurfaceData@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::SurfaceData::SurfaceData
PUBLIC	??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<char,std::allocator<char> >::operator=
PUBLIC	??4SurfaceData@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::SurfaceData::operator=
; Function compile flags: /Odtp
;	COMDAT ??4SurfaceData@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4SurfaceData@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::SurfaceData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<char,std::allocator<char> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4SurfaceData@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::SurfaceData::operator=
_TEXT	ENDS
PUBLIC	??_GSurfaceData@Ogre@@UAEPAXI@Z			; Ogre::SurfaceData::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GSurfaceData@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSurfaceData@Ogre@@UAEPAXI@Z PROC			; Ogre::SurfaceData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SurfaceData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@17
	push	60					; 0000003cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@17:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSurfaceData@Ogre@@UAEPAXI@Z ENDP			; Ogre::SurfaceData::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ESurfaceData@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ESurfaceData@Ogre@@UAEPAXI@Z PROC			; Ogre::SurfaceData::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@17
	push	OFFSET ??1SurfaceData@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	60					; 0000003cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@17
	push	60					; 0000003cH
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@17:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@17
$LN3@vector@17:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SurfaceData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@17
	push	60					; 0000003cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@17:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@17:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ESurfaceData@Ogre@@UAEPAXI@Z ENDP			; Ogre::SurfaceData::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::DummyTexture::getRTTI
EXTRN	?m_RTTI@DummyTexture@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::DummyTexture::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::DummyTexture::getRTTI, COMDAT
; _this$ = ecx

; 64   : 		DECLARE_RTTI(DummyTexture)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@DummyTexture@Ogre@@2VRuntimeClass@2@B ; Ogre::DummyTexture::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::DummyTexture::getRTTI
_TEXT	ENDS
PUBLIC	??0DummyTexture@Ogre@@QAE@XZ			; Ogre::DummyTexture::DummyTexture
PUBLIC	?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::DummyTexture::newObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T90552 = -20						; size = 4
$T90551 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::DummyTexture::newObject, COMDAT

; 64   : 		DECLARE_RTTI(DummyTexture)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	16					; 00000010H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T90552[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T90552[ebp], 0
	je	SHORT $LN3@newObject@3
	mov	ecx, DWORD PTR $T90552[ebp]
	call	??0DummyTexture@Ogre@@QAE@XZ
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@3
$LN3@newObject@3:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@3:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T90551[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T90551[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	16					; 00000010H
	mov	eax, DWORD PTR $T90552[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::DummyTexture::newObject
PUBLIC	?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z ; Ogre::DummyTexture::getDesc
; Function compile flags: /Odtp
;	COMDAT ?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_desc$ = 8						; size = 4
?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z PROC ; Ogre::DummyTexture::getDesc, COMDAT
; _this$ = ecx

; 67   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 			assert(0);
; 69   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z ENDP ; Ogre::DummyTexture::getDesc
_TEXT	ENDS
PUBLIC	?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ ; Ogre::DummyTexture::getHardwareTexture
; Function compile flags: /Odtp
;	COMDAT ?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ PROC ; Ogre::DummyTexture::getHardwareTexture, COMDAT
; _this$ = ecx

; 72   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 73   : 			return NULL;

	xor	eax, eax

; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ ENDP ; Ogre::DummyTexture::getHardwareTexture
_TEXT	ENDS
PUBLIC	?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z ; Ogre::DummyTexture::lock
; Function compile flags: /Odtp
;	COMDAT ?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_face$ = 8						; size = 4
_level$ = 12						; size = 4
_readonly$ = 16						; size = 1
_lockresult$ = 20					; size = 4
?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z PROC ; Ogre::DummyTexture::lock, COMDAT
; _this$ = ecx

; 77   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 			return NULL;

	xor	eax, eax

; 79   : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z ENDP ; Ogre::DummyTexture::lock
_TEXT	ENDS
PUBLIC	?unlock@DummyTexture@Ogre@@UAEXII@Z		; Ogre::DummyTexture::unlock
; Function compile flags: /Odtp
;	COMDAT ?unlock@DummyTexture@Ogre@@UAEXII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_face$ = 8						; size = 4
_level$ = 12						; size = 4
?unlock@DummyTexture@Ogre@@UAEXII@Z PROC		; Ogre::DummyTexture::unlock, COMDAT
; _this$ = ecx

; 82   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?unlock@DummyTexture@Ogre@@UAEXII@Z ENDP		; Ogre::DummyTexture::unlock
_TEXT	ENDS
PUBLIC	??_7DummyTexture@Ogre@@6B@			; Ogre::DummyTexture::`vftable'
PUBLIC	??1DummyTexture@Ogre@@EAE@XZ			; Ogre::DummyTexture::~DummyTexture
PUBLIC	??_R4DummyTexture@Ogre@@6B@			; Ogre::DummyTexture::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDummyTexture@Ogre@@@8			; Ogre::DummyTexture `RTTI Type Descriptor'
PUBLIC	??_R3DummyTexture@Ogre@@8			; Ogre::DummyTexture::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DummyTexture@Ogre@@8			; Ogre::DummyTexture::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DummyTexture@Ogre@@8		; Ogre::DummyTexture::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDummyTexture@Ogre@@EAEPAXI@Z		; Ogre::DummyTexture::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@DummyTexture@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DummyTexture@Ogre@@8 DD FLAT:??_R0?AVDummyTexture@Ogre@@@8 ; Ogre::DummyTexture::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DummyTexture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DummyTexture@Ogre@@8
rdata$r	SEGMENT
??_R2DummyTexture@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DummyTexture@Ogre@@8 ; Ogre::DummyTexture::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Texture@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3DummyTexture@Ogre@@8
rdata$r	SEGMENT
??_R3DummyTexture@Ogre@@8 DD 00H			; Ogre::DummyTexture::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2DummyTexture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDummyTexture@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDummyTexture@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::DummyTexture `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDummyTexture@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DummyTexture@Ogre@@6B@
rdata$r	SEGMENT
??_R4DummyTexture@Ogre@@6B@ DD 00H			; Ogre::DummyTexture::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDummyTexture@Ogre@@@8
	DD	FLAT:??_R3DummyTexture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DummyTexture@Ogre@@6B@
CONST	SEGMENT
??_7DummyTexture@Ogre@@6B@ DD FLAT:??_R4DummyTexture@Ogre@@6B@ ; Ogre::DummyTexture::`vftable'
	DD	FLAT:?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EDummyTexture@Ogre@@EAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z
	DD	FLAT:?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
	DD	FLAT:?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z
	DD	FLAT:?unlock@DummyTexture@Ogre@@UAEXII@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1DummyTexture@Ogre@@EAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DummyTexture@Ogre@@EAE@XZ$0
__ehfuncinfo$??1DummyTexture@Ogre@@EAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1DummyTexture@Ogre@@EAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1DummyTexture@Ogre@@EAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1DummyTexture@Ogre@@EAE@XZ PROC			; Ogre::DummyTexture::~DummyTexture, COMDAT
; _this$ = ecx

; 87   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DummyTexture@Ogre@@EAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DummyTexture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 88   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DummyTexture@Ogre@@EAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??1DummyTexture@Ogre@@EAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1DummyTexture@Ogre@@EAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1DummyTexture@Ogre@@EAE@XZ ENDP			; Ogre::DummyTexture::~DummyTexture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DummyTexture@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DummyTexture@Ogre@@QAE@XZ$0
__ehfuncinfo$??0DummyTexture@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DummyTexture@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DummyTexture@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0DummyTexture@Ogre@@QAE@XZ PROC			; Ogre::DummyTexture::DummyTexture, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DummyTexture@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DummyTexture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DummyTexture@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??0DummyTexture@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DummyTexture@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DummyTexture@Ogre@@QAE@XZ ENDP			; Ogre::DummyTexture::DummyTexture
PUBLIC	??0DummyTexture@Ogre@@QAE@ABV01@@Z		; Ogre::DummyTexture::DummyTexture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DummyTexture@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DummyTexture@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0DummyTexture@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DummyTexture@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DummyTexture@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0DummyTexture@Ogre@@QAE@ABV01@@Z PROC			; Ogre::DummyTexture::DummyTexture, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DummyTexture@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7DummyTexture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DummyTexture@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??0DummyTexture@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DummyTexture@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DummyTexture@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::DummyTexture::DummyTexture
PUBLIC	??4DummyTexture@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::DummyTexture::operator=
; Function compile flags: /Odtp
;	COMDAT ??4DummyTexture@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DummyTexture@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::DummyTexture::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Texture@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DummyTexture@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::DummyTexture::operator=
_TEXT	ENDS
PUBLIC	??_GDummyTexture@Ogre@@EAEPAXI@Z		; Ogre::DummyTexture::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GDummyTexture@Ogre@@EAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDummyTexture@Ogre@@EAEPAXI@Z PROC			; Ogre::DummyTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DummyTexture@Ogre@@EAE@XZ		; Ogre::DummyTexture::~DummyTexture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@18
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@18:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDummyTexture@Ogre@@EAEPAXI@Z ENDP			; Ogre::DummyTexture::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EDummyTexture@Ogre@@EAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDummyTexture@Ogre@@EAEPAXI@Z PROC			; Ogre::DummyTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@18
	push	OFFSET ??1DummyTexture@Ogre@@EAE@XZ	; Ogre::DummyTexture::~DummyTexture
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@18
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@18:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@18
$LN3@vector@18:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DummyTexture@Ogre@@EAE@XZ		; Ogre::DummyTexture::~DummyTexture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@18
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@18:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@18:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDummyTexture@Ogre@@EAEPAXI@Z ENDP			; Ogre::DummyTexture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::TextureData::getRTTI
EXTRN	?m_RTTI@TextureData@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::TextureData::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::TextureData::getRTTI, COMDAT
; _this$ = ecx

; 93   : 		DECLARE_RTTI(TextureData)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@TextureData@Ogre@@2VRuntimeClass@2@B ; Ogre::TextureData::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::TextureData::getRTTI
_TEXT	ENDS
PUBLIC	?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::TextureData::newObject
EXTRN	??0TextureData@Ogre@@QAE@XZ:PROC		; Ogre::TextureData::TextureData
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T90608 = -20						; size = 4
$T90607 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::TextureData::newObject, COMDAT

; 93   : 		DECLARE_RTTI(TextureData)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	108					; 0000006cH
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T90608[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T90608[ebp], 0
	je	SHORT $LN3@newObject@4
	mov	ecx, DWORD PTR $T90608[ebp]
	call	??0TextureData@Ogre@@QAE@XZ		; Ogre::TextureData::TextureData
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@4
$LN3@newObject@4:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@4:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T90607[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T90607[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	108					; 0000006cH
	mov	eax, DWORD PTR $T90608[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::TextureData::newObject
PUBLIC	?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z ; Ogre::TextureData::getDesc
; Function compile flags: /Odtp
;	COMDAT ?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_desc$ = 8						; size = 4
?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z PROC	; Ogre::TextureData::getDesc, COMDAT
; _this$ = ecx

; 107  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 			desc = m_Desc;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 16					; 00000010H
	mov	ecx, 7
	mov	edi, DWORD PTR _desc$[ebp]
	rep movsd

; 109  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z ENDP	; Ogre::TextureData::getDesc
_TEXT	ENDS
PUBLIC	?getWidth@TextureData@Ogre@@QAEIXZ		; Ogre::TextureData::getWidth
; Function compile flags: /Odtp
;	COMDAT ?getWidth@TextureData@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWidth@TextureData@Ogre@@QAEIXZ PROC			; Ogre::TextureData::getWidth, COMDAT
; _this$ = ecx

; 112  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 113  : 			return m_Desc.width;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 114  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getWidth@TextureData@Ogre@@QAEIXZ ENDP			; Ogre::TextureData::getWidth
_TEXT	ENDS
PUBLIC	?getHeight@TextureData@Ogre@@QAEIXZ		; Ogre::TextureData::getHeight
; Function compile flags: /Odtp
;	COMDAT ?getHeight@TextureData@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHeight@TextureData@Ogre@@QAEIXZ PROC		; Ogre::TextureData::getHeight, COMDAT
; _this$ = ecx

; 117  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 			return m_Desc.height;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 119  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getHeight@TextureData@Ogre@@QAEIXZ ENDP		; Ogre::TextureData::getHeight
_TEXT	ENDS
PUBLIC	?getFormat@TextureData@Ogre@@QAE?AW4PixelFormat@2@XZ ; Ogre::TextureData::getFormat
; Function compile flags: /Odtp
;	COMDAT ?getFormat@TextureData@Ogre@@QAE?AW4PixelFormat@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getFormat@TextureData@Ogre@@QAE?AW4PixelFormat@2@XZ PROC ; Ogre::TextureData::getFormat, COMDAT
; _this$ = ecx

; 122  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 			return m_Desc.format;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 124  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getFormat@TextureData@Ogre@@QAE?AW4PixelFormat@2@XZ ENDP ; Ogre::TextureData::getFormat
_TEXT	ENDS
PUBLIC	?setStatic@TextureData@Ogre@@QAEX_N@Z		; Ogre::TextureData::setStatic
; Function compile flags: /Odtp
;	COMDAT ?setStatic@TextureData@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_is_static$ = 8						; size = 1
?setStatic@TextureData@Ogre@@QAEX_N@Z PROC		; Ogre::TextureData::setStatic, COMDAT
; _this$ = ecx

; 142  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 			m_isStatic = is_static;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _is_static$[ebp]
	mov	BYTE PTR [eax+76], cl

; 144  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setStatic@TextureData@Ogre@@QAEX_N@Z ENDP		; Ogre::TextureData::setStatic
_TEXT	ENDS
PUBLIC	??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??_7TextureData@Ogre@@6B@			; Ogre::TextureData::`vftable'
PUBLIC	??0TextureData@Ogre@@QAE@ABV01@@Z		; Ogre::TextureData::TextureData
PUBLIC	??_R4TextureData@Ogre@@6B@			; Ogre::TextureData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTextureData@Ogre@@@8			; Ogre::TextureData `RTTI Type Descriptor'
PUBLIC	??_R3TextureData@Ogre@@8			; Ogre::TextureData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TextureData@Ogre@@8			; Ogre::TextureData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TextureData@Ogre@@8		; Ogre::TextureData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ETextureData@Ogre@@MAEPAXI@Z			; Ogre::TextureData::`vector deleting destructor'
EXTRN	?_serialize@TextureData@Ogre@@EAEXAAVArchive@2@H@Z:PROC ; Ogre::TextureData::_serialize
EXTRN	?getHardwareTexture@TextureData@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ:PROC ; Ogre::TextureData::getHardwareTexture
EXTRN	?lock@TextureData@Ogre@@UAEPAXII_NAAULockResult@2@@Z:PROC ; Ogre::TextureData::lock
EXTRN	?unlock@TextureData@Ogre@@UAEXII@Z:PROC		; Ogre::TextureData::unlock
;	COMDAT ??_R1A@?0A@EA@TextureData@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TextureData@Ogre@@8 DD FLAT:??_R0?AVTextureData@Ogre@@@8 ; Ogre::TextureData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TextureData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2TextureData@Ogre@@8
rdata$r	SEGMENT
??_R2TextureData@Ogre@@8 DD FLAT:??_R1A@?0A@EA@TextureData@Ogre@@8 ; Ogre::TextureData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Texture@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3TextureData@Ogre@@8
rdata$r	SEGMENT
??_R3TextureData@Ogre@@8 DD 00H				; Ogre::TextureData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2TextureData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTextureData@Ogre@@@8
_DATA	SEGMENT
??_R0?AVTextureData@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::TextureData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTextureData@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TextureData@Ogre@@6B@
rdata$r	SEGMENT
??_R4TextureData@Ogre@@6B@ DD 00H			; Ogre::TextureData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTextureData@Ogre@@@8
	DD	FLAT:??_R3TextureData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7TextureData@Ogre@@6B@
CONST	SEGMENT
??_7TextureData@Ogre@@6B@ DD FLAT:??_R4TextureData@Ogre@@6B@ ; Ogre::TextureData::`vftable'
	DD	FLAT:?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@TextureData@Ogre@@EAEXAAVArchive@2@H@Z
	DD	FLAT:??_ETextureData@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z
	DD	FLAT:?getHardwareTexture@TextureData@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
	DD	FLAT:?lock@TextureData@Ogre@@UAEPAXII_NAAULockResult@2@@Z
	DD	FLAT:?unlock@TextureData@Ogre@@UAEXII@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0TextureData@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$2
__ehfuncinfo$??0TextureData@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0TextureData@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0TextureData@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0TextureData@Ogre@@QAE@ABV01@@Z PROC			; Ogre::TextureData::TextureData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0TextureData@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7TextureData@Ogre@@6B@
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 16					; 00000010H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 16					; 00000010H
	mov	ecx, 7
	rep movsd
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+68], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+72], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+76]
	mov	BYTE PTR [eax+76], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0TextureData@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0TextureData@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0TextureData@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::TextureData::TextureData
PUBLIC	??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator=
PUBLIC	??4TextureData@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::TextureData::operator=
; Function compile flags: /Odtp
;	COMDAT ??4TextureData@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4TextureData@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::TextureData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Texture@Ogre@@QAEAAV01@ABV01@@Z
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 16					; 00000010H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 16					; 00000010H
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [edx+68], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR [edx+72], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+76]
	mov	BYTE PTR [edx+76], cl
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 80					; 00000050H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4TextureData@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::TextureData::operator=
_TEXT	ENDS
PUBLIC	??_GTextureData@Ogre@@MAEPAXI@Z			; Ogre::TextureData::`scalar deleting destructor'
EXTRN	??1TextureData@Ogre@@MAE@XZ:PROC		; Ogre::TextureData::~TextureData
; Function compile flags: /Odtp
;	COMDAT ??_GTextureData@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTextureData@Ogre@@MAEPAXI@Z PROC			; Ogre::TextureData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TextureData@Ogre@@MAE@XZ		; Ogre::TextureData::~TextureData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@19
	push	108					; 0000006cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@19:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTextureData@Ogre@@MAEPAXI@Z ENDP			; Ogre::TextureData::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ETextureData@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ETextureData@Ogre@@MAEPAXI@Z PROC			; Ogre::TextureData::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@19
	push	OFFSET ??1TextureData@Ogre@@MAE@XZ	; Ogre::TextureData::~TextureData
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	108					; 0000006cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@19
	push	108					; 0000006cH
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@19:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@19
$LN3@vector@19:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TextureData@Ogre@@MAE@XZ		; Ogre::TextureData::~TextureData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@19
	push	108					; 0000006cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@19:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@19:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ETextureData@Ogre@@MAEPAXI@Z ENDP			; Ogre::TextureData::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::RT_TEXTURE::getRTTI
EXTRN	?m_RTTI@RT_TEXTURE@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::RT_TEXTURE::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::RT_TEXTURE::getRTTI, COMDAT
; _this$ = ecx

; 179  : 		DECLARE_RTTI(RT_TEXTURE)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@RT_TEXTURE@Ogre@@2VRuntimeClass@2@B ; Ogre::RT_TEXTURE::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::RT_TEXTURE::getRTTI
_TEXT	ENDS
PUBLIC	??0RT_TEXTURE@Ogre@@QAE@XZ			; Ogre::RT_TEXTURE::RT_TEXTURE
PUBLIC	?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::RT_TEXTURE::newObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T90650 = -20						; size = 4
$T90649 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::RT_TEXTURE::newObject, COMDAT

; 179  : 		DECLARE_RTTI(RT_TEXTURE)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	48					; 00000030H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T90650[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T90650[ebp], 0
	je	SHORT $LN3@newObject@5
	mov	ecx, DWORD PTR $T90650[ebp]
	call	??0RT_TEXTURE@Ogre@@QAE@XZ		; Ogre::RT_TEXTURE::RT_TEXTURE
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@5
$LN3@newObject@5:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@5:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T90649[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T90649[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	48					; 00000030H
	mov	eax, DWORD PTR $T90650[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::RT_TEXTURE::newObject
PUBLIC	??_7RT_TEXTURE@Ogre@@6B@			; Ogre::RT_TEXTURE::`vftable'
PUBLIC	??_R4RT_TEXTURE@Ogre@@6B@			; Ogre::RT_TEXTURE::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRT_TEXTURE@Ogre@@@8			; Ogre::RT_TEXTURE `RTTI Type Descriptor'
PUBLIC	??_R3RT_TEXTURE@Ogre@@8				; Ogre::RT_TEXTURE::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RT_TEXTURE@Ogre@@8				; Ogre::RT_TEXTURE::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RT_TEXTURE@Ogre@@8		; Ogre::RT_TEXTURE::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ERT_TEXTURE@Ogre@@MAEPAXI@Z			; Ogre::RT_TEXTURE::`vector deleting destructor'
PUBLIC	?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z ; Ogre::RT_TEXTURE::getDesc
PUBLIC	?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ ; Ogre::RT_TEXTURE::getHardwareTexture
EXTRN	?lock@RT_TEXTURE@Ogre@@UAEPAXII_NAAULockResult@2@@Z:PROC ; Ogre::RT_TEXTURE::lock
EXTRN	?unlock@RT_TEXTURE@Ogre@@UAEXII@Z:PROC		; Ogre::RT_TEXTURE::unlock
;	COMDAT ??_R1A@?0A@EA@RT_TEXTURE@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RT_TEXTURE@Ogre@@8 DD FLAT:??_R0?AVRT_TEXTURE@Ogre@@@8 ; Ogre::RT_TEXTURE::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RT_TEXTURE@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2RT_TEXTURE@Ogre@@8
rdata$r	SEGMENT
??_R2RT_TEXTURE@Ogre@@8 DD FLAT:??_R1A@?0A@EA@RT_TEXTURE@Ogre@@8 ; Ogre::RT_TEXTURE::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Texture@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3RT_TEXTURE@Ogre@@8
rdata$r	SEGMENT
??_R3RT_TEXTURE@Ogre@@8 DD 00H				; Ogre::RT_TEXTURE::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2RT_TEXTURE@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRT_TEXTURE@Ogre@@@8
_DATA	SEGMENT
??_R0?AVRT_TEXTURE@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::RT_TEXTURE `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRT_TEXTURE@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RT_TEXTURE@Ogre@@6B@
rdata$r	SEGMENT
??_R4RT_TEXTURE@Ogre@@6B@ DD 00H			; Ogre::RT_TEXTURE::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRT_TEXTURE@Ogre@@@8
	DD	FLAT:??_R3RT_TEXTURE@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7RT_TEXTURE@Ogre@@6B@
CONST	SEGMENT
??_7RT_TEXTURE@Ogre@@6B@ DD FLAT:??_R4RT_TEXTURE@Ogre@@6B@ ; Ogre::RT_TEXTURE::`vftable'
	DD	FLAT:?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_ERT_TEXTURE@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z
	DD	FLAT:?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
	DD	FLAT:?lock@RT_TEXTURE@Ogre@@UAEPAXII_NAAULockResult@2@@Z
	DD	FLAT:?unlock@RT_TEXTURE@Ogre@@UAEXII@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RT_TEXTURE@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RT_TEXTURE@Ogre@@QAE@XZ$0
__ehfuncinfo$??0RT_TEXTURE@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RT_TEXTURE@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RT_TEXTURE@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0RT_TEXTURE@Ogre@@QAE@XZ PROC				; Ogre::RT_TEXTURE::RT_TEXTURE, COMDAT
; _this$ = ecx

; 181  : 		RT_TEXTURE() : m_pTexture(NULL){}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RT_TEXTURE@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RT_TEXTURE@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RT_TEXTURE@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??0RT_TEXTURE@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RT_TEXTURE@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RT_TEXTURE@Ogre@@QAE@XZ ENDP				; Ogre::RT_TEXTURE::RT_TEXTURE
; Function compile flags: /Odtp
;	COMDAT ?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ PROC ; Ogre::RT_TEXTURE::getHardwareTexture, COMDAT
; _this$ = ecx

; 184  : 		virtual HardwareTexture *getHardwareTexture(){return m_pTexture;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ ENDP ; Ogre::RT_TEXTURE::getHardwareTexture
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_desc$ = 8						; size = 4
?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z PROC	; Ogre::RT_TEXTURE::getDesc, COMDAT
; _this$ = ecx

; 189  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 190  : 			desc = m_Desc;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 16					; 00000010H
	mov	ecx, 7
	mov	edi, DWORD PTR _desc$[ebp]
	rep movsd

; 191  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z ENDP	; Ogre::RT_TEXTURE::getDesc
_TEXT	ENDS
PUBLIC	??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z		; Ogre::RT_TEXTURE::RT_TEXTURE
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z PROC			; Ogre::RT_TEXTURE::RT_TEXTURE, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7RT_TEXTURE@Ogre@@6B@
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 16					; 00000010H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 16					; 00000010H
	mov	ecx, 7
	rep movsd
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+44], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::RT_TEXTURE::RT_TEXTURE
PUBLIC	??4RT_TEXTURE@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::RT_TEXTURE::operator=
; Function compile flags: /Odtp
;	COMDAT ??4RT_TEXTURE@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4RT_TEXTURE@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::RT_TEXTURE::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Texture@Ogre@@QAEAAV01@ABV01@@Z
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 16					; 00000010H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 16					; 00000010H
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4RT_TEXTURE@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::RT_TEXTURE::operator=
_TEXT	ENDS
PUBLIC	??_GRT_TEXTURE@Ogre@@MAEPAXI@Z			; Ogre::RT_TEXTURE::`scalar deleting destructor'
EXTRN	??1RT_TEXTURE@Ogre@@MAE@XZ:PROC			; Ogre::RT_TEXTURE::~RT_TEXTURE
; Function compile flags: /Odtp
;	COMDAT ??_GRT_TEXTURE@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRT_TEXTURE@Ogre@@MAEPAXI@Z PROC			; Ogre::RT_TEXTURE::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RT_TEXTURE@Ogre@@MAE@XZ		; Ogre::RT_TEXTURE::~RT_TEXTURE
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@20
	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@20:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRT_TEXTURE@Ogre@@MAEPAXI@Z ENDP			; Ogre::RT_TEXTURE::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ERT_TEXTURE@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ERT_TEXTURE@Ogre@@MAEPAXI@Z PROC			; Ogre::RT_TEXTURE::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@20
	push	OFFSET ??1RT_TEXTURE@Ogre@@MAE@XZ	; Ogre::RT_TEXTURE::~RT_TEXTURE
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@20
	push	48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@20:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@20
$LN3@vector@20:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RT_TEXTURE@Ogre@@MAE@XZ		; Ogre::RT_TEXTURE::~RT_TEXTURE
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@20
	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@20:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@20:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ERT_TEXTURE@Ogre@@MAEPAXI@Z ENDP			; Ogre::RT_TEXTURE::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7LoadWrap@Ogre@@6B@				; Ogre::LoadWrap::`vftable'
PUBLIC	??0LoadWrap@Ogre@@QAE@XZ			; Ogre::LoadWrap::LoadWrap
PUBLIC	??_R4LoadWrap@Ogre@@6B@				; Ogre::LoadWrap::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVLoadWrap@Ogre@@@8			; Ogre::LoadWrap `RTTI Type Descriptor'
PUBLIC	??_R3LoadWrap@Ogre@@8				; Ogre::LoadWrap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2LoadWrap@Ogre@@8				; Ogre::LoadWrap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@LoadWrap@Ogre@@8			; Ogre::LoadWrap::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ELoadWrap@Ogre@@MAEPAXI@Z			; Ogre::LoadWrap::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@LoadWrap@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@LoadWrap@Ogre@@8 DD FLAT:??_R0?AVLoadWrap@Ogre@@@8 ; Ogre::LoadWrap::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3LoadWrap@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2LoadWrap@Ogre@@8
rdata$r	SEGMENT
??_R2LoadWrap@Ogre@@8 DD FLAT:??_R1A@?0A@EA@LoadWrap@Ogre@@8 ; Ogre::LoadWrap::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3LoadWrap@Ogre@@8
rdata$r	SEGMENT
??_R3LoadWrap@Ogre@@8 DD 00H				; Ogre::LoadWrap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2LoadWrap@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVLoadWrap@Ogre@@@8
_DATA	SEGMENT
??_R0?AVLoadWrap@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::LoadWrap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVLoadWrap@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4LoadWrap@Ogre@@6B@
rdata$r	SEGMENT
??_R4LoadWrap@Ogre@@6B@ DD 00H				; Ogre::LoadWrap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVLoadWrap@Ogre@@@8
	DD	FLAT:??_R3LoadWrap@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7LoadWrap@Ogre@@6B@
CONST	SEGMENT
??_7LoadWrap@Ogre@@6B@ DD FLAT:??_R4LoadWrap@Ogre@@6B@	; Ogre::LoadWrap::`vftable'
	DD	FLAT:??_ELoadWrap@Ogre@@MAEPAXI@Z
	DD	FLAT:__purecall
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0LoadWrap@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0LoadWrap@Ogre@@QAE@XZ PROC				; Ogre::LoadWrap::LoadWrap, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7LoadWrap@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0LoadWrap@Ogre@@QAE@XZ ENDP				; Ogre::LoadWrap::LoadWrap
_TEXT	ENDS
PUBLIC	??0LoadWrap@Ogre@@QAE@ABV01@@Z			; Ogre::LoadWrap::LoadWrap
; Function compile flags: /Odtp
;	COMDAT ??0LoadWrap@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0LoadWrap@Ogre@@QAE@ABV01@@Z PROC			; Ogre::LoadWrap::LoadWrap, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7LoadWrap@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0LoadWrap@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::LoadWrap::LoadWrap
_TEXT	ENDS
PUBLIC	??4LoadWrap@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::LoadWrap::operator=
; Function compile flags: /Odtp
;	COMDAT ??4LoadWrap@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4LoadWrap@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::LoadWrap::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4LoadWrap@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::LoadWrap::operator=
_TEXT	ENDS
PUBLIC	??_GLoadWrap@Ogre@@MAEPAXI@Z			; Ogre::LoadWrap::`scalar deleting destructor'
EXTRN	??1LoadWrap@Ogre@@MAE@XZ:PROC			; Ogre::LoadWrap::~LoadWrap
; Function compile flags: /Odtp
;	COMDAT ??_GLoadWrap@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GLoadWrap@Ogre@@MAEPAXI@Z PROC			; Ogre::LoadWrap::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1LoadWrap@Ogre@@MAE@XZ		; Ogre::LoadWrap::~LoadWrap
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@21
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@21:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GLoadWrap@Ogre@@MAEPAXI@Z ENDP			; Ogre::LoadWrap::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ELoadWrap@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ELoadWrap@Ogre@@MAEPAXI@Z PROC			; Ogre::LoadWrap::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@21
	push	OFFSET ??1LoadWrap@Ogre@@MAE@XZ		; Ogre::LoadWrap::~LoadWrap
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@21
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@21:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@21
$LN3@vector@21:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1LoadWrap@Ogre@@MAE@XZ		; Ogre::LoadWrap::~LoadWrap
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@21
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@21:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@21:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ELoadWrap@Ogre@@MAEPAXI@Z ENDP			; Ogre::LoadWrap::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@XZ ; std::map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::~map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >
PUBLIC	??0?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z ; std::map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >
PUBLIC	??_7MultiLoader@Ogre@@6B@			; Ogre::MultiLoader::`vftable'
PUBLIC	??0MultiLoader@Ogre@@QAE@ABV01@@Z		; Ogre::MultiLoader::MultiLoader
PUBLIC	??_R4MultiLoader@Ogre@@6B@			; Ogre::MultiLoader::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMultiLoader@Ogre@@@8			; Ogre::MultiLoader `RTTI Type Descriptor'
PUBLIC	??_R3MultiLoader@Ogre@@8			; Ogre::MultiLoader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MultiLoader@Ogre@@8			; Ogre::MultiLoader::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MultiLoader@Ogre@@8		; Ogre::MultiLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EMultiLoader@Ogre@@UAEPAXI@Z			; Ogre::MultiLoader::`vector deleting destructor'
EXTRN	?ResourceLoaded@MultiLoader@Ogre@@EAEXPAVResource@2@I@Z:PROC ; Ogre::MultiLoader::ResourceLoaded
;	COMDAT ??_R1A@?0A@EA@MultiLoader@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MultiLoader@Ogre@@8 DD FLAT:??_R0?AVMultiLoader@Ogre@@@8 ; Ogre::MultiLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MultiLoader@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MultiLoader@Ogre@@8
rdata$r	SEGMENT
??_R2MultiLoader@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MultiLoader@Ogre@@8 ; Ogre::MultiLoader::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@LoadWrap@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3MultiLoader@Ogre@@8
rdata$r	SEGMENT
??_R3MultiLoader@Ogre@@8 DD 00H				; Ogre::MultiLoader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2MultiLoader@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMultiLoader@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMultiLoader@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::MultiLoader `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMultiLoader@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MultiLoader@Ogre@@6B@
rdata$r	SEGMENT
??_R4MultiLoader@Ogre@@6B@ DD 00H			; Ogre::MultiLoader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMultiLoader@Ogre@@@8
	DD	FLAT:??_R3MultiLoader@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7MultiLoader@Ogre@@6B@
CONST	SEGMENT
??_7MultiLoader@Ogre@@6B@ DD FLAT:??_R4MultiLoader@Ogre@@6B@ ; Ogre::MultiLoader::`vftable'
	DD	FLAT:??_EMultiLoader@Ogre@@UAEPAXI@Z
	DD	FLAT:?ResourceLoaded@MultiLoader@Ogre@@EAEXPAVResource@2@I@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0MultiLoader@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MultiLoader@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MultiLoader@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0MultiLoader@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0MultiLoader@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0MultiLoader@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0MultiLoader@Ogre@@QAE@ABV01@@Z PROC			; Ogre::MultiLoader::MultiLoader, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MultiLoader@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0LoadWrap@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7MultiLoader@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 4
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MultiLoader@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1LoadWrap@Ogre@@MAE@XZ		; Ogre::LoadWrap::~LoadWrap
__unwindfunclet$??0MultiLoader@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@XZ
__ehhandler$??0MultiLoader@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0MultiLoader@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MultiLoader@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::MultiLoader::MultiLoader
PUBLIC	??4?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z ; std::map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::operator=
PUBLIC	??4MultiLoader@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::MultiLoader::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MultiLoader@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MultiLoader@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::MultiLoader::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4LoadWrap@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??4?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MultiLoader@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::MultiLoader::operator=
_TEXT	ENDS
PUBLIC	??_GMultiLoader@Ogre@@UAEPAXI@Z			; Ogre::MultiLoader::`scalar deleting destructor'
EXTRN	??1MultiLoader@Ogre@@UAE@XZ:PROC		; Ogre::MultiLoader::~MultiLoader
; Function compile flags: /Odtp
;	COMDAT ??_GMultiLoader@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMultiLoader@Ogre@@UAEPAXI@Z PROC			; Ogre::MultiLoader::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MultiLoader@Ogre@@UAE@XZ		; Ogre::MultiLoader::~MultiLoader
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@22
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@22:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GMultiLoader@Ogre@@UAEPAXI@Z ENDP			; Ogre::MultiLoader::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EMultiLoader@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EMultiLoader@Ogre@@UAEPAXI@Z PROC			; Ogre::MultiLoader::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@22
	push	OFFSET ??1MultiLoader@Ogre@@UAE@XZ	; Ogre::MultiLoader::~MultiLoader
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@22
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@22:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@22
$LN3@vector@22:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MultiLoader@Ogre@@UAE@XZ		; Ogre::MultiLoader::~MultiLoader
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@22
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@22:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@22:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EMultiLoader@Ogre@@UAEPAXI@Z ENDP			; Ogre::MultiLoader::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z PROC ; std::map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
__ehhandler$??0?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z ENDP ; std::map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@XZ$0
__ehfuncinfo$??1?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@XZ PROC ; std::map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::~map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
__ehhandler$??1?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::~map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >
PUBLIC	??4?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$map@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::operator=
_TEXT	ENDS
PUBLIC	?setCanUseStaticLight@SubMeshInstance@Ogre@@QAEX_N@Z ; Ogre::SubMeshInstance::setCanUseStaticLight
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremodel.h
;	COMDAT ?setCanUseStaticLight@SubMeshInstance@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_canUse$ = 8						; size = 1
?setCanUseStaticLight@SubMeshInstance@Ogre@@QAEX_N@Z PROC ; Ogre::SubMeshInstance::setCanUseStaticLight, COMDAT
; _this$ = ecx

; 60   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 			m_bCanUseStaticLight = canUse;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _canUse$[ebp]
	mov	BYTE PTR [eax+65], cl

; 62   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setCanUseStaticLight@SubMeshInstance@Ogre@@QAEX_N@Z ENDP ; Ogre::SubMeshInstance::setCanUseStaticLight
_TEXT	ENDS
PUBLIC	?canUseStaticLight@SubMeshInstance@Ogre@@QAE_NXZ ; Ogre::SubMeshInstance::canUseStaticLight
; Function compile flags: /Odtp
;	COMDAT ?canUseStaticLight@SubMeshInstance@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?canUseStaticLight@SubMeshInstance@Ogre@@QAE_NXZ PROC	; Ogre::SubMeshInstance::canUseStaticLight, COMDAT
; _this$ = ecx

; 65   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 			return m_bCanUseStaticLight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+65]

; 67   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?canUseStaticLight@SubMeshInstance@Ogre@@QAE_NXZ ENDP	; Ogre::SubMeshInstance::canUseStaticLight
_TEXT	ENDS
PUBLIC	?hasStaticLight@SubMeshInstance@Ogre@@QAE_NXZ	; Ogre::SubMeshInstance::hasStaticLight
; Function compile flags: /Odtp
;	COMDAT ?hasStaticLight@SubMeshInstance@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?hasStaticLight@SubMeshInstance@Ogre@@QAE_NXZ PROC	; Ogre::SubMeshInstance::hasStaticLight, COMDAT
; _this$ = ecx

; 71   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 			return m_bUseStaticLight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+64]

; 73   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?hasStaticLight@SubMeshInstance@Ogre@@QAE_NXZ ENDP	; Ogre::SubMeshInstance::hasStaticLight
_TEXT	ENDS
PUBLIC	?enableUVMask@SubMeshInstance@Ogre@@QAEX_N0@Z	; Ogre::SubMeshInstance::enableUVMask
; Function compile flags: /Odtp
;	COMDAT ?enableUVMask@SubMeshInstance@Ogre@@QAEX_N0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_enable$ = 8						; size = 1
_stdmtluse$ = 12					; size = 1
?enableUVMask@SubMeshInstance@Ogre@@QAEX_N0@Z PROC	; Ogre::SubMeshInstance::enableUVMask, COMDAT
; _this$ = ecx

; 76   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   : 			m_bEnableUVMask = enable;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _enable$[ebp]
	mov	BYTE PTR [eax+92], cl

; 78   : 			m_bStdEnableUVMask = stdmtluse;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _stdmtluse$[ebp]
	mov	BYTE PTR [edx+93], al

; 79   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?enableUVMask@SubMeshInstance@Ogre@@QAEX_N0@Z ENDP	; Ogre::SubMeshInstance::enableUVMask
_TEXT	ENDS
PUBLIC	?setUVMaskTrans@SubMeshInstance@Ogre@@QAEXVVector2@2@@Z ; Ogre::SubMeshInstance::setUVMaskTrans
; Function compile flags: /Odtp
;	COMDAT ?setUVMaskTrans@SubMeshInstance@Ogre@@QAEXVVector2@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_uvTrans$ = 8						; size = 8
?setUVMaskTrans@SubMeshInstance@Ogre@@QAEXVVector2@2@@Z PROC ; Ogre::SubMeshInstance::setUVMaskTrans, COMDAT
; _this$ = ecx

; 82   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 			mTrans = uvTrans;

	lea	eax, DWORD PTR _uvTrans$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??4Vector2@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector2::operator=

; 84   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setUVMaskTrans@SubMeshInstance@Ogre@@QAEXVVector2@2@@Z ENDP ; Ogre::SubMeshInstance::setUVMaskTrans
_TEXT	ENDS
PUBLIC	?setUVMaskColor@SubMeshInstance@Ogre@@QAEXVVector3@2@@Z ; Ogre::SubMeshInstance::setUVMaskColor
; Function compile flags: /Odtp
;	COMDAT ?setUVMaskColor@SubMeshInstance@Ogre@@QAEXVVector3@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_color$ = 8						; size = 12
?setUVMaskColor@SubMeshInstance@Ogre@@QAEXVVector3@2@@Z PROC ; Ogre::SubMeshInstance::setUVMaskColor, COMDAT
; _this$ = ecx

; 87   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 			mUVMaskColor = color;

	lea	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 89   : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setUVMaskColor@SubMeshInstance@Ogre@@QAEXVVector3@2@@Z ENDP ; Ogre::SubMeshInstance::setUVMaskColor
_TEXT	ENDS
PUBLIC	?setLiuGuangTexture@SubMeshInstance@Ogre@@QAEXPAVTextureData@2@@Z ; Ogre::SubMeshInstance::setLiuGuangTexture
; Function compile flags: /Odtp
;	COMDAT ?setLiuGuangTexture@SubMeshInstance@Ogre@@QAEXPAVTextureData@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_texture$ = 8						; size = 4
?setLiuGuangTexture@SubMeshInstance@Ogre@@QAEXPAVTextureData@2@@Z PROC ; Ogre::SubMeshInstance::setLiuGuangTexture, COMDAT
; _this$ = ecx

; 92   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 			if (m_pLiuGuangTexture)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN2@setLiuGuan

; 94   : 				m_pLiuGuangTexture->release();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN2@setLiuGuan:

; 95   : 
; 96   : 			if (texture)

	cmp	DWORD PTR _texture$[ebp], 0
	je	SHORT $LN1@setLiuGuan

; 97   : 				texture->addRef();

	mov	ecx, DWORD PTR _texture$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _texture$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN1@setLiuGuan:

; 98   : 			m_pLiuGuangTexture = texture;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _texture$[ebp]
	mov	DWORD PTR [ecx+68], edx

; 99   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLiuGuangTexture@SubMeshInstance@Ogre@@QAEXPAVTextureData@2@@Z ENDP ; Ogre::SubMeshInstance::setLiuGuangTexture
_TEXT	ENDS
PUBLIC	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	??0SubMeshInstance@Ogre@@QAE@ABV01@@Z		; Ogre::SubMeshInstance::SubMeshInstance
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SubMeshInstance@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SubMeshInstance@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0SubMeshInstance@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SubMeshInstance@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0SubMeshInstance@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0SubMeshInstance@Ogre@@QAE@ABV01@@Z PROC		; Ogre::SubMeshInstance::SubMeshInstance, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SubMeshInstance@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+48]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+52]
	mov	BYTE PTR [eax+52], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [ecx+56]
	fstp	DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+60], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+64]
	mov	BYTE PTR [edx+64], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+65]
	mov	BYTE PTR [edx+65], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [edx+68], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [edx+76]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+72], eax
	mov	DWORD PTR [edx+76], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+92]
	mov	BYTE PTR [ecx+92], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+93]
	mov	BYTE PTR [ecx+93], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SubMeshInstance@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__ehhandler$??0SubMeshInstance@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SubMeshInstance@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SubMeshInstance@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::SubMeshInstance::SubMeshInstance
PUBLIC	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
PUBLIC	??4SubMeshInstance@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::SubMeshInstance::operator=
; Function compile flags: /Odtp
;	COMDAT ??4SubMeshInstance@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4SubMeshInstance@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::SubMeshInstance::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+48]
	fstp	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+52]
	mov	BYTE PTR [eax+52], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [ecx+56]
	fstp	DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+60], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+64]
	mov	BYTE PTR [edx+64], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+65]
	mov	BYTE PTR [edx+65], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [edx+68], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??4Vector2@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector2::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+92]
	mov	BYTE PTR [ecx+92], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+93]
	mov	BYTE PTR [ecx+93], al
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4SubMeshInstance@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::SubMeshInstance::operator=
_TEXT	ENDS
PUBLIC	?show@MeshInstance@Ogre@@QAEX_N@Z		; Ogre::MeshInstance::show
; Function compile flags: /Odtp
;	COMDAT ?show@MeshInstance@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_b$ = 8							; size = 1
?show@MeshInstance@Ogre@@QAEX_N@Z PROC			; Ogre::MeshInstance::show, COMDAT
; _this$ = ecx

; 142  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 			m_bShow = b;  

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _b$[ebp]
	mov	BYTE PTR [eax+4], cl

; 144  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?show@MeshInstance@Ogre@@QAEX_N@Z ENDP			; Ogre::MeshInstance::show
_TEXT	ENDS
PUBLIC	?isShow@MeshInstance@Ogre@@QAE_NXZ		; Ogre::MeshInstance::isShow
; Function compile flags: /Odtp
;	COMDAT ?isShow@MeshInstance@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isShow@MeshInstance@Ogre@@QAE_NXZ PROC			; Ogre::MeshInstance::isShow, COMDAT
; _this$ = ecx

; 147  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 			return m_bShow;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4]

; 149  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?isShow@MeshInstance@Ogre@@QAE_NXZ ENDP			; Ogre::MeshInstance::isShow
_TEXT	ENDS
PUBLIC	??A?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAPAVSubMeshInstance@Ogre@@I@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator[]
PUBLIC	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
PUBLIC	?enableDeadEffect@MeshInstance@Ogre@@QAEX_N@Z	; Ogre::MeshInstance::enableDeadEffect
; Function compile flags: /Odtp
;	COMDAT ?enableDeadEffect@MeshInstance@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$64543 = -4						; size = 4
_enable$ = 8						; size = 1
?enableDeadEffect@MeshInstance@Ogre@@QAEX_N@Z PROC	; Ogre::MeshInstance::enableDeadEffect, COMDAT
; _this$ = ecx

; 154  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 			for (size_t i=0; i<m_SubMeshes.size(); i++)

	mov	DWORD PTR _i$64543[ebp], 0
	jmp	SHORT $LN3@enableDead
$LN2@enableDead:
	mov	eax, DWORD PTR _i$64543[ebp]
	add	eax, 1
	mov	DWORD PTR _i$64543[ebp], eax
$LN3@enableDead:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	cmp	DWORD PTR _i$64543[ebp], eax
	jae	SHORT $LN4@enableDead

; 156  : 			{
; 157  : 				m_SubMeshes[i]->m_bEnableDeadEffect = enable;

	mov	ecx, DWORD PTR _i$64543[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAPAVSubMeshInstance@Ogre@@I@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	al, BYTE PTR _enable$[ebp]
	mov	BYTE PTR [edx+52], al

; 158  : 			}

	jmp	SHORT $LN2@enableDead
$LN4@enableDead:

; 159  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?enableDeadEffect@MeshInstance@Ogre@@QAEX_N@Z ENDP	; Ogre::MeshInstance::enableDeadEffect
_TEXT	ENDS
PUBLIC	?setDeadScale@MeshInstance@Ogre@@QAEXM@Z	; Ogre::MeshInstance::setDeadScale
; Function compile flags: /Odtp
;	COMDAT ?setDeadScale@MeshInstance@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$64549 = -4						; size = 4
_deadScale$ = 8						; size = 4
?setDeadScale@MeshInstance@Ogre@@QAEXM@Z PROC		; Ogre::MeshInstance::setDeadScale, COMDAT
; _this$ = ecx

; 162  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 163  : 			for (size_t i=0; i<m_SubMeshes.size(); i++)

	mov	DWORD PTR _i$64549[ebp], 0
	jmp	SHORT $LN3@setDeadSca
$LN2@setDeadSca:
	mov	eax, DWORD PTR _i$64549[ebp]
	add	eax, 1
	mov	DWORD PTR _i$64549[ebp], eax
$LN3@setDeadSca:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	cmp	DWORD PTR _i$64549[ebp], eax
	jae	SHORT $LN1@setDeadSca

; 164  : 			{
; 165  : 				m_SubMeshes[i]->m_fDeadScale = deadScale;

	mov	ecx, DWORD PTR _i$64549[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAPAVSubMeshInstance@Ogre@@I@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator[]
	mov	edx, DWORD PTR [eax]
	fld	DWORD PTR _deadScale$[ebp]
	fstp	DWORD PTR [edx+56]

; 166  : 			}

	jmp	SHORT $LN2@setDeadSca
$LN1@setDeadSca:

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setDeadScale@MeshInstance@Ogre@@QAEXM@Z ENDP		; Ogre::MeshInstance::setDeadScale
_TEXT	ENDS
PUBLIC	?enableUVMask@MeshInstance@Ogre@@QAEX_N0@Z	; Ogre::MeshInstance::enableUVMask
; Function compile flags: /Odtp
;	COMDAT ?enableUVMask@MeshInstance@Ogre@@QAEX_N0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$64555 = -4						; size = 4
_enable$ = 8						; size = 1
_stdmtlUse$ = 12					; size = 1
?enableUVMask@MeshInstance@Ogre@@QAEX_N0@Z PROC		; Ogre::MeshInstance::enableUVMask, COMDAT
; _this$ = ecx

; 170  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 171  : 			for (size_t i=0; i<m_SubMeshes.size(); i++)

	mov	DWORD PTR _i$64555[ebp], 0
	jmp	SHORT $LN3@enableUVMa
$LN2@enableUVMa:
	mov	eax, DWORD PTR _i$64555[ebp]
	add	eax, 1
	mov	DWORD PTR _i$64555[ebp], eax
$LN3@enableUVMa:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	cmp	DWORD PTR _i$64555[ebp], eax
	jae	SHORT $LN4@enableUVMa

; 172  : 			{
; 173  : 				m_SubMeshes[i]->enableUVMask(enable, stdmtlUse);

	movzx	ecx, BYTE PTR _stdmtlUse$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _enable$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$64555[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAPAVSubMeshInstance@Ogre@@I@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?enableUVMask@SubMeshInstance@Ogre@@QAEX_N0@Z ; Ogre::SubMeshInstance::enableUVMask

; 174  : 			}

	jmp	SHORT $LN2@enableUVMa
$LN4@enableUVMa:

; 175  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?enableUVMask@MeshInstance@Ogre@@QAEX_N0@Z ENDP		; Ogre::MeshInstance::enableUVMask
_TEXT	ENDS
PUBLIC	?setUVMaskTrans@MeshInstance@Ogre@@QAEXVVector2@2@@Z ; Ogre::MeshInstance::setUVMaskTrans
; Function compile flags: /Odtp
;	COMDAT ?setUVMaskTrans@MeshInstance@Ogre@@QAEXVVector2@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$64561 = -4						; size = 4
_uvTrans$ = 8						; size = 8
?setUVMaskTrans@MeshInstance@Ogre@@QAEXVVector2@2@@Z PROC ; Ogre::MeshInstance::setUVMaskTrans, COMDAT
; _this$ = ecx

; 178  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 			for (size_t i=0; i<m_SubMeshes.size(); i++)

	mov	DWORD PTR _i$64561[ebp], 0
	jmp	SHORT $LN3@setUVMaskT
$LN2@setUVMaskT:
	mov	eax, DWORD PTR _i$64561[ebp]
	add	eax, 1
	mov	DWORD PTR _i$64561[ebp], eax
$LN3@setUVMaskT:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	cmp	DWORD PTR _i$64561[ebp], eax
	jae	SHORT $LN4@setUVMaskT

; 180  : 			{
; 181  : 				m_SubMeshes[i]->setUVMaskTrans(uvTrans);

	mov	ecx, DWORD PTR _uvTrans$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _uvTrans$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$64561[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAPAVSubMeshInstance@Ogre@@I@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?setUVMaskTrans@SubMeshInstance@Ogre@@QAEXVVector2@2@@Z ; Ogre::SubMeshInstance::setUVMaskTrans

; 182  : 			}

	jmp	SHORT $LN2@setUVMaskT
$LN4@setUVMaskT:

; 183  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setUVMaskTrans@MeshInstance@Ogre@@QAEXVVector2@2@@Z ENDP ; Ogre::MeshInstance::setUVMaskTrans
_TEXT	ENDS
PUBLIC	?setUVMaskColor@MeshInstance@Ogre@@QAEXVVector3@2@@Z ; Ogre::MeshInstance::setUVMaskColor
; Function compile flags: /Odtp
;	COMDAT ?setUVMaskColor@MeshInstance@Ogre@@QAEXVVector3@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$64567 = -4						; size = 4
_color$ = 8						; size = 12
?setUVMaskColor@MeshInstance@Ogre@@QAEXVVector3@2@@Z PROC ; Ogre::MeshInstance::setUVMaskColor, COMDAT
; _this$ = ecx

; 186  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 			for (size_t i=0; i<m_SubMeshes.size(); i++)

	mov	DWORD PTR _i$64567[ebp], 0
	jmp	SHORT $LN3@setUVMaskC
$LN2@setUVMaskC:
	mov	eax, DWORD PTR _i$64567[ebp]
	add	eax, 1
	mov	DWORD PTR _i$64567[ebp], eax
$LN3@setUVMaskC:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	cmp	DWORD PTR _i$64567[ebp], eax
	jae	SHORT $LN4@setUVMaskC

; 188  : 			{
; 189  : 				m_SubMeshes[i]->setUVMaskColor(color);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _color$[ebp]
	push	edx
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR _i$64567[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAPAVSubMeshInstance@Ogre@@I@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?setUVMaskColor@SubMeshInstance@Ogre@@QAEXVVector3@2@@Z ; Ogre::SubMeshInstance::setUVMaskColor

; 190  : 			}

	jmp	SHORT $LN2@setUVMaskC
$LN4@setUVMaskC:

; 191  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setUVMaskColor@MeshInstance@Ogre@@QAEXVVector3@2@@Z ENDP ; Ogre::MeshInstance::setUVMaskColor
_TEXT	ENDS
PUBLIC	?setLiuGuangTexture@MeshInstance@Ogre@@QAEXPAVTextureData@2@@Z ; Ogre::MeshInstance::setLiuGuangTexture
; Function compile flags: /Odtp
;	COMDAT ?setLiuGuangTexture@MeshInstance@Ogre@@QAEXPAVTextureData@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$64574 = -4						; size = 4
_texture$ = 8						; size = 4
?setLiuGuangTexture@MeshInstance@Ogre@@QAEXPAVTextureData@2@@Z PROC ; Ogre::MeshInstance::setLiuGuangTexture, COMDAT
; _this$ = ecx

; 194  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 195  : 			for (size_t i=0; i<m_SubMeshes.size(); i++)

	mov	DWORD PTR _i$64574[ebp], 0
	jmp	SHORT $LN3@setLiuGuan@2
$LN2@setLiuGuan@2:
	mov	eax, DWORD PTR _i$64574[ebp]
	add	eax, 1
	mov	DWORD PTR _i$64574[ebp], eax
$LN3@setLiuGuan@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	cmp	DWORD PTR _i$64574[ebp], eax
	jae	SHORT $LN4@setLiuGuan@2

; 196  : 			{
; 197  : 				m_SubMeshes[i]->setLiuGuangTexture(texture);

	mov	ecx, DWORD PTR _texture$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$64574[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAPAVSubMeshInstance@Ogre@@I@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?setLiuGuangTexture@SubMeshInstance@Ogre@@QAEXPAVTextureData@2@@Z ; Ogre::SubMeshInstance::setLiuGuangTexture

; 198  : 			}

	jmp	SHORT $LN2@setLiuGuan@2
$LN4@setLiuGuan@2:

; 199  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLiuGuangTexture@MeshInstance@Ogre@@QAEXPAVTextureData@2@@Z ENDP ; Ogre::MeshInstance::setLiuGuangTexture
_TEXT	ENDS
PUBLIC	?getNumSubMesh@MeshInstance@Ogre@@QAEIXZ	; Ogre::MeshInstance::getNumSubMesh
; Function compile flags: /Odtp
;	COMDAT ?getNumSubMesh@MeshInstance@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumSubMesh@MeshInstance@Ogre@@QAEIXZ PROC		; Ogre::MeshInstance::getNumSubMesh, COMDAT
; _this$ = ecx

; 202  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 			return m_SubMeshes.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size

; 204  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumSubMesh@MeshInstance@Ogre@@QAEIXZ ENDP		; Ogre::MeshInstance::getNumSubMesh
_TEXT	ENDS
PUBLIC	?getSubMesh@MeshInstance@Ogre@@QAEPAVSubMeshInstance@2@I@Z ; Ogre::MeshInstance::getSubMesh
; Function compile flags: /Odtp
;	COMDAT ?getSubMesh@MeshInstance@Ogre@@QAEPAVSubMeshInstance@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?getSubMesh@MeshInstance@Ogre@@QAEPAVSubMeshInstance@2@I@Z PROC ; Ogre::MeshInstance::getSubMesh, COMDAT
; _this$ = ecx

; 207  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 208  : 			if (i >= m_SubMeshes.size() || i<0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN1@getSubMesh
	cmp	DWORD PTR _i$[ebp], 0
	jae	SHORT $LN2@getSubMesh
$LN1@getSubMesh:

; 209  : 				return NULL;

	xor	eax, eax
	jmp	SHORT $LN3@getSubMesh
$LN2@getSubMesh:

; 210  : 
; 211  : 			return m_SubMeshes[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAPAVSubMeshInstance@Ogre@@I@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator[]
	mov	eax, DWORD PTR [eax]
$LN3@getSubMesh:

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getSubMesh@MeshInstance@Ogre@@QAEPAVSubMeshInstance@2@I@Z ENDP ; Ogre::MeshInstance::getSubMesh
_TEXT	ENDS
PUBLIC	??1?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::~vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
PUBLIC	??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
PUBLIC	??0MeshInstance@Ogre@@QAE@ABV01@@Z		; Ogre::MeshInstance::MeshInstance
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0MeshInstance@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MeshInstance@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0MeshInstance@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MeshInstance@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0MeshInstance@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0MeshInstance@Ogre@@QAE@ABV01@@Z PROC			; Ogre::MeshInstance::MeshInstance, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MeshInstance@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MeshInstance@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::~vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
__ehhandler$??0MeshInstance@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0MeshInstance@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MeshInstance@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::MeshInstance::MeshInstance
PUBLIC	??4?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator=
PUBLIC	??4MeshInstance@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::MeshInstance::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MeshInstance@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MeshInstance@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::MeshInstance::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MeshInstance@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::MeshInstance::operator=
_TEXT	ENDS
PUBLIC	??_7TextureDataLoader@Ogre@@6B@			; Ogre::TextureDataLoader::`vftable'
PUBLIC	??0TextureDataLoader@Ogre@@QAE@XZ		; Ogre::TextureDataLoader::TextureDataLoader
PUBLIC	??_R4TextureDataLoader@Ogre@@6B@		; Ogre::TextureDataLoader::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTextureDataLoader@Ogre@@@8		; Ogre::TextureDataLoader `RTTI Type Descriptor'
PUBLIC	??_R3TextureDataLoader@Ogre@@8			; Ogre::TextureDataLoader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TextureDataLoader@Ogre@@8			; Ogre::TextureDataLoader::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TextureDataLoader@Ogre@@8		; Ogre::TextureDataLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ETextureDataLoader@Ogre@@UAEPAXI@Z		; Ogre::TextureDataLoader::`vector deleting destructor'
EXTRN	??0MultiLoader@Ogre@@QAE@XZ:PROC		; Ogre::MultiLoader::MultiLoader
EXTRN	?onComplete@TextureDataLoader@Ogre@@EAEXIPAPAVResource@2@PAI@Z:PROC ; Ogre::TextureDataLoader::onComplete
;	COMDAT ??_R1A@?0A@EA@TextureDataLoader@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TextureDataLoader@Ogre@@8 DD FLAT:??_R0?AVTextureDataLoader@Ogre@@@8 ; Ogre::TextureDataLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TextureDataLoader@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2TextureDataLoader@Ogre@@8
rdata$r	SEGMENT
??_R2TextureDataLoader@Ogre@@8 DD FLAT:??_R1A@?0A@EA@TextureDataLoader@Ogre@@8 ; Ogre::TextureDataLoader::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@MultiLoader@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@LoadWrap@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3TextureDataLoader@Ogre@@8
rdata$r	SEGMENT
??_R3TextureDataLoader@Ogre@@8 DD 00H			; Ogre::TextureDataLoader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2TextureDataLoader@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTextureDataLoader@Ogre@@@8
_DATA	SEGMENT
??_R0?AVTextureDataLoader@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::TextureDataLoader `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTextureDataLoader@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TextureDataLoader@Ogre@@6B@
rdata$r	SEGMENT
??_R4TextureDataLoader@Ogre@@6B@ DD 00H			; Ogre::TextureDataLoader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTextureDataLoader@Ogre@@@8
	DD	FLAT:??_R3TextureDataLoader@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7TextureDataLoader@Ogre@@6B@
CONST	SEGMENT
??_7TextureDataLoader@Ogre@@6B@ DD FLAT:??_R4TextureDataLoader@Ogre@@6B@ ; Ogre::TextureDataLoader::`vftable'
	DD	FLAT:??_ETextureDataLoader@Ogre@@UAEPAXI@Z
	DD	FLAT:?ResourceLoaded@MultiLoader@Ogre@@EAEXPAVResource@2@I@Z
	DD	FLAT:?onComplete@TextureDataLoader@Ogre@@EAEXIPAPAVResource@2@PAI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0TextureDataLoader@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0TextureDataLoader@Ogre@@QAE@XZ$0
__ehfuncinfo$??0TextureDataLoader@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0TextureDataLoader@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0TextureDataLoader@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0TextureDataLoader@Ogre@@QAE@XZ PROC			; Ogre::TextureDataLoader::TextureDataLoader, COMDAT
; _this$ = ecx

; 261  : 		TextureDataLoader() : m_pModel(NULL) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0TextureDataLoader@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0MultiLoader@Ogre@@QAE@XZ		; Ogre::MultiLoader::MultiLoader
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TextureDataLoader@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0TextureDataLoader@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1MultiLoader@Ogre@@UAE@XZ		; Ogre::MultiLoader::~MultiLoader
__ehhandler$??0TextureDataLoader@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0TextureDataLoader@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0TextureDataLoader@Ogre@@QAE@XZ ENDP			; Ogre::TextureDataLoader::TextureDataLoader
PUBLIC	??1TextureDataLoader@Ogre@@UAE@XZ		; Ogre::TextureDataLoader::~TextureDataLoader
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1TextureDataLoader@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1TextureDataLoader@Ogre@@UAE@XZ$0
__ehfuncinfo$??1TextureDataLoader@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1TextureDataLoader@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1TextureDataLoader@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TextureDataLoader@Ogre@@UAE@XZ PROC			; Ogre::TextureDataLoader::~TextureDataLoader, COMDAT
; _this$ = ecx

; 262  : 		virtual ~TextureDataLoader() {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1TextureDataLoader@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TextureDataLoader@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MultiLoader@Ogre@@UAE@XZ		; Ogre::MultiLoader::~MultiLoader
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1TextureDataLoader@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1MultiLoader@Ogre@@UAE@XZ		; Ogre::MultiLoader::~MultiLoader
__ehhandler$??1TextureDataLoader@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1TextureDataLoader@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1TextureDataLoader@Ogre@@UAE@XZ ENDP			; Ogre::TextureDataLoader::~TextureDataLoader
PUBLIC	??0TextureDataLoader@Ogre@@QAE@ABV01@@Z		; Ogre::TextureDataLoader::TextureDataLoader
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0TextureDataLoader@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0TextureDataLoader@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0TextureDataLoader@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0TextureDataLoader@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0TextureDataLoader@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0TextureDataLoader@Ogre@@QAE@ABV01@@Z PROC		; Ogre::TextureDataLoader::TextureDataLoader, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0TextureDataLoader@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0MultiLoader@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7TextureDataLoader@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0TextureDataLoader@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1MultiLoader@Ogre@@UAE@XZ		; Ogre::MultiLoader::~MultiLoader
__ehhandler$??0TextureDataLoader@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0TextureDataLoader@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0TextureDataLoader@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::TextureDataLoader::TextureDataLoader
PUBLIC	??4TextureDataLoader@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::TextureDataLoader::operator=
; Function compile flags: /Odtp
;	COMDAT ??4TextureDataLoader@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4TextureDataLoader@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::TextureDataLoader::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4MultiLoader@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4TextureDataLoader@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::TextureDataLoader::operator=
_TEXT	ENDS
PUBLIC	??_GTextureDataLoader@Ogre@@UAEPAXI@Z		; Ogre::TextureDataLoader::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GTextureDataLoader@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTextureDataLoader@Ogre@@UAEPAXI@Z PROC		; Ogre::TextureDataLoader::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TextureDataLoader@Ogre@@UAE@XZ	; Ogre::TextureDataLoader::~TextureDataLoader
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@23
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@23:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTextureDataLoader@Ogre@@UAEPAXI@Z ENDP		; Ogre::TextureDataLoader::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ETextureDataLoader@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ETextureDataLoader@Ogre@@UAEPAXI@Z PROC		; Ogre::TextureDataLoader::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@23
	push	OFFSET ??1TextureDataLoader@Ogre@@UAE@XZ ; Ogre::TextureDataLoader::~TextureDataLoader
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@23
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@23:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@23
$LN3@vector@23:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TextureDataLoader@Ogre@@UAE@XZ	; Ogre::TextureDataLoader::~TextureDataLoader
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@23
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@23:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@23:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ETextureDataLoader@Ogre@@UAEPAXI@Z ENDP		; Ogre::TextureDataLoader::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@Model@Ogre@@UBEPBVRuntimeClass@2@XZ	; Ogre::Model::getRTTI
EXTRN	?m_RTTI@Model@Ogre@@2VRuntimeClass@2@B:BYTE	; Ogre::Model::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@Model@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@Model@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::Model::getRTTI, COMDAT
; _this$ = ecx

; 275  : 		DECLARE_RTTI(Model)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@Model@Ogre@@2VRuntimeClass@2@B ; Ogre::Model::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@Model@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::Model::getRTTI
_TEXT	ENDS
PUBLIC	?newObject@Model@Ogre@@SAPAVBaseObject@2@XZ	; Ogre::Model::newObject
EXTRN	??0Model@Ogre@@QAE@XZ:PROC			; Ogre::Model::Model
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@Model@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@Model@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@Model@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@Model@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@Model@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T90829 = -20						; size = 4
$T90828 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@Model@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::Model::newObject, COMDAT

; 275  : 		DECLARE_RTTI(Model)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@Model@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	540					; 0000021cH
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T90829[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T90829[ebp], 0
	je	SHORT $LN3@newObject@6
	mov	ecx, DWORD PTR $T90829[ebp]
	call	??0Model@Ogre@@QAE@XZ			; Ogre::Model::Model
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@6
$LN3@newObject@6:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@6:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T90828[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T90828[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@Model@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	540					; 0000021cH
	mov	eax, DWORD PTR $T90829[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@Model@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@Model@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@Model@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::Model::newObject
PUBLIC	??A?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEAAPAVMeshInstance@Ogre@@I@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator[]
PUBLIC	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
PUBLIC	?enableDeadEffect@Model@Ogre@@QAEX_N@Z		; Ogre::Model::enableDeadEffect
; Function compile flags: /Odtp
;	COMDAT ?enableDeadEffect@Model@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$68083 = -4						; size = 4
_enable$ = 8						; size = 1
?enableDeadEffect@Model@Ogre@@QAEX_N@Z PROC		; Ogre::Model::enableDeadEffect, COMDAT
; _this$ = ecx

; 283  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 284  : 			for (int i=0; i<(int)m_Meshes.size(); i++)

	mov	DWORD PTR _i$68083[ebp], 0
	jmp	SHORT $LN3@enableDead@2
$LN2@enableDead@2:
	mov	eax, DWORD PTR _i$68083[ebp]
	add	eax, 1
	mov	DWORD PTR _i$68083[ebp], eax
$LN3@enableDead@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
	cmp	DWORD PTR _i$68083[ebp], eax
	jge	SHORT $LN4@enableDead@2

; 285  : 			{
; 286  : 				m_Meshes[i]->enableDeadEffect(enable);

	movzx	ecx, BYTE PTR _enable$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$68083[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	??A?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEAAPAVMeshInstance@Ogre@@I@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?enableDeadEffect@MeshInstance@Ogre@@QAEX_N@Z ; Ogre::MeshInstance::enableDeadEffect

; 287  : 			}

	jmp	SHORT $LN2@enableDead@2
$LN4@enableDead@2:

; 288  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?enableDeadEffect@Model@Ogre@@QAEX_N@Z ENDP		; Ogre::Model::enableDeadEffect
_TEXT	ENDS
PUBLIC	?setDeadScale@Model@Ogre@@QAEXM@Z		; Ogre::Model::setDeadScale
; Function compile flags: /Odtp
;	COMDAT ?setDeadScale@Model@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$68090 = -4						; size = 4
_deadScale$ = 8						; size = 4
?setDeadScale@Model@Ogre@@QAEXM@Z PROC			; Ogre::Model::setDeadScale, COMDAT
; _this$ = ecx

; 291  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 292  : 			for (int i=0; i<(int)m_Meshes.size(); i++)

	mov	DWORD PTR _i$68090[ebp], 0
	jmp	SHORT $LN3@setDeadSca@2
$LN2@setDeadSca@2:
	mov	eax, DWORD PTR _i$68090[ebp]
	add	eax, 1
	mov	DWORD PTR _i$68090[ebp], eax
$LN3@setDeadSca@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
	cmp	DWORD PTR _i$68090[ebp], eax
	jge	SHORT $LN1@setDeadSca@2

; 293  : 			{
; 294  : 				m_Meshes[i]->setDeadScale(deadScale);

	push	ecx
	fld	DWORD PTR _deadScale$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$68090[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	??A?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEAAPAVMeshInstance@Ogre@@I@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?setDeadScale@MeshInstance@Ogre@@QAEXM@Z ; Ogre::MeshInstance::setDeadScale

; 295  : 			}

	jmp	SHORT $LN2@setDeadSca@2
$LN1@setDeadSca@2:

; 296  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setDeadScale@Model@Ogre@@QAEXM@Z ENDP			; Ogre::Model::setDeadScale
_TEXT	ENDS
PUBLIC	?enableUVMask@Model@Ogre@@UAEX_N0@Z		; Ogre::Model::enableUVMask
; Function compile flags: /Odtp
;	COMDAT ?enableUVMask@Model@Ogre@@UAEX_N0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$68097 = -4						; size = 4
_enable$ = 8						; size = 1
_stdmtluse$ = 12					; size = 1
?enableUVMask@Model@Ogre@@UAEX_N0@Z PROC		; Ogre::Model::enableUVMask, COMDAT
; _this$ = ecx

; 299  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 			for (int i=0; i<(int)m_Meshes.size(); i++)

	mov	DWORD PTR _i$68097[ebp], 0
	jmp	SHORT $LN3@enableUVMa@2
$LN2@enableUVMa@2:
	mov	eax, DWORD PTR _i$68097[ebp]
	add	eax, 1
	mov	DWORD PTR _i$68097[ebp], eax
$LN3@enableUVMa@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
	cmp	DWORD PTR _i$68097[ebp], eax
	jge	SHORT $LN4@enableUVMa@2

; 301  : 			{
; 302  : 				m_Meshes[i]->enableUVMask(enable, stdmtluse);

	movzx	ecx, BYTE PTR _stdmtluse$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _enable$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$68097[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	??A?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEAAPAVMeshInstance@Ogre@@I@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?enableUVMask@MeshInstance@Ogre@@QAEX_N0@Z ; Ogre::MeshInstance::enableUVMask

; 303  : 			}

	jmp	SHORT $LN2@enableUVMa@2
$LN4@enableUVMa@2:

; 304  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?enableUVMask@Model@Ogre@@UAEX_N0@Z ENDP		; Ogre::Model::enableUVMask
_TEXT	ENDS
PUBLIC	?setUVMaskSpeed@Model@Ogre@@QAEXVVector2@2@@Z	; Ogre::Model::setUVMaskSpeed
; Function compile flags: /Odtp
;	COMDAT ?setUVMaskSpeed@Model@Ogre@@QAEXVVector2@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_uvSpeed$ = 8						; size = 8
?setUVMaskSpeed@Model@Ogre@@QAEXVVector2@2@@Z PROC	; Ogre::Model::setUVMaskSpeed, COMDAT
; _this$ = ecx

; 307  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 308  : 			m_UVSpeed = uvSpeed;

	lea	eax, DWORD PTR _uvSpeed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 524				; 0000020cH
	call	??4Vector2@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector2::operator=

; 309  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setUVMaskSpeed@Model@Ogre@@QAEXVVector2@2@@Z ENDP	; Ogre::Model::setUVMaskSpeed
_TEXT	ENDS
PUBLIC	?setUVMaskColor@Model@Ogre@@QAEXVVector3@2@@Z	; Ogre::Model::setUVMaskColor
; Function compile flags: /Odtp
;	COMDAT ?setUVMaskColor@Model@Ogre@@QAEXVVector3@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$68106 = -4						; size = 4
_color$ = 8						; size = 12
?setUVMaskColor@Model@Ogre@@QAEXVVector3@2@@Z PROC	; Ogre::Model::setUVMaskColor, COMDAT
; _this$ = ecx

; 312  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 			for (int i=0; i<(int)m_Meshes.size(); i++)

	mov	DWORD PTR _i$68106[ebp], 0
	jmp	SHORT $LN3@setUVMaskC@2
$LN2@setUVMaskC@2:
	mov	eax, DWORD PTR _i$68106[ebp]
	add	eax, 1
	mov	DWORD PTR _i$68106[ebp], eax
$LN3@setUVMaskC@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
	cmp	DWORD PTR _i$68106[ebp], eax
	jge	SHORT $LN4@setUVMaskC@2

; 314  : 			{
; 315  : 				m_Meshes[i]->setUVMaskColor(color);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _color$[ebp]
	push	edx
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR _i$68106[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	??A?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEAAPAVMeshInstance@Ogre@@I@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?setUVMaskColor@MeshInstance@Ogre@@QAEXVVector3@2@@Z ; Ogre::MeshInstance::setUVMaskColor

; 316  : 			}

	jmp	SHORT $LN2@setUVMaskC@2
$LN4@setUVMaskC@2:

; 317  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setUVMaskColor@Model@Ogre@@QAEXVVector3@2@@Z ENDP	; Ogre::Model::setUVMaskColor
_TEXT	ENDS
PUBLIC	?setLiuGuangTexture@Model@Ogre@@UAEXPAVTextureData@2@@Z ; Ogre::Model::setLiuGuangTexture
; Function compile flags: /Odtp
;	COMDAT ?setLiuGuangTexture@Model@Ogre@@UAEXPAVTextureData@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$68114 = -4						; size = 4
_texture$ = 8						; size = 4
?setLiuGuangTexture@Model@Ogre@@UAEXPAVTextureData@2@@Z PROC ; Ogre::Model::setLiuGuangTexture, COMDAT
; _this$ = ecx

; 320  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 			for (int i=0; i<(int)m_Meshes.size(); i++)

	mov	DWORD PTR _i$68114[ebp], 0
	jmp	SHORT $LN3@setLiuGuan@3
$LN2@setLiuGuan@3:
	mov	eax, DWORD PTR _i$68114[ebp]
	add	eax, 1
	mov	DWORD PTR _i$68114[ebp], eax
$LN3@setLiuGuan@3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
	cmp	DWORD PTR _i$68114[ebp], eax
	jge	SHORT $LN4@setLiuGuan@3

; 322  : 			{
; 323  : 				m_Meshes[i]->setLiuGuangTexture(texture);

	mov	ecx, DWORD PTR _texture$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$68114[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	??A?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEAAPAVMeshInstance@Ogre@@I@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?setLiuGuangTexture@MeshInstance@Ogre@@QAEXPAVTextureData@2@@Z ; Ogre::MeshInstance::setLiuGuangTexture

; 324  : 			}

	jmp	SHORT $LN2@setLiuGuan@3
$LN4@setLiuGuan@3:

; 325  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLiuGuangTexture@Model@Ogre@@UAEXPAVTextureData@2@@Z ENDP ; Ogre::Model::setLiuGuangTexture
_TEXT	ENDS
PUBLIC	?canUseStaticLight@Model@Ogre@@QAE_NXZ		; Ogre::Model::canUseStaticLight
; Function compile flags: /Odtp
;	COMDAT ?canUseStaticLight@Model@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?canUseStaticLight@Model@Ogre@@QAE_NXZ PROC		; Ogre::Model::canUseStaticLight, COMDAT
; _this$ = ecx

; 330  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 			return m_bCanUseStaticLight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+520]

; 332  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?canUseStaticLight@Model@Ogre@@QAE_NXZ ENDP		; Ogre::Model::canUseStaticLight
_TEXT	ENDS
PUBLIC	?getSkeletonInstance@Model@Ogre@@QAEPAVSkeletonInstance@2@XZ ; Ogre::Model::getSkeletonInstance
; Function compile flags: /Odtp
;	COMDAT ?getSkeletonInstance@Model@Ogre@@QAEPAVSkeletonInstance@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSkeletonInstance@Model@Ogre@@QAEPAVSkeletonInstance@2@XZ PROC ; Ogre::Model::getSkeletonInstance, COMDAT
; _this$ = ecx

; 346  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 347  : 			return m_pSkeleton;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+288]

; 348  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getSkeletonInstance@Model@Ogre@@QAEPAVSkeletonInstance@2@XZ ENDP ; Ogre::Model::getSkeletonInstance
_TEXT	ENDS
PUBLIC	?getModelData@Model@Ogre@@QAEPAVModelData@2@XZ	; Ogre::Model::getModelData
; Function compile flags: /Odtp
;	COMDAT ?getModelData@Model@Ogre@@QAEPAVModelData@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getModelData@Model@Ogre@@QAEPAVModelData@2@XZ PROC	; Ogre::Model::getModelData, COMDAT
; _this$ = ecx

; 377  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 			return m_pModelData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+284]

; 379  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getModelData@Model@Ogre@@QAEPAVModelData@2@XZ ENDP	; Ogre::Model::getModelData
_TEXT	ENDS
PUBLIC	?getAnimPlayer@Model@Ogre@@QAEPAVAnimationPlayer@2@XZ ; Ogre::Model::getAnimPlayer
; Function compile flags: /Odtp
;	COMDAT ?getAnimPlayer@Model@Ogre@@QAEPAVAnimationPlayer@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getAnimPlayer@Model@Ogre@@QAEPAVAnimationPlayer@2@XZ PROC ; Ogre::Model::getAnimPlayer, COMDAT
; _this$ = ecx

; 382  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 383  : 			return m_pAnimPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+468]

; 384  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getAnimPlayer@Model@Ogre@@QAEPAVAnimationPlayer@2@XZ ENDP ; Ogre::Model::getAnimPlayer
_TEXT	ENDS
PUBLIC	?setInstanceAmbient@Model@Ogre@@QAEXABVColourValue@2@@Z ; Ogre::Model::setInstanceAmbient
; Function compile flags: /Odtp
;	COMDAT ?setInstanceAmbient@Model@Ogre@@QAEXABVColourValue@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_color$ = 8						; size = 4
?setInstanceAmbient@Model@Ogre@@QAEXABVColourValue@2@@Z PROC ; Ogre::Model::setInstanceAmbient, COMDAT
; _this$ = ecx

; 392  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 393  : 			m_InstanceAmbient = color;

	mov	eax, DWORD PTR _color$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 500				; 000001f4H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 394  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setInstanceAmbient@Model@Ogre@@QAEXABVColourValue@2@@Z ENDP ; Ogre::Model::setInstanceAmbient
_TEXT	ENDS
PUBLIC	??1?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@XZ ; std::map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::~map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >
PUBLIC	??1?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@XZ ; std::map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::~map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >
PUBLIC	??1?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@XZ ; std::map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >::~map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >
PUBLIC	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
PUBLIC	??1?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::~vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
PUBLIC	??1?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::~vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
PUBLIC	??0?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z ; std::map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >
PUBLIC	??0?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@ABV01@@Z ; std::map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >
PUBLIC	??0?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@ABV01@@Z ; std::map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >::map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >
PUBLIC	??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
PUBLIC	??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
PUBLIC	??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
PUBLIC	??_7Model@Ogre@@6BLoadWrap@1@@			; Ogre::Model::`vftable'
PUBLIC	??_7Model@Ogre@@6BRenderableObject@1@@		; Ogre::Model::`vftable'
PUBLIC	??0Model@Ogre@@QAE@ABV01@@Z			; Ogre::Model::Model
PUBLIC	??_R4Model@Ogre@@6BRenderableObject@1@@		; Ogre::Model::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVModel@Ogre@@@8				; Ogre::Model `RTTI Type Descriptor'
PUBLIC	??_R3Model@Ogre@@8				; Ogre::Model::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Model@Ogre@@8				; Ogre::Model::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Model@Ogre@@8			; Ogre::Model::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1BBI@?0A@EA@LoadWrap@Ogre@@8		; Ogre::LoadWrap::`RTTI Base Class Descriptor at (280,-1,0,64)'
PUBLIC	??_EModel@Ogre@@MAEPAXI@Z			; Ogre::Model::`vector deleting destructor'
PUBLIC	??_R4Model@Ogre@@6BLoadWrap@1@@			; Ogre::Model::`RTTI Complete Object Locator'
PUBLIC	??_EModel@Ogre@@OBBI@AEPAXI@Z			; [thunk]:Ogre::Model::`vector deleting destructor'
EXTRN	?update@Model@Ogre@@UAEXI@Z:PROC		; Ogre::Model::update
EXTRN	?resetUpdate@Model@Ogre@@UAEX_NI@Z:PROC		; Ogre::Model::resetUpdate
EXTRN	?intersectRay@Model@Ogre@@UAE_NW4IntersectType@2@ABVRay@2@PAM@Z:PROC ; Ogre::Model::intersectRay
EXTRN	?getAnchorWorldMatrix@Model@Ogre@@UAE?AVMatrix4@2@H@Z:PROC ; Ogre::Model::getAnchorWorldMatrix
EXTRN	?updateWorldCache@Model@Ogre@@UAEXXZ:PROC	; Ogre::Model::updateWorldCache
EXTRN	?render@Model@Ogre@@UAEXPAVSceneRenderer@2@ABUShaderEnvData@2@@Z:PROC ; Ogre::Model::render
EXTRN	?setCanUseStaticLight@Model@Ogre@@UAEX_N@Z:PROC	; Ogre::Model::setCanUseStaticLight
EXTRN	?ResourceLoaded@Model@Ogre@@MAEXPAVResource@2@I@Z:PROC ; Ogre::Model::ResourceLoaded
;	COMDAT ??_R4Model@Ogre@@6BLoadWrap@1@@
rdata$r	SEGMENT
??_R4Model@Ogre@@6BLoadWrap@1@@ DD 00H			; Ogre::Model::`RTTI Complete Object Locator'
	DD	0118H
	DD	00H
	DD	FLAT:??_R0?AVModel@Ogre@@@8
	DD	FLAT:??_R3Model@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1BBI@?0A@EA@LoadWrap@Ogre@@8
rdata$r	SEGMENT
??_R1BBI@?0A@EA@LoadWrap@Ogre@@8 DD FLAT:??_R0?AVLoadWrap@Ogre@@@8 ; Ogre::LoadWrap::`RTTI Base Class Descriptor at (280,-1,0,64)'
	DD	00H
	DD	0118H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3LoadWrap@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Model@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Model@Ogre@@8 DD FLAT:??_R0?AVModel@Ogre@@@8 ; Ogre::Model::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Model@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Model@Ogre@@8
rdata$r	SEGMENT
??_R2Model@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Model@Ogre@@8	; Ogre::Model::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@RenderableObject@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@MovableObject@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
	DD	FLAT:??_R1BBI@?0A@EA@LoadWrap@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3Model@Ogre@@8
rdata$r	SEGMENT
??_R3Model@Ogre@@8 DD 00H				; Ogre::Model::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	06H
	DD	FLAT:??_R2Model@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVModel@Ogre@@@8
_DATA	SEGMENT
??_R0?AVModel@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Model `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVModel@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Model@Ogre@@6BRenderableObject@1@@
rdata$r	SEGMENT
??_R4Model@Ogre@@6BRenderableObject@1@@ DD 00H		; Ogre::Model::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVModel@Ogre@@@8
	DD	FLAT:??_R3Model@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Model@Ogre@@6BLoadWrap@1@@
CONST	SEGMENT
??_7Model@Ogre@@6BLoadWrap@1@@ DD FLAT:??_R4Model@Ogre@@6BLoadWrap@1@@ ; Ogre::Model::`vftable'
	DD	FLAT:??_EModel@Ogre@@OBBI@AEPAXI@Z
	DD	FLAT:?ResourceLoaded@Model@Ogre@@MAEXPAVResource@2@I@Z
CONST	ENDS
;	COMDAT ??_7Model@Ogre@@6BRenderableObject@1@@
CONST	SEGMENT
??_7Model@Ogre@@6BRenderableObject@1@@ DD FLAT:??_R4Model@Ogre@@6BRenderableObject@1@@ ; Ogre::Model::`vftable'
	DD	FLAT:?getRTTI@Model@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EModel@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?enableUVMask@Model@Ogre@@UAEX_N0@Z
	DD	FLAT:?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPBD@Z
	DD	FLAT:?setLiuGuangTexture@Model@Ogre@@UAEXPAVTextureData@2@@Z
	DD	FLAT:?SetForceShadowMapCull@MovableObject@Ogre@@UAEX_N@Z
	DD	FLAT:?update@Model@Ogre@@UAEXI@Z
	DD	FLAT:?resetUpdate@Model@Ogre@@UAEX_NI@Z
	DD	FLAT:?attachToScene@MovableObject@Ogre@@UAEXPAVGameScene@2@_N@Z
	DD	FLAT:?detachFromScene@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:?intersectRay@Model@Ogre@@UAE_NW4IntersectType@2@ABVRay@2@PAM@Z
	DD	FLAT:?getAnchorWorldMatrix@Model@Ogre@@UAE?AVMatrix4@2@H@Z
	DD	FLAT:?invalidWorldCache@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:?updateWorldCache@Model@Ogre@@UAEXXZ
	DD	FLAT:?render@Model@Ogre@@UAEXPAVSceneRenderer@2@ABUShaderEnvData@2@@Z
	DD	FLAT:?setCanSel@RenderableObject@Ogre@@UAEX_N@Z
	DD	FLAT:?setLayer@RenderableObject@Ogre@@UAEXW4RenderLayer@2@@Z
	DD	FLAT:?BuildDecalMesh@RenderableObject@Ogre@@UAEXABVBoxBound@2@PAVVector3@2@PAGHHAAH3@Z
	DD	FLAT:?addRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z
	DD	FLAT:?clearRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z
	DD	FLAT:?getRenderPassRequired@RenderableObject@Ogre@@UAEXAAURenderPassDesc@2@@Z
	DD	FLAT:?setCanUseStaticLight@Model@Ogre@@UAEX_N@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0Model@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??0Model@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0Model@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$7
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Model@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv90 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Model@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Model::Model, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Model@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0RenderableObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR ___that$[ebp], 0
	je	SHORT $LN3@Model
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 280				; 00000118H
	mov	DWORD PTR tv90[ebp], ecx
	jmp	SHORT $LN4@Model
$LN3@Model:
	mov	DWORD PTR tv90[ebp], 0
$LN4@Model:
	mov	edx, DWORD PTR tv90[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	call	??0LoadWrap@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Model@Ogre@@6BRenderableObject@1@@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+280], OFFSET ??_7Model@Ogre@@6BLoadWrap@1@@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	mov	DWORD PTR [edx+284], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	mov	DWORD PTR [edx+288], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 292				; 00000124H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 316				; 0000013cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	call	??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 340				; 00000154H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	call	??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 372				; 00000174H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	call	??0?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 404				; 00000194H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	call	??0?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 436				; 000001b4H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 436				; 000001b4H
	call	??0?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+468]
	mov	DWORD PTR [edx+468], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 472				; 000001d8H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 472				; 000001d8H
	call	??0BoxSphereBound@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 500				; 000001f4H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 500				; 000001f4H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+516]
	mov	DWORD PTR [ecx+516], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+520]
	mov	BYTE PTR [ecx+520], al
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+524]
	mov	eax, DWORD PTR [ecx+528]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+524], edx
	mov	DWORD PTR [ecx+528], eax
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+532]
	mov	ecx, DWORD PTR [edx+536]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+532], eax
	mov	DWORD PTR [edx+536], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RenderableObject@Ogre@@MAE@XZ	; Ogre::RenderableObject::~RenderableObject
__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	jmp	??1LoadWrap@Ogre@@MAE@XZ		; Ogre::LoadWrap::~LoadWrap
__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	jmp	??1?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::~vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	jmp	??1?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::~vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	jmp	??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	jmp	??1?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	jmp	??1?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@XZ
__unwindfunclet$??0Model@Ogre@@QAE@ABV01@@Z$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 436				; 000001b4H
	jmp	??1?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@XZ
__ehhandler$??0Model@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Model@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Model@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Model::Model
PUBLIC	??4?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z ; std::map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::operator=
PUBLIC	??4?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAEAAV01@ABV01@@Z ; std::map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::operator=
PUBLIC	??4?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >::operator=
PUBLIC	??4?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator=
PUBLIC	??4?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::operator=
PUBLIC	??4?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator=
PUBLIC	??4Model@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Model::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Model@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv84 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Model@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Model::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4RenderableObject@Ogre@@QAEAAV01@ABV01@@Z
	cmp	DWORD PTR ___that$[ebp], 0
	je	SHORT $LN3@operator@9
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 280				; 00000118H
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN4@operator@9
$LN3@operator@9:
	mov	DWORD PTR tv84[ebp], 0
$LN4@operator@9:
	mov	edx, DWORD PTR tv84[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	call	??4LoadWrap@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+284]
	mov	DWORD PTR [eax+284], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	mov	DWORD PTR [eax+288], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 292				; 00000124H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	??4?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 316				; 0000013cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	call	??4?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 340				; 00000154H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	call	??4?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 372				; 00000174H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	call	??4?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 404				; 00000194H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	call	??4?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAEAAV01@ABV01@@Z
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 436				; 000001b4H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 436				; 000001b4H
	call	??4?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+468]
	mov	DWORD PTR [eax+468], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 472				; 000001d8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 472				; 000001d8H
	call	??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 500				; 000001f4H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 500				; 000001f4H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+516]
	mov	DWORD PTR [edx+516], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+520]
	mov	BYTE PTR [edx+520], cl
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 524				; 0000020cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 524				; 0000020cH
	call	??4Vector2@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector2::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 532				; 00000214H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	??4Vector2@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector2::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Model@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Model::operator=
_TEXT	ENDS
PUBLIC	??_GModel@Ogre@@MAEPAXI@Z			; Ogre::Model::`scalar deleting destructor'
EXTRN	??1Model@Ogre@@MAE@XZ:PROC			; Ogre::Model::~Model
; Function compile flags: /Odtp
;	COMDAT ??_GModel@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GModel@Ogre@@MAEPAXI@Z PROC				; Ogre::Model::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Model@Ogre@@MAE@XZ			; Ogre::Model::~Model
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@24
	push	540					; 0000021cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@24:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GModel@Ogre@@MAEPAXI@Z ENDP				; Ogre::Model::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EModel@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EModel@Ogre@@MAEPAXI@Z PROC				; Ogre::Model::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@24
	push	OFFSET ??1Model@Ogre@@MAE@XZ		; Ogre::Model::~Model
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	540					; 0000021cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@24
	push	540					; 0000021cH
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@24:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@24
$LN3@vector@24:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Model@Ogre@@MAE@XZ			; Ogre::Model::~Model
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@24
	push	540					; 0000021cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@24:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@24:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EModel@Ogre@@MAEPAXI@Z ENDP				; Ogre::Model::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
__ehhandler$??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
__ehhandler$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::~map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >::map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
__ehhandler$??0?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >::map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@XZ PROC ; std::map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >::~map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
__ehhandler$??1?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >::~map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@ABV01@@Z PROC ; std::map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
__ehhandler$??0?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@ABV01@@Z ENDP ; std::map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@XZ$0
__ehfuncinfo$??1?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@XZ PROC ; std::map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::~map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
__ehhandler$??1?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAE@XZ ENDP ; std::map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::~map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z PROC ; std::map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
__ehhandler$??0?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z ENDP ; std::map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@XZ$0
__ehfuncinfo$??1?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@XZ PROC ; std::map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::~map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
__ehhandler$??1?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::~map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >
PUBLIC	??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$map@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> > >::operator=
_TEXT	ENDS
PUBLIC	??4?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$map@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> > >::operator=
_TEXT	ENDS
PUBLIC	??4?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$map@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::operator=
_TEXT	ENDS
PUBLIC	??4?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$map@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::operator=
_TEXT	ENDS
PUBLIC	?TickToTime@Ogre@@YAMI@Z			; Ogre::TickToTime
PUBLIC	?update@AnimPlayTrack@Ogre@@QAEXI@Z		; Ogre::AnimPlayTrack::update
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreanimationplayer.cpp
_TEXT	SEGMENT
tv186 = -32						; size = 8
tv184 = -24						; size = 4
tv181 = -18						; size = 2
tv176 = -16						; size = 8
_this$ = -8						; size = 4
_curtick$ = -4						; size = 4
_dtick$ = 8						; size = 4
?update@AnimPlayTrack@Ogre@@QAEXI@Z PROC		; Ogre::AnimPlayTrack::update
; _this$ = ecx

; 10   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 11   : 		assert( m_CurTick>=m_Start && m_CurTick<=m_End );
; 12   : 		uint curtick = m_CurTick + (uint)(dtick*m_Speed);

	mov	eax, DWORD PTR _dtick$[ebp]
	mov	DWORD PTR tv176[ebp], eax
	mov	DWORD PTR tv176[ebp+4], 0
	fild	QWORD PTR tv176[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+44]
	fnstcw	WORD PTR tv181[ebp]
	movzx	eax, WORD PTR tv181[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv184[ebp], eax
	fldcw	WORD PTR tv184[ebp]
	fistp	QWORD PTR tv186[ebp]
	fldcw	WORD PTR tv181[ebp]
	mov	edx, DWORD PTR tv186[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+24]
	mov	DWORD PTR _curtick$[ebp], edx

; 13   : 
; 14   : 		if( m_Start == m_End )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [edx+32]
	jne	SHORT $LN16@update

; 15   : 		{
; 16   : 			curtick = m_Start;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _curtick$[ebp], edx
	jmp	SHORT $LN10@update
$LN16@update:

; 17   : 		}
; 18   : 		else if( curtick >= m_End )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _curtick$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jb	SHORT $LN10@update

; 19   : 		{
; 20   : 			if( m_PlayMode == ANIM_MODE_LOOP )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN13@update

; 21   : 			{
; 22   : 				curtick = ( (curtick-m_Start)%(m_End-m_Start) ) + m_Start;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _curtick$[ebp]
	sub	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+32]
	sub	esi, DWORD PTR [eax+28]
	mov	eax, ecx
	xor	edx, edx
	div	esi
	mov	ecx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _curtick$[ebp], edx

; 23   : 			}
; 24   : 			else

	jmp	SHORT $LN10@update
$LN13@update:

; 25   : 			{
; 26   : 				curtick = m_End;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _curtick$[ebp], eax

; 27   : 				if( m_PlayMode == ANIM_MODE_ONCE ) m_State = STATE_OUT;

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+36], 1
	jne	SHORT $LN11@update
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 3
	jmp	SHORT $LN10@update
$LN11@update:

; 28   : 				else m_Speed = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+44]
$LN10@update:

; 29   : 			}
; 30   : 		}
; 31   : 
; 32   : 		if( m_State == STATE_IN )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 1
	jne	SHORT $LN9@update

; 33   : 		{
; 34   : 			if( m_DelayIn == 0 )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+48]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@update

; 35   : 			{
; 36   : 				m_Weight = 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax+20]

; 37   : 				m_State = STATE_ACTIVE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 2

; 38   : 			}
; 39   : 			else

	jmp	SHORT $LN6@update
$LN8@update:

; 40   : 			{
; 41   : 				m_Weight += TickToTime(dtick)/m_DelayIn;

	mov	edx, DWORD PTR _dtick$[ebp]
	push	edx
	call	?TickToTime@Ogre@@YAMI@Z		; Ogre::TickToTime
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [eax+48]
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+20]

; 42   : 				if(m_Weight >= 1.0f)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+20]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN6@update

; 43   : 				{
; 44   : 					m_Weight = 1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [ecx+20]

; 45   : 					m_State = STATE_ACTIVE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 2
$LN6@update:

; 46   : 				}
; 47   : 			}

	jmp	SHORT $LN1@update
$LN9@update:

; 48   : 		}
; 49   : 		else if( m_State == STATE_OUT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 3
	jne	SHORT $LN1@update

; 50   : 		{
; 51   : 			if( m_DelayOut == 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+52]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@update

; 52   : 			{
; 53   : 				m_Weight = 0;

	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+20]

; 54   : 				m_State = STATE_NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 55   : 			}
; 56   : 			else

	jmp	SHORT $LN1@update
$LN3@update:

; 57   : 			{
; 58   : 				m_Weight -= TickToTime(dtick)/m_DelayOut;

	mov	ecx, DWORD PTR _dtick$[ebp]
	push	ecx
	call	?TickToTime@Ogre@@YAMI@Z		; Ogre::TickToTime
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [edx+52]
	mov	eax, DWORD PTR _this$[ebp]
	fsubr	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+20]

; 59   : 				if( m_Weight <= 0 )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+20]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN1@update

; 60   : 				{
; 61   : 					m_Weight = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+20]

; 62   : 					m_State = STATE_NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
$LN1@update:

; 63   : 				}
; 64   : 			}
; 65   : 		}
; 66   : 
; 67   : 		m_CurTick = curtick;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _curtick$[ebp]
	mov	DWORD PTR [edx+24], eax

; 68   : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?update@AnimPlayTrack@Ogre@@QAEXI@Z ENDP		; Ogre::AnimPlayTrack::update
_TEXT	ENDS
PUBLIC	__real@408f400000000000
;	COMDAT __real@408f400000000000
; File i:\svnroot\client\ogremain\ogreprerequisites.h
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?TickToTime@Ogre@@YAMI@Z
_TEXT	SEGMENT
tv75 = -12						; size = 4
tv70 = -8						; size = 8
_tick$ = 8						; size = 4
?TickToTime@Ogre@@YAMI@Z PROC				; Ogre::TickToTime, COMDAT

; 290  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 291  : 		return (float)(tick/1000.0f);

	mov	eax, DWORD PTR _tick$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	mov	DWORD PTR tv70[ebp+4], 0
	fild	QWORD PTR tv70[ebp]
	fdiv	QWORD PTR __real@408f400000000000
	fstp	DWORD PTR tv75[ebp]
	fld	DWORD PTR tv75[ebp]

; 292  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?TickToTime@Ogre@@YAMI@Z ENDP				; Ogre::TickToTime
_TEXT	ENDS
PUBLIC	?resetUpdate@AnimPlayTrack@Ogre@@QAEXI@Z	; Ogre::AnimPlayTrack::resetUpdate
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreanimationplayer.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_tick$ = 8						; size = 4
?resetUpdate@AnimPlayTrack@Ogre@@QAEXI@Z PROC		; Ogre::AnimPlayTrack::resetUpdate
; _this$ = ecx

; 71   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 		m_CurTick = m_Start;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+24], edx

; 73   : 		update(tick);

	mov	eax, DWORD PTR _tick$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?update@AnimPlayTrack@Ogre@@QAEXI@Z	; Ogre::AnimPlayTrack::update

; 74   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?resetUpdate@AnimPlayTrack@Ogre@@QAEXI@Z ENDP		; Ogre::AnimPlayTrack::resetUpdate
_TEXT	ENDS
PUBLIC	__real@3e4ccccd
PUBLIC	??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
PUBLIC	??0AnimationPlayer@Ogre@@QAE@PAVModel@1@@Z	; Ogre::AnimationPlayer::AnimationPlayer
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0AnimationPlayer@Ogre@@QAE@PAVModel@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AnimationPlayer@Ogre@@QAE@PAVModel@1@@Z$0
__ehfuncinfo$??0AnimationPlayer@Ogre@@QAE@PAVModel@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0AnimationPlayer@Ogre@@QAE@PAVModel@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pmodel$ = 8						; size = 4
??0AnimationPlayer@Ogre@@QAE@PAVModel@1@@Z PROC		; Ogre::AnimationPlayer::AnimationPlayer
; _this$ = ecx

; 77   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AnimationPlayer@Ogre@@QAE@PAVModel@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pmodel$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 78   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0AnimationPlayer@Ogre@@QAE@PAVModel@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::~vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
__ehhandler$??0AnimationPlayer@Ogre@@QAE@PAVModel@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AnimationPlayer@Ogre@@QAE@PAVModel@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AnimationPlayer@Ogre@@QAE@PAVModel@1@@Z ENDP		; Ogre::AnimationPlayer::AnimationPlayer
PUBLIC	??$DeletePointerArray@VAnimPlayTrack@Ogre@@@Ogre@@YAXAAV?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@Z ; Ogre::DeletePointerArray<Ogre::AnimPlayTrack>
PUBLIC	??1AnimationPlayer@Ogre@@QAE@XZ			; Ogre::AnimationPlayer::~AnimationPlayer
xdata$x	SEGMENT
__unwindtable$??1AnimationPlayer@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1AnimationPlayer@Ogre@@QAE@XZ$0
__ehfuncinfo$??1AnimationPlayer@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1AnimationPlayer@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1AnimationPlayer@Ogre@@QAE@XZ PROC			; Ogre::AnimationPlayer::~AnimationPlayer
; _this$ = ecx

; 81   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1AnimationPlayer@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 82   : 		DeletePointerArray(m_PlayTracks);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$DeletePointerArray@VAnimPlayTrack@Ogre@@@Ogre@@YAXAAV?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@Z ; Ogre::DeletePointerArray<Ogre::AnimPlayTrack>
	add	esp, 4

; 83   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::~vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1AnimationPlayer@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::~vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
__ehhandler$??1AnimationPlayer@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1AnimationPlayer@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AnimationPlayer@Ogre@@QAE@XZ ENDP			; Ogre::AnimationPlayer::~AnimationPlayer
PUBLIC	?setAnimDelayInOut@AnimationPlayer@Ogre@@QAEXMM@Z ; Ogre::AnimationPlayer::setAnimDelayInOut
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_delayin$ = 8						; size = 4
_delayout$ = 12						; size = 4
?setAnimDelayInOut@AnimationPlayer@Ogre@@QAEXMM@Z PROC	; Ogre::AnimationPlayer::setAnimDelayInOut
; _this$ = ecx

; 86   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 		m_AnimDelayIn = delayin;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _delayin$[ebp]
	fstp	DWORD PTR [eax+24]

; 88   : 		m_AnimDelayOut = delayout;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _delayout$[ebp]
	fstp	DWORD PTR [ecx+28]

; 89   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?setAnimDelayInOut@AnimationPlayer@Ogre@@QAEXMM@Z ENDP	; Ogre::AnimationPlayer::setAnimDelayInOut
_TEXT	ENDS
PUBLIC	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
PUBLIC	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
PUBLIC	?findPlayTrack@AnimationPlayer@Ogre@@QAEPAVAnimPlayTrack@2@H@Z ; Ogre::AnimationPlayer::findPlayTrack
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_ptrack$71688 = -8					; size = 4
_i$71684 = -4						; size = 4
_seq$ = 8						; size = 4
?findPlayTrack@AnimationPlayer@Ogre@@QAEPAVAnimPlayTrack@2@H@Z PROC ; Ogre::AnimationPlayer::findPlayTrack
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		for(size_t i=0; i<m_PlayTracks.size(); i++)

	mov	DWORD PTR _i$71684[ebp], 0
	jmp	SHORT $LN5@findPlayTr
$LN4@findPlayTr:
	mov	eax, DWORD PTR _i$71684[ebp]
	add	eax, 1
	mov	DWORD PTR _i$71684[ebp], eax
$LN5@findPlayTr:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	cmp	DWORD PTR _i$71684[ebp], eax
	jae	SHORT $LN3@findPlayTr

; 94   : 		{
; 95   : 			AnimPlayTrack *ptrack = m_PlayTracks[i];

	mov	ecx, DWORD PTR _i$71684[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _ptrack$71688[ebp], edx

; 96   : 			if(ptrack->m_State != AnimPlayTrack::STATE_NULL)

	mov	eax, DWORD PTR _ptrack$71688[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN2@findPlayTr

; 97   : 			{
; 98   : 				if(ptrack->m_nSequence == seq) return ptrack;

	mov	ecx, DWORD PTR _ptrack$71688[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _seq$[ebp]
	jne	SHORT $LN2@findPlayTr
	mov	eax, DWORD PTR _ptrack$71688[ebp]
	jmp	SHORT $LN6@findPlayTr
$LN2@findPlayTr:

; 99   : 			}
; 100  : 		}

	jmp	SHORT $LN4@findPlayTr
$LN3@findPlayTr:

; 101  : 
; 102  : 		return NULL;

	xor	eax, eax
$LN6@findPlayTr:

; 103  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?findPlayTrack@AnimationPlayer@Ogre@@QAEPAVAnimPlayTrack@2@H@Z ENDP ; Ogre::AnimationPlayer::findPlayTrack
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEXABQAVAnimPlayTrack@Ogre@@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::push_back
PUBLIC	??0AnimPlayTrack@Ogre@@QAE@XZ			; Ogre::AnimPlayTrack::AnimPlayTrack
PUBLIC	?getSingleton@?$Singleton@VSequenceMap@Ogre@@@Ogre@@SAAAVSequenceMap@2@XZ ; Ogre::Singleton<Ogre::SequenceMap>::getSingleton
PUBLIC	?play@AnimationPlayer@Ogre@@QAEPAVAnimPlayTrack@2@HPAVBaseAnimationData@2@MM@Z ; Ogre::AnimationPlayer::play
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	?findSequenceDesc@SequenceMap@Ogre@@QAEPAUSeqDesc@12@H@Z:PROC ; Ogre::SequenceMap::findSequenceDesc
EXTRN	?getSequence@BaseAnimationData@Ogre@@QAEPAUSequenceDesc@2@I@Z:PROC ; Ogre::BaseAnimationData::getSequence
EXTRN	?getSequenceIndex@BaseAnimationData@Ogre@@QAEHH@Z:PROC ; Ogre::BaseAnimationData::getSequenceIndex
xdata$x	SEGMENT
__unwindtable$?play@AnimationPlayer@Ogre@@QAEPAVAnimPlayTrack@2@HPAVBaseAnimationData@2@MM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?play@AnimationPlayer@Ogre@@QAEPAVAnimPlayTrack@2@HPAVBaseAnimationData@2@MM@Z$0
__ehfuncinfo$?play@AnimationPlayer@Ogre@@QAEPAVAnimPlayTrack@2@HPAVBaseAnimationData@2@MM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?play@AnimationPlayer@Ogre@@QAEPAVAnimPlayTrack@2@HPAVBaseAnimationData@2@MM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv160 = -76						; size = 4
tv155 = -72						; size = 4
tv141 = -68						; size = 4
tv95 = -64						; size = 4
_this$ = -60						; size = 4
$T90995 = -56						; size = 4
$T90994 = -52						; size = 4
_ptmp$71710 = -48					; size = 4
_pdesc$ = -44						; size = 4
_pnulltrack$ = -40					; size = 4
_seq_index$ = -36					; size = 4
_priority$ = -32					; size = 4
_loopmode$ = -28					; size = 4
_i$ = -24						; size = 4
_pseq$ = -20						; size = 4
_pempty$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_seq$ = 8						; size = 4
_panimdata$ = 12					; size = 4
_weight$ = 16						; size = 4
_speed$ = 20						; size = 4
?play@AnimationPlayer@Ogre@@QAEPAVAnimPlayTrack@2@HPAVBaseAnimationData@2@MM@Z PROC ; Ogre::AnimationPlayer::play
; _this$ = ecx

; 106  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?play@AnimationPlayer@Ogre@@QAEPAVAnimPlayTrack@2@HPAVBaseAnimationData@2@MM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 		int seq_index = panimdata->getSequenceIndex(seq);

	mov	eax, DWORD PTR _seq$[ebp]
	push	eax
	mov	ecx, DWORD PTR _panimdata$[ebp]
	call	?getSequenceIndex@BaseAnimationData@Ogre@@QAEHH@Z ; Ogre::BaseAnimationData::getSequenceIndex
	mov	DWORD PTR _seq_index$[ebp], eax

; 108  : 		SequenceDesc *pseq = panimdata->getSequence(seq_index);

	mov	ecx, DWORD PTR _seq_index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _panimdata$[ebp]
	call	?getSequence@BaseAnimationData@Ogre@@QAEPAUSequenceDesc@2@I@Z ; Ogre::BaseAnimationData::getSequence
	mov	DWORD PTR _pseq$[ebp], eax

; 109  : 		SequenceMap::SeqDesc *pdesc = SequenceMap::getSingleton().findSequenceDesc(seq);

	mov	edx, DWORD PTR _seq$[ebp]
	push	edx
	call	?getSingleton@?$Singleton@VSequenceMap@Ogre@@@Ogre@@SAAAVSequenceMap@2@XZ ; Ogre::Singleton<Ogre::SequenceMap>::getSingleton
	mov	ecx, eax
	call	?findSequenceDesc@SequenceMap@Ogre@@QAEPAUSeqDesc@12@H@Z ; Ogre::SequenceMap::findSequenceDesc
	mov	DWORD PTR _pdesc$[ebp], eax

; 110  : 
; 111  : 		int priority = 0;

	mov	DWORD PTR _priority$[ebp], 0

; 112  : 		int loopmode = pseq->loopmode;

	mov	eax, DWORD PTR _pseq$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _loopmode$[ebp], ecx

; 113  : 		if(pdesc)

	cmp	DWORD PTR _pdesc$[ebp], 0
	je	SHORT $LN12@play

; 114  : 		{
; 115  : 			priority = pdesc->priority;

	mov	edx, DWORD PTR _pdesc$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _priority$[ebp], eax

; 116  : 			loopmode = pdesc->loopmode;

	mov	ecx, DWORD PTR _pdesc$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _loopmode$[ebp], edx
$LN12@play:

; 117  : 		}
; 118  : 
; 119  : 		//m_AnimDelayIn = m_AnimDelayOut = 0;
; 120  : 
; 121  : 		size_t i;
; 122  : 		AnimPlayTrack *pempty = NULL;

	mov	DWORD PTR _pempty$[ebp], 0

; 123  : 		AnimPlayTrack *pnulltrack = NULL;

	mov	DWORD PTR _pnulltrack$[ebp], 0

; 124  : 		for( i=0; i<m_PlayTracks.size(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@play
$LN10@play:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@play:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN9@play

; 125  : 		{
; 126  : 			AnimPlayTrack *ptmp = m_PlayTracks[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _ptmp$71710[ebp], edx

; 127  : 			if((ptmp->m_State==AnimPlayTrack::STATE_ACTIVE||ptmp->m_State==AnimPlayTrack::STATE_IN) && ptmp->m_nPriority==priority)

	mov	eax, DWORD PTR _ptmp$71710[ebp]
	cmp	DWORD PTR [eax+16], 2
	je	SHORT $LN7@play
	mov	ecx, DWORD PTR _ptmp$71710[ebp]
	cmp	DWORD PTR [ecx+16], 1
	jne	SHORT $LN8@play
$LN7@play:
	mov	edx, DWORD PTR _ptmp$71710[ebp]
	mov	eax, DWORD PTR [edx+40]
	cmp	eax, DWORD PTR _priority$[ebp]
	jne	SHORT $LN8@play

; 128  : 			{
; 129  : 				ptmp->m_State = m_AnimDelayOut==0?AnimPlayTrack::STATE_NULL:AnimPlayTrack::STATE_OUT;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+28]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@play
	mov	DWORD PTR tv95[ebp], 0
	jmp	SHORT $LN16@play
$LN15@play:
	mov	DWORD PTR tv95[ebp], 3
$LN16@play:
	mov	edx, DWORD PTR _ptmp$71710[ebp]
	mov	eax, DWORD PTR tv95[ebp]
	mov	DWORD PTR [edx+16], eax
$LN8@play:

; 130  : 			}
; 131  : 
; 132  : 			if(ptmp->m_State == AnimPlayTrack::STATE_NULL) pnulltrack = ptmp;

	mov	ecx, DWORD PTR _ptmp$71710[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN6@play
	mov	edx, DWORD PTR _ptmp$71710[ebp]
	mov	DWORD PTR _pnulltrack$[ebp], edx
	jmp	SHORT $LN4@play
$LN6@play:

; 133  : 			else if(ptmp->m_nSequence == seq) pempty = ptmp;

	mov	eax, DWORD PTR _ptmp$71710[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _seq$[ebp]
	jne	SHORT $LN4@play
	mov	edx, DWORD PTR _ptmp$71710[ebp]
	mov	DWORD PTR _pempty$[ebp], edx
$LN4@play:

; 134  : 		}

	jmp	$LN10@play
$LN9@play:

; 135  : 
; 136  : 		if(pempty == NULL)

	cmp	DWORD PTR _pempty$[ebp], 0
	jne	SHORT $LN1@play

; 137  : 		{
; 138  : 			if(pnulltrack) pempty = pnulltrack;

	cmp	DWORD PTR _pnulltrack$[ebp], 0
	je	SHORT $LN2@play
	mov	eax, DWORD PTR _pnulltrack$[ebp]
	mov	DWORD PTR _pempty$[ebp], eax

; 139  : 			else

	jmp	SHORT $LN1@play
$LN2@play:

; 140  : 			{
; 141  : 				pempty = new AnimPlayTrack;

	push	56					; 00000038H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T90995[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T90995[ebp], 0
	je	SHORT $LN17@play
	mov	ecx, DWORD PTR $T90995[ebp]
	call	??0AnimPlayTrack@Ogre@@QAE@XZ		; Ogre::AnimPlayTrack::AnimPlayTrack
	mov	DWORD PTR tv141[ebp], eax
	jmp	SHORT $LN18@play
$LN17@play:
	mov	DWORD PTR tv141[ebp], 0
$LN18@play:
	mov	ecx, DWORD PTR tv141[ebp]
	mov	DWORD PTR $T90994[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T90994[ebp]
	mov	DWORD PTR _pempty$[ebp], edx

; 142  : 				m_PlayTracks.push_back(pempty);

	lea	eax, DWORD PTR _pempty$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEXABQAVAnimPlayTrack@Ogre@@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::push_back
$LN1@play:

; 143  : 			}
; 144  : 		}
; 145  : 		assert(m_PlayTracks.size() <= 8);
; 146  : 
; 147  : 		pempty->m_AnimType = panimdata->getType();

	mov	ecx, DWORD PTR _panimdata$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _panimdata$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	mov	ecx, DWORD PTR _pempty$[ebp]
	mov	DWORD PTR [ecx], eax

; 148  : 		pempty->m_pAnimData = panimdata;

	mov	edx, DWORD PTR _pempty$[ebp]
	mov	eax, DWORD PTR _panimdata$[ebp]
	mov	DWORD PTR [edx+4], eax

; 149  : 		pempty->m_iSeq = seq_index;

	mov	ecx, DWORD PTR _pempty$[ebp]
	mov	edx, DWORD PTR _seq_index$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 150  : 		pempty->m_nSequence = seq;

	mov	eax, DWORD PTR _pempty$[ebp]
	mov	ecx, DWORD PTR _seq$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 151  : 		pempty->m_nPriority = priority;

	mov	edx, DWORD PTR _pempty$[ebp]
	mov	eax, DWORD PTR _priority$[ebp]
	mov	DWORD PTR [edx+40], eax

; 152  : 		pempty->m_State = m_AnimDelayIn==0?AnimPlayTrack::STATE_ACTIVE:AnimPlayTrack::STATE_IN;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+24]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@play
	mov	DWORD PTR tv155[ebp], 2
	jmp	SHORT $LN20@play
$LN19@play:
	mov	DWORD PTR tv155[ebp], 1
$LN20@play:
	mov	edx, DWORD PTR _pempty$[ebp]
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR [edx+16], eax

; 153  : 		pempty->m_Weight = m_AnimDelayIn==0?1.0f:0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+24]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@play
	fld1
	fstp	DWORD PTR tv160[ebp]
	jmp	SHORT $LN22@play
$LN21@play:
	fldz
	fstp	DWORD PTR tv160[ebp]
$LN22@play:
	mov	edx, DWORD PTR _pempty$[ebp]
	fld	DWORD PTR tv160[ebp]
	fstp	DWORD PTR [edx+20]

; 154  : 		pempty->m_CurTick = pseq->time_start;

	mov	eax, DWORD PTR _pempty$[ebp]
	mov	ecx, DWORD PTR _pseq$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+24], edx

; 155  : 		pempty->m_Start = pseq->time_start;

	mov	eax, DWORD PTR _pempty$[ebp]
	mov	ecx, DWORD PTR _pseq$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+28], edx

; 156  : 		pempty->m_End = pseq->time_end;

	mov	eax, DWORD PTR _pempty$[ebp]
	mov	ecx, DWORD PTR _pseq$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+32], edx

; 157  : 		pempty->m_PlayMode = (AnimPlayMode)loopmode;

	mov	eax, DWORD PTR _pempty$[ebp]
	mov	ecx, DWORD PTR _loopmode$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 158  : 		pempty->m_Speed = speed;

	mov	edx, DWORD PTR _pempty$[ebp]
	fld	DWORD PTR _speed$[ebp]
	fstp	DWORD PTR [edx+44]

; 159  : 		pempty->m_DelayIn = m_AnimDelayIn;

	mov	eax, DWORD PTR _pempty$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+24]
	fstp	DWORD PTR [eax+48]

; 160  : 		pempty->m_DelayOut = m_AnimDelayOut;

	mov	edx, DWORD PTR _pempty$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+28]
	fstp	DWORD PTR [edx+52]

; 161  : 
; 162  : 		return pempty;

	mov	eax, DWORD PTR _pempty$[ebp]

; 163  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?play@AnimationPlayer@Ogre@@QAEPAVAnimPlayTrack@2@HPAVBaseAnimationData@2@MM@Z$0:
	mov	eax, DWORD PTR $T90995[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?play@AnimationPlayer@Ogre@@QAEPAVAnimPlayTrack@2@HPAVBaseAnimationData@2@MM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?play@AnimationPlayer@Ogre@@QAEPAVAnimPlayTrack@2@HPAVBaseAnimationData@2@MM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?play@AnimationPlayer@Ogre@@QAEPAVAnimPlayTrack@2@HPAVBaseAnimationData@2@MM@Z ENDP ; Ogre::AnimationPlayer::play
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreanimationplayer.h
;	COMDAT ??0AnimPlayTrack@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0AnimPlayTrack@Ogre@@QAE@XZ PROC			; Ogre::AnimPlayTrack::AnimPlayTrack, COMDAT
; _this$ = ecx

; 22   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 23   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0AnimPlayTrack@Ogre@@QAE@XZ ENDP			; Ogre::AnimPlayTrack::AnimPlayTrack
_TEXT	ENDS
PUBLIC	?play@AnimationPlayer@Ogre@@QAEXABUAnimGroupPlayInfo@2@@Z ; Ogre::AnimationPlayer::play
xdata$x	SEGMENT
__unwindtable$?play@AnimationPlayer@Ogre@@QAEXABUAnimGroupPlayInfo@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?play@AnimationPlayer@Ogre@@QAEXABUAnimGroupPlayInfo@2@@Z$0
__ehfuncinfo$?play@AnimationPlayer@Ogre@@QAEXABUAnimGroupPlayInfo@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?play@AnimationPlayer@Ogre@@QAEXABUAnimGroupPlayInfo@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreanimationplayer.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv188 = -72						; size = 4
tv161 = -68						; size = 4
tv77 = -64						; size = 4
_this$ = -60						; size = 4
$T91013 = -56						; size = 4
$T91012 = -52						; size = 4
_nSeq$71740 = -48					; size = 4
_panimdata$71756 = -44					; size = 4
_pOldSameTrack$71742 = -40				; size = 4
_i$71741 = -36						; size = 4
_pseq$71757 = -32					; size = 4
_k$71736 = -28						; size = 4
_ptmp$71733 = -24					; size = 4
_i$71729 = -20						; size = 4
_pempty$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_playInfo$ = 8						; size = 4
?play@AnimationPlayer@Ogre@@QAEXABUAnimGroupPlayInfo@2@@Z PROC ; Ogre::AnimationPlayer::play
; _this$ = ecx

; 166  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?play@AnimationPlayer@Ogre@@QAEXABUAnimGroupPlayInfo@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 		// trackSTATE_OUT
; 168  : 		for( size_t i=0; i<m_PlayTracks.size(); i++ )

	mov	DWORD PTR _i$71729[ebp], 0
	jmp	SHORT $LN18@play@2
$LN17@play@2:
	mov	eax, DWORD PTR _i$71729[ebp]
	add	eax, 1
	mov	DWORD PTR _i$71729[ebp], eax
$LN18@play@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	cmp	DWORD PTR _i$71729[ebp], eax
	jae	SHORT $LN16@play@2

; 169  : 		{
; 170  : 			AnimPlayTrack *ptmp = m_PlayTracks[i];

	mov	ecx, DWORD PTR _i$71729[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _ptmp$71733[ebp], edx

; 171  : 			if(ptmp->m_State==AnimPlayTrack::STATE_ACTIVE)

	mov	eax, DWORD PTR _ptmp$71733[ebp]
	cmp	DWORD PTR [eax+16], 2
	jne	SHORT $LN15@play@2

; 172  : 			{
; 173  : 				ptmp->m_State = m_AnimDelayOut==0?AnimPlayTrack::STATE_NULL:AnimPlayTrack::STATE_OUT;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+28]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@play@2
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN22@play@2
$LN21@play@2:
	mov	DWORD PTR tv77[ebp], 3
$LN22@play@2:
	mov	edx, DWORD PTR _ptmp$71733[ebp]
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR [edx+16], eax

; 174  : 				// 
; 175  : 				ptmp->m_nPriority += 100;

	mov	ecx, DWORD PTR _ptmp$71733[ebp]
	mov	edx, DWORD PTR [ecx+40]
	add	edx, 100				; 00000064H
	mov	eax, DWORD PTR _ptmp$71733[ebp]
	mov	DWORD PTR [eax+40], edx
$LN15@play@2:

; 176  : 			}
; 177  : 		}

	jmp	SHORT $LN17@play@2
$LN16@play@2:

; 178  : 
; 179  : 		AnimPlayTrack *pempty;
; 180  : 
; 181  : 		for( int k=0; k<playInfo.nseq; k++ )

	mov	DWORD PTR _k$71736[ebp], 0
	jmp	SHORT $LN14@play@2
$LN13@play@2:
	mov	ecx, DWORD PTR _k$71736[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$71736[ebp], ecx
$LN14@play@2:
	mov	edx, DWORD PTR _playInfo$[ebp]
	mov	eax, DWORD PTR _k$71736[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	$LN12@play@2

; 182  : 		{
; 183  : 			int nSeq = playInfo.seq[k];

	mov	ecx, DWORD PTR _k$71736[ebp]
	mov	edx, DWORD PTR _playInfo$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	mov	DWORD PTR _nSeq$71740[ebp], eax

; 184  : 
; 185  : 			size_t i;
; 186  : 			AnimPlayTrack* pOldSameTrack = NULL;

	mov	DWORD PTR _pOldSameTrack$71742[ebp], 0

; 187  : 			pempty = NULL;

	mov	DWORD PTR _pempty$[ebp], 0

; 188  : 			for( i=m_PlayTracks.size() -1 ; i>=0; i-- )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	sub	eax, 1
	mov	DWORD PTR _i$71741[ebp], eax
	jmp	SHORT $LN11@play@2
$LN10@play@2:
	mov	ecx, DWORD PTR _i$71741[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$71741[ebp], ecx
$LN11@play@2:
	cmp	DWORD PTR _i$71741[ebp], 0
	jb	SHORT $LN9@play@2

; 189  : 			{
; 190  : 				if( m_PlayTracks[i]->m_State != AnimPlayTrack::STATE_NULL 
; 191  : 					&& m_PlayTracks[i]->m_nSequence == nSeq 
; 192  : 					&& m_PlayTracks[i]->m_PlayMode == ANIM_MODE_LOOP )

	mov	edx, DWORD PTR _i$71741[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN8@play@2
	mov	ecx, DWORD PTR _i$71741[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _nSeq$71740[ebp]
	jne	SHORT $LN8@play@2
	mov	ecx, DWORD PTR _i$71741[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	edx, DWORD PTR [eax]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN8@play@2

; 193  : 				{
; 194  : 					pOldSameTrack = m_PlayTracks[i];

	mov	eax, DWORD PTR _i$71741[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pOldSameTrack$71742[ebp], ecx

; 195  : 					break;

	jmp	SHORT $LN9@play@2
$LN8@play@2:

; 196  : 				}
; 197  : 			}

	jmp	SHORT $LN10@play@2
$LN9@play@2:

; 198  : 
; 199  : 			for( i=0; i<m_PlayTracks.size(); i++ )

	mov	DWORD PTR _i$71741[ebp], 0
	jmp	SHORT $LN7@play@2
$LN6@play@2:
	mov	edx, DWORD PTR _i$71741[ebp]
	add	edx, 1
	mov	DWORD PTR _i$71741[ebp], edx
$LN7@play@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	cmp	DWORD PTR _i$71741[ebp], eax
	jae	SHORT $LN5@play@2

; 200  : 			{
; 201  : 				if( m_PlayTracks[i]->m_State == AnimPlayTrack::STATE_NULL)

	mov	eax, DWORD PTR _i$71741[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN4@play@2

; 202  : 				{
; 203  : 					pempty = m_PlayTracks[i];

	mov	edx, DWORD PTR _i$71741[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pempty$[ebp], eax

; 204  : 					break;

	jmp	SHORT $LN5@play@2
$LN4@play@2:

; 205  : 				}
; 206  : 			}

	jmp	SHORT $LN6@play@2
$LN5@play@2:

; 207  : 
; 208  : 			if(pempty == NULL)

	cmp	DWORD PTR _pempty$[ebp], 0
	jne	SHORT $LN3@play@2

; 209  : 			{
; 210  : 				pempty = new AnimPlayTrack;

	push	56					; 00000038H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T91013[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T91013[ebp], 0
	je	SHORT $LN23@play@2
	mov	ecx, DWORD PTR $T91013[ebp]
	call	??0AnimPlayTrack@Ogre@@QAE@XZ		; Ogre::AnimPlayTrack::AnimPlayTrack
	mov	DWORD PTR tv161[ebp], eax
	jmp	SHORT $LN24@play@2
$LN23@play@2:
	mov	DWORD PTR tv161[ebp], 0
$LN24@play@2:
	mov	ecx, DWORD PTR tv161[ebp]
	mov	DWORD PTR $T91012[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T91012[ebp]
	mov	DWORD PTR _pempty$[ebp], edx

; 211  : 				m_PlayTracks.push_back(pempty);

	lea	eax, DWORD PTR _pempty$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEXABQAVAnimPlayTrack@Ogre@@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::push_back
$LN3@play@2:

; 212  : 			}
; 213  : 
; 214  : 			BaseAnimationData *panimdata = playInfo.panimdata[k];

	mov	ecx, DWORD PTR _k$71736[ebp]
	mov	edx, DWORD PTR _playInfo$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+36]
	mov	DWORD PTR _panimdata$71756[ebp], eax

; 215  : 
; 216  : 			pempty->m_AnimType = panimdata->getType();

	mov	ecx, DWORD PTR _panimdata$71756[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _panimdata$71756[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	mov	ecx, DWORD PTR _pempty$[ebp]
	mov	DWORD PTR [ecx], eax

; 217  : 			pempty->m_pAnimData = panimdata;

	mov	edx, DWORD PTR _pempty$[ebp]
	mov	eax, DWORD PTR _panimdata$71756[ebp]
	mov	DWORD PTR [edx+4], eax

; 218  : 			pempty->m_iSeq = panimdata->getSequenceIndex(nSeq);

	mov	ecx, DWORD PTR _nSeq$71740[ebp]
	push	ecx
	mov	ecx, DWORD PTR _panimdata$71756[ebp]
	call	?getSequenceIndex@BaseAnimationData@Ogre@@QAEHH@Z ; Ogre::BaseAnimationData::getSequenceIndex
	mov	edx, DWORD PTR _pempty$[ebp]
	mov	DWORD PTR [edx+8], eax

; 219  : 			pempty->m_nSequence = nSeq;

	mov	eax, DWORD PTR _pempty$[ebp]
	mov	ecx, DWORD PTR _nSeq$71740[ebp]
	mov	DWORD PTR [eax+12], ecx

; 220  : 			SequenceDesc *pseq = panimdata->getSequence(pempty->m_iSeq);

	mov	edx, DWORD PTR _pempty$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _panimdata$71756[ebp]
	call	?getSequence@BaseAnimationData@Ogre@@QAEPAUSequenceDesc@2@I@Z ; Ogre::BaseAnimationData::getSequence
	mov	DWORD PTR _pseq$71757[ebp], eax

; 221  : 
; 222  : 			pempty->m_nPriority = playInfo.priority[k];

	mov	ecx, DWORD PTR _pempty$[ebp]
	mov	edx, DWORD PTR _k$71736[ebp]
	mov	eax, DWORD PTR _playInfo$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+20]
	mov	DWORD PTR [ecx+40], edx

; 223  : 			pempty->m_State = m_AnimDelayIn==0?AnimPlayTrack::STATE_ACTIVE:AnimPlayTrack::STATE_IN;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+24]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN25@play@2
	mov	DWORD PTR tv188[ebp], 2
	jmp	SHORT $LN26@play@2
$LN25@play@2:
	mov	DWORD PTR tv188[ebp], 1
$LN26@play@2:
	mov	ecx, DWORD PTR _pempty$[ebp]
	mov	edx, DWORD PTR tv188[ebp]
	mov	DWORD PTR [ecx+16], edx

; 224  : 			pempty->m_Weight = 1.0f;

	mov	eax, DWORD PTR _pempty$[ebp]
	fld1
	fstp	DWORD PTR [eax+20]

; 225  : 
; 226  : 			if( pOldSameTrack )

	cmp	DWORD PTR _pOldSameTrack$71742[ebp], 0
	je	SHORT $LN2@play@2

; 227  : 				pempty->m_CurTick = pOldSameTrack->m_CurTick;

	mov	ecx, DWORD PTR _pempty$[ebp]
	mov	edx, DWORD PTR _pOldSameTrack$71742[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax

; 228  : 			else

	jmp	SHORT $LN1@play@2
$LN2@play@2:

; 229  : 				pempty->m_CurTick = pseq->time_start;

	mov	ecx, DWORD PTR _pempty$[ebp]
	mov	edx, DWORD PTR _pseq$71757[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+24], eax
$LN1@play@2:

; 230  : 
; 231  : 			pempty->m_Start = pseq->time_start;

	mov	ecx, DWORD PTR _pempty$[ebp]
	mov	edx, DWORD PTR _pseq$71757[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+28], eax

; 232  : 			pempty->m_End = pseq->time_end;

	mov	ecx, DWORD PTR _pempty$[ebp]
	mov	edx, DWORD PTR _pseq$71757[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+32], eax

; 233  : 			pempty->m_PlayMode = pseq->loopmode;

	mov	ecx, DWORD PTR _pempty$[ebp]
	mov	edx, DWORD PTR _pseq$71757[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+36], eax

; 234  : 			pempty->m_Speed = 1.0f;

	mov	ecx, DWORD PTR _pempty$[ebp]
	fld1
	fstp	DWORD PTR [ecx+44]

; 235  : 			pempty->m_DelayIn = m_AnimDelayIn;

	mov	edx, DWORD PTR _pempty$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+24]
	fstp	DWORD PTR [edx+48]

; 236  : 			pempty->m_DelayOut = m_AnimDelayOut;

	mov	ecx, DWORD PTR _pempty$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+28]
	fstp	DWORD PTR [ecx+52]
	jmp	$LN13@play@2
$LN12@play@2:

; 237  : 		}
; 238  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?play@AnimationPlayer@Ogre@@QAEXABUAnimGroupPlayInfo@2@@Z$0:
	mov	eax, DWORD PTR $T91013[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?play@AnimationPlayer@Ogre@@QAEXABUAnimGroupPlayInfo@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?play@AnimationPlayer@Ogre@@QAEXABUAnimGroupPlayInfo@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?play@AnimationPlayer@Ogre@@QAEXABUAnimGroupPlayInfo@2@@Z ENDP ; Ogre::AnimationPlayer::play
PUBLIC	?stop@AnimationPlayer@Ogre@@QAEXPAVAnimPlayTrack@2@@Z ; Ogre::AnimationPlayer::stop
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hanim$ = 8						; size = 4
?stop@AnimationPlayer@Ogre@@QAEXPAVAnimPlayTrack@2@@Z PROC ; Ogre::AnimationPlayer::stop
; _this$ = ecx

; 241  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 242  : 		((AnimPlayTrack *)hanim)->m_State = AnimPlayTrack::STATE_NULL;

	mov	eax, DWORD PTR _hanim$[ebp]
	mov	DWORD PTR [eax+16], 0

; 243  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?stop@AnimationPlayer@Ogre@@QAEXPAVAnimPlayTrack@2@@Z ENDP ; Ogre::AnimationPlayer::stop
_TEXT	ENDS
PUBLIC	?stopAll@AnimationPlayer@Ogre@@QAEXXZ		; Ogre::AnimationPlayer::stopAll
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_ptmp$71772 = -8					; size = 4
_i$71768 = -4						; size = 4
?stopAll@AnimationPlayer@Ogre@@QAEXXZ PROC		; Ogre::AnimationPlayer::stopAll
; _this$ = ecx

; 246  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 		for( size_t i=0; i<m_PlayTracks.size(); i++ )

	mov	DWORD PTR _i$71768[ebp], 0
	jmp	SHORT $LN3@stopAll
$LN2@stopAll:
	mov	eax, DWORD PTR _i$71768[ebp]
	add	eax, 1
	mov	DWORD PTR _i$71768[ebp], eax
$LN3@stopAll:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	cmp	DWORD PTR _i$71768[ebp], eax
	jae	SHORT $LN4@stopAll

; 248  : 		{
; 249  : 			AnimPlayTrack *ptmp = m_PlayTracks[i];

	mov	ecx, DWORD PTR _i$71768[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _ptmp$71772[ebp], edx

; 250  : 			ptmp->m_State = AnimPlayTrack::STATE_NULL;

	mov	eax, DWORD PTR _ptmp$71772[ebp]
	mov	DWORD PTR [eax+16], 0
	jmp	SHORT $LN2@stopAll
$LN4@stopAll:

; 251  : 		}
; 252  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?stopAll@AnimationPlayer@Ogre@@QAEXXZ ENDP		; Ogre::AnimationPlayer::stopAll
_TEXT	ENDS
PUBLIC	?pause@AnimationPlayer@Ogre@@QAEXPAVAnimPlayTrack@2@@Z ; Ogre::AnimationPlayer::pause
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hanim$ = 8						; size = 4
?pause@AnimationPlayer@Ogre@@QAEXPAVAnimPlayTrack@2@@Z PROC ; Ogre::AnimationPlayer::pause
; _this$ = ecx

; 255  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 256  : 		((AnimPlayTrack *)hanim)->m_Speed = 0;

	mov	eax, DWORD PTR _hanim$[ebp]
	fldz
	fstp	DWORD PTR [eax+44]

; 257  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?pause@AnimationPlayer@Ogre@@QAEXPAVAnimPlayTrack@2@@Z ENDP ; Ogre::AnimationPlayer::pause
_TEXT	ENDS
PUBLIC	?resume@AnimationPlayer@Ogre@@QAEXPAVAnimPlayTrack@2@@Z ; Ogre::AnimationPlayer::resume
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hanim$ = 8						; size = 4
?resume@AnimationPlayer@Ogre@@QAEXPAVAnimPlayTrack@2@@Z PROC ; Ogre::AnimationPlayer::resume
; _this$ = ecx

; 260  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 261  : 		((AnimPlayTrack *)hanim)->m_Speed = 1.0f;

	mov	eax, DWORD PTR _hanim$[ebp]
	fld1
	fstp	DWORD PTR [eax+44]

; 262  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?resume@AnimationPlayer@Ogre@@QAEXPAVAnimPlayTrack@2@@Z ENDP ; Ogre::AnimationPlayer::resume
_TEXT	ENDS
PUBLIC	??$sort@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ; std::sort<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
PUBLIC	?AnimPlayTrackPred@Ogre@@YA_NPAVAnimPlayTrack@1@0@Z ; Ogre::AnimPlayTrackPred
PUBLIC	?update@AnimationPlayer@Ogre@@QAEXI@Z		; Ogre::AnimationPlayer::update
EXTRN	?applyAnimation@Model@Ogre@@QAEXQAPAVAnimPlayTrack@2@I@Z:PROC ; Ogre::Model::applyAnimation
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -80						; size = 4
_ptrack$71803 = -76					; size = 4
_ptracks$ = -72						; size = 64
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_dtick$ = 8						; size = 4
?update@AnimationPlayer@Ogre@@QAEXI@Z PROC		; Ogre::AnimationPlayer::update
; _this$ = ecx

; 272  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 273  : 		size_t i;
; 274  : 		for(i=0; i<m_PlayTracks.size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@update@2
$LN8@update@2:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@update@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN7@update@2

; 275  : 		{
; 276  : 			if( m_PlayTracks[i]->m_State != AnimPlayTrack::STATE_NULL )

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	edx, DWORD PTR [eax]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN6@update@2

; 277  : 			{
; 278  : 				m_PlayTracks[i]->update(dtick);

	mov	eax, DWORD PTR _dtick$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?update@AnimPlayTrack@Ogre@@QAEXI@Z	; Ogre::AnimPlayTrack::update
$LN6@update@2:

; 279  : 			}
; 280  : 		}

	jmp	SHORT $LN8@update@2
$LN7@update@2:

; 281  : 
; 282  : 		size_t count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 283  : 		AnimPlayTrack *ptracks[16];
; 284  : 		assert(m_PlayTracks.size() < ARRAY_ELEMENTS(ptracks));
; 285  : 		for(i=0; i<m_PlayTracks.size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@update@2
$LN4@update@2:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN5@update@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN3@update@2

; 286  : 		{
; 287  : 			AnimPlayTrack *ptrack = m_PlayTracks[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ptrack$71803[ebp], ecx

; 288  : 			if(ptrack->m_State != AnimPlayTrack::STATE_NULL)

	mov	edx, DWORD PTR _ptrack$71803[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN2@update@2

; 289  : 			{
; 290  : 				ptracks[count++] = ptrack;

	mov	eax, DWORD PTR _count$[ebp]
	mov	ecx, DWORD PTR _ptrack$71803[ebp]
	mov	DWORD PTR _ptracks$[ebp+eax*4], ecx
	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx
$LN2@update@2:

; 291  : 			}
; 292  : 		}

	jmp	SHORT $LN4@update@2
$LN3@update@2:

; 293  : 
; 294  : 		if(count > 1) std::sort(&ptracks[0], &ptracks[count], AnimPlayTrackPred);

	cmp	DWORD PTR _count$[ebp], 1
	jbe	SHORT $LN1@update@2
	push	OFFSET ?AnimPlayTrackPred@Ogre@@YA_NPAVAnimPlayTrack@1@0@Z ; Ogre::AnimPlayTrackPred
	mov	eax, DWORD PTR _count$[ebp]
	lea	ecx, DWORD PTR _ptracks$[ebp+eax*4]
	push	ecx
	lea	edx, DWORD PTR _ptracks$[ebp]
	push	edx
	call	??$sort@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ; std::sort<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 12					; 0000000cH
$LN1@update@2:

; 295  : 
; 296  : 		m_pModel->applyAnimation(ptracks, count);

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ptracks$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?applyAnimation@Model@Ogre@@QAEXQAPAVAnimPlayTrack@2@I@Z ; Ogre::Model::applyAnimation

; 297  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?update@AnimationPlayer@Ogre@@QAEXI@Z ENDP		; Ogre::AnimationPlayer::update
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?AnimPlayTrackPred@Ogre@@YA_NPAVAnimPlayTrack@1@0@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
?AnimPlayTrackPred@Ogre@@YA_NPAVAnimPlayTrack@1@0@Z PROC ; Ogre::AnimPlayTrackPred, COMDAT

; 265  : 	{

	push	ebp
	mov	ebp, esp

; 266  : 		assert(p1->m_AnimType == p2->m_AnimType);
; 267  : 
; 268  : 		return p1->m_nPriority > p2->m_nPriority;

	mov	eax, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR _p2$[ebp]
	mov	edx, DWORD PTR [eax+40]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+40]
	setg	al

; 269  : 	}

	pop	ebp
	ret	0
?AnimPlayTrackPred@Ogre@@YA_NPAVAnimPlayTrack@1@0@Z ENDP ; Ogre::AnimPlayTrackPred
_TEXT	ENDS
PUBLIC	?resetUpdate@AnimationPlayer@Ogre@@QAEXI@Z	; Ogre::AnimationPlayer::resetUpdate
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -80						; size = 4
_i$71819 = -76						; size = 4
_ptracks$ = -72						; size = 64
_count$ = -4						; size = 4
_tick$ = 8						; size = 4
?resetUpdate@AnimationPlayer@Ogre@@QAEXI@Z PROC		; Ogre::AnimationPlayer::resetUpdate
; _this$ = ecx

; 300  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 301  : 		size_t count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 302  : 		AnimPlayTrack *ptracks[16];
; 303  : 		for(size_t i=0; i<m_PlayTracks.size(); i++)

	mov	DWORD PTR _i$71819[ebp], 0
	jmp	SHORT $LN5@resetUpdat
$LN4@resetUpdat:
	mov	eax, DWORD PTR _i$71819[ebp]
	add	eax, 1
	mov	DWORD PTR _i$71819[ebp], eax
$LN5@resetUpdat:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	cmp	DWORD PTR _i$71819[ebp], eax
	jae	SHORT $LN3@resetUpdat

; 304  : 		{
; 305  : 			if( m_PlayTracks[i]->m_State != AnimPlayTrack::STATE_NULL )

	mov	ecx, DWORD PTR _i$71819[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	edx, DWORD PTR [eax]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN2@resetUpdat

; 306  : 			{
; 307  : 				m_PlayTracks[i]->resetUpdate(tick);

	mov	eax, DWORD PTR _tick$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$71819[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?resetUpdate@AnimPlayTrack@Ogre@@QAEXI@Z ; Ogre::AnimPlayTrack::resetUpdate

; 308  : 				ptracks[count++] = m_PlayTracks[i];

	mov	edx, DWORD PTR _i$71819[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _ptracks$[ebp+ecx*4], edx
	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN2@resetUpdat:

; 309  : 			}
; 310  : 		}

	jmp	SHORT $LN4@resetUpdat
$LN3@resetUpdat:

; 311  : 		if(count > 1) std::sort(&ptracks[0], &ptracks[count], AnimPlayTrackPred);

	cmp	DWORD PTR _count$[ebp], 1
	jbe	SHORT $LN1@resetUpdat
	push	OFFSET ?AnimPlayTrackPred@Ogre@@YA_NPAVAnimPlayTrack@1@0@Z ; Ogre::AnimPlayTrackPred
	mov	ecx, DWORD PTR _count$[ebp]
	lea	edx, DWORD PTR _ptracks$[ebp+ecx*4]
	push	edx
	lea	eax, DWORD PTR _ptracks$[ebp]
	push	eax
	call	??$sort@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ; std::sort<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 12					; 0000000cH
$LN1@resetUpdat:

; 312  : 		m_pModel->applyAnimation(ptracks, count);

	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ptracks$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	call	?applyAnimation@Model@Ogre@@QAEXQAPAVAnimPlayTrack@2@I@Z ; Ogre::Model::applyAnimation

; 313  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?resetUpdate@AnimationPlayer@Ogre@@QAEXI@Z ENDP		; Ogre::AnimationPlayer::resetUpdate
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	?_Buy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Buy
PUBLIC	??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@XZ	; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T91032 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91032[ebp], esp
	call	??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	?_Tidy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@1@0PAU23@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >
PUBLIC	?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin
PUBLIC	?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end
PUBLIC	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
PUBLIC	??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T91044 = -36						; size = 8
$T91043 = -28						; size = 8
$T91042 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91042[ebp], esp
	push	eax
	call	??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@25

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T91043[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T91044[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@1@0PAU23@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@25
__catch$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@25
	ret	0
$LN5@vector@25:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@25:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@25:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	?deallocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@I@Z ; std::allocator<Ogre::TriggerDesc>::deallocate
PUBLIC	??$_Ucopy@PAUTriggerDesc@Ogre@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<Ogre::TriggerDesc *>
PUBLIC	?capacity@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::capacity
PUBLIC	?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Destroy
PUBLIC	??$unchecked_copy@PAUTriggerDesc@Ogre@@PAU12@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
PUBLIC	?clear@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$73329 = -8					; size = 4
__Ptr$73319 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@10

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@10

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::clear
	jmp	$LN9@operator@10
$LN8@operator@10:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@10

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUTriggerDesc@Ogre@@PAU12@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$73319[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73319[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@10
$LN6@operator@10:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@10

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Ptr$73329[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$73329[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAUTriggerDesc@Ogre@@PAU12@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73329[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUTriggerDesc@Ogre@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<Ogre::TriggerDesc *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@10
$LN4@operator@10:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@10

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@I@Z ; std::allocator<Ogre::TriggerDesc>::deallocate
$LN2@operator@10:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@10

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUTriggerDesc@Ogre@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<Ogre::TriggerDesc *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@10:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	?_Buy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Buy
PUBLIC	??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@XZ	; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T91073 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91073[ebp], esp
	call	??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	?_Tidy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@1@0PAU23@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >
PUBLIC	?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin
PUBLIC	?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end
PUBLIC	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
PUBLIC	??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T91085 = -36						; size = 8
$T91084 = -28						; size = 8
$T91083 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91083[ebp], esp
	push	eax
	call	??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@26

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T91084[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T91085[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@1@0PAU23@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@26
__catch$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@26
	ret	0
$LN5@vector@26:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@26:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@26:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	?deallocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@I@Z ; std::allocator<Ogre::SequenceDesc>::deallocate
PUBLIC	??$_Ucopy@PAUSequenceDesc@Ogre@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<Ogre::SequenceDesc *>
PUBLIC	?capacity@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::capacity
PUBLIC	?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Destroy
PUBLIC	??$unchecked_copy@PAUSequenceDesc@Ogre@@PAU12@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
PUBLIC	?clear@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$73488 = -8					; size = 4
__Ptr$73478 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@11

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@11

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::clear
	jmp	$LN9@operator@11
$LN8@operator@11:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@11

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUSequenceDesc@Ogre@@PAU12@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$73478[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73478[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@11
$LN6@operator@11:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@11

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	shl	eax, 4
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$73488[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$73488[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUSequenceDesc@Ogre@@PAU12@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$73488[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUSequenceDesc@Ogre@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<Ogre::SequenceDesc *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@11
$LN4@operator@11:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@11

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@I@Z ; std::allocator<Ogre::SequenceDesc>::deallocate
$LN2@operator@11:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@11

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUSequenceDesc@Ogre@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<Ogre::SequenceDesc *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@11:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	?_Tidy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >
PUBLIC	?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
PUBLIC	?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
PUBLIC	?_Buy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Buy
PUBLIC	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
PUBLIC	??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T91115 = -36						; size = 8
$T91114 = -28						; size = 8
$T91113 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91113[ebp], esp
	push	eax
	call	??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@27

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T91114[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T91115[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@27
__catch$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@27
	ret	0
$LN5@vector@27:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@27:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@27:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	?deallocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEXPAPAVBoneTrack@Ogre@@I@Z ; std::allocator<Ogre::BoneTrack *>::deallocate
PUBLIC	??$_Ucopy@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<Ogre::BoneTrack * *>
PUBLIC	?capacity@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
PUBLIC	?clear@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$73642 = -8					; size = 4
__Ptr$73632 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@12

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@12

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::clear
	jmp	$LN9@operator@12
$LN8@operator@12:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@12

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$73632[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73632[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@12
$LN6@operator@12:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@12

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$73642[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$73642[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73642[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<Ogre::BoneTrack * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@12
$LN4@operator@12:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@12

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEXPAPAVBoneTrack@Ogre@@I@Z ; std::allocator<Ogre::BoneTrack *>::deallocate
$LN2@operator@12:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@12

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<Ogre::BoneTrack * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@12:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::~_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	?_Tidy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >
PUBLIC	?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin
PUBLIC	?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end
PUBLIC	?_Buy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Buy
PUBLIC	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
PUBLIC	??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ; std::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	??0?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::MaterialParamTrack *>::allocator<Ogre::MaterialParamTrack *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T91145 = -36						; size = 8
$T91144 = -28						; size = 8
$T91143 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91143[ebp], esp
	push	eax
	call	??0?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::MaterialParamTrack *>::allocator<Ogre::MaterialParamTrack *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ; std::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@28

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T91144[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T91145[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@28
__catch$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@28
	ret	0
$LN5@vector@28:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@28:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@28:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::~vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::~vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	?deallocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEXPAPAVMaterialParamTrack@Ogre@@I@Z ; std::allocator<Ogre::MaterialParamTrack *>::deallocate
PUBLIC	??$_Ucopy@PAPAVMaterialParamTrack@Ogre@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<Ogre::MaterialParamTrack * *>
PUBLIC	?capacity@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
PUBLIC	?clear@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$73796 = -8					; size = 4
__Ptr$73786 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@13

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@13

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::clear
	jmp	$LN9@operator@13
$LN8@operator@13:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@13

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$73786[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73786[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@13
$LN6@operator@13:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@13

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$73796[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$73796[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73796[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVMaterialParamTrack@Ogre@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<Ogre::MaterialParamTrack * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@13
$LN4@operator@13:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@13

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEXPAPAVMaterialParamTrack@Ogre@@I@Z ; std::allocator<Ogre::MaterialParamTrack *>::deallocate
$LN2@operator@13:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@13

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVMaterialParamTrack@Ogre@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<Ogre::MaterialParamTrack * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@13:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::~_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
PUBLIC	?_Buy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Buy
PUBLIC	??0?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z ; std::_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
PUBLIC	??0?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::AnimPlayTrack *>::allocator<Ogre::AnimPlayTrack *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T91173 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91173[ebp], esp
	call	??0?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::AnimPlayTrack *>::allocator<Ogre::AnimPlayTrack *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z ; std::_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
PUBLIC	?_Tidy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> > >
PUBLIC	?begin@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::begin
PUBLIC	?end@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::end
PUBLIC	??0?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::AnimPlayTrack *>::allocator<Ogre::AnimPlayTrack *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T91185 = -36						; size = 8
$T91184 = -28						; size = 8
$T91183 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91183[ebp], esp
	push	eax
	call	??0?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::AnimPlayTrack *>::allocator<Ogre::AnimPlayTrack *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z ; std::_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@29

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T91184[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T91185[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@29
__catch$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@29
	ret	0
$LN5@vector@29:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@29:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@29:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::~vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::~vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
PUBLIC	?deallocate@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAEXPAPAVAnimPlayTrack@Ogre@@I@Z ; std::allocator<Ogre::AnimPlayTrack *>::deallocate
PUBLIC	??$_Ucopy@PAPAVAnimPlayTrack@Ogre@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ucopy<Ogre::AnimPlayTrack * *>
PUBLIC	?capacity@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
PUBLIC	?clear@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$73955 = -8					; size = 4
__Ptr$73945 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@14

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@14

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::clear
	jmp	$LN9@operator@14
$LN8@operator@14:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@14

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$73945[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73945[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@14
$LN6@operator@14:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@14

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$73955[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$73955[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73955[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVAnimPlayTrack@Ogre@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ucopy<Ogre::AnimPlayTrack * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@14
$LN4@operator@14:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@14

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAEXPAPAVAnimPlayTrack@Ogre@@I@Z ; std::allocator<Ogre::AnimPlayTrack *>::deallocate
$LN2@operator@14:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@14

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVAnimPlayTrack@Ogre@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ucopy<Ogre::AnimPlayTrack * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@14:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
_TEXT	ENDS
EXTRN	__imp___invalid_parameter_noinfo:PROC
; Function compile flags: /Odtp
;	COMDAT ??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@15
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@15:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@ABQAVAnimPlayTrack@Ogre@@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::insert
PUBLIC	?end@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::end
PUBLIC	?_Ufill@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ufill
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEXABQAVAnimPlayTrack@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T91219 = -24						; size = 8
$T91218 = -16						; size = 8
$T91217 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEXABQAVAnimPlayTrack@Ogre@@@Z PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T91218[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T91217[ebp], ecx
	mov	DWORD PTR $T91217[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T91217[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T91217[ebp]
	push	edx
	lea	eax, DWORD PTR $T91219[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@ABQAVAnimPlayTrack@Ogre@@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::insert
$LN3@push_back:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEXABQAVAnimPlayTrack@Ogre@@@Z ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::push_back
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrerect.h
_TEXT	ENDS
;	COMDAT ??0?$TBox@H@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$TBox@H@Ogre@@QAE@XZ PROC				; Ogre::TBox<int>::TBox<int>, COMDAT
; _this$ = ecx

; 68   : 		TBox(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$TBox@H@Ogre@@QAE@XZ ENDP				; Ogre::TBox<int>::TBox<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$TBox@H@Ogre@@QAE@HHHHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_left$ = 8						; size = 4
_top$ = 12						; size = 4
_front$ = 16						; size = 4
_right$ = 20						; size = 4
_bottom$ = 24						; size = 4
_back$ = 28						; size = 4
??0?$TBox@H@Ogre@@QAE@HHHHHH@Z PROC			; Ogre::TBox<int>::TBox<int>, COMDAT
; _this$ = ecx

; 70   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _top$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _front$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _bottom$[ebp]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _back$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 71   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$TBox@H@Ogre@@QAE@HHHHHH@Z ENDP			; Ogre::TBox<int>::TBox<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getWidth@?$TBox@H@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWidth@?$TBox@H@Ogre@@QBEHXZ PROC			; Ogre::TBox<int>::getWidth, COMDAT
; _this$ = ecx

; 73   : 		T getWidth() const{ return m_Right-m_Left; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx]
	mov	esp, ebp
	pop	ebp
	ret	0
?getWidth@?$TBox@H@Ogre@@QBEHXZ ENDP			; Ogre::TBox<int>::getWidth
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getHeight@?$TBox@H@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHeight@?$TBox@H@Ogre@@QBEHXZ PROC			; Ogre::TBox<int>::getHeight, COMDAT
; _this$ = ecx

; 74   : 		T getHeight() const{ return m_Bottom-m_Top; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?getHeight@?$TBox@H@Ogre@@QBEHXZ ENDP			; Ogre::TBox<int>::getHeight
_TEXT	ENDS
PUBLIC	?getDepth@?$TBox@H@Ogre@@QBEHXZ			; Ogre::TBox<int>::getDepth
; Function compile flags: /Odtp
;	COMDAT ?getDepth@?$TBox@H@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getDepth@?$TBox@H@Ogre@@QBEHXZ PROC			; Ogre::TBox<int>::getDepth, COMDAT
; _this$ = ecx

; 75   : 		T getDepth() const{ return m_Back-m_Front; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?getDepth@?$TBox@H@Ogre@@QBEHXZ ENDP			; Ogre::TBox<int>::getDepth
_TEXT	ENDS
PUBLIC	?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z		; Ogre::TBox<int>::contains
; Function compile flags: /Odtp
;	COMDAT ?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z
_TEXT	SEGMENT
tv80 = -8						; size = 4
_this$ = -4						; size = 4
_def$ = 8						; size = 4
?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z PROC		; Ogre::TBox<int>::contains, COMDAT
; _this$ = ecx

; 78   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 			return (def.m_Left >= m_Left && def.m_Top >= m_Top && def.m_Front >= m_Front &&
; 80   : 				def.m_Right <= m_Right && def.m_Bottom <= m_Bottom && def.m_Back <= m_Back);

	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jl	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jg	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+16]
	jg	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+20]
	jg	SHORT $LN3@contains
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN4@contains
$LN3@contains:
	mov	DWORD PTR tv80[ebp], 0
$LN4@contains:
	mov	al, BYTE PTR tv80[ebp]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z ENDP		; Ogre::TBox<int>::contains
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_Vector_val<char,std::allocator<char> >::~_Vector_val<char,std::allocator<char> >
PUBLIC	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z ; std::vector<char,std::allocator<char> >::_Ucopy<std::_Vector_const_iterator<char,std::allocator<char> > >
PUBLIC	?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
PUBLIC	?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
PUBLIC	?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
PUBLIC	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
PUBLIC	??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >
EXTRN	__imp_??0?$allocator@D@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T91238 = -36						; size = 8
$T91237 = -28						; size = 8
$T91236 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91236[ebp], esp
	push	eax
	call	DWORD PTR __imp_??0?$allocator@D@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@30

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T91237[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T91238[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z ; std::vector<char,std::allocator<char> >::_Ucopy<std::_Vector_const_iterator<char,std::allocator<char> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@30
__catch$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@30
	ret	0
$LN5@vector@30:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@30:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@30:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
PUBLIC	??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
PUBLIC	?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::capacity
PUBLIC	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy
PUBLIC	??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z	; stdext::unchecked_copy<char *,char *>
PUBLIC	?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ ; std::vector<char,std::allocator<char> >::clear
EXTRN	__imp_?deallocate@?$allocator@D@std@@QAEXPADI@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$74177 = -8					; size = 4
__Ptr$74167 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<char,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@16

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@16

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ ; std::vector<char,std::allocator<char> >::clear
	jmp	$LN9@operator@16
$LN8@operator@16:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@16

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z ; stdext::unchecked_copy<char *,char *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$74167[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$74167[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@16
$LN6@operator@16:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@16

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$74177[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$74177[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z ; stdext::unchecked_copy<char *,char *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$74177[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@16
$LN4@operator@16:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@16

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?deallocate@?$allocator@D@std@@QAEXPADI@Z
$LN2@operator@16:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@16

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@16:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<char,std::allocator<char> >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z PROC	; std::vector<char,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@17
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@17:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	add	eax, DWORD PTR __Pos$[ebp]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ENDP	; std::vector<char,std::allocator<char> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
PUBLIC	?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
PUBLIC	?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
PUBLIC	?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy
PUBLIC	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
PUBLIC	??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T91270 = -36						; size = 8
$T91269 = -28						; size = 8
$T91268 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91268[ebp], esp
	push	eax
	call	??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@31

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T91269[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T91270[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@31
__catch$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@31
	ret	0
$LN5@vector@31:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@31:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@31:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::deallocate
PUBLIC	??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>
PUBLIC	?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
PUBLIC	?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$74335 = -8					; size = 4
__Ptr$74325 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@18

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@18

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::clear
	jmp	$LN9@operator@18
$LN8@operator@18:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@18

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$74325[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$74325[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@18
$LN6@operator@18:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@18

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$74335[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$74335[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$74335[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@18
$LN4@operator@18:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@18

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::deallocate
$LN2@operator@18:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@18

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@18:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tidy
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Copy
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Init
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::key_comp
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::get_allocator
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T91299 = -21						; size = 1
$T91298 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T91298[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::get_allocator
	lea	ecx, DWORD PTR $T91299[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?key_comp@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::key_comp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 529  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Init

; 530  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 531  : 		_Copy(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Copy
	jmp	SHORT $LN4@Tree
__catch$??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 535  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@Tree
	ret	0
$LN4@Tree:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree:

; 536  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::erase
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::end
; Function compile flags: /Odtp
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T91329 = -40						; size = 8
$T91328 = -32						; size = 8
$T91327 = -24						; size = 8
$T91326 = -16						; size = 8
$T91325 = -8						; size = 8
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator@19

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	lea	ecx, DWORD PTR $T91326[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T91325[ebp], edx
	mov	DWORD PTR $T91325[ebp+4], eax
	lea	ecx, DWORD PTR $T91328[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::begin
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T91327[ebp], edx
	mov	DWORD PTR $T91327[ebp+4], eax
	mov	ecx, DWORD PTR $T91325[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T91325[ebp]
	push	edx
	mov	eax, DWORD PTR $T91327[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T91327[ebp]
	push	ecx
	lea	edx, DWORD PTR $T91329[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Copy
$LN1@operator@19:

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 552  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
PUBLIC	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@1@0PAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
PUBLIC	?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
PUBLIC	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
PUBLIC	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
PUBLIC	??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
PUBLIC	??0?$allocator@I@std@@QAE@ABV01@@Z		; std::allocator<unsigned int>::allocator<unsigned int>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T91334 = -36						; size = 8
$T91333 = -28						; size = 8
$T91332 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91332[ebp], esp
	push	eax
	call	??0?$allocator@I@std@@QAE@ABV01@@Z	; std::allocator<unsigned int>::allocator<unsigned int>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@32

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T91333[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T91334[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@1@0PAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@32
__catch$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@32
	ret	0
$LN5@vector@32:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@32:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@32:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	?deallocate@?$allocator@I@std@@QAEXPAII@Z	; std::allocator<unsigned int>::deallocate
PUBLIC	??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
PUBLIC	?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
PUBLIC	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
PUBLIC	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z	; stdext::unchecked_copy<unsigned int *,unsigned int *>
PUBLIC	?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$74607 = -8					; size = 4
__Ptr$74597 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@20

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@20

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::clear
	jmp	$LN9@operator@20
$LN8@operator@20:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@20

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::unchecked_copy<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$74597[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$74597[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@20
$LN6@operator@20:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@20

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$74607[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$74607[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::unchecked_copy<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$74607[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@20
$LN4@operator@20:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@20

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@I@std@@QAEXPAII@Z ; std::allocator<unsigned int>::deallocate
$LN2@operator@20:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@20

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@20:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::~_Vector_val<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
PUBLIC	?_Tidy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEPAPAVSubMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> > >
PUBLIC	?begin@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::begin
PUBLIC	?end@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::end
PUBLIC	?_Buy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Buy
PUBLIC	??0?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_val<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
PUBLIC	??0?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SubMeshInstance *>::allocator<Ogre::SubMeshInstance *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T91364 = -36						; size = 8
$T91363 = -28						; size = 8
$T91362 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91362[ebp], esp
	push	eax
	call	??0?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SubMeshInstance *>::allocator<Ogre::SubMeshInstance *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_val<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@33

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T91363[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T91364[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEPAPAVSubMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@33
__catch$??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@33
	ret	0
$LN5@vector@33:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@33:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@33:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::~vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::~vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
PUBLIC	?deallocate@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAEXPAPAVSubMeshInstance@Ogre@@I@Z ; std::allocator<Ogre::SubMeshInstance *>::deallocate
PUBLIC	??$_Ucopy@PAPAVSubMeshInstance@Ogre@@@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEPAPAVSubMeshInstance@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Ucopy<Ogre::SubMeshInstance * *>
PUBLIC	?capacity@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVSubMeshInstance@Ogre@@0@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@@stdext@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>
PUBLIC	?clear@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$74761 = -8					; size = 4
__Ptr$74751 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@21

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@21

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::clear
	jmp	$LN9@operator@21
$LN8@operator@21:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@21

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@@stdext@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$74751[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$74751[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVSubMeshInstance@Ogre@@0@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@21
$LN6@operator@21:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@21

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$74761[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$74761[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@@stdext@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$74761[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVSubMeshInstance@Ogre@@@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEPAPAVSubMeshInstance@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Ucopy<Ogre::SubMeshInstance * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@21
$LN4@operator@21:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@21

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVSubMeshInstance@Ogre@@0@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAEXPAPAVSubMeshInstance@Ogre@@I@Z ; std::allocator<Ogre::SubMeshInstance *>::deallocate
$LN2@operator@21:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@21

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVSubMeshInstance@Ogre@@@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEPAPAVSubMeshInstance@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Ucopy<Ogre::SubMeshInstance * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@21:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAPAVSubMeshInstance@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAPAVSubMeshInstance@Ogre@@I@Z PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@22
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@22:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEAAPAVSubMeshInstance@Ogre@@I@Z ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::~_Vector_val<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
PUBLIC	?_Tidy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEPAPAVMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Ucopy<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> > >
PUBLIC	?begin@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::begin
PUBLIC	?end@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::end
PUBLIC	?_Buy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Buy
PUBLIC	??0?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z ; std::_Vector_val<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_val<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
PUBLIC	??0?$allocator@PAVMeshInstance@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::MeshInstance *>::allocator<Ogre::MeshInstance *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T91398 = -36						; size = 8
$T91397 = -28						; size = 8
$T91396 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91396[ebp], esp
	push	eax
	call	??0?$allocator@PAVMeshInstance@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::MeshInstance *>::allocator<Ogre::MeshInstance *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z ; std::_Vector_val<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_val<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@34

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T91397[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T91398[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEPAPAVMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Ucopy<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@34
__catch$??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@34
	ret	0
$LN5@vector@34:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@34:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@34:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::~vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::~vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
PUBLIC	?deallocate@?$allocator@PAVMeshInstance@Ogre@@@std@@QAEXPAPAVMeshInstance@Ogre@@I@Z ; std::allocator<Ogre::MeshInstance *>::deallocate
PUBLIC	??$_Ucopy@PAPAVMeshInstance@Ogre@@@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEPAPAVMeshInstance@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Ucopy<Ogre::MeshInstance * *>
PUBLIC	?capacity@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVMeshInstance@Ogre@@0@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVMeshInstance@Ogre@@PAPAV12@@stdext@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MeshInstance * *,Ogre::MeshInstance * *>
PUBLIC	?clear@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$74921 = -8					; size = 4
__Ptr$74911 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@23

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@23

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::clear
	jmp	$LN9@operator@23
$LN8@operator@23:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@23

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVMeshInstance@Ogre@@PAPAV12@@stdext@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MeshInstance * *,Ogre::MeshInstance * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$74911[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$74911[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVMeshInstance@Ogre@@0@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@23
$LN6@operator@23:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@23

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$74921[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$74921[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVMeshInstance@Ogre@@PAPAV12@@stdext@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MeshInstance * *,Ogre::MeshInstance * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$74921[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVMeshInstance@Ogre@@@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEPAPAVMeshInstance@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Ucopy<Ogre::MeshInstance * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@23
$LN4@operator@23:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@23

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVMeshInstance@Ogre@@0@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVMeshInstance@Ogre@@@std@@QAEXPAPAVMeshInstance@Ogre@@I@Z ; std::allocator<Ogre::MeshInstance *>::deallocate
$LN2@operator@23:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@23

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVMeshInstance@Ogre@@@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEPAPAVMeshInstance@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Ucopy<Ogre::MeshInstance * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@23:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEAAPAVMeshInstance@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEAAPAVMeshInstance@Ogre@@I@Z PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@24
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@24:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEAAPAVMeshInstance@Ogre@@I@Z ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::~_Vector_val<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
PUBLIC	?_Tidy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEPAPAVModelAnchorNode@Ogre@@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Ucopy<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> > >
PUBLIC	?begin@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::begin
PUBLIC	?end@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::end
PUBLIC	?_Buy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Buy
PUBLIC	?size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::size
PUBLIC	??0?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z ; std::_Vector_val<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_val<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
PUBLIC	??0?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ModelAnchorNode *>::allocator<Ogre::ModelAnchorNode *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T91432 = -36						; size = 8
$T91431 = -28						; size = 8
$T91430 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91430[ebp], esp
	push	eax
	call	??0?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ModelAnchorNode *>::allocator<Ogre::ModelAnchorNode *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z ; std::_Vector_val<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_val<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@35

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T91431[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T91432[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEPAPAVModelAnchorNode@Ogre@@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Ucopy<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@35
__catch$??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@35
	ret	0
$LN5@vector@35:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@35:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@35:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::~vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::~vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
PUBLIC	?deallocate@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAEXPAPAVModelAnchorNode@Ogre@@I@Z ; std::allocator<Ogre::ModelAnchorNode *>::deallocate
PUBLIC	??$_Ucopy@PAPAVModelAnchorNode@Ogre@@@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEPAPAVModelAnchorNode@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Ucopy<Ogre::ModelAnchorNode * *>
PUBLIC	?capacity@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEXPAPAVModelAnchorNode@Ogre@@0@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@@stdext@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>
PUBLIC	?clear@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$75081 = -8					; size = 4
__Ptr$75071 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@25

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@25

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::clear
	jmp	$LN9@operator@25
$LN8@operator@25:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@25

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@@stdext@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$75071[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$75071[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEXPAPAVModelAnchorNode@Ogre@@0@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@25
$LN6@operator@25:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@25

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$75081[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$75081[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@@stdext@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$75081[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVModelAnchorNode@Ogre@@@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEPAPAVModelAnchorNode@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Ucopy<Ogre::ModelAnchorNode * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@25
$LN4@operator@25:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@25

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEXPAPAVModelAnchorNode@Ogre@@0@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAEXPAPAVModelAnchorNode@Ogre@@I@Z ; std::allocator<Ogre::ModelAnchorNode *>::deallocate
$LN2@operator@25:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@25

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVModelAnchorNode@Ogre@@@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEPAPAVModelAnchorNode@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Ucopy<Ogre::ModelAnchorNode * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@25:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::key_comp
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIH@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::get_allocator
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T91461 = -21						; size = 1
$T91460 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T91460[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?get_allocator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIH@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::get_allocator
	lea	ecx, DWORD PTR $T91461[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?key_comp@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::key_comp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 529  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init

; 530  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 531  : 		_Copy(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
	jmp	SHORT $LN4@Tree@2
__catch$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 535  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@Tree@2
	ret	0
$LN4@Tree@2:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree@2:

; 536  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
; Function compile flags: /Odtp
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T91491 = -40						; size = 8
$T91490 = -32						; size = 8
$T91489 = -24						; size = 8
$T91488 = -16						; size = 8
$T91487 = -8						; size = 8
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator@26

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	lea	ecx, DWORD PTR $T91488[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T91487[ebp], edx
	mov	DWORD PTR $T91487[ebp+4], eax
	lea	ecx, DWORD PTR $T91490[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T91489[ebp], edx
	mov	DWORD PTR $T91489[ebp+4], eax
	mov	ecx, DWORD PTR $T91487[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T91487[ebp]
	push	edx
	mov	eax, DWORD PTR $T91489[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T91489[ebp]
	push	ecx
	lea	edx, DWORD PTR $T91491[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
$LN1@operator@26:

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 552  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree_val<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tidy
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Copy
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Init
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree_val<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::key_comp
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHI@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::get_allocator
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T91495 = -21						; size = 1
$T91494 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T91494[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?get_allocator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHI@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::get_allocator
	lea	ecx, DWORD PTR $T91495[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?key_comp@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::key_comp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree_val<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 529  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Init

; 530  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 531  : 		_Copy(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Copy
	jmp	SHORT $LN4@Tree@3
__catch$??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 535  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@Tree@3
	ret	0
$LN4@Tree@3:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree@3:

; 536  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree@3:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::erase
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::end
; Function compile flags: /Odtp
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T91525 = -40						; size = 8
$T91524 = -32						; size = 8
$T91523 = -24						; size = 8
$T91522 = -16						; size = 8
$T91521 = -8						; size = 8
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator@27

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	lea	ecx, DWORD PTR $T91522[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T91521[ebp], edx
	mov	DWORD PTR $T91521[ebp+4], eax
	lea	ecx, DWORD PTR $T91524[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::begin
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T91523[ebp], edx
	mov	DWORD PTR $T91523[ebp+4], eax
	mov	ecx, DWORD PTR $T91521[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T91521[ebp]
	push	edx
	mov	eax, DWORD PTR $T91523[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T91523[ebp]
	push	ecx
	lea	edx, DWORD PTR $T91525[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Copy
$LN1@operator@27:

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 552  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree_val<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tidy
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Copy
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Init
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree_val<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AU?$less@PAVTextureDataLoader@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::key_comp
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::get_allocator
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T91529 = -21						; size = 1
$T91528 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T91528[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?get_allocator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::get_allocator
	lea	ecx, DWORD PTR $T91529[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?key_comp@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AU?$less@PAVTextureDataLoader@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::key_comp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree_val<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 529  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Init

; 530  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 531  : 		_Copy(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Copy
	jmp	SHORT $LN4@Tree@4
__catch$??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 535  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@Tree@4
	ret	0
$LN4@Tree@4:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree@4:

; 536  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree@4:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::erase
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::end
; Function compile flags: /Odtp
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T91559 = -40						; size = 8
$T91558 = -32						; size = 8
$T91557 = -24						; size = 8
$T91556 = -16						; size = 8
$T91555 = -8						; size = 8
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator@28

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	lea	ecx, DWORD PTR $T91556[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T91555[ebp], edx
	mov	DWORD PTR $T91555[ebp+4], eax
	lea	ecx, DWORD PTR $T91558[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::begin
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T91557[ebp], edx
	mov	DWORD PTR $T91557[ebp+4], eax
	mov	ecx, DWORD PTR $T91555[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T91555[ebp]
	push	edx
	mov	eax, DWORD PTR $T91557[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T91557[ebp]
	push	ecx
	lea	edx, DWORD PTR $T91559[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Copy
$LN1@operator@28:

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 552  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree_val<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tidy
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Copy
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Init
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree_val<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::key_comp
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::get_allocator
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T91563 = -21						; size = 1
$T91562 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T91562[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?get_allocator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::get_allocator
	lea	ecx, DWORD PTR $T91563[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?key_comp@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::key_comp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree_val<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 529  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Init

; 530  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 531  : 		_Copy(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Copy
	jmp	SHORT $LN4@Tree@5
__catch$??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 535  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@Tree@5
	ret	0
$LN4@Tree@5:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree@5:

; 536  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree@5:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::erase
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::end
; Function compile flags: /Odtp
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T91593 = -40						; size = 8
$T91592 = -32						; size = 8
$T91591 = -24						; size = 8
$T91590 = -16						; size = 8
$T91589 = -8						; size = 8
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator@29

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	lea	ecx, DWORD PTR $T91590[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T91589[ebp], edx
	mov	DWORD PTR $T91589[ebp+4], eax
	lea	ecx, DWORD PTR $T91592[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::begin
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T91591[ebp], edx
	mov	DWORD PTR $T91591[ebp+4], eax
	mov	ecx, DWORD PTR $T91589[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T91589[ebp]
	push	edx
	mov	eax, DWORD PTR $T91591[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T91591[ebp]
	push	ecx
	lea	edx, DWORD PTR $T91593[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Copy
$LN1@operator@29:

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 552  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::operator=
_TEXT	ENDS
PUBLIC	?ms_Singleton@?$Singleton@VSequenceMap@Ogre@@@Ogre@@1PAVSequenceMap@2@A ; Ogre::Singleton<Ogre::SequenceMap>::ms_Singleton
;	COMDAT ?ms_Singleton@?$Singleton@VSequenceMap@Ogre@@@Ogre@@1PAVSequenceMap@2@A
; File i:\svnroot\client\ogremain\ogresingleton.h
_BSS	SEGMENT
?ms_Singleton@?$Singleton@VSequenceMap@Ogre@@@Ogre@@1PAVSequenceMap@2@A DD 01H DUP (?) ; Ogre::Singleton<Ogre::SequenceMap>::ms_Singleton
; Function compile flags: /Odtp
_BSS	ENDS
;	COMDAT ?getSingleton@?$Singleton@VSequenceMap@Ogre@@@Ogre@@SAAAVSequenceMap@2@XZ
_TEXT	SEGMENT
?getSingleton@?$Singleton@VSequenceMap@Ogre@@@Ogre@@SAAAVSequenceMap@2@XZ PROC ; Ogre::Singleton<Ogre::SequenceMap>::getSingleton, COMDAT

; 77   : 		{	assert( ms_Singleton );  return ( *ms_Singleton ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?ms_Singleton@?$Singleton@VSequenceMap@Ogre@@@Ogre@@1PAVSequenceMap@2@A ; Ogre::Singleton<Ogre::SequenceMap>::ms_Singleton
	pop	ebp
	ret	0
?getSingleton@?$Singleton@VSequenceMap@Ogre@@@Ogre@@SAAAVSequenceMap@2@XZ ENDP ; Ogre::Singleton<Ogre::SequenceMap>::getSingleton
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
__ehhandler$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::~_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
__ehhandler$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::~_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
__ehhandler$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::~_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::~_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
__ehhandler$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::~_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::~_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >
__ehhandler$??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::~_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Vector_val<char,std::allocator<char> >::~_Vector_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
__ehhandler$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<char,std::allocator<char> >::~_Vector_val<char,std::allocator<char> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
__ehhandler$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::~_Container_base_aux_alloc_real<std::allocator<unsigned int> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::~_Container_base_aux_alloc_real<std::allocator<unsigned int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::~_Container_base_aux_alloc_real<std::allocator<unsigned int> >
__ehhandler$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::~_Vector_val<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >
__ehhandler$??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::~_Vector_val<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::~_Vector_val<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >
__ehhandler$??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::~_Vector_val<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::~_Vector_val<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >
__ehhandler$??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::~_Vector_val<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree_ptr<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree_val<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree_val<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree_val<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree_val<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree_ptr<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree_val<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree_val<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree_ptr<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree_ptr<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree_ptr<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree_ptr<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree_ptr<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
PUBLIC	??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ ; std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0>::~_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
PUBLIC	??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::~_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ
__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ ; std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0>::~_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ
__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::~_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
PUBLIC	??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ ; std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0>::~_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ
__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::~_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
PUBLIC	??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ ; std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0>::~_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::~_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0>::~_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >
__ehhandler$??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0>::~_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0>
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::~_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >
__ehhandler$??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::~_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0>::~_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >
__ehhandler$??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0>::~_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0>
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0>::~_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >
__ehhandler$??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0>::~_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0>
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0>::~_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >
__ehhandler$??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0>::~_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity
$LN3@capacity:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::erase
PUBLIC	?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin
PUBLIC	?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T91892 = -40						; size = 8
$T91891 = -32						; size = 8
$T91890 = -24						; size = 8
$T91889 = -16						; size = 8
$T91888 = -8						; size = 8
?clear@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T91889[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T91888[ebp], ecx
	mov	DWORD PTR $T91888[ebp+4], edx
	lea	eax, DWORD PTR $T91891[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T91890[ebp], ecx
	mov	DWORD PTR $T91890[ebp+4], edx
	mov	eax, DWORD PTR $T91888[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T91888[ebp]
	push	ecx
	mov	edx, DWORD PTR $T91890[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T91890[ebp]
	push	eax
	lea	ecx, DWORD PTR $T91892[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEPAUTriggerDesc@Ogre@@I@Z ; std::allocator<Ogre::TriggerDesc>::allocate
PUBLIC	?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Xlen
PUBLIC	?max_size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEPAUTriggerDesc@Ogre@@I@Z ; std::allocator<Ogre::TriggerDesc>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@I@Z ; std::allocator<Ogre::TriggerDesc>::deallocate
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T91901 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91901[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
__ehhandler$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_val<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??1_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::~_Container_base_aux
PUBLIC	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
;	COMDAT ??1_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::~_Container_base_aux, COMDAT
; _this$ = ecx

; 402  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 		// Do nothing: ~_Container_base_aux_alloc_real() previously destroyed the aux object.
; 404  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::~_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@XZ PROC	; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UTriggerDesc@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::TriggerDesc>::allocator<Ogre::TriggerDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@I@Z PROC ; std::allocator<Ogre::TriggerDesc>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@I@Z ENDP ; std::allocator<Ogre::TriggerDesc>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@2
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@2
$LN3@capacity@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@2:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 4

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::erase
PUBLIC	?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin
PUBLIC	?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T91942 = -40						; size = 8
$T91941 = -32						; size = 8
$T91940 = -24						; size = 8
$T91939 = -16						; size = 8
$T91938 = -8						; size = 8
?clear@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T91939[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T91938[ebp], ecx
	mov	DWORD PTR $T91938[ebp+4], edx
	lea	eax, DWORD PTR $T91941[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T91940[ebp], ecx
	mov	DWORD PTR $T91940[ebp+4], edx
	mov	eax, DWORD PTR $T91938[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T91938[ebp]
	push	ecx
	mov	edx, DWORD PTR $T91940[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T91940[ebp]
	push	eax
	lea	ecx, DWORD PTR $T91942[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEPAUSequenceDesc@Ogre@@I@Z ; std::allocator<Ogre::SequenceDesc>::allocate
PUBLIC	?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Xlen
PUBLIC	?max_size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2
$LN2@Buy@2:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEPAUSequenceDesc@Ogre@@I@Z ; std::allocator<Ogre::SequenceDesc>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@I@Z ; std::allocator<Ogre::SequenceDesc>::deallocate
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T91951 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91951[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
__ehhandler$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_val<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@XZ PROC	; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@USequenceDesc@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::SequenceDesc>::allocator<Ogre::SequenceDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@I@Z PROC ; std::allocator<Ogre::SequenceDesc>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@I@Z ENDP ; std::allocator<Ogre::SequenceDesc>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@3
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@3
$LN3@capacity@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@3:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::erase
PUBLIC	?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
PUBLIC	?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T91990 = -40						; size = 8
$T91989 = -32						; size = 8
$T91988 = -24						; size = 8
$T91987 = -16						; size = 8
$T91986 = -8						; size = 8
?clear@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T91987[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T91986[ebp], ecx
	mov	DWORD PTR $T91986[ebp+4], edx
	lea	eax, DWORD PTR $T91989[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T91988[ebp], ecx
	mov	DWORD PTR $T91988[ebp+4], edx
	mov	eax, DWORD PTR $T91986[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T91986[ebp]
	push	ecx
	mov	edx, DWORD PTR $T91988[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T91988[ebp]
	push	eax
	lea	ecx, DWORD PTR $T91990[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEPAPAVBoneTrack@Ogre@@I@Z ; std::allocator<Ogre::BoneTrack *>::allocate
PUBLIC	?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@3
$LN2@Buy@3:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEPAPAVBoneTrack@Ogre@@I@Z ; std::allocator<Ogre::BoneTrack *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@3:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEXPAPAVBoneTrack@Ogre@@I@Z ; std::allocator<Ogre::BoneTrack *>::deallocate
$LN1@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T91999 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T91999[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
__ehhandler$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_val<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVBoneTrack@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::BoneTrack *>::allocator<Ogre::BoneTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEXPAPAVBoneTrack@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEXPAPAVBoneTrack@Ogre@@I@Z PROC ; std::allocator<Ogre::BoneTrack *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEXPAPAVBoneTrack@Ogre@@I@Z ENDP ; std::allocator<Ogre::BoneTrack *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@4
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@4
$LN3@capacity@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@4:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::erase
PUBLIC	?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin
PUBLIC	?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T92036 = -40						; size = 8
$T92035 = -32						; size = 8
$T92034 = -24						; size = 8
$T92033 = -16						; size = 8
$T92032 = -8						; size = 8
?clear@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T92033[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92032[ebp], ecx
	mov	DWORD PTR $T92032[ebp+4], edx
	lea	eax, DWORD PTR $T92035[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92034[ebp], ecx
	mov	DWORD PTR $T92034[ebp+4], edx
	mov	eax, DWORD PTR $T92032[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T92032[ebp]
	push	ecx
	mov	edx, DWORD PTR $T92034[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T92034[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92036[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEPAPAVMaterialParamTrack@Ogre@@I@Z ; std::allocator<Ogre::MaterialParamTrack *>::allocate
PUBLIC	?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@4

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@4
	jmp	SHORT $LN3@Buy@4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@4
$LN2@Buy@4:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEPAPAVMaterialParamTrack@Ogre@@I@Z ; std::allocator<Ogre::MaterialParamTrack *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@4:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@4:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEXPAPAVMaterialParamTrack@Ogre@@I@Z ; std::allocator<Ogre::MaterialParamTrack *>::deallocate
$LN1@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T92045 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T92045[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::MaterialParamTrack *>::allocator<Ogre::MaterialParamTrack *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::MaterialParamTrack *>::allocator<Ogre::MaterialParamTrack *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
__ehhandler$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_val<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::MaterialParamTrack *>::allocator<Ogre::MaterialParamTrack *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::MaterialParamTrack *>::allocator<Ogre::MaterialParamTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEXPAPAVMaterialParamTrack@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEXPAPAVMaterialParamTrack@Ogre@@I@Z PROC ; std::allocator<Ogre::MaterialParamTrack *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEXPAPAVMaterialParamTrack@Ogre@@I@Z ENDP ; std::allocator<Ogre::MaterialParamTrack *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@5
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@5
$LN3@capacity@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@5:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@PAPAVAnimPlayTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@PAPAVAnimPlayTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::begin
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@PAPAVAnimPlayTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@PAPAVAnimPlayTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@PAPAVAnimPlayTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator+
PUBLIC	?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator-
PUBLIC	?begin@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@ABQAVAnimPlayTrack@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T92081 = -20						; size = 8
$T92078 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@ABQAVAnimPlayTrack@Ogre@@@Z PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	lea	eax, DWORD PTR $T92078[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92081[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@ABQAVAnimPlayTrack@Ogre@@@Z ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T92088 = -40						; size = 8
$T92087 = -32						; size = 8
$T92086 = -24						; size = 8
$T92085 = -16						; size = 8
$T92084 = -8						; size = 8
?clear@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T92085[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92084[ebp], ecx
	mov	DWORD PTR $T92084[ebp+4], edx
	lea	eax, DWORD PTR $T92087[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92086[ebp], ecx
	mov	DWORD PTR $T92086[ebp+4], edx
	mov	eax, DWORD PTR $T92084[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T92084[ebp]
	push	ecx
	mov	edx, DWORD PTR $T92086[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T92086[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92088[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAEPAPAVAnimPlayTrack@Ogre@@I@Z ; std::allocator<Ogre::AnimPlayTrack *>::allocate
PUBLIC	?_Xlen@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@5

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@5
	jmp	SHORT $LN3@Buy@5
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@5
$LN2@Buy@5:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAEPAPAVAnimPlayTrack@Ogre@@I@Z ; std::allocator<Ogre::AnimPlayTrack *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@5:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@5:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXPAPAVAnimPlayTrack@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXPAPAVAnimPlayTrack@Ogre@@0@Z PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::AnimPlayTrack *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXPAPAVAnimPlayTrack@Ogre@@0@Z ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAEXPAPAVAnimPlayTrack@Ogre@@I@Z ; std::allocator<Ogre::AnimPlayTrack *>::deallocate
$LN1@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV34@IABQAV34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV34@IABQAV34@@Z PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV34@IABQAV34@@Z ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T92099 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T92099[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::AnimPlayTrack *>::allocator<Ogre::AnimPlayTrack *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::AnimPlayTrack *>::allocator<Ogre::AnimPlayTrack *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >
__ehhandler$??0?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_val<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAE@XZ PROC	; std::allocator<Ogre::AnimPlayTrack *>::allocator<Ogre::AnimPlayTrack *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<Ogre::AnimPlayTrack *>::allocator<Ogre::AnimPlayTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::AnimPlayTrack *>::allocator<Ogre::AnimPlayTrack *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::AnimPlayTrack *>::allocator<Ogre::AnimPlayTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAEXPAPAVAnimPlayTrack@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAEXPAPAVAnimPlayTrack@Ogre@@I@Z PROC ; std::allocator<Ogre::AnimPlayTrack *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAEXPAPAVAnimPlayTrack@Ogre@@I@Z ENDP ; std::allocator<Ogre::AnimPlayTrack *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@6
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN4@capacity@6
$LN3@capacity@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv69[ebp], eax
$LN4@capacity@6:
	mov	eax, DWORD PTR tv69[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC	; std::vector<char,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP	; std::vector<char,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z ; std::vector<char,std::allocator<char> >::erase
PUBLIC	?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
PUBLIC	?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T92138 = -40						; size = 8
$T92137 = -32						; size = 8
$T92136 = -24						; size = 8
$T92135 = -16						; size = 8
$T92134 = -8						; size = 8
?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ PROC	; std::vector<char,std::allocator<char> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T92135[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92134[ebp], ecx
	mov	DWORD PTR $T92134[ebp+4], edx
	lea	eax, DWORD PTR $T92137[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92136[ebp], ecx
	mov	DWORD PTR $T92136[ebp+4], edx
	mov	eax, DWORD PTR $T92134[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T92134[ebp]
	push	ecx
	mov	edx, DWORD PTR $T92136[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T92136[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92138[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z ; std::vector<char,std::allocator<char> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ ENDP	; std::vector<char,std::allocator<char> >::clear
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ ; std::vector<char,std::allocator<char> >::_Xlen
PUBLIC	?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::max_size
EXTRN	__imp_?allocate@?$allocator@D@std@@QAEPADI@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z PROC	; std::vector<char,std::allocator<char> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@6

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@6
	jmp	SHORT $LN3@Buy@6
$LN4@Buy@6:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@6

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ ; std::vector<char,std::allocator<char> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@6
$LN2@Buy@6:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?allocate@?$allocator@D@std@@QAEPADI@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN3@Buy@6:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@6:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ENDP	; std::vector<char,std::allocator<char> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z PROC ; std::vector<char,std::allocator<char> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ENDP ; std::vector<char,std::allocator<char> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ PROC	; std::vector<char,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@6

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?deallocate@?$allocator@D@std@@QAEXPADI@Z
$LN1@Tidy@6:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ENDP	; std::vector<char,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T92147 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T92147[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	DWORD PTR __imp_??0?$allocator@D@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_??0?$allocator@D@std@@QAE@ABV01@@Z

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
__ehhandler$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@7
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@7
$LN3@capacity@7:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@7:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::erase
PUBLIC	?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
PUBLIC	?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T92180 = -40						; size = 8
$T92179 = -32						; size = 8
$T92178 = -24						; size = 8
$T92177 = -16						; size = 8
$T92176 = -8						; size = 8
?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T92177[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92176[ebp], ecx
	mov	DWORD PTR $T92176[ebp+4], edx
	lea	eax, DWORD PTR $T92179[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92178[ebp], ecx
	mov	DWORD PTR $T92178[ebp+4], edx
	mov	eax, DWORD PTR $T92176[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T92176[ebp]
	push	ecx
	mov	edx, DWORD PTR $T92178[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T92178[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92180[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::allocate
PUBLIC	?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@7

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@7
	jmp	SHORT $LN3@Buy@7
$LN4@Buy@7:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@7

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@7
$LN2@Buy@7:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@7:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@7:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@7

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::deallocate
$LN1@Tidy@7:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T92189 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T92189[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
__ehhandler$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z PROC ; std::allocator<Ogre::SurfaceData *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z ENDP ; std::allocator<Ogre::SurfaceData *>::deallocate
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::iterator::iterator
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lmost
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::begin, COMDAT
; _this$ = ecx

; 555  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 557  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::end, COMDAT
; _this$ = ecx

; 565  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 567  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::end
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >::allocator<std::pair<unsigned int const ,Ogre::Resource *> >
; Function compile flags: /Odtp
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 615  : 		{	// return allocator object for values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >::allocator<std::pair<unsigned int const ,Ogre::Resource *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 617  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::get_allocator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 620  : 		{	// return object for comparing keys

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 622  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Make_iter
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::erase
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator++
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator!=
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::clear
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T92223 = -32						; size = 8
$T92222 = -24						; size = 8
$T92221 = -16						; size = 8
$T92220 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	lea	eax, DWORD PTR $T92220[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@erase
	lea	edx, DWORD PTR $T92221[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@erase

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::clear

; 938  : 			return (begin());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::begin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase
$LN2@erase:

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@erase

; 943  : 				erase(_First++);

	push	0
	lea	ecx, DWORD PTR $T92222[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator++
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T92223[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::erase
	jmp	SHORT $LN2@erase
$LN1@erase:

; 944  : 			return (_Make_iter(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rmost
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Min
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::size
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Copy
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
; Function compile flags: /Odtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	DWORD PTR [eax], esi

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 1065 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN2@Copy

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Min
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lmost
	mov	DWORD PTR [eax], esi

; 1068 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Max@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Max
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rmost
	mov	DWORD PTR [eax], esi

; 1069 : 			}
; 1070 : 		else

	jmp	SHORT $LN3@Copy
$LN2@Copy:

; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
$LN3@Copy:

; 1072 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1182 : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::deallocate
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::destroy
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T92234 = -40						; size = 8
$T92233 = -32						; size = 8
$T92232 = -24						; size = 8
$T92231 = -16						; size = 8
$T92230 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T92231[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92230[ebp], ecx
	mov	DWORD PTR $T92230[ebp+4], edx
	lea	eax, DWORD PTR $T92233[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92232[ebp], ecx
	mov	DWORD PTR $T92232[ebp+4], edx
	mov	eax, DWORD PTR $T92230[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T92230[ebp]
	push	ecx
	mov	edx, DWORD PTR $T92232[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T92232[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92234[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::destroy

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::destroy

; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::destroy

; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::deallocate

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T92237 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T92237[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >::allocator<std::pair<unsigned int const ,Ogre::Resource *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >::allocator<std::pair<unsigned int const ,Ogre::Resource *> >

; 98   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_val@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@I@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@I@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@I@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@I@std@@QAEXPAII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@I@std@@QAEXPAII@Z PROC		; std::allocator<unsigned int>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@I@std@@QAEXPAII@Z ENDP		; std::allocator<unsigned int>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@8
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@8
$LN3@capacity@8:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@8:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
PUBLIC	?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T92274 = -40						; size = 8
$T92273 = -32						; size = 8
$T92272 = -24						; size = 8
$T92271 = -16						; size = 8
$T92270 = -8						; size = 8
?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T92271[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92270[ebp], ecx
	mov	DWORD PTR $T92270[ebp+4], edx
	lea	eax, DWORD PTR $T92273[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92272[ebp], ecx
	mov	DWORD PTR $T92272[ebp+4], edx
	mov	eax, DWORD PTR $T92270[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T92270[ebp]
	push	ecx
	mov	edx, DWORD PTR $T92272[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T92272[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92274[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@I@std@@QAEPAII@Z		; std::allocator<unsigned int>::allocate
PUBLIC	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
PUBLIC	?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@8

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@8
	jmp	SHORT $LN3@Buy@8
$LN4@Buy@8:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@8

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@8
$LN2@Buy@8:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@8:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@8:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@8

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@I@std@@QAEXPAII@Z ; std::allocator<unsigned int>::deallocate
$LN1@Tidy@8:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::_Container_base_aux_alloc_real<std::allocator<unsigned int> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T92283 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T92283[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@I@std@@QAE@ABV01@@Z	; std::allocator<unsigned int>::allocator<unsigned int>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::_Container_base_aux_alloc_real<std::allocator<unsigned int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@I@std@@QAE@ABV01@@Z	; std::allocator<unsigned int>::allocator<unsigned int>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::~_Container_base_aux_alloc_real<std::allocator<unsigned int> >
__ehhandler$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::~_Container_base_aux_alloc_real<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::~_Container_base_aux_alloc_real<std::allocator<unsigned int> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@9
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@9
$LN3@capacity@9:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@9:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVSubMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVSubMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVSubMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::end
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::erase
PUBLIC	?begin@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::begin
PUBLIC	?end@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T92314 = -40						; size = 8
$T92313 = -32						; size = 8
$T92312 = -24						; size = 8
$T92311 = -16						; size = 8
$T92310 = -8						; size = 8
?clear@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T92311[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92310[ebp], ecx
	mov	DWORD PTR $T92310[ebp+4], edx
	lea	eax, DWORD PTR $T92313[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92312[ebp], ecx
	mov	DWORD PTR $T92312[ebp+4], edx
	mov	eax, DWORD PTR $T92310[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T92310[ebp]
	push	ecx
	mov	edx, DWORD PTR $T92312[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T92312[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92314[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAEPAPAVSubMeshInstance@Ogre@@I@Z ; std::allocator<Ogre::SubMeshInstance *>::allocate
PUBLIC	?_Xlen@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@9

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@9
	jmp	SHORT $LN3@Buy@9
$LN4@Buy@9:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@9

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@9
$LN2@Buy@9:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAEPAPAVSubMeshInstance@Ogre@@I@Z ; std::allocator<Ogre::SubMeshInstance *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@9:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@9:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAXPAPAVSubMeshInstance@Ogre@@0AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SubMeshInstance *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVSubMeshInstance@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVSubMeshInstance@Ogre@@0@Z PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAXPAPAVSubMeshInstance@Ogre@@0AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SubMeshInstance *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVSubMeshInstance@Ogre@@0@Z ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@9

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVSubMeshInstance@Ogre@@0@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAEXPAPAVSubMeshInstance@Ogre@@I@Z ; std::allocator<Ogre::SubMeshInstance *>::deallocate
$LN1@Tidy@9:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T92323 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_val<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T92323[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SubMeshInstance *>::allocator<Ogre::SubMeshInstance *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SubMeshInstance *>::allocator<Ogre::SubMeshInstance *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >
__ehhandler$??0?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_val<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::SubMeshInstance *>::allocator<Ogre::SubMeshInstance *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::SubMeshInstance *>::allocator<Ogre::SubMeshInstance *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAEXPAPAVSubMeshInstance@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAEXPAPAVSubMeshInstance@Ogre@@I@Z PROC ; std::allocator<Ogre::SubMeshInstance *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAEXPAPAVSubMeshInstance@Ogre@@I@Z ENDP ; std::allocator<Ogre::SubMeshInstance *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@10
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@10
$LN3@capacity@10:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@10:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::end
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::erase
PUBLIC	?begin@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::begin
PUBLIC	?end@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T92358 = -40						; size = 8
$T92357 = -32						; size = 8
$T92356 = -24						; size = 8
$T92355 = -16						; size = 8
$T92354 = -8						; size = 8
?clear@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T92355[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92354[ebp], ecx
	mov	DWORD PTR $T92354[ebp+4], edx
	lea	eax, DWORD PTR $T92357[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92356[ebp], ecx
	mov	DWORD PTR $T92356[ebp+4], edx
	mov	eax, DWORD PTR $T92354[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T92354[ebp]
	push	ecx
	mov	edx, DWORD PTR $T92356[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T92356[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92358[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVMeshInstance@Ogre@@@std@@QAEPAPAVMeshInstance@Ogre@@I@Z ; std::allocator<Ogre::MeshInstance *>::allocate
PUBLIC	?_Xlen@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@10

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@10
	jmp	SHORT $LN3@Buy@10
$LN4@Buy@10:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@10

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@10
$LN2@Buy@10:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVMeshInstance@Ogre@@@std@@QAEPAPAVMeshInstance@Ogre@@I@Z ; std::allocator<Ogre::MeshInstance *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@10:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@10:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAXPAPAVMeshInstance@Ogre@@0AAV?$allocator@PAVMeshInstance@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MeshInstance *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVMeshInstance@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVMeshInstance@Ogre@@0@Z PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAXPAPAVMeshInstance@Ogre@@0AAV?$allocator@PAVMeshInstance@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MeshInstance *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVMeshInstance@Ogre@@0@Z ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@10

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVMeshInstance@Ogre@@0@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVMeshInstance@Ogre@@@std@@QAEXPAPAVMeshInstance@Ogre@@I@Z ; std::allocator<Ogre::MeshInstance *>::deallocate
$LN1@Tidy@10:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T92367 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_val<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T92367[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVMeshInstance@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::MeshInstance *>::allocator<Ogre::MeshInstance *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVMeshInstance@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::MeshInstance *>::allocator<Ogre::MeshInstance *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >
__ehhandler$??0?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_val<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVMeshInstance@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVMeshInstance@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::MeshInstance *>::allocator<Ogre::MeshInstance *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVMeshInstance@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::MeshInstance *>::allocator<Ogre::MeshInstance *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVMeshInstance@Ogre@@@std@@QAEXPAPAVMeshInstance@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVMeshInstance@Ogre@@@std@@QAEXPAPAVMeshInstance@Ogre@@I@Z PROC ; std::allocator<Ogre::MeshInstance *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVMeshInstance@Ogre@@@std@@QAEXPAPAVMeshInstance@Ogre@@I@Z ENDP ; std::allocator<Ogre::MeshInstance *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@11
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@11
$LN3@capacity@11:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@11:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@PAPAVModelAnchorNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@PAPAVModelAnchorNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@PAPAVModelAnchorNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::erase
PUBLIC	?begin@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::begin
PUBLIC	?end@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T92404 = -40						; size = 8
$T92403 = -32						; size = 8
$T92402 = -24						; size = 8
$T92401 = -16						; size = 8
$T92400 = -8						; size = 8
?clear@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T92401[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92400[ebp], ecx
	mov	DWORD PTR $T92400[ebp+4], edx
	lea	eax, DWORD PTR $T92403[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92402[ebp], ecx
	mov	DWORD PTR $T92402[ebp+4], edx
	mov	eax, DWORD PTR $T92400[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T92400[ebp]
	push	ecx
	mov	edx, DWORD PTR $T92402[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T92402[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92404[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAEPAPAVModelAnchorNode@Ogre@@I@Z ; std::allocator<Ogre::ModelAnchorNode *>::allocate
PUBLIC	?_Xlen@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@11

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@11
	jmp	SHORT $LN3@Buy@11
$LN4@Buy@11:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@11

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@11
$LN2@Buy@11:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAEPAPAVModelAnchorNode@Ogre@@I@Z ; std::allocator<Ogre::ModelAnchorNode *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@11:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@11:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAXPAPAVModelAnchorNode@Ogre@@0AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ModelAnchorNode *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEXPAPAVModelAnchorNode@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEXPAPAVModelAnchorNode@Ogre@@0@Z PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAXPAPAVModelAnchorNode@Ogre@@0AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ModelAnchorNode *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEXPAPAVModelAnchorNode@Ogre@@0@Z ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@11

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEXPAPAVModelAnchorNode@Ogre@@0@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAEXPAPAVModelAnchorNode@Ogre@@I@Z ; std::allocator<Ogre::ModelAnchorNode *>::deallocate
$LN1@Tidy@11:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T92413 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_val<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T92413[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ModelAnchorNode *>::allocator<Ogre::ModelAnchorNode *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ModelAnchorNode *>::allocator<Ogre::ModelAnchorNode *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >
__ehhandler$??0?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_val<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::ModelAnchorNode *>::allocator<Ogre::ModelAnchorNode *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::ModelAnchorNode *>::allocator<Ogre::ModelAnchorNode *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAEXPAPAVModelAnchorNode@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAEXPAPAVModelAnchorNode@Ogre@@I@Z PROC ; std::allocator<Ogre::ModelAnchorNode *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAEXPAPAVModelAnchorNode@Ogre@@I@Z ENDP ; std::allocator<Ogre::ModelAnchorNode *>::deallocate
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 555  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 557  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 565  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 567  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
; Function compile flags: /Odtp
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIH@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIH@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 615  : 		{	// return allocator object for values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 617  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIH@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::get_allocator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 620  : 		{	// return object for comparing keys

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 622  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Make_iter
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator!=
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T92447 = -32						; size = 8
$T92446 = -24						; size = 8
$T92445 = -16						; size = 8
$T92444 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	lea	eax, DWORD PTR $T92444[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@erase@2
	lea	edx, DWORD PTR $T92445[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@erase@2

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear

; 938  : 			return (begin());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@2

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@2
$LN2@erase@2:

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@erase@2

; 943  : 				erase(_First++);

	push	0
	lea	ecx, DWORD PTR $T92446[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T92447[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
	jmp	SHORT $LN2@erase@2
$LN1@erase@2:

; 944  : 			return (_Make_iter(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@2:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::size
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
; Function compile flags: /Odtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	DWORD PTR [eax], esi

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 1065 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN2@Copy@2

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
	mov	DWORD PTR [eax], esi

; 1068 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost
	mov	DWORD PTR [eax], esi

; 1069 : 			}
; 1070 : 		else

	jmp	SHORT $LN3@Copy@2
$LN2@Copy@2:

; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
$LN3@Copy@2:

; 1072 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1182 : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T92458 = -40						; size = 8
$T92457 = -32						; size = 8
$T92456 = -24						; size = 8
$T92455 = -16						; size = 8
$T92454 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T92455[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92454[ebp], ecx
	mov	DWORD PTR $T92454[ebp+4], edx
	lea	eax, DWORD PTR $T92457[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92456[ebp], ecx
	mov	DWORD PTR $T92456[ebp+4], edx
	mov	eax, DWORD PTR $T92454[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T92454[ebp]
	push	ecx
	mov	edx, DWORD PTR $T92456[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T92456[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92458[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy

; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy

; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T92461 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T92461[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >

; 98   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_val@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::iterator::iterator
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lmost
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::begin, COMDAT
; _this$ = ecx

; 555  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 557  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::end, COMDAT
; _this$ = ecx

; 565  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 567  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::end
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHI@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,unsigned int> >::allocator<std::pair<int const ,unsigned int> >
; Function compile flags: /Odtp
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHI@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHI@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 615  : 		{	// return allocator object for values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@U?$pair@$$CBHI@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,unsigned int> >::allocator<std::pair<int const ,unsigned int> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 617  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHI@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::get_allocator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 620  : 		{	// return object for comparing keys

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 622  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Make_iter
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::erase
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator++
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator!=
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::clear
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T92491 = -32						; size = 8
$T92490 = -24						; size = 8
$T92489 = -16						; size = 8
$T92488 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	lea	eax, DWORD PTR $T92488[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@erase@3
	lea	edx, DWORD PTR $T92489[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@erase@3

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::clear

; 938  : 			return (begin());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::begin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@3

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@3
$LN2@erase@3:

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@erase@3

; 943  : 				erase(_First++);

	push	0
	lea	ecx, DWORD PTR $T92490[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator++
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T92491[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::erase
	jmp	SHORT $LN2@erase@3
$LN1@erase@3:

; 944  : 			return (_Make_iter(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@3:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rmost
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Min
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::size
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Copy
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
; Function compile flags: /Odtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	DWORD PTR [eax], esi

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 1065 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN2@Copy@3

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Min
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lmost
	mov	DWORD PTR [eax], esi

; 1068 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Max@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Max
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rmost
	mov	DWORD PTR [eax], esi

; 1069 : 			}
; 1070 : 		else

	jmp	SHORT $LN3@Copy@3
$LN2@Copy@3:

; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
$LN3@Copy@3:

; 1072 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1182 : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::deallocate
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::destroy
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T92502 = -40						; size = 8
$T92501 = -32						; size = 8
$T92500 = -24						; size = 8
$T92499 = -16						; size = 8
$T92498 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T92499[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92498[ebp], ecx
	mov	DWORD PTR $T92498[ebp+4], edx
	lea	eax, DWORD PTR $T92501[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92500[ebp], ecx
	mov	DWORD PTR $T92500[ebp+4], edx
	mov	eax, DWORD PTR $T92498[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T92498[ebp]
	push	ecx
	mov	edx, DWORD PTR $T92500[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T92500[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92502[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::destroy

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::destroy

; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::destroy

; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::deallocate

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree_ptr<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T92505 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree_val<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T92505[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBHI@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,unsigned int> >::allocator<std::pair<int const ,unsigned int> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree_ptr<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$allocator@U?$pair@$$CBHI@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,unsigned int> >::allocator<std::pair<int const ,unsigned int> >

; 98   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_val@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree_val<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::iterator::iterator
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lmost
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 555  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 557  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::end, COMDAT
; _this$ = ecx

; 565  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 567  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::end
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >::allocator<std::pair<Ogre::TextureDataLoader * const,int> >
; Function compile flags: /Odtp
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 615  : 		{	// return allocator object for values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >::allocator<std::pair<Ogre::TextureDataLoader * const,int> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 617  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::get_allocator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AU?$less@PAVTextureDataLoader@Ogre@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AU?$less@PAVTextureDataLoader@Ogre@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 620  : 		{	// return object for comparing keys

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 622  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AU?$less@PAVTextureDataLoader@Ogre@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Make_iter
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::erase
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator++
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator!=
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::clear
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T92535 = -32						; size = 8
$T92534 = -24						; size = 8
$T92533 = -16						; size = 8
$T92532 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	lea	eax, DWORD PTR $T92532[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@erase@4
	lea	edx, DWORD PTR $T92533[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@erase@4

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::clear

; 938  : 			return (begin());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::begin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@4

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@4
$LN2@erase@4:

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@erase@4

; 943  : 				erase(_First++);

	push	0
	lea	ecx, DWORD PTR $T92534[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator++
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T92535[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::erase
	jmp	SHORT $LN2@erase@4
$LN1@erase@4:

; 944  : 			return (_Make_iter(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@4:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rmost
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Min
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::size
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Copy
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
; Function compile flags: /Odtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	DWORD PTR [eax], esi

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 1065 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN2@Copy@4

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Min
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lmost
	mov	DWORD PTR [eax], esi

; 1068 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Max@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Max
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rmost
	mov	DWORD PTR [eax], esi

; 1069 : 			}
; 1070 : 		else

	jmp	SHORT $LN3@Copy@4
$LN2@Copy@4:

; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
$LN3@Copy@4:

; 1072 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1182 : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::deallocate
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::destroy
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T92546 = -40						; size = 8
$T92545 = -32						; size = 8
$T92544 = -24						; size = 8
$T92543 = -16						; size = 8
$T92542 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T92543[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92542[ebp], ecx
	mov	DWORD PTR $T92542[ebp+4], edx
	lea	eax, DWORD PTR $T92545[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92544[ebp], ecx
	mov	DWORD PTR $T92544[ebp+4], edx
	mov	eax, DWORD PTR $T92542[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T92542[ebp]
	push	ecx
	mov	edx, DWORD PTR $T92544[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T92544[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92546[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::destroy

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::destroy

; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::destroy

; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::deallocate

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree_ptr<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T92549 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree_val<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T92549[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >::allocator<std::pair<Ogre::TextureDataLoader * const,int> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree_ptr<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >::allocator<std::pair<Ogre::TextureDataLoader * const,int> >

; 98   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_val@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree_val<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::iterator::iterator
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lmost
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::begin, COMDAT
; _this$ = ecx

; 555  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 557  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::end, COMDAT
; _this$ = ecx

; 565  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 567  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::end
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >
; Function compile flags: /Odtp
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 615  : 		{	// return allocator object for values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 617  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::get_allocator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 620  : 		{	// return object for comparing keys

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 622  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Make_iter
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::erase
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator++
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator!=
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::clear
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T92579 = -32						; size = 8
$T92578 = -24						; size = 8
$T92577 = -16						; size = 8
$T92576 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	lea	eax, DWORD PTR $T92576[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@erase@5
	lea	edx, DWORD PTR $T92577[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@erase@5

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::clear

; 938  : 			return (begin());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::begin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@5

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@5
$LN2@erase@5:

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@erase@5

; 943  : 				erase(_First++);

	push	0
	lea	ecx, DWORD PTR $T92578[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator++
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T92579[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::erase
	jmp	SHORT $LN2@erase@5
$LN1@erase@5:

; 944  : 			return (_Make_iter(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@5:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rmost
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Min
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::size
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Copy
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
; Function compile flags: /Odtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	DWORD PTR [eax], esi

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 1065 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN2@Copy@5

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Min
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lmost
	mov	DWORD PTR [eax], esi

; 1068 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Max@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Max
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rmost
	mov	DWORD PTR [eax], esi

; 1069 : 			}
; 1070 : 		else

	jmp	SHORT $LN3@Copy@5
$LN2@Copy@5:

; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
$LN3@Copy@5:

; 1072 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1182 : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::deallocate
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::destroy
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T92590 = -40						; size = 8
$T92589 = -32						; size = 8
$T92588 = -24						; size = 8
$T92587 = -16						; size = 8
$T92586 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T92587[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92586[ebp], ecx
	mov	DWORD PTR $T92586[ebp+4], edx
	lea	eax, DWORD PTR $T92589[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T92588[ebp], ecx
	mov	DWORD PTR $T92588[ebp+4], edx
	mov	eax, DWORD PTR $T92586[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T92586[ebp]
	push	ecx
	mov	edx, DWORD PTR $T92588[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T92588[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92590[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::destroy

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::destroy

; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::destroy

; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::deallocate

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T92593 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree_val<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T92593[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >

; 98   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_val@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree_val<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >
PUBLIC	??0?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UTriggerDesc@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::TriggerDesc>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UTriggerDesc@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::TriggerDesc>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator!=
PUBLIC	?_Make_iter@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$77991 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@6

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUTriggerDesc@Ogre@@PAU12@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$77991[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$77991[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEXPAUTriggerDesc@Ogre@@0@Z ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$77991[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@6:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::erase
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T92621 = -80						; size = 28
$T92620 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T92621[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T92621[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92620[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T92620[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T92621[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T92621[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Xlen
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1logic_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$1
__ehfuncinfo$??1logic_error@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1logic_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 31   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1logic_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??1logic_error@std@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1logic_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@25
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@25:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1length_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1length_error@std@@UAE@XZ$0
__ehfuncinfo$??1length_error@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1length_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1length_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1length_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1length_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1length_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@26
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@26:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
PUBLIC	??$?0UTriggerDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTriggerDesc@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TriggerDesc>
PUBLIC	??0_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::_Container_base_aux
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T92687 = -24						; size = 4
$T92686 = -20						; size = 4
$T92685 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UTriggerDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTriggerDesc@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TriggerDesc>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T92687[ebp], eax
	mov	ecx, DWORD PTR $T92687[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T92686[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T92686[ebp], 0
	je	SHORT $LN3@Container_
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T92686[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_
$LN3@Container_:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T92685[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T92685[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T92687[ebp]
	push	eax
	mov	ecx, DWORD PTR $T92686[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UTriggerDesc@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 58   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 60   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z PROC	; std::_Aux_cont::_Aux_cont, COMDAT
; _this$ = ecx

; 364  : 	explicit _Aux_cont(const _Container_base_aux * const _Pcont)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ENDP	; std::_Aux_cont::_Aux_cont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::_Container_base_aux, COMDAT
; _this$ = ecx

; 379  : 	_Container_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		{
; 381  : 		// Do nothing: _Container_base_aux_alloc_real() will construct the aux object.
; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::_Container_base_aux
_TEXT	ENDS
PUBLIC	??$_Allocate@UTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::TriggerDesc>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEPAUTriggerDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEPAUTriggerDesc@Ogre@@I@Z PROC ; std::allocator<Ogre::TriggerDesc>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::TriggerDesc>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UTriggerDesc@Ogre@@@std@@QAEPAUTriggerDesc@Ogre@@I@Z ENDP ; std::allocator<Ogre::TriggerDesc>::allocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@USequenceDesc@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::SequenceDesc>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@USequenceDesc@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::SequenceDesc>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator!=
PUBLIC	?_Make_iter@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78042 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@7

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUSequenceDesc@Ogre@@PAU12@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78042[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78042[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEXPAUSequenceDesc@Ogre@@0@Z ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78042[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@7:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T92721 = -80						; size = 28
$T92720 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T92721[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T92721[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92720[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T92720[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T92721[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T92721[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Xlen
PUBLIC	??$?0USequenceDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@USequenceDesc@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SequenceDesc>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T92733 = -24						; size = 4
$T92732 = -20						; size = 4
$T92731 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0USequenceDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@USequenceDesc@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SequenceDesc>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T92733[ebp], eax
	mov	ecx, DWORD PTR $T92733[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T92732[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T92732[ebp], 0
	je	SHORT $LN3@Container_@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T92732[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@2
$LN3@Container_@2:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@2:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T92731[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T92731[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T92733[ebp]
	push	eax
	mov	ecx, DWORD PTR $T92732[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAE@V?$allocator@USequenceDesc@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SequenceDesc> >
PUBLIC	??$_Allocate@USequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::SequenceDesc>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEPAUSequenceDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEPAUSequenceDesc@Ogre@@I@Z PROC ; std::allocator<Ogre::SequenceDesc>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@USequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::SequenceDesc>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@USequenceDesc@Ogre@@@std@@QAEPAUSequenceDesc@Ogre@@I@Z ENDP ; std::allocator<Ogre::SequenceDesc>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVBoneTrack@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::BoneTrack *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVBoneTrack@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::BoneTrack *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78086 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@8

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78086[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78086[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEXPAPAVBoneTrack@Ogre@@0@Z ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78086[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@8:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T92757 = -80						; size = 28
$T92756 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T92757[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T92757[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92756[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T92756[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T92757[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T92757[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Xlen
PUBLIC	??$?0PAVBoneTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVBoneTrack@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BoneTrack *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T92769 = -24						; size = 4
$T92768 = -20						; size = 4
$T92767 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVBoneTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVBoneTrack@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BoneTrack *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T92769[ebp], eax
	mov	ecx, DWORD PTR $T92769[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T92768[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T92768[ebp], 0
	je	SHORT $LN3@Container_@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T92768[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@3
$LN3@Container_@3:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@3:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T92767[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T92767[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T92769[ebp]
	push	eax
	mov	ecx, DWORD PTR $T92768[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVBoneTrack@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BoneTrack *> >
PUBLIC	??$_Allocate@PAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::BoneTrack *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEPAPAVBoneTrack@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEPAPAVBoneTrack@Ogre@@I@Z PROC ; std::allocator<Ogre::BoneTrack *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::BoneTrack *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVBoneTrack@Ogre@@@std@@QAEPAPAVBoneTrack@Ogre@@I@Z ENDP ; std::allocator<Ogre::BoneTrack *>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::MaterialParamTrack *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::MaterialParamTrack *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78130 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@9

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78130[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78130[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEXPAPAVMaterialParamTrack@Ogre@@0@Z ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78130[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@9:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T92793 = -80						; size = 28
$T92792 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T92793[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T92793[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92792[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T92792[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T92793[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@4:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T92793[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Xlen
PUBLIC	??$?0PAVMaterialParamTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::MaterialParamTrack *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T92805 = -24						; size = 4
$T92804 = -20						; size = 4
$T92803 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVMaterialParamTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::MaterialParamTrack *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T92805[ebp], eax
	mov	ecx, DWORD PTR $T92805[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T92804[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T92804[ebp], 0
	je	SHORT $LN3@Container_@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T92804[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@4
$LN3@Container_@4:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@4:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T92803[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T92803[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T92805[ebp]
	push	eax
	mov	ecx, DWORD PTR $T92804[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	??$_Allocate@PAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::MaterialParamTrack *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEPAPAVMaterialParamTrack@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEPAPAVMaterialParamTrack@Ogre@@I@Z PROC ; std::allocator<Ogre::MaterialParamTrack *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::MaterialParamTrack *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QAEPAPAVMaterialParamTrack@Ogre@@I@Z ENDP ; std::allocator<Ogre::MaterialParamTrack *>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@PAPAVAnimPlayTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::AnimPlayTrack *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::AnimPlayTrack *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78170 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@10

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78170[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78170[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78170[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@10:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::erase
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
PUBLIC	??$fill@PAPAVAnimPlayTrack@Ogre@@PAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack *>
PUBLIC	??$_Umove@PAPAVAnimPlayTrack@Ogre@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Umove<Ogre::AnimPlayTrack * *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$78205 = -44					; size = 4
__Oldend$78206 = -40					; size = 4
__Tmp$78195 = -36					; size = 4
__Ncopied$78182 = -32					; size = 4
__Newvec$78180 = -28					; size = 4
__Whereoff$78181 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Xlen
	jmp	$LN16@Insert_n
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAEPAPAVAnimPlayTrack@Ogre@@I@Z ; std::allocator<Ogre::AnimPlayTrack *>::allocate
	mov	DWORD PTR __Newvec$78180[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$78181[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$78182[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$78181[ebp]
	mov	ecx, DWORD PTR __Newvec$78180[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$78182[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$78182[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$78180[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVAnimPlayTrack@Ogre@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Umove<Ogre::AnimPlayTrack * *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$78182[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$78182[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$78181[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$78180[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVAnimPlayTrack@Ogre@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Umove<Ogre::AnimPlayTrack * *>
	jmp	SHORT $LN19@Insert_n
__catch$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$78182[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$78181[ebp]
	mov	ecx, DWORD PTR __Newvec$78180[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$78180[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Destroy
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$78182[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$78181[ebp]
	mov	edx, DWORD PTR __Newvec$78180[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$78181[ebp]
	mov	ecx, DWORD PTR __Newvec$78180[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Destroy
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$78180[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAEXPAPAVAnimPlayTrack@Ogre@@I@Z ; std::allocator<Ogre::AnimPlayTrack *>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z$1
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAEXPAPAVAnimPlayTrack@Ogre@@I@Z ; std::allocator<Ogre::AnimPlayTrack *>::deallocate
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$78180[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$78180[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$78180[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$78195[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVAnimPlayTrack@Ogre@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Umove<Ogre::AnimPlayTrack * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$78195[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ufill
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$78195[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAPAVAnimPlayTrack@Ogre@@PAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack *>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$78205[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$78206[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$78206[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$78206[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVAnimPlayTrack@Ogre@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Umove<Ogre::AnimPlayTrack * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$78206[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$78206[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$78205[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAPAVAnimPlayTrack@Ogre@@PAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack *>
	add	esp, 12					; 0000000cH
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@IABQAVAnimPlayTrack@Ogre@@@Z ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T92850 = -80						; size = 28
$T92849 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T92850[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T92850[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92849[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T92849[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T92850[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@5:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T92850[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Xlen
PUBLIC	??$?0PAVAnimPlayTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::AnimPlayTrack *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T92862 = -24						; size = 4
$T92861 = -20						; size = 4
$T92860 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVAnimPlayTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::AnimPlayTrack *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T92862[ebp], eax
	mov	ecx, DWORD PTR $T92862[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T92861[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T92861[ebp], 0
	je	SHORT $LN3@Container_@5
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T92861[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@5
$LN3@Container_@5:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@5:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T92860[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T92860[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T92862[ebp]
	push	eax
	mov	ecx, DWORD PTR $T92861[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAE@V?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::AnimPlayTrack *> >
PUBLIC	??$_Allocate@PAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::AnimPlayTrack *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAEPAPAVAnimPlayTrack@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAEPAPAVAnimPlayTrack@Ogre@@I@Z PROC ; std::allocator<Ogre::AnimPlayTrack *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::AnimPlayTrack *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QAEPAPAVAnimPlayTrack@Ogre@@I@Z ENDP ; std::allocator<Ogre::AnimPlayTrack *>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::end
_TEXT	ENDS
EXTRN	__imp_?max_size@?$allocator@D@std@@QBEIXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?max_size@?$allocator@D@std@@QBEIXZ

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=
PUBLIC	?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ; std::vector<char,std::allocator<char> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78257 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z PROC ; std::vector<char,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ; std::vector<char,std::allocator<char> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ; std::vector<char,std::allocator<char> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@11

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z ; stdext::unchecked_copy<char *,char *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78257[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78257[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78257[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@11:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z ENDP ; std::vector<char,std::allocator<char> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T92886 = -80						; size = 28
$T92885 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ PROC	; std::vector<char,std::allocator<char> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T92886[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T92886[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92885[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T92885[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T92886[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@6:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T92886[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ ENDP	; std::vector<char,std::allocator<char> >::_Xlen
PUBLIC	??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T92898 = -24						; size = 4
$T92897 = -20						; size = 4
$T92896 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T92898[ebp], eax
	mov	ecx, DWORD PTR $T92898[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T92897[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T92897[ebp], 0
	je	SHORT $LN3@Container_@6
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T92897[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@6
$LN3@Container_@6:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@6:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T92896[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T92896[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$1:
	mov	eax, DWORD PTR $T92898[ebp]
	push	eax
	mov	ecx, DWORD PTR $T92897[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >
PUBLIC	??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::SurfaceData *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::SurfaceData *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78293 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@12

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78293[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78293[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78293[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@12:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T92920 = -80						; size = 28
$T92919 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T92920[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T92920[ebp]
	push	eax
	lea	ecx, DWORD PTR $T92919[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T92919[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T92920[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@7:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T92920[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Xlen
PUBLIC	??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SurfaceData *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T92932 = -24						; size = 4
$T92931 = -20						; size = 4
$T92930 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SurfaceData *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T92932[ebp], eax
	mov	ecx, DWORD PTR $T92932[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T92931[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T92931[ebp], 0
	je	SHORT $LN3@Container_@7
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T92931[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@7
$LN3@Container_@7:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@7:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T92930[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T92930[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T92932[ebp]
	push	eax
	mov	ecx, DWORD PTR $T92931[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
PUBLIC	??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::SurfaceData *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z PROC ; std::allocator<Ogre::SurfaceData *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::SurfaceData *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z ENDP ; std::allocator<Ogre::SurfaceData *>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil, COMDAT

; 156  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 21					; 00000015H

; 158  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left, COMDAT

; 166  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 168  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent, COMDAT

; 171  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 173  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right, COMDAT

; 176  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 178  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T92955 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 575  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	lea	ecx, DWORD PTR $T92955[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::iterator::iterator
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 577  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::size, COMDAT
; _this$ = ecx

; 600  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 602  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::size
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::destroy
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lrotate
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator++
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::_Mynode
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -108						; size = 4
tv165 = -104						; size = 4
_this$ = -100						; size = 4
$T92961 = -96						; size = 28
$T92960 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN40@erase@13

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T92961[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T92961[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T92960[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T92960[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T92961[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN40@erase@13:

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Erasednode$[ebp], eax

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator++

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN39@erase@13

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@13
$LN39@erase@13:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN37@erase@13

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@13
$LN37@erase@13:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], eax
$LN38@erase@13:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	$LN35@erase@13

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 797  : 			if (!_Isnil(_Fixnode))

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN34@erase@13

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], ecx
$LN34@erase@13:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN33@erase@13

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN32@erase@13
$LN33@erase@13:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN31@erase@13

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], edx

; 804  : 			else

	jmp	SHORT $LN32@erase@13
$LN31@erase@13:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN32@erase@13:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN29@erase@13

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@erase@13
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], edx
	jmp	SHORT $LN44@erase@13
$LN43@erase@13:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Min@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Min
	add	esp, 4
	mov	DWORD PTR tv165[ebp], eax
$LN44@erase@13:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lmost
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@erase@13:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@13

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN45@erase@13
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN46@erase@13
$LN45@erase@13:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR tv177[ebp], eax
$LN46@erase@13:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rmost
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR [eax], ecx
$LN28@erase@13:

; 816  : 			}
; 817  : 		else

	jmp	$LN27@erase@13
$LN35@erase@13:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN26@erase@13

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 824  : 			else

	jmp	$LN25@erase@13
$LN26@erase@13:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN24@erase@13

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], edx
$LN24@erase@13:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN25@erase@13:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN23@erase@13

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN22@erase@13
$LN23@erase@13:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN21@erase@13

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN22@erase@13
$LN21@erase@13:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN22@erase@13:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	push	eax
	call	??$swap@D@std@@YAXAAD0@Z		; std::swap<char>
	add	esp, 8
$LN27@erase@13:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	$LN19@erase@13

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN18@erase@13
$LN17@erase@13:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@13:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	edx, DWORD PTR __Fixnode$[ebp]
	cmp	edx, DWORD PTR [eax]
	je	$LN16@erase@13
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	$LN16@erase@13

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN15@erase@13

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN14@erase@13

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@13:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN13@erase@13

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@13
$LN13@erase@13:

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@13
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@13

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	$LN12@erase@13
$LN11@erase@13:

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 1
	jne	SHORT $LN9@erase@13

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN9@erase@13:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN16@erase@13
$LN12@erase@13:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@13
$LN15@erase@13:

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN7@erase@13

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN7@erase@13:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@erase@13

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], edx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@13
$LN6@erase@13:

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@13
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@13

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 902  : 						}
; 903  : 					else

	jmp	$LN8@erase@13
$LN4@erase@13:

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN2@erase@13

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 909  : 							_Lrotate(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@13:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@13
$LN8@erase@13:

; 918  : 						}
; 919  : 					}

	jmp	$LN17@erase@13
$LN16@erase@13:

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1
$LN19@erase@13:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::destroy

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	1
	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::deallocate

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jbe	SHORT $LN1@erase@13

; 928  : 			--_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx
$LN1@erase@13:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@13:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T92961[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::erase
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1out_of_range@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1out_of_range@std@@UAE@XZ$0
__ehfuncinfo$??1out_of_range@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1out_of_range@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1out_of_range@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 134  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1out_of_range@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1out_of_range@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1out_of_range@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odtp
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ		; std::out_of_range::~out_of_range
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@27
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@27:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Buynode
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVResource@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Myval
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
__Pnode$78436 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	$LN3@Copy@6

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVResource@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Myval
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Buynode
	mov	DWORD PTR __Pnode$78436[ebp], eax

; 1082 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@Copy@6

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$78436[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@6:

; 1084 : 
; 1085 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$78436[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Copy
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$78436[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	DWORD PTR [eax], esi

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR __Pnode$78436[ebp]
	push	ecx
	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR __Pnode$78436[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN6@Copy@6
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1091 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Copy@6
	ret	0
$LN6@Copy@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@6:

; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@6:

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Copy
; Function compile flags: /Odtp
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1280 : 		{	// return leftmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4

; 1282 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Max, COMDAT

; 1305 : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Max:

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Max

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1309 : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Max
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Min, COMDAT

; 1312 : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Min:

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Min

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1316 : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Min
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1319 : 		{	// return rightmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4

; 1321 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1324 : 		{	// return root of nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4

; 1326 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::construct
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T93033 = -36						; size = 4
$T93032 = -32						; size = 4
$T93031 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T93031[ebp], 0
	lea	eax, DWORD PTR $T93031[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::construct

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T93032[ebp], 0
	lea	eax, DWORD PTR $T93032[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::construct

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T93033[ebp], 0
	lea	eax, DWORD PTR $T93033[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::construct
	jmp	SHORT $LN6@Buynode
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 1
	jle	SHORT $LN2@Buynode

; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::destroy
$LN2@Buynode:

; 1396 : 		if (0 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 0
	jle	SHORT $LN1@Buynode

; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::destroy
$LN1@Buynode:

; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::deallocate

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ$1
	ret	0
$LN6@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ$1:

; 1401 : 		_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *><std::pair<unsigned int const ,Ogre::Resource *> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T93049 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T93049[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >::allocator<std::pair<unsigned int const ,Ogre::Resource *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *><std::pair<unsigned int const ,Ogre::Resource *> >

; 79   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_ptr@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >::allocator<std::pair<unsigned int const ,Ogre::Resource *> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >::allocator<std::pair<unsigned int const ,Ogre::Resource *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	??$_Allocate@I@std@@YAPAIIPAI@Z			; std::_Allocate<unsigned int>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@I@std@@QAEPAII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@I@std@@QAEPAII@Z PROC		; std::allocator<unsigned int>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@I@std@@QAEPAII@Z ENDP		; std::allocator<unsigned int>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@I@std@@QBEIXZ		; std::allocator<unsigned int>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@I@std@@QBEIXZ	; std::allocator<unsigned int>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=
PUBLIC	?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78508 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@14

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::unchecked_copy<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78508[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78508[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78508[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@14:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T93076 = -80						; size = 28
$T93075 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T93076[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T93076[ebp]
	push	eax
	lea	ecx, DWORD PTR $T93075[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T93075[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T93076[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@8:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T93076[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
PUBLIC	??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned int>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T93088 = -24						; size = 4
$T93087 = -20						; size = 4
$T93086 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::_Container_base_aux_alloc_real<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned int>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T93088[ebp], eax
	mov	ecx, DWORD PTR $T93088[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T93087[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T93087[ebp], 0
	je	SHORT $LN3@Container_@8
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T93087[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@8
$LN3@Container_@8:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@8:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T93086[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T93086[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z$1:
	mov	eax, DWORD PTR $T93088[ebp]
	push	eax
	mov	ecx, DWORD PTR $T93087[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::_Container_base_aux_alloc_real<std::allocator<unsigned int> >
PUBLIC	??0?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVSubMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVSubMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVSubMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::SubMeshInstance *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::SubMeshInstance *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78544 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@15

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@@stdext@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78544[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78544[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVSubMeshInstance@Ogre@@0@Z ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78544[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@15:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T93110 = -80						; size = 28
$T93109 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T93110[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T93110[ebp]
	push	eax
	lea	ecx, DWORD PTR $T93109[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T93109[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T93110[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@9:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T93110[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Xlen
PUBLIC	??$?0PAVSubMeshInstance@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SubMeshInstance *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T93122 = -24						; size = 4
$T93121 = -20						; size = 4
$T93120 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVSubMeshInstance@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SubMeshInstance *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T93122[ebp], eax
	mov	ecx, DWORD PTR $T93122[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T93121[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T93121[ebp], 0
	je	SHORT $LN3@Container_@9
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T93121[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@9
$LN3@Container_@9:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@9:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T93120[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T93120[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T93122[ebp]
	push	eax
	mov	ecx, DWORD PTR $T93121[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SubMeshInstance *> >
PUBLIC	??$_Allocate@PAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::SubMeshInstance *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAEPAPAVSubMeshInstance@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAEPAPAVSubMeshInstance@Ogre@@I@Z PROC ; std::allocator<Ogre::SubMeshInstance *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::SubMeshInstance *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QAEPAPAVSubMeshInstance@Ogre@@I@Z ENDP ; std::allocator<Ogre::SubMeshInstance *>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVMeshInstance@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::MeshInstance *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVMeshInstance@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::MeshInstance *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78588 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@16

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVMeshInstance@Ogre@@PAPAV12@@stdext@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MeshInstance * *,Ogre::MeshInstance * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78588[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78588[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEXPAPAVMeshInstance@Ogre@@0@Z ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78588[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@16:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T93146 = -80						; size = 28
$T93145 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T93146[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T93146[ebp]
	push	eax
	lea	ecx, DWORD PTR $T93145[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T93145[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T93146[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@10:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T93146[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Xlen
PUBLIC	??$?0PAVMeshInstance@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMeshInstance@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::MeshInstance *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T93158 = -24						; size = 4
$T93157 = -20						; size = 4
$T93156 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVMeshInstance@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMeshInstance@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::MeshInstance *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T93158[ebp], eax
	mov	ecx, DWORD PTR $T93158[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T93157[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T93157[ebp], 0
	je	SHORT $LN3@Container_@10
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T93157[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@10
$LN3@Container_@10:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@10:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T93156[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T93156[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T93158[ebp]
	push	eax
	mov	ecx, DWORD PTR $T93157[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAE@V?$allocator@PAVMeshInstance@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::MeshInstance *> >
PUBLIC	??$_Allocate@PAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::MeshInstance *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVMeshInstance@Ogre@@@std@@QAEPAPAVMeshInstance@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVMeshInstance@Ogre@@@std@@QAEPAPAVMeshInstance@Ogre@@I@Z PROC ; std::allocator<Ogre::MeshInstance *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::MeshInstance *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVMeshInstance@Ogre@@@std@@QAEPAPAVMeshInstance@Ogre@@I@Z ENDP ; std::allocator<Ogre::MeshInstance *>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@PAPAVModelAnchorNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@PAPAVModelAnchorNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@PAPAVModelAnchorNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::ModelAnchorNode *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::ModelAnchorNode *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78632 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@17

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@@stdext@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78632[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78632[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEXPAPAVModelAnchorNode@Ogre@@0@Z ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78632[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@17:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T93182 = -80						; size = 28
$T93181 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T93182[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T93182[ebp]
	push	eax
	lea	ecx, DWORD PTR $T93181[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T93181[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T93182[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@11:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T93182[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Xlen
PUBLIC	??$?0PAVModelAnchorNode@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ModelAnchorNode *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T93194 = -24						; size = 4
$T93193 = -20						; size = 4
$T93192 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVModelAnchorNode@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ModelAnchorNode *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T93194[ebp], eax
	mov	ecx, DWORD PTR $T93194[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T93193[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T93193[ebp], 0
	je	SHORT $LN3@Container_@11
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T93193[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@11
$LN3@Container_@11:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@11:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T93192[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T93192[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T93194[ebp]
	push	eax
	mov	ecx, DWORD PTR $T93193[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ModelAnchorNode *> >
PUBLIC	??$_Allocate@PAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::ModelAnchorNode *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAEPAPAVModelAnchorNode@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAEPAPAVModelAnchorNode@Ogre@@I@Z PROC ; std::allocator<Ogre::ModelAnchorNode *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::ModelAnchorNode *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QAEPAPAVModelAnchorNode@Ogre@@I@Z ENDP ; std::allocator<Ogre::ModelAnchorNode *>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil, COMDAT

; 156  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 21					; 00000015H

; 158  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left, COMDAT

; 166  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 168  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent, COMDAT

; 171  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 173  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right, COMDAT

; 176  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 178  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T93217 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 575  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	lea	ecx, DWORD PTR $T93217[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 577  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::size, COMDAT
; _this$ = ecx

; 600  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 602  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::size
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::destroy
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -108						; size = 4
tv165 = -104						; size = 4
_this$ = -100						; size = 4
$T93223 = -96						; size = 28
$T93222 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN40@erase@18

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T93223[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T93223[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T93222[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T93222[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T93223[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN40@erase@18:

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Erasednode$[ebp], eax

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN39@erase@18

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@18
$LN39@erase@18:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN37@erase@18

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@18
$LN37@erase@18:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], eax
$LN38@erase@18:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	$LN35@erase@18

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 797  : 			if (!_Isnil(_Fixnode))

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN34@erase@18

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], ecx
$LN34@erase@18:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN33@erase@18

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN32@erase@18
$LN33@erase@18:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN31@erase@18

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], edx

; 804  : 			else

	jmp	SHORT $LN32@erase@18
$LN31@erase@18:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN32@erase@18:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN29@erase@18

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@erase@18
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], edx
	jmp	SHORT $LN44@erase@18
$LN43@erase@18:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min
	add	esp, 4
	mov	DWORD PTR tv165[ebp], eax
$LN44@erase@18:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@erase@18:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@18

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN45@erase@18
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN46@erase@18
$LN45@erase@18:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR tv177[ebp], eax
$LN46@erase@18:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR [eax], ecx
$LN28@erase@18:

; 816  : 			}
; 817  : 		else

	jmp	$LN27@erase@18
$LN35@erase@18:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN26@erase@18

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 824  : 			else

	jmp	$LN25@erase@18
$LN26@erase@18:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN24@erase@18

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], edx
$LN24@erase@18:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN25@erase@18:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN23@erase@18

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN22@erase@18
$LN23@erase@18:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN21@erase@18

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN22@erase@18
$LN21@erase@18:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN22@erase@18:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	push	eax
	call	??$swap@D@std@@YAXAAD0@Z		; std::swap<char>
	add	esp, 8
$LN27@erase@18:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	$LN19@erase@18

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN18@erase@18
$LN17@erase@18:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@18:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	edx, DWORD PTR __Fixnode$[ebp]
	cmp	edx, DWORD PTR [eax]
	je	$LN16@erase@18
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	$LN16@erase@18

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN15@erase@18

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN14@erase@18

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@18:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN13@erase@18

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@18
$LN13@erase@18:

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@18
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@18

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	$LN12@erase@18
$LN11@erase@18:

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 1
	jne	SHORT $LN9@erase@18

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN9@erase@18:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN16@erase@18
$LN12@erase@18:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@18
$LN15@erase@18:

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN7@erase@18

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN7@erase@18:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@erase@18

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], edx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@18
$LN6@erase@18:

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@18
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@18

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 902  : 						}
; 903  : 					else

	jmp	$LN8@erase@18
$LN4@erase@18:

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN2@erase@18

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 909  : 							_Lrotate(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@18:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@18
$LN8@erase@18:

; 918  : 						}
; 919  : 					}

	jmp	$LN17@erase@18
$LN16@erase@18:

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1
$LN19@erase@18:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::destroy

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	1
	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jbe	SHORT $LN1@erase@18

; 928  : 			--_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx
$LN1@erase@18:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@18:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T93223[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::erase
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Myval
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
__Pnode$78769 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	$LN3@Copy@7

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Myval
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
	mov	DWORD PTR __Pnode$78769[ebp], eax

; 1082 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@Copy@7

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$78769[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@7:

; 1084 : 
; 1085 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$78769[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$78769[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	DWORD PTR [eax], esi

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR __Pnode$78769[ebp]
	push	ecx
	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR __Pnode$78769[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN6@Copy@7
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1091 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Copy@7
	ret	0
$LN6@Copy@7:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@7:

; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@7:

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Copy
; Function compile flags: /Odtp
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1280 : 		{	// return leftmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4

; 1282 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max, COMDAT

; 1305 : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Max@2:

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Max@2

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Max@2
$LN1@Max@2:

; 1308 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1309 : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Max
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min, COMDAT

; 1312 : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Min@2:

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Min@2

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Min@2
$LN1@Min@2:

; 1315 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1316 : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1319 : 		{	// return rightmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4

; 1321 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1324 : 		{	// return root of nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4

; 1326 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::construct
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T93266 = -36						; size = 4
$T93265 = -32						; size = 4
$T93264 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T93264[ebp], 0
	lea	eax, DWORD PTR $T93264[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::construct

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T93265[ebp], 0
	lea	eax, DWORD PTR $T93265[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::construct

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T93266[ebp], 0
	lea	eax, DWORD PTR $T93266[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::construct
	jmp	SHORT $LN6@Buynode@2
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 1
	jle	SHORT $LN2@Buynode@2

; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy
$LN2@Buynode@2:

; 1396 : 		if (0 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 0
	jle	SHORT $LN1@Buynode@2

; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy
$LN1@Buynode@2:

; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ$1
	ret	0
$LN6@Buynode@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ$1:

; 1401 : 		_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode@2:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBIH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *><std::pair<unsigned int const ,int> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T93282 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T93282[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??$?0U?$pair@$$CBIH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *><std::pair<unsigned int const ,int> >

; 79   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_ptr@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::destroy
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil, COMDAT

; 156  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 21					; 00000015H

; 158  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left, COMDAT

; 166  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 168  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent, COMDAT

; 171  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 173  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right, COMDAT

; 176  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 178  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T93306 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 575  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	lea	ecx, DWORD PTR $T93306[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::iterator::iterator
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 577  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::size, COMDAT
; _this$ = ecx

; 600  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 602  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::size
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::destroy
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lrotate
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator++
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::_Mynode
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -108						; size = 4
tv165 = -104						; size = 4
_this$ = -100						; size = 4
$T93312 = -96						; size = 28
$T93311 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN40@erase@19

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T93312[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T93312[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T93311[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T93311[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T93312[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN40@erase@19:

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Erasednode$[ebp], eax

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator++

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN39@erase@19

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@19
$LN39@erase@19:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN37@erase@19

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@19
$LN37@erase@19:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], eax
$LN38@erase@19:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	$LN35@erase@19

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 797  : 			if (!_Isnil(_Fixnode))

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN34@erase@19

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], ecx
$LN34@erase@19:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN33@erase@19

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN32@erase@19
$LN33@erase@19:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN31@erase@19

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], edx

; 804  : 			else

	jmp	SHORT $LN32@erase@19
$LN31@erase@19:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN32@erase@19:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN29@erase@19

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@erase@19
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], edx
	jmp	SHORT $LN44@erase@19
$LN43@erase@19:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Min@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Min
	add	esp, 4
	mov	DWORD PTR tv165[ebp], eax
$LN44@erase@19:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lmost
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@erase@19:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@19

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN45@erase@19
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN46@erase@19
$LN45@erase@19:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR tv177[ebp], eax
$LN46@erase@19:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rmost
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR [eax], ecx
$LN28@erase@19:

; 816  : 			}
; 817  : 		else

	jmp	$LN27@erase@19
$LN35@erase@19:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN26@erase@19

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 824  : 			else

	jmp	$LN25@erase@19
$LN26@erase@19:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN24@erase@19

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], edx
$LN24@erase@19:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN25@erase@19:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN23@erase@19

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN22@erase@19
$LN23@erase@19:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN21@erase@19

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN22@erase@19
$LN21@erase@19:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN22@erase@19:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	push	eax
	call	??$swap@D@std@@YAXAAD0@Z		; std::swap<char>
	add	esp, 8
$LN27@erase@19:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	$LN19@erase@19

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN18@erase@19
$LN17@erase@19:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@19:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	edx, DWORD PTR __Fixnode$[ebp]
	cmp	edx, DWORD PTR [eax]
	je	$LN16@erase@19
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	$LN16@erase@19

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN15@erase@19

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN14@erase@19

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@19:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN13@erase@19

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@19
$LN13@erase@19:

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@19
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@19

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	$LN12@erase@19
$LN11@erase@19:

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 1
	jne	SHORT $LN9@erase@19

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN9@erase@19:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN16@erase@19
$LN12@erase@19:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@19
$LN15@erase@19:

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN7@erase@19

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN7@erase@19:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@erase@19

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], edx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@19
$LN6@erase@19:

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@19
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@19

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 902  : 						}
; 903  : 					else

	jmp	$LN8@erase@19
$LN4@erase@19:

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN2@erase@19

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 909  : 							_Lrotate(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@19:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@19
$LN8@erase@19:

; 918  : 						}
; 919  : 					}

	jmp	$LN17@erase@19
$LN16@erase@19:

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1
$LN19@erase@19:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::destroy

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	1
	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::deallocate

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jbe	SHORT $LN1@erase@19

; 928  : 			--_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx
$LN1@erase@19:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@19:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T93312[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::erase
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Buynode
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHI@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Myval
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
__Pnode$78926 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	$LN3@Copy@8

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHI@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Myval
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Buynode
	mov	DWORD PTR __Pnode$78926[ebp], eax

; 1082 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@Copy@8

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$78926[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@8:

; 1084 : 
; 1085 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$78926[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Copy
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$78926[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	DWORD PTR [eax], esi

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR __Pnode$78926[ebp]
	push	ecx
	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR __Pnode$78926[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN6@Copy@8
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1091 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Copy@8
	ret	0
$LN6@Copy@8:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@8:

; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@8:

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Copy
; Function compile flags: /Odtp
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1280 : 		{	// return leftmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4

; 1282 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Max, COMDAT

; 1305 : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Max@3:

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Max@3

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Max@3
$LN1@Max@3:

; 1308 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1309 : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Max
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Min, COMDAT

; 1312 : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Min@3:

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Min@3

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Min@3
$LN1@Min@3:

; 1315 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1316 : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Min
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1319 : 		{	// return rightmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4

; 1321 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1324 : 		{	// return root of nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4

; 1326 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::construct
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T93355 = -36						; size = 4
$T93354 = -32						; size = 4
$T93353 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T93353[ebp], 0
	lea	eax, DWORD PTR $T93353[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::construct

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T93354[ebp], 0
	lea	eax, DWORD PTR $T93354[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::construct

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T93355[ebp], 0
	lea	eax, DWORD PTR $T93355[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::construct
	jmp	SHORT $LN6@Buynode@3
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 1
	jle	SHORT $LN2@Buynode@3

; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::destroy
$LN2@Buynode@3:

; 1396 : 		if (0 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 0
	jle	SHORT $LN1@Buynode@3

; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::destroy
$LN1@Buynode@3:

; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::deallocate

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ$1
	ret	0
$LN6@Buynode@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ$1:

; 1401 : 		_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode@3:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBHI@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *><std::pair<int const ,unsigned int> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T93371 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree_ptr<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T93371[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBHI@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,unsigned int> >::allocator<std::pair<int const ,unsigned int> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??$?0U?$pair@$$CBHI@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *><std::pair<int const ,unsigned int> >

; 79   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_ptr@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree_ptr<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHI@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHI@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,unsigned int> >::allocator<std::pair<int const ,unsigned int> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@U?$pair@$$CBHI@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,unsigned int> >::allocator<std::pair<int const ,unsigned int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::destroy
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil, COMDAT

; 156  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 21					; 00000015H

; 158  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left, COMDAT

; 166  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 168  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent, COMDAT

; 171  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 173  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right, COMDAT

; 176  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 178  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T93395 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 575  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	lea	ecx, DWORD PTR $T93395[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::iterator::iterator
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 577  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::size, COMDAT
; _this$ = ecx

; 600  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 602  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::size
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::destroy
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lrotate
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator++
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::_Mynode
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -108						; size = 4
tv165 = -104						; size = 4
_this$ = -100						; size = 4
$T93401 = -96						; size = 28
$T93400 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN40@erase@20

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T93401[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T93401[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T93400[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T93400[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T93401[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN40@erase@20:

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Erasednode$[ebp], eax

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator++

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN39@erase@20

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@20
$LN39@erase@20:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN37@erase@20

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@20
$LN37@erase@20:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], eax
$LN38@erase@20:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	$LN35@erase@20

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 797  : 			if (!_Isnil(_Fixnode))

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN34@erase@20

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], ecx
$LN34@erase@20:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN33@erase@20

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN32@erase@20
$LN33@erase@20:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN31@erase@20

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], edx

; 804  : 			else

	jmp	SHORT $LN32@erase@20
$LN31@erase@20:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN32@erase@20:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN29@erase@20

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@erase@20
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], edx
	jmp	SHORT $LN44@erase@20
$LN43@erase@20:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Min@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Min
	add	esp, 4
	mov	DWORD PTR tv165[ebp], eax
$LN44@erase@20:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lmost
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@erase@20:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@20

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN45@erase@20
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN46@erase@20
$LN45@erase@20:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR tv177[ebp], eax
$LN46@erase@20:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rmost
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR [eax], ecx
$LN28@erase@20:

; 816  : 			}
; 817  : 		else

	jmp	$LN27@erase@20
$LN35@erase@20:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN26@erase@20

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 824  : 			else

	jmp	$LN25@erase@20
$LN26@erase@20:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN24@erase@20

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], edx
$LN24@erase@20:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN25@erase@20:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN23@erase@20

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN22@erase@20
$LN23@erase@20:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN21@erase@20

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN22@erase@20
$LN21@erase@20:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN22@erase@20:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	push	eax
	call	??$swap@D@std@@YAXAAD0@Z		; std::swap<char>
	add	esp, 8
$LN27@erase@20:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	$LN19@erase@20

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN18@erase@20
$LN17@erase@20:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@20:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	edx, DWORD PTR __Fixnode$[ebp]
	cmp	edx, DWORD PTR [eax]
	je	$LN16@erase@20
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	$LN16@erase@20

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN15@erase@20

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN14@erase@20

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@20:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN13@erase@20

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@20
$LN13@erase@20:

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@20
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@20

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	$LN12@erase@20
$LN11@erase@20:

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 1
	jne	SHORT $LN9@erase@20

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN9@erase@20:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN16@erase@20
$LN12@erase@20:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@20
$LN15@erase@20:

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN7@erase@20

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN7@erase@20:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@erase@20

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], edx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@20
$LN6@erase@20:

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@20
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@20

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 902  : 						}
; 903  : 					else

	jmp	$LN8@erase@20
$LN4@erase@20:

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN2@erase@20

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 909  : 							_Lrotate(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@20:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@20
$LN8@erase@20:

; 918  : 						}
; 919  : 					}

	jmp	$LN17@erase@20
$LN16@erase@20:

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1
$LN19@erase@20:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::destroy

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	1
	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::deallocate

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jbe	SHORT $LN1@erase@20

; 928  : 			--_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx
$LN1@erase@20:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@20:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T93401[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::erase
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Buynode
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAU?$pair@QAVTextureDataLoader@Ogre@@H@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Myval
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
__Pnode$79083 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	$LN3@Copy@9

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAU?$pair@QAVTextureDataLoader@Ogre@@H@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Myval
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Buynode
	mov	DWORD PTR __Pnode$79083[ebp], eax

; 1082 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@Copy@9

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$79083[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@9:

; 1084 : 
; 1085 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$79083[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Copy
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$79083[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	DWORD PTR [eax], esi

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR __Pnode$79083[ebp]
	push	ecx
	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR __Pnode$79083[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN6@Copy@9
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1091 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Copy@9
	ret	0
$LN6@Copy@9:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@9:

; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@9:

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Copy
; Function compile flags: /Odtp
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1280 : 		{	// return leftmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4

; 1282 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Max, COMDAT

; 1305 : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Max@4:

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Max@4

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Max@4
$LN1@Max@4:

; 1308 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1309 : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Max
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Min, COMDAT

; 1312 : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Min@4:

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Min@4

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Min@4
$LN1@Min@4:

; 1315 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1316 : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Min
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1319 : 		{	// return rightmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4

; 1321 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1324 : 		{	// return root of nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4

; 1326 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::construct
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T93444 = -36						; size = 4
$T93443 = -32						; size = 4
$T93442 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T93442[ebp], 0
	lea	eax, DWORD PTR $T93442[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::construct

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T93443[ebp], 0
	lea	eax, DWORD PTR $T93443[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::construct

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T93444[ebp], 0
	lea	eax, DWORD PTR $T93444[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::construct
	jmp	SHORT $LN6@Buynode@4
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 1
	jle	SHORT $LN2@Buynode@4

; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::destroy
$LN2@Buynode@4:

; 1396 : 		if (0 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 0
	jle	SHORT $LN1@Buynode@4

; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::destroy
$LN1@Buynode@4:

; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::deallocate

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ$1
	ret	0
$LN6@Buynode@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ$1:

; 1401 : 		_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode@4:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *><std::pair<Ogre::TextureDataLoader * const,int> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T93460 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree_ptr<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T93460[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >::allocator<std::pair<Ogre::TextureDataLoader * const,int> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *><std::pair<Ogre::TextureDataLoader * const,int> >

; 79   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_ptr@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree_ptr<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >::allocator<std::pair<Ogre::TextureDataLoader * const,int> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >::allocator<std::pair<Ogre::TextureDataLoader * const,int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::destroy
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil, COMDAT

; 156  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 21					; 00000015H

; 158  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left, COMDAT

; 166  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 168  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent, COMDAT

; 171  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 173  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right, COMDAT

; 176  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 178  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T93484 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 575  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	lea	ecx, DWORD PTR $T93484[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::iterator::iterator
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 577  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::size, COMDAT
; _this$ = ecx

; 600  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 602  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::size
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::destroy
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lrotate
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator++
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::_Mynode
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -108						; size = 4
tv165 = -104						; size = 4
_this$ = -100						; size = 4
$T93490 = -96						; size = 28
$T93489 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN40@erase@21

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T93490[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T93490[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T93489[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T93489[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T93490[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN40@erase@21:

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Erasednode$[ebp], eax

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator++

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN39@erase@21

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@21
$LN39@erase@21:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN37@erase@21

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@21
$LN37@erase@21:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], eax
$LN38@erase@21:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	$LN35@erase@21

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 797  : 			if (!_Isnil(_Fixnode))

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN34@erase@21

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], ecx
$LN34@erase@21:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN33@erase@21

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN32@erase@21
$LN33@erase@21:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN31@erase@21

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], edx

; 804  : 			else

	jmp	SHORT $LN32@erase@21
$LN31@erase@21:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN32@erase@21:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN29@erase@21

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@erase@21
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], edx
	jmp	SHORT $LN44@erase@21
$LN43@erase@21:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Min@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Min
	add	esp, 4
	mov	DWORD PTR tv165[ebp], eax
$LN44@erase@21:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lmost
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@erase@21:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@21

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN45@erase@21
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN46@erase@21
$LN45@erase@21:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR tv177[ebp], eax
$LN46@erase@21:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rmost
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR [eax], ecx
$LN28@erase@21:

; 816  : 			}
; 817  : 		else

	jmp	$LN27@erase@21
$LN35@erase@21:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN26@erase@21

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 824  : 			else

	jmp	$LN25@erase@21
$LN26@erase@21:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN24@erase@21

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], edx
$LN24@erase@21:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN25@erase@21:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN23@erase@21

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN22@erase@21
$LN23@erase@21:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN21@erase@21

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN22@erase@21
$LN21@erase@21:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN22@erase@21:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	push	eax
	call	??$swap@D@std@@YAXAAD0@Z		; std::swap<char>
	add	esp, 8
$LN27@erase@21:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	$LN19@erase@21

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN18@erase@21
$LN17@erase@21:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@21:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	edx, DWORD PTR __Fixnode$[ebp]
	cmp	edx, DWORD PTR [eax]
	je	$LN16@erase@21
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	$LN16@erase@21

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN15@erase@21

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN14@erase@21

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@21:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN13@erase@21

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@21
$LN13@erase@21:

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@21
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@21

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	$LN12@erase@21
$LN11@erase@21:

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 1
	jne	SHORT $LN9@erase@21

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN9@erase@21:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN16@erase@21
$LN12@erase@21:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@21
$LN15@erase@21:

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN7@erase@21

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN7@erase@21:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@erase@21

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], edx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@21
$LN6@erase@21:

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@21
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@21

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 902  : 						}
; 903  : 					else

	jmp	$LN8@erase@21
$LN4@erase@21:

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN2@erase@21

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 909  : 							_Lrotate(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@21:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@21
$LN8@erase@21:

; 918  : 						}
; 919  : 					}

	jmp	$LN17@erase@21
$LN16@erase@21:

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1
$LN19@erase@21:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::destroy

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	1
	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::deallocate

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jbe	SHORT $LN1@erase@21

; 928  : 			--_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx
$LN1@erase@21:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@21:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T93490[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::erase
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Buynode
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Myval
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
__Pnode$79240 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	$LN3@Copy@10

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Myval
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Buynode
	mov	DWORD PTR __Pnode$79240[ebp], eax

; 1082 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@Copy@10

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$79240[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@10:

; 1084 : 
; 1085 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$79240[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Copy
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$79240[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	DWORD PTR [eax], esi

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR __Pnode$79240[ebp]
	push	ecx
	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR __Pnode$79240[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN6@Copy@10
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1091 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Copy@10
	ret	0
$LN6@Copy@10:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@10:

; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@10:

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Copy
; Function compile flags: /Odtp
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1280 : 		{	// return leftmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4

; 1282 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Max, COMDAT

; 1305 : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Max@5:

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Max@5

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Max@5
$LN1@Max@5:

; 1308 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1309 : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Max
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Min, COMDAT

; 1312 : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Min@5:

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Min@5

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Min@5
$LN1@Min@5:

; 1315 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1316 : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Min
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1319 : 		{	// return rightmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4

; 1321 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1324 : 		{	// return root of nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4

; 1326 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::construct
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T93533 = -36						; size = 4
$T93532 = -32						; size = 4
$T93531 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T93531[ebp], 0
	lea	eax, DWORD PTR $T93531[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::construct

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T93532[ebp], 0
	lea	eax, DWORD PTR $T93532[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::construct

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T93533[ebp], 0
	lea	eax, DWORD PTR $T93533[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::construct
	jmp	SHORT $LN6@Buynode@5
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 1
	jle	SHORT $LN2@Buynode@5

; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::destroy
$LN2@Buynode@5:

; 1396 : 		if (0 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 0
	jle	SHORT $LN1@Buynode@5

; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::destroy
$LN1@Buynode@5:

; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::deallocate

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ$1
	ret	0
$LN6@Buynode@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ$1:

; 1401 : 		_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode@5:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *><std::pair<int const ,Ogre::TextureDataLoader *> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T93549 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T93549[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *><std::pair<int const ,Ogre::TextureDataLoader *> >

; 79   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
PUBLIC	??0?$_Ranit@UTriggerDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Ranit<Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &>::_Ranit<Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UTriggerDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con
$LN1@Vector_con:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = ecx

; 452  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 454  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
_TEXT	ENDS
PUBLIC	??0?$_Ranit@USequenceDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Ranit<Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &>::_Ranit<Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@USequenceDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@2
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@2
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@2
$LN1@Vector_con@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@2:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVBoneTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &>::_Ranit<Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVBoneTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@3
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@3
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@3
$LN1@Vector_con@3:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@3:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVMaterialParamTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &>::_Ranit<Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVMaterialParamTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@4
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@4
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@4
$LN1@Vector_con@4:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@4:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVAnimPlayTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::AnimPlayTrack *,int,Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * const &>::_Ranit<Ogre::AnimPlayTrack *,int,Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@PAPAVAnimPlayTrack@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@PAPAVAnimPlayTrack@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVAnimPlayTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@5
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@5
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@5
$LN1@Vector_con@5:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@5:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@PAPAVAnimPlayTrack@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
_TEXT	ENDS
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
;	COMDAT ??G?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@30
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@30
$LN1@operator@30:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@30:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator-
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = ecx

; 462  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Other$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al

; 464  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 467  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 		return _Myaux != 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	al, cl

; 469  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@PAPAVAnimPlayTrack@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@PAPAVAnimPlayTrack@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@PAPAVAnimPlayTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@PAPAVAnimPlayTrack@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator+
_TEXT	ENDS
PUBLIC	??0?$_Ranit@DHPBDABD@std@@QAE@XZ		; std::_Ranit<char,int,char const *,char const &>::_Ranit<char,int,char const *,char const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@DHPBDABD@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@6
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@6
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@6
$LN1@Vector_con@6:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@6:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@7
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@7
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@7
$LN1@Vector_con@7:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@7:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 451  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::const_iterator

; 452  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::iterator::iterator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 279  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 281  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator++

; 282  : 			return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  : 			}

	mov	esp, ebp
	pop	ebp
	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 299  : 			{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@31
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@31
$LN1@operator@31:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@31:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 312  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 315  : 			{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 317  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@IHPBIABI@std@@QAE@XZ		; std::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@IHPBIABI@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@8
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@8
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@8
$LN1@Vector_con@8:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@8:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVSubMeshInstance@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::SubMeshInstance *,int,Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * const &>::_Ranit<Ogre::SubMeshInstance *,int,Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVSubMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVSubMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVSubMeshInstance@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@9
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@9
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@9
$LN1@Vector_con@9:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@9:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVSubMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVMeshInstance@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::MeshInstance *,int,Ogre::MeshInstance * const *,Ogre::MeshInstance * const &>::_Ranit<Ogre::MeshInstance *,int,Ogre::MeshInstance * const *,Ogre::MeshInstance * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVMeshInstance@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@10
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@10
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@10
$LN1@Vector_con@10:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@10:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVModelAnchorNode@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::ModelAnchorNode *,int,Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * const &>::_Ranit<Ogre::ModelAnchorNode *,int,Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@PAPAVModelAnchorNode@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@PAPAVModelAnchorNode@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVModelAnchorNode@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@11
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@11
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@11
$LN1@Vector_con@11:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@11:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@PAPAVModelAnchorNode@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 451  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator

; 452  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::iterator::iterator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 279  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 281  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++

; 282  : 			return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  : 			}

	mov	esp, ebp
	pop	ebp
	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 299  : 			{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@32
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@32
$LN1@operator@32:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@32:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 312  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 315  : 			{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 317  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 451  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::const_iterator

; 452  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::iterator::iterator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 279  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 281  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator++

; 282  : 			return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  : 			}

	mov	esp, ebp
	pop	ebp
	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 299  : 			{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@33
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@33
$LN1@operator@33:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@33:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 312  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 315  : 			{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 317  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 451  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::const_iterator

; 452  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::iterator::iterator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 279  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 281  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator++

; 282  : 			return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  : 			}

	mov	esp, ebp
	pop	ebp
	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 299  : 			{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@34
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@34
$LN1@operator@34:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@34:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 312  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 315  : 			{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 317  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 451  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::const_iterator

; 452  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::iterator::iterator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 279  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 281  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator++

; 282  : 			return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  : 			}

	mov	esp, ebp
	pop	ebp
	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 299  : 			{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@35
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@35
$LN1@operator@35:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@35:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 312  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 315  : 			{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 317  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTriggerDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UTriggerDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UTriggerDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &>::_Ranit<Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTriggerDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UTriggerDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &>::_Ranit<Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@USequenceDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@USequenceDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@USequenceDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &>::_Ranit<Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@USequenceDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@USequenceDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &>::_Ranit<Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVBoneTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVBoneTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVBoneTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &>::_Ranit<Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVBoneTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVBoneTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &>::_Ranit<Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParamTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVMaterialParamTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVMaterialParamTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &>::_Ranit<Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParamTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVMaterialParamTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &>::_Ranit<Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVAnimPlayTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::AnimPlayTrack *,int,Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::AnimPlayTrack *,int,Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVAnimPlayTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVAnimPlayTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::AnimPlayTrack *,int,Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * const &>::_Ranit<Ogre::AnimPlayTrack *,int,Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVAnimPlayTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVAnimPlayTrack@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::AnimPlayTrack *,int,Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * const &>::_Ranit<Ogre::AnimPlayTrack *,int,Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@DHPBDABD@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@DHPBDABD@std@@QAE@XZ PROC			; std::_Ranit<char,int,char const *,char const &>::_Ranit<char,int,char const *,char const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@DHPBDABD@std@@QAE@XZ ENDP			; std::_Ranit<char,int,char const *,char const &>::_Ranit<char,int,char const *,char const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@IHPBIABI@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@IHPBIABI@std@@QAE@XZ PROC			; std::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@IHPBIABI@std@@QAE@XZ ENDP			; std::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSubMeshInstance@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SubMeshInstance *,int,Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SubMeshInstance *,int,Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVSubMeshInstance@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVSubMeshInstance@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::SubMeshInstance *,int,Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * const &>::_Ranit<Ogre::SubMeshInstance *,int,Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSubMeshInstance@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVSubMeshInstance@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::SubMeshInstance *,int,Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * const &>::_Ranit<Ogre::SubMeshInstance *,int,Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMeshInstance@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MeshInstance *,int,Ogre::MeshInstance * const *,Ogre::MeshInstance * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MeshInstance *,int,Ogre::MeshInstance * const *,Ogre::MeshInstance * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVMeshInstance@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVMeshInstance@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::MeshInstance *,int,Ogre::MeshInstance * const *,Ogre::MeshInstance * const &>::_Ranit<Ogre::MeshInstance *,int,Ogre::MeshInstance * const *,Ogre::MeshInstance * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMeshInstance@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVMeshInstance@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::MeshInstance *,int,Ogre::MeshInstance * const *,Ogre::MeshInstance * const &>::_Ranit<Ogre::MeshInstance *,int,Ogre::MeshInstance * const *,Ogre::MeshInstance * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVModelAnchorNode@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ModelAnchorNode *,int,Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ModelAnchorNode *,int,Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVModelAnchorNode@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVModelAnchorNode@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::ModelAnchorNode *,int,Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * const &>::_Ranit<Ogre::ModelAnchorNode *,int,Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVModelAnchorNode@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVModelAnchorNode@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::ModelAnchorNode *,int,Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * const &>::_Ranit<Ogre::ModelAnchorNode *,int,Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * const &>
_TEXT	ENDS
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTriggerDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTriggerDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTriggerDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TriggerDesc,int,Ogre::TriggerDesc const *,Ogre::TriggerDesc const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = ecx

; 448  : 	_Iterator_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@USequenceDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@USequenceDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@USequenceDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SequenceDesc,int,Ogre::SequenceDesc const *,Ogre::SequenceDesc const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVBoneTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVBoneTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVBoneTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BoneTrack *,int,Ogre::BoneTrack * const *,Ogre::BoneTrack * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParamTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParamTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParamTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParamTrack *,int,Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVAnimPlayTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVAnimPlayTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::AnimPlayTrack *,int,Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::AnimPlayTrack *,int,Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVAnimPlayTrack@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::AnimPlayTrack *,int,Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::AnimPlayTrack *,int,Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSubMeshInstance@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSubMeshInstance@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SubMeshInstance *,int,Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SubMeshInstance *,int,Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSubMeshInstance@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SubMeshInstance *,int,Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SubMeshInstance *,int,Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMeshInstance@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMeshInstance@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MeshInstance *,int,Ogre::MeshInstance * const *,Ogre::MeshInstance * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MeshInstance *,int,Ogre::MeshInstance * const *,Ogre::MeshInstance * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMeshInstance@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MeshInstance *,int,Ogre::MeshInstance * const *,Ogre::MeshInstance * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MeshInstance *,int,Ogre::MeshInstance * const *,Ogre::MeshInstance * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVModelAnchorNode@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVModelAnchorNode@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ModelAnchorNode *,int,Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ModelAnchorNode *,int,Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVModelAnchorNode@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ModelAnchorNode *,int,Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ModelAnchorNode *,int,Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UTriggerDesc@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UTriggerDesc@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::TriggerDesc>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UTriggerDesc@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::TriggerDesc>::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@USequenceDesc@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@USequenceDesc@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::SequenceDesc>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 268435455	; 0fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@2
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@2
$LN3@max_size@2:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@USequenceDesc@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::SequenceDesc>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVBoneTrack@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVBoneTrack@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::BoneTrack *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@3
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@3
$LN3@max_size@3:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@3:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVBoneTrack@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::BoneTrack *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::MaterialParamTrack *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@4
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@4
$LN3@max_size@4:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@4:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVMaterialParamTrack@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::MaterialParamTrack *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAE@PAPAVAnimPlayTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::AnimPlayTrack *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@5
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@5
$LN3@max_size@5:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@5:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVAnimPlayTrack@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::AnimPlayTrack *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z PROC ; std::vector<char,std::allocator<char> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ENDP ; std::vector<char,std::allocator<char> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::SurfaceData *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@6
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@6
$LN3@max_size@6:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@6:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::SurfaceData *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color, COMDAT

; 151  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 20					; 00000014H

; 153  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Color
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVResource@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVResource@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Myval, COMDAT

; 181  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 183  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVResource@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Myval
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$79688 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$79688[ebp], eax
	jmp	SHORT $LN3@Erase
$LN2@Erase:
	mov	ecx, DWORD PTR __Pnode$79688[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN3@Erase:
	mov	edx, DWORD PTR __Pnode$79688[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Erase

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$79688[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$79688[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$79688[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::destroy

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	1
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::deallocate

; 1173 : 			}

	jmp	SHORT $LN2@Erase
$LN4@Erase:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Lrotate
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1297 : 		else

	jmp	SHORT $LN3@Lrotate
$LN2@Lrotate:

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Lrotate:

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1302 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Rrotate
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1341 : 		else

	jmp	SHORT $LN3@Rrotate
$LN2@Rrotate:

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Rrotate:

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1346 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node::_Node
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z$3
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z
_TEXT	SEGMENT
tv86 = -36						; size = 4
_this$ = -32						; size = 4
$T93745 = -28						; size = 4
$T93744 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	24					; 00000018H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T93745[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T93745[ebp], 0
	je	SHORT $LN4@Buynode@6
	movzx	ecx, BYTE PTR __Carg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Rarg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Larg$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T93745[ebp]
	call	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node::_Node
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN5@Buynode@6
$LN4@Buynode@6:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@6:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T93744[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Buynode@6
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::deallocate

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z$1
	ret	0
$LN6@Buynode@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@6:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T93745[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node><std::pair<unsigned int const ,Ogre::Resource *> >
PUBLIC	??0?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0>::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T93764 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T93764[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >::allocator<std::pair<unsigned int const ,Ogre::Resource *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0>::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node><std::pair<unsigned int const ,Ogre::Resource *> >

; 53   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::construct
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@I@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@I@std@@QBEIXZ PROC		; std::allocator<unsigned int>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@7
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@7
$LN3@max_size@7:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@7:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@I@std@@QBEIXZ ENDP		; std::allocator<unsigned int>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVSubMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::SubMeshInstance *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@8
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@8
$LN3@max_size@8:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@8:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVSubMeshInstance@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::SubMeshInstance *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVMeshInstance@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVMeshInstance@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::MeshInstance *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@9
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@9
$LN3@max_size@9:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@9:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVMeshInstance@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::MeshInstance *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@PAPAVModelAnchorNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::ModelAnchorNode *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@10
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@10
$LN3@max_size@10:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@10:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVModelAnchorNode@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::ModelAnchorNode *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color, COMDAT

; 151  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 20					; 00000014H

; 153  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Color
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Myval, COMDAT

; 181  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 183  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Myval
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$79789 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$79789[ebp], eax
	jmp	SHORT $LN3@Erase@2
$LN2@Erase@2:
	mov	ecx, DWORD PTR __Pnode$79789[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN3@Erase@2:
	mov	edx, DWORD PTR __Pnode$79789[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Erase@2

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$79789[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$79789[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$79789[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::destroy

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	1
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate

; 1173 : 			}

	jmp	SHORT $LN2@Erase@2
$LN4@Erase@2:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Lrotate@2

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Lrotate@2:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Lrotate@2

; 1294 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Lrotate@2
$LN4@Lrotate@2:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Lrotate@2

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1297 : 		else

	jmp	SHORT $LN3@Lrotate@2
$LN2@Lrotate@2:

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Lrotate@2:

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1302 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Rrotate@2

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Rrotate@2:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Rrotate@2

; 1338 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Rrotate@2
$LN4@Rrotate@2:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Rrotate@2

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1341 : 		else

	jmp	SHORT $LN3@Rrotate@2
$LN2@Rrotate@2:

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Rrotate@2:

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1346 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIH@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node::_Node
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z$3
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z
_TEXT	SEGMENT
tv86 = -36						; size = 4
_this$ = -32						; size = 4
$T93815 = -28						; size = 4
$T93814 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	24					; 00000018H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T93815[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T93815[ebp], 0
	je	SHORT $LN4@Buynode@7
	movzx	ecx, BYTE PTR __Carg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Rarg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Larg$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T93815[ebp]
	call	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIH@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node::_Node
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN5@Buynode@7
$LN4@Buynode@7:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@7:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T93814[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Buynode@7
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::deallocate

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z$1
	ret	0
$LN6@Buynode@7:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@7:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T93815[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIH@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBIH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node><std::pair<unsigned int const ,int> >
PUBLIC	??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T93834 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T93834[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??$?0U?$pair@$$CBIH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node><std::pair<unsigned int const ,int> >

; 53   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@XZ
__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::construct
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color, COMDAT

; 151  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 20					; 00000014H

; 153  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Color
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHI@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHI@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Myval, COMDAT

; 181  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 183  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHI@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Myval
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$79854 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$79854[ebp], eax
	jmp	SHORT $LN3@Erase@3
$LN2@Erase@3:
	mov	ecx, DWORD PTR __Pnode$79854[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN3@Erase@3:
	mov	edx, DWORD PTR __Pnode$79854[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Erase@3

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$79854[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$79854[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$79854[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::destroy

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	1
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::deallocate

; 1173 : 			}

	jmp	SHORT $LN2@Erase@3
$LN4@Erase@3:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Lrotate@3

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Lrotate@3:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Lrotate@3

; 1294 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Lrotate@3
$LN4@Lrotate@3:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Lrotate@3

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1297 : 		else

	jmp	SHORT $LN3@Lrotate@3
$LN2@Lrotate@3:

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Lrotate@3:

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1302 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Rrotate@3

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Rrotate@3:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Rrotate@3

; 1338 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Rrotate@3
$LN4@Rrotate@3:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Rrotate@3

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1341 : 		else

	jmp	SHORT $LN3@Rrotate@3
$LN2@Rrotate@3:

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Rrotate@3:

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1346 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHI@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node::_Node
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z$3
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z
_TEXT	SEGMENT
tv86 = -36						; size = 4
_this$ = -32						; size = 4
$T93861 = -28						; size = 4
$T93860 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	24					; 00000018H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T93861[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T93861[ebp], 0
	je	SHORT $LN4@Buynode@8
	movzx	ecx, BYTE PTR __Carg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Rarg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Larg$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T93861[ebp]
	call	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHI@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node::_Node
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN5@Buynode@8
$LN4@Buynode@8:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@8:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T93860[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Buynode@8
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::deallocate

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z$1
	ret	0
$LN6@Buynode@8:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@8:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T93861[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHI@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBHI@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node><std::pair<int const ,unsigned int> >
PUBLIC	??0?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0>::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T93880 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T93880[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBHI@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,unsigned int> >::allocator<std::pair<int const ,unsigned int> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0>::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??$?0U?$pair@$$CBHI@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node><std::pair<int const ,unsigned int> >

; 53   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@XZ
__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::construct
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color, COMDAT

; 151  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 20					; 00000014H

; 153  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Color
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAU?$pair@QAVTextureDataLoader@Ogre@@H@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAU?$pair@QAVTextureDataLoader@Ogre@@H@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Myval, COMDAT

; 181  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 183  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAU?$pair@QAVTextureDataLoader@Ogre@@H@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Myval
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$79919 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$79919[ebp], eax
	jmp	SHORT $LN3@Erase@4
$LN2@Erase@4:
	mov	ecx, DWORD PTR __Pnode$79919[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN3@Erase@4:
	mov	edx, DWORD PTR __Pnode$79919[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Erase@4

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$79919[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$79919[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$79919[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::destroy

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	1
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::deallocate

; 1173 : 			}

	jmp	SHORT $LN2@Erase@4
$LN4@Erase@4:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Lrotate@4

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Lrotate@4:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Lrotate@4

; 1294 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Lrotate@4
$LN4@Lrotate@4:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Lrotate@4

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1297 : 		else

	jmp	SHORT $LN3@Lrotate@4
$LN2@Lrotate@4:

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Lrotate@4:

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1302 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Rrotate@4

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Rrotate@4:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Rrotate@4

; 1338 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Rrotate@4
$LN4@Rrotate@4:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Rrotate@4

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1341 : 		else

	jmp	SHORT $LN3@Rrotate@4
$LN2@Rrotate@4:

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Rrotate@4:

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1346 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node::_Node
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z$3
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z
_TEXT	SEGMENT
tv86 = -36						; size = 4
_this$ = -32						; size = 4
$T93907 = -28						; size = 4
$T93906 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	24					; 00000018H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T93907[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T93907[ebp], 0
	je	SHORT $LN4@Buynode@9
	movzx	ecx, BYTE PTR __Carg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Rarg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Larg$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T93907[ebp]
	call	??0_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node::_Node
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN5@Buynode@9
$LN4@Buynode@9:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@9:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T93906[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Buynode@9
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::deallocate

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z$1
	ret	0
$LN6@Buynode@9:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@9:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T93907[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node><std::pair<Ogre::TextureDataLoader * const,int> >
PUBLIC	??0?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@U?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0>::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T93926 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T93926[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >::allocator<std::pair<Ogre::TextureDataLoader * const,int> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@U?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0>::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node><std::pair<Ogre::TextureDataLoader * const,int> >

; 53   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@XZ
__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::construct
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color, COMDAT

; 151  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 20					; 00000014H

; 153  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Color
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Myval, COMDAT

; 181  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 183  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Myval
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$79984 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$79984[ebp], eax
	jmp	SHORT $LN3@Erase@5
$LN2@Erase@5:
	mov	ecx, DWORD PTR __Pnode$79984[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN3@Erase@5:
	mov	edx, DWORD PTR __Pnode$79984[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Erase@5

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$79984[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$79984[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$79984[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::destroy

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	1
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::deallocate

; 1173 : 			}

	jmp	SHORT $LN2@Erase@5
$LN4@Erase@5:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Lrotate@5

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Lrotate@5:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Lrotate@5

; 1294 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Lrotate@5
$LN4@Lrotate@5:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Lrotate@5

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1297 : 		else

	jmp	SHORT $LN3@Lrotate@5
$LN2@Lrotate@5:

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Lrotate@5:

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1302 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Rrotate@5

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Rrotate@5:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Rrotate@5

; 1338 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Rrotate@5
$LN4@Rrotate@5:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Rrotate@5

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1341 : 		else

	jmp	SHORT $LN3@Rrotate@5
$LN2@Rrotate@5:

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Rrotate@5:

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1346 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node::_Node
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z$3
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z
_TEXT	SEGMENT
tv86 = -36						; size = 4
_this$ = -32						; size = 4
$T93953 = -28						; size = 4
$T93952 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	24					; 00000018H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T93953[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T93953[ebp], 0
	je	SHORT $LN4@Buynode@10
	movzx	ecx, BYTE PTR __Carg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Rarg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Larg$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T93953[ebp]
	call	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node::_Node
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN5@Buynode@10
$LN4@Buynode@10:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@10:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T93952[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Buynode@10
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::deallocate

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z$1
	ret	0
$LN6@Buynode@10:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@10:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T93953[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node><std::pair<int const ,Ogre::TextureDataLoader *> >
PUBLIC	??0?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0>::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T93972 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T93972[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0>::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node><std::pair<int const ,Ogre::TextureDataLoader *> >

; 53   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator!=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator+=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Bidit@U?$pair@$$CBIPAVResource@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<unsigned int const ,Ogre::Resource *>,int,std::pair<unsigned int const ,Ogre::Resource *> const *,std::pair<unsigned int const ,Ogre::Resource *> const &>::_Bidit<std::pair<unsigned int const ,Ogre::Resource *>,int,std::pair<unsigned int const ,Ogre::Resource *> const *,std::pair<unsigned int const ,Ogre::Resource *> const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 234  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@$$CBIPAVResource@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	cmp	DWORD PTR __Plist$[ebp], 0
	jne	SHORT $LN1@const_iter
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@const_iter:

; 236  : 			this->_Set_container(_Plist);

	mov	edx, DWORD PTR __Plist$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 237  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 			_Inc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 276  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 409  : 			{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 411  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Bidit@U?$pair@$$CBIH@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &>::_Bidit<std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 234  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@$$CBIH@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	cmp	DWORD PTR __Plist$[ebp], 0
	jne	SHORT $LN1@const_iter@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@const_iter@2:

; 236  : 			this->_Set_container(_Plist);

	mov	edx, DWORD PTR __Plist$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 237  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 			_Inc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 276  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 409  : 			{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 411  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0?$_Bidit@U?$pair@$$CBHI@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<int const ,unsigned int>,int,std::pair<int const ,unsigned int> const *,std::pair<int const ,unsigned int> const &>::_Bidit<std::pair<int const ,unsigned int>,int,std::pair<int const ,unsigned int> const *,std::pair<int const ,unsigned int> const &>
; Function compile flags: /Odtp
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 234  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@$$CBHI@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	cmp	DWORD PTR __Plist$[ebp], 0
	jne	SHORT $LN1@const_iter@3
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@const_iter@3:

; 236  : 			this->_Set_container(_Plist);

	mov	edx, DWORD PTR __Plist$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 237  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 			_Inc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 276  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 409  : 			{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 411  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0?$_Bidit@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<Ogre::TextureDataLoader * const,int>,int,std::pair<Ogre::TextureDataLoader * const,int> const *,std::pair<Ogre::TextureDataLoader * const,int> const &>::_Bidit<std::pair<Ogre::TextureDataLoader * const,int>,int,std::pair<Ogre::TextureDataLoader * const,int> const *,std::pair<Ogre::TextureDataLoader * const,int> const &>
; Function compile flags: /Odtp
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 234  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	cmp	DWORD PTR __Plist$[ebp], 0
	jne	SHORT $LN1@const_iter@4
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@const_iter@4:

; 236  : 			this->_Set_container(_Plist);

	mov	edx, DWORD PTR __Plist$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 237  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 			_Inc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 276  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 409  : 			{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 411  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0?$_Bidit@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<int const ,Ogre::TextureDataLoader *>,int,std::pair<int const ,Ogre::TextureDataLoader *> const *,std::pair<int const ,Ogre::TextureDataLoader *> const &>::_Bidit<std::pair<int const ,Ogre::TextureDataLoader *>,int,std::pair<int const ,Ogre::TextureDataLoader *> const *,std::pair<int const ,Ogre::TextureDataLoader *> const &>
; Function compile flags: /Odtp
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 234  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	cmp	DWORD PTR __Plist$[ebp], 0
	jne	SHORT $LN1@const_iter@5
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@const_iter@5:

; 236  : 			this->_Set_container(_Plist);

	mov	edx, DWORD PTR __Plist$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 237  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 			_Inc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 276  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 409  : 			{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 411  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QAE@PAUTriggerDesc@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Vector_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QAE@PAUSequenceDesc@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Vector_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QAE@PAPAVBoneTrack@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Vector_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QAE@PAPAVMaterialParamTrack@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Vector_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVSubMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVSubMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVSubMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVSubMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Vector_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QAE@PAPAVMeshInstance@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Vector_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@PAPAVModelAnchorNode@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@PAPAVModelAnchorNode@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@PAPAVModelAnchorNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QAE@PAPAVModelAnchorNode@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Vector_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVResource@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::Resource *>,int,std::pair<unsigned int const ,Ogre::Resource *> const *,std::pair<unsigned int const ,Ogre::Resource *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::Resource *>,int,std::pair<unsigned int const ,Ogre::Resource *> const *,std::pair<unsigned int const ,Ogre::Resource *> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Bidit@U?$pair@$$CBIPAVResource@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Bidit@U?$pair@$$CBIPAVResource@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<unsigned int const ,Ogre::Resource *>,int,std::pair<unsigned int const ,Ogre::Resource *> const *,std::pair<unsigned int const ,Ogre::Resource *> const &>::_Bidit<std::pair<unsigned int const ,Ogre::Resource *>,int,std::pair<unsigned int const ,Ogre::Resource *> const *,std::pair<unsigned int const ,Ogre::Resource *> const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVResource@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Bidit@U?$pair@$$CBIPAVResource@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<unsigned int const ,Ogre::Resource *>,int,std::pair<unsigned int const ,Ogre::Resource *> const *,std::pair<unsigned int const ,Ogre::Resource *> const &>::_Bidit<std::pair<unsigned int const ,Ogre::Resource *>,int,std::pair<unsigned int const ,Ogre::Resource *> const *,std::pair<unsigned int const ,Ogre::Resource *> const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIH@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Bidit@U?$pair@$$CBIH@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Bidit@U?$pair@$$CBIH@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &>::_Bidit<std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIH@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Bidit@U?$pair@$$CBIH@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &>::_Bidit<std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHI@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<int const ,unsigned int>,int,std::pair<int const ,unsigned int> const *,std::pair<int const ,unsigned int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<int const ,unsigned int>,int,std::pair<int const ,unsigned int> const *,std::pair<int const ,unsigned int> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Bidit@U?$pair@$$CBHI@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Bidit@U?$pair@$$CBHI@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<int const ,unsigned int>,int,std::pair<int const ,unsigned int> const *,std::pair<int const ,unsigned int> const &>::_Bidit<std::pair<int const ,unsigned int>,int,std::pair<int const ,unsigned int> const *,std::pair<int const ,unsigned int> const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHI@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Bidit@U?$pair@$$CBHI@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<int const ,unsigned int>,int,std::pair<int const ,unsigned int> const *,std::pair<int const ,unsigned int> const &>::_Bidit<std::pair<int const ,unsigned int>,int,std::pair<int const ,unsigned int> const *,std::pair<int const ,unsigned int> const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@QAVTextureDataLoader@Ogre@@H@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<Ogre::TextureDataLoader * const,int>,int,std::pair<Ogre::TextureDataLoader * const,int> const *,std::pair<Ogre::TextureDataLoader * const,int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<Ogre::TextureDataLoader * const,int>,int,std::pair<Ogre::TextureDataLoader * const,int> const *,std::pair<Ogre::TextureDataLoader * const,int> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Bidit@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Bidit@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<Ogre::TextureDataLoader * const,int>,int,std::pair<Ogre::TextureDataLoader * const,int> const *,std::pair<Ogre::TextureDataLoader * const,int> const &>::_Bidit<std::pair<Ogre::TextureDataLoader * const,int>,int,std::pair<Ogre::TextureDataLoader * const,int> const *,std::pair<Ogre::TextureDataLoader * const,int> const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@QAVTextureDataLoader@Ogre@@H@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Bidit@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<Ogre::TextureDataLoader * const,int>,int,std::pair<Ogre::TextureDataLoader * const,int> const *,std::pair<Ogre::TextureDataLoader * const,int> const &>::_Bidit<std::pair<Ogre::TextureDataLoader * const,int>,int,std::pair<Ogre::TextureDataLoader * const,int> const *,std::pair<Ogre::TextureDataLoader * const,int> const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<int const ,Ogre::TextureDataLoader *>,int,std::pair<int const ,Ogre::TextureDataLoader *> const *,std::pair<int const ,Ogre::TextureDataLoader *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<int const ,Ogre::TextureDataLoader *>,int,std::pair<int const ,Ogre::TextureDataLoader *> const *,std::pair<int const ,Ogre::TextureDataLoader *> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Bidit@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Bidit@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<int const ,Ogre::TextureDataLoader *>,int,std::pair<int const ,Ogre::TextureDataLoader *> const *,std::pair<int const ,Ogre::TextureDataLoader *> const &>::_Bidit<std::pair<int const ,Ogre::TextureDataLoader *>,int,std::pair<int const ,Ogre::TextureDataLoader *> const *,std::pair<int const ,Ogre::TextureDataLoader *> const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Bidit@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<int const ,Ogre::TextureDataLoader *>,int,std::pair<int const ,Ogre::TextureDataLoader *> const *,std::pair<int const ,Ogre::TextureDataLoader *> const &>::_Bidit<std::pair<int const ,Ogre::TextureDataLoader *>,int,std::pair<int const ,Ogre::TextureDataLoader *> const *,std::pair<int const ,Ogre::TextureDataLoader *> const &>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVResource@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVResource@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::Resource *>,int,std::pair<unsigned int const ,Ogre::Resource *> const *,std::pair<unsigned int const ,Ogre::Resource *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::Resource *>,int,std::pair<unsigned int const ,Ogre::Resource *> const *,std::pair<unsigned int const ,Ogre::Resource *> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVResource@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::Resource *>,int,std::pair<unsigned int const ,Ogre::Resource *> const *,std::pair<unsigned int const ,Ogre::Resource *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::Resource *>,int,std::pair<unsigned int const ,Ogre::Resource *> const *,std::pair<unsigned int const ,Ogre::Resource *> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIH@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIH@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIH@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,int>,int,std::pair<unsigned int const ,int> const *,std::pair<unsigned int const ,int> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHI@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHI@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<int const ,unsigned int>,int,std::pair<int const ,unsigned int> const *,std::pair<int const ,unsigned int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<int const ,unsigned int>,int,std::pair<int const ,unsigned int> const *,std::pair<int const ,unsigned int> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHI@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<int const ,unsigned int>,int,std::pair<int const ,unsigned int> const *,std::pair<int const ,unsigned int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<int const ,unsigned int>,int,std::pair<int const ,unsigned int> const *,std::pair<int const ,unsigned int> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@QAVTextureDataLoader@Ogre@@H@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@QAVTextureDataLoader@Ogre@@H@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<Ogre::TextureDataLoader * const,int>,int,std::pair<Ogre::TextureDataLoader * const,int> const *,std::pair<Ogre::TextureDataLoader * const,int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<Ogre::TextureDataLoader * const,int>,int,std::pair<Ogre::TextureDataLoader * const,int> const *,std::pair<Ogre::TextureDataLoader * const,int> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@QAVTextureDataLoader@Ogre@@H@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<Ogre::TextureDataLoader * const,int>,int,std::pair<Ogre::TextureDataLoader * const,int> const *,std::pair<Ogre::TextureDataLoader * const,int> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<Ogre::TextureDataLoader * const,int>,int,std::pair<Ogre::TextureDataLoader * const,int> const *,std::pair<Ogre::TextureDataLoader * const,int> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<int const ,Ogre::TextureDataLoader *>,int,std::pair<int const ,Ogre::TextureDataLoader *> const *,std::pair<int const ,Ogre::TextureDataLoader *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<int const ,Ogre::TextureDataLoader *>,int,std::pair<int const ,Ogre::TextureDataLoader *> const *,std::pair<int const ,Ogre::TextureDataLoader *> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<int const ,Ogre::TextureDataLoader *>,int,std::pair<int const ,Ogre::TextureDataLoader *> const *,std::pair<int const ,Ogre::TextureDataLoader *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<int const ,Ogre::TextureDataLoader *>,int,std::pair<int const ,Ogre::TextureDataLoader *> const *,std::pair<int const ,Ogre::TextureDataLoader *> const &,std::_Iterator_base_aux>
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??0?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T94082 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0>::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T94082[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >::allocator<std::pair<unsigned int const ,Ogre::Resource *> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 40   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >
__ehhandler$??0?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0>::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T94092 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T94092[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,int> >::allocator<std::pair<unsigned int const ,int> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 40   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >
__ehhandler$??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T94102 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0>::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T94102[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBHI@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,unsigned int> >::allocator<std::pair<int const ,unsigned int> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 40   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >
__ehhandler$??0?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0>::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@U?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@U?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@U?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@U?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@U?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T94112 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@U?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z PROC ; std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0>::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@U?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T94112[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >::allocator<std::pair<Ogre::TextureDataLoader * const,int> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 40   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@U?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >
__ehhandler$??0?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@U?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@U?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@QAE@U?$less@PAVTextureDataLoader@Ogre@@@1@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ENDP ; std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0>::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T94122 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z PROC ; std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0>::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T94122[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 40   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >
__ehhandler$??0?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ENDP ; std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0>::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@36
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@36
$LN1@operator@36:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@36:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@37
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@37
$LN1@operator@37:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@37:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@38
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@38
$LN1@operator@38:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@38:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@39
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@39
$LN1@operator@39:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@39:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::operator==
_TEXT	ENDS
PUBLIC	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@40
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@40:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@40
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@40
$LN1@operator@40:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@40:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator+=
_TEXT	ENDS
PUBLIC	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Iterator_base_aux::_Getmycont, COMDAT
; _this$ = ecx

; 457  : 		{	// Go through the aux object to get the container

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		return _Myaux ? _Myaux->_Getcont() : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN4@Getmycont
$LN3@Getmycont:
	mov	DWORD PTR tv67[ebp], 0
$LN4@Getmycont:
	mov	eax, DWORD PTR tv67[ebp]

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Aux_cont::_Getcont, COMDAT
; _this$ = ecx

; 368  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 		return _Mycontainer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@41
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@41
$LN1@operator@41:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@41:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@42
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@42
$LN1@operator@42:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@42:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@43
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@43
$LN1@operator@43:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@43:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$80268 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@Inc
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Inc:

; 389  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	$LN8@Inc
$LN6@Inc:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Min
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 398  : 			else

	jmp	SHORT $LN8@Inc
$LN2@Inc:

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$80268[ebp], edx
	mov	eax, DWORD PTR __Pnode$80268[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@Inc
	mov	edx, DWORD PTR __Pnode$80268[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$80268[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$80268[ebp]
	mov	DWORD PTR [edx+4], eax
$LN8@Inc:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@44
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@44
$LN1@operator@44:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@44:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@45
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@45
$LN1@operator@45:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@45:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@46
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@46
$LN1@operator@46:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@46:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@47
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@47
$LN1@operator@47:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@47:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$80301 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@Inc@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Inc@2:

; 389  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Inc@2

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	$LN8@Inc@2
$LN6@Inc@2:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Inc@2

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Min
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 398  : 			else

	jmp	SHORT $LN8@Inc@2
$LN2@Inc@2:

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$80301[ebp], edx
	mov	eax, DWORD PTR __Pnode$80301[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@Inc@2
	mov	edx, DWORD PTR __Pnode$80301[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@Inc@2

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$80301[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN2@Inc@2
$LN1@Inc@2:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$80301[ebp]
	mov	DWORD PTR [edx+4], eax
$LN8@Inc@2:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$80314 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@Inc@3
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Inc@3:

; 389  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Inc@3

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	$LN8@Inc@3
$LN6@Inc@3:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Inc@3

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Min
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 398  : 			else

	jmp	SHORT $LN8@Inc@3
$LN2@Inc@3:

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$80314[ebp], edx
	mov	eax, DWORD PTR __Pnode$80314[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@Inc@3
	mov	edx, DWORD PTR __Pnode$80314[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@Inc@3

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$80314[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN2@Inc@3
$LN1@Inc@3:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$80314[ebp]
	mov	DWORD PTR [edx+4], eax
$LN8@Inc@3:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$80327 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@Inc@4
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Inc@4:

; 389  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Inc@4

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	$LN8@Inc@4
$LN6@Inc@4:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Inc@4

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Min
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 398  : 			else

	jmp	SHORT $LN8@Inc@4
$LN2@Inc@4:

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$80327[ebp], edx
	mov	eax, DWORD PTR __Pnode$80327[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@Inc@4
	mov	edx, DWORD PTR __Pnode$80327[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@Inc@4

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$80327[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN2@Inc@4
$LN1@Inc@4:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$80327[ebp]
	mov	DWORD PTR [edx+4], eax
$LN8@Inc@4:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$80340 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@Inc@5
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Inc@5:

; 389  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Inc@5

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	$LN8@Inc@5
$LN6@Inc@5:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Inc@5

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Min
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 398  : 			else

	jmp	SHORT $LN8@Inc@5
$LN2@Inc@5:

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$80340[ebp], edx
	mov	eax, DWORD PTR __Pnode$80340[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@Inc@5
	mov	edx, DWORD PTR __Pnode$80340[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@Inc@5

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$80340[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN2@Inc@5
$LN1@Inc@5:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$80340[ebp]
	mov	DWORD PTR [edx+4], eax
$LN8@Inc@5:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+20], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], 0

; 39   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVResource@Ogre@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node::_Node
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIH@2@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIH@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+20], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], 0

; 39   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIH@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node::_Node
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHI@2@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHI@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+20], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], 0

; 39   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHI@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node::_Node
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+20], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], 0

; 39   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@QAVTextureDataLoader@Ogre@@H@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node::_Node
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+20], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], 0

; 39   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVTextureDataLoader@Ogre@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,Ogre::Resource *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T94184 = -24						; size = 4
$T94183 = -20						; size = 4
$T94182 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,Ogre::Resource *> >

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T94184[ebp], eax
	mov	ecx, DWORD PTR $T94184[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T94183[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T94183[ebp], 0
	je	SHORT $LN3@Container_@12
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T94183[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@12
$LN3@Container_@12:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@12:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T94182[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T94182[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z$1:
	mov	eax, DWORD PTR $T94184[ebp]
	push	eax
	mov	ecx, DWORD PTR $T94183[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::Resource *> > >
PUBLIC	??$?0U?$pair@$$CBIH@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,int> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T94199 = -24						; size = 4
$T94198 = -20						; size = 4
$T94197 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$pair@$$CBIH@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,int> >

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T94199[ebp], eax
	mov	ecx, DWORD PTR $T94199[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T94198[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T94198[ebp], 0
	je	SHORT $LN3@Container_@13
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T94198[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@13
$LN3@Container_@13:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@13:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T94197[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T94197[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z$1:
	mov	eax, DWORD PTR $T94199[ebp]
	push	eax
	mov	ecx, DWORD PTR $T94198[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,int> > >
PUBLIC	??$?0U?$pair@$$CBHI@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<int const ,unsigned int> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T94214 = -24						; size = 4
$T94213 = -20						; size = 4
$T94212 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$pair@$$CBHI@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<int const ,unsigned int> >

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T94214[ebp], eax
	mov	ecx, DWORD PTR $T94214[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T94213[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T94213[ebp], 0
	je	SHORT $LN3@Container_@14
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T94213[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@14
$LN3@Container_@14:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@14:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T94212[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T94212[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z$1:
	mov	eax, DWORD PTR $T94214[ebp]
	push	eax
	mov	ecx, DWORD PTR $T94213[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHI@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,unsigned int> > >
PUBLIC	??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<Ogre::TextureDataLoader * const,int> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T94229 = -24						; size = 4
$T94228 = -20						; size = 4
$T94227 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<Ogre::TextureDataLoader * const,int> >

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T94229[ebp], eax
	mov	ecx, DWORD PTR $T94229[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T94228[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T94228[ebp], 0
	je	SHORT $LN3@Container_@15
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T94228[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@15
$LN3@Container_@15:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@15:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T94227[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T94227[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z$1:
	mov	eax, DWORD PTR $T94229[ebp]
	push	eax
	mov	ecx, DWORD PTR $T94228[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::TextureDataLoader * const,int> > >
PUBLIC	??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<int const ,Ogre::TextureDataLoader *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T94244 = -24						; size = 4
$T94243 = -20						; size = 4
$T94242 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<int const ,Ogre::TextureDataLoader *> >

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T94244[ebp], eax
	mov	ecx, DWORD PTR $T94244[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T94243[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T94243[ebp], 0
	je	SHORT $LN3@Container_@16
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T94243[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@16
$LN3@Container_@16:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@16:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T94242[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T94242[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z$1:
	mov	eax, DWORD PTR $T94244[ebp]
	push	eax
	mov	ecx, DWORD PTR $T94243[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> > >
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
;	COMDAT ??$Abs@M@Ogre@@YAMABM@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
_x$ = 8							; size = 4
??$Abs@M@Ogre@@YAMABM@Z PROC				; Ogre::Abs<float>, COMDAT

; 125  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 126  : 		return (x<0.0f) ? (-x) : x;

	mov	eax, DWORD PTR _x$[ebp]
	fld	DWORD PTR [eax]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@Abs
	mov	ecx, DWORD PTR _x$[ebp]
	fld	DWORD PTR [ecx]
	fchs
	fstp	DWORD PTR tv68[ebp]
	jmp	SHORT $LN4@Abs
$LN3@Abs:
	mov	edx, DWORD PTR _x$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR tv68[ebp]
$LN4@Abs:
	fld	DWORD PTR tv68[ebp]

; 127  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$Abs@M@Ogre@@YAMABM@Z ENDP				; Ogre::Abs<float>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$Max@M@Ogre@@YAMABM0@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$Max@M@Ogre@@YAMABM0@Z PROC				; Ogre::Max<float>, COMDAT

; 120  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 121  : 		return ( (a) > (b) ? (a) : (b) );

	mov	eax, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@Max@6
	mov	edx, DWORD PTR _a$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR tv67[ebp]
	jmp	SHORT $LN4@Max@6
$LN3@Max@6:
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR tv67[ebp]
$LN4@Max@6:
	fld	DWORD PTR tv67[ebp]

; 122  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$Max@M@Ogre@@YAMABM0@Z ENDP				; Ogre::Max<float>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$Min@M@Ogre@@YAMABM0@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$Min@M@Ogre@@YAMABM0@Z PROC				; Ogre::Min<float>, COMDAT

; 115  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 116  : 		return ( (a) < (b) ? (a) : (b) );

	mov	eax, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@Min@6
	mov	edx, DWORD PTR _a$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR tv67[ebp]
	jmp	SHORT $LN4@Min@6
$LN3@Min@6:
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR tv67[ebp]
$LN4@Min@6:
	fld	DWORD PTR tv67[ebp]

; 117  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$Min@M@Ogre@@YAMABM0@Z ENDP				; Ogre::Min<float>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreprerequisites.h
_TEXT	ENDS
;	COMDAT ??$DeletePointerArray@VAnimPlayTrack@Ogre@@@Ogre@@YAXAAV?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@Z
_TEXT	SEGMENT
$T94269 = -8						; size = 4
_i$80608 = -4						; size = 4
_array$ = 8						; size = 4
??$DeletePointerArray@VAnimPlayTrack@Ogre@@@Ogre@@YAXAAV?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@Z PROC ; Ogre::DeletePointerArray<Ogre::AnimPlayTrack>, COMDAT

; 271  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 272  : 		for(size_t i=0; i<array.size(); i++)

	mov	DWORD PTR _i$80608[ebp], 0
	jmp	SHORT $LN3@DeletePoin
$LN2@DeletePoin:
	mov	eax, DWORD PTR _i$80608[ebp]
	add	eax, 1
	mov	DWORD PTR _i$80608[ebp], eax
$LN3@DeletePoin:
	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::size
	cmp	DWORD PTR _i$80608[ebp], eax
	jae	SHORT $LN1@DeletePoin

; 273  : 		{
; 274  : 			delete array[i];

	mov	ecx, DWORD PTR _i$80608[ebp]
	push	ecx
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEAAPAVAnimPlayTrack@Ogre@@I@Z ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T94269[ebp], edx
	mov	eax, DWORD PTR $T94269[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 275  : 		}

	jmp	SHORT $LN2@DeletePoin
$LN1@DeletePoin:

; 276  : 		array.clear();

	mov	ecx, DWORD PTR _array$[ebp]
	call	?clear@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::clear

; 277  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$DeletePointerArray@VAnimPlayTrack@Ogre@@@Ogre@@YAXAAV?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@Z ENDP ; Ogre::DeletePointerArray<Ogre::AnimPlayTrack>
_TEXT	ENDS
PUBLIC	??$_Sort@PAPAVAnimPlayTrack@Ogre@@HP6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0HP6A_NPAV12@1@Z@Z ; std::_Sort<Ogre::AnimPlayTrack * *,int,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
PUBLIC	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$sort@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z PROC ; std::sort<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 3276 : 	{	// order [_First, _Last), using _Pred

	push	ebp
	mov	ebp, esp

; 3277 : 	_DEBUG_RANGE(_First, _Last);
; 3278 : 	_DEBUG_POINTER(_Pred);
; 3279 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First, _Pred);

	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 2
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	call	??$_Sort@PAPAVAnimPlayTrack@Ogre@@HP6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0HP6A_NPAV12@1@Z@Z ; std::_Sort<Ogre::AnimPlayTrack * *,int,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 16					; 00000010H

; 3280 : 	}

	pop	ebp
	ret	0
??$sort@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ENDP ; std::sort<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@2@@stdext@@YAPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@1@0PAU23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@1@0PAU23@@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@2@@stdext@@YAPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@1@0PAU23@@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
PUBLIC	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
PUBLIC	??$_Iter_random@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTriggerDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
PUBLIC	??$_Ptr_cat@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTriggerDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUTriggerDesc@Ogre@@PAU12@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00@Z
_TEXT	SEGMENT
$T94278 = -3						; size = 1
$T94277 = -2						; size = 1
$T94276 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUTriggerDesc@Ogre@@PAU12@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00@Z PROC ; stdext::unchecked_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94276[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTriggerDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 8
	mov	BYTE PTR $T94277[ebp], al
	movzx	eax, BYTE PTR $T94276[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94277[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94278[ebp]
	push	ecx
	call	??$_Iter_random@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTriggerDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUTriggerDesc@Ogre@@PAU12@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00@Z ENDP ; stdext::unchecked_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUTriggerDesc@Ogre@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@PAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUTriggerDesc@Ogre@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@PAU23@00@Z PROC ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<Ogre::TriggerDesc *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUTriggerDesc@Ogre@@@?$vector@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@IAEPAUTriggerDesc@Ogre@@PAU23@00@Z ENDP ; std::vector<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Ucopy<Ogre::TriggerDesc *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@2@@stdext@@YAPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@1@0PAU23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@1@0PAU23@@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@2@@stdext@@YAPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@1@0PAU23@@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
PUBLIC	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
PUBLIC	??$_Iter_random@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSequenceDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
PUBLIC	??$_Ptr_cat@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSequenceDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUSequenceDesc@Ogre@@PAU12@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00@Z
_TEXT	SEGMENT
$T94287 = -3						; size = 1
$T94286 = -2						; size = 1
$T94285 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUSequenceDesc@Ogre@@PAU12@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00@Z PROC ; stdext::unchecked_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94285[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSequenceDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 8
	mov	BYTE PTR $T94286[ebp], al
	movzx	eax, BYTE PTR $T94285[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94286[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94287[ebp]
	push	ecx
	call	??$_Iter_random@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSequenceDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUSequenceDesc@Ogre@@PAU12@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00@Z ENDP ; stdext::unchecked_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUSequenceDesc@Ogre@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@PAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUSequenceDesc@Ogre@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@PAU23@00@Z PROC ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<Ogre::SequenceDesc *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUSequenceDesc@Ogre@@@?$vector@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@IAEPAUSequenceDesc@Ogre@@PAU23@00@Z ENDP ; std::vector<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Ucopy<Ogre::SequenceDesc *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@2@@stdext@@YAPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@2@@stdext@@YAPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
PUBLIC	??$_Iter_random@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@0@Z ; std::_Iter_random<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
PUBLIC	??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T94296 = -3						; size = 1
$T94295 = -2						; size = 1
$T94294 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94294[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 8
	mov	BYTE PTR $T94295[ebp], al
	movzx	eax, BYTE PTR $T94294[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94295[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94296[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@0@Z ; std::_Iter_random<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVBoneTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<Ogre::BoneTrack * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVBoneTrack@Ogre@@@?$vector@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@IAEPAPAVBoneTrack@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Ucopy<Ogre::BoneTrack * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@2@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@2@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVMaterialParamTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParamTrack * *>
PUBLIC	??$_Iter_random@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParamTrack@Ogre@@0@Z ; std::_Iter_random<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
PUBLIC	??$_Ptr_cat@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParamTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T94305 = -3						; size = 1
$T94304 = -2						; size = 1
$T94303 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94303[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParamTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
	add	esp, 8
	mov	BYTE PTR $T94304[ebp], al
	movzx	eax, BYTE PTR $T94303[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94304[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94305[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParamTrack@Ogre@@0@Z ; std::_Iter_random<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParamTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParamTrack * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVMaterialParamTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVMaterialParamTrack@Ogre@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVMaterialParamTrack@Ogre@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<Ogre::MaterialParamTrack * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVMaterialParamTrack@Ogre@@@?$vector@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@IAEPAPAVMaterialParamTrack@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Ucopy<Ogre::MaterialParamTrack * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@PAPAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@2@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@PAPAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@2@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ucopy<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::random_access_iterator_tag>
PUBLIC	??$_Iter_random@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVAnimPlayTrack@Ogre@@0@Z ; std::_Iter_random<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
PUBLIC	??$_Ptr_cat@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVAnimPlayTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T94314 = -3						; size = 1
$T94313 = -2						; size = 1
$T94312 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94312[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVAnimPlayTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
	mov	BYTE PTR $T94313[ebp], al
	movzx	eax, BYTE PTR $T94312[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94313[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94314[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVAnimPlayTrack@Ogre@@0@Z ; std::_Iter_random<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVAnimPlayTrack@Ogre@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVAnimPlayTrack@Ogre@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ucopy<Ogre::AnimPlayTrack * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVAnimPlayTrack@Ogre@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Ucopy<Ogre::AnimPlayTrack * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<char,std::allocator<char> >,char *,std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z PROC ; std::vector<char,std::allocator<char> >::_Ucopy<std::_Vector_const_iterator<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<char,std::allocator<char> >,char *,std::allocator<char> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z ENDP ; std::vector<char,std::allocator<char> >::_Ucopy<std::_Vector_const_iterator<char,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAD@std@@YAPADAAPAD@Z		; std::_Checked_base<char *>
PUBLIC	??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z ; std::_Iter_random<char *,char *>
PUBLIC	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z
_TEXT	SEGMENT
$T94323 = -3						; size = 1
$T94322 = -2						; size = 1
$T94321 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z PROC	; stdext::unchecked_copy<char *,char *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94321[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
	add	esp, 8
	mov	BYTE PTR $T94322[ebp], al
	movzx	eax, BYTE PTR $T94321[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94322[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94323[ebp]
	push	ecx
	call	??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z ; std::_Iter_random<char *,char *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z ENDP	; stdext::unchecked_copy<char *,char *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z PROC ; std::vector<char,std::allocator<char> >::_Ucopy<char *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ENDP ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
PUBLIC	??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z ; std::_Iter_random<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
PUBLIC	??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T94332 = -3						; size = 1
$T94331 = -2						; size = 1
$T94330 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94330[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 8
	mov	BYTE PTR $T94331[ebp], al
	movzx	eax, BYTE PTR $T94330[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94331[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94332[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z ; std::_Iter_random<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@1@0PAI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@1@0PAI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@1@0PAI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z		; std::_Checked_base<unsigned int *>
PUBLIC	??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z ; std::_Iter_random<unsigned int *,unsigned int *>
PUBLIC	??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ; std::_Ptr_cat<unsigned int *,unsigned int *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
$T94341 = -3						; size = 1
$T94340 = -2						; size = 1
$T94339 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z PROC	; stdext::unchecked_copy<unsigned int *,unsigned int *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94339[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ; std::_Ptr_cat<unsigned int *,unsigned int *>
	add	esp, 8
	mov	BYTE PTR $T94340[ebp], al
	movzx	eax, BYTE PTR $T94339[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94340[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94341[ebp]
	push	ecx
	call	??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z ; std::_Iter_random<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z	; std::_Checked_base<unsigned int *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z	; std::_Checked_base<unsigned int *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ENDP	; stdext::unchecked_copy<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@PAPAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@2@@stdext@@YAPAPAVSubMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSubMeshInstance@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEPAPAVSubMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEPAPAVSubMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@PAPAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@2@@stdext@@YAPAPAVSubMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSubMeshInstance@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEPAPAVSubMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVSubMeshInstance@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SubMeshInstance * *>
PUBLIC	??$_Iter_random@PAPAVSubMeshInstance@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSubMeshInstance@Ogre@@0@Z ; std::_Iter_random<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>
PUBLIC	??$_Ptr_cat@PAPAVSubMeshInstance@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSubMeshInstance@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@@stdext@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T94350 = -3						; size = 1
$T94349 = -2						; size = 1
$T94348 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@@stdext@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94348[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVSubMeshInstance@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSubMeshInstance@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>
	add	esp, 8
	mov	BYTE PTR $T94349[ebp], al
	movzx	eax, BYTE PTR $T94348[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94349[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94350[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVSubMeshInstance@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSubMeshInstance@Ogre@@0@Z ; std::_Iter_random<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SubMeshInstance * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SubMeshInstance * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVSubMeshInstance@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@@stdext@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@stdext@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVSubMeshInstance@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVSubMeshInstance@Ogre@@@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEPAPAVSubMeshInstance@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVSubMeshInstance@Ogre@@@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEPAPAVSubMeshInstance@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Ucopy<Ogre::SubMeshInstance * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@stdext@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVSubMeshInstance@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVSubMeshInstance@Ogre@@@?$vector@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@IAEPAPAVSubMeshInstance@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Ucopy<Ogre::SubMeshInstance * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@PAPAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@2@@stdext@@YAPAPAVMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMeshInstance@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEPAPAVMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEPAPAVMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Ucopy<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@PAPAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@2@@stdext@@YAPAPAVMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMeshInstance@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEPAPAVMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Ucopy<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVMeshInstance@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::MeshInstance * *,Ogre::MeshInstance * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MeshInstance * *>
PUBLIC	??$_Iter_random@PAPAVMeshInstance@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMeshInstance@Ogre@@0@Z ; std::_Iter_random<Ogre::MeshInstance * *,Ogre::MeshInstance * *>
PUBLIC	??$_Ptr_cat@PAPAVMeshInstance@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMeshInstance@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MeshInstance * *,Ogre::MeshInstance * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVMeshInstance@Ogre@@PAPAV12@@stdext@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T94359 = -3						; size = 1
$T94358 = -2						; size = 1
$T94357 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVMeshInstance@Ogre@@PAPAV12@@stdext@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::MeshInstance * *,Ogre::MeshInstance * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94357[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVMeshInstance@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMeshInstance@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MeshInstance * *,Ogre::MeshInstance * *>
	add	esp, 8
	mov	BYTE PTR $T94358[ebp], al
	movzx	eax, BYTE PTR $T94357[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94358[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94359[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVMeshInstance@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMeshInstance@Ogre@@0@Z ; std::_Iter_random<Ogre::MeshInstance * *,Ogre::MeshInstance * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MeshInstance * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MeshInstance * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVMeshInstance@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::MeshInstance * *,Ogre::MeshInstance * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVMeshInstance@Ogre@@PAPAV12@@stdext@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::MeshInstance * *,Ogre::MeshInstance * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@stdext@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVMeshInstance@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::MeshInstance * *,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVMeshInstance@Ogre@@@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEPAPAVMeshInstance@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVMeshInstance@Ogre@@@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEPAPAVMeshInstance@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Ucopy<Ogre::MeshInstance * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@stdext@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVMeshInstance@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::MeshInstance * *,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVMeshInstance@Ogre@@@?$vector@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@IAEPAPAVMeshInstance@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Ucopy<Ogre::MeshInstance * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@PAPAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@2@@stdext@@YAPAPAVModelAnchorNode@Ogre@@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVModelAnchorNode@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEPAPAVModelAnchorNode@Ogre@@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEPAPAVModelAnchorNode@Ogre@@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Ucopy<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@PAPAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@2@@stdext@@YAPAPAVModelAnchorNode@Ogre@@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVModelAnchorNode@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEPAPAVModelAnchorNode@Ogre@@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Ucopy<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVModelAnchorNode@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::ModelAnchorNode * *>
PUBLIC	??$_Iter_random@PAPAVModelAnchorNode@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVModelAnchorNode@Ogre@@0@Z ; std::_Iter_random<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>
PUBLIC	??$_Ptr_cat@PAPAVModelAnchorNode@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVModelAnchorNode@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@@stdext@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T94368 = -3						; size = 1
$T94367 = -2						; size = 1
$T94366 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@@stdext@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94366[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVModelAnchorNode@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVModelAnchorNode@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>
	add	esp, 8
	mov	BYTE PTR $T94367[ebp], al
	movzx	eax, BYTE PTR $T94366[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94367[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94368[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVModelAnchorNode@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVModelAnchorNode@Ogre@@0@Z ; std::_Iter_random<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::ModelAnchorNode * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::ModelAnchorNode * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVModelAnchorNode@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@@stdext@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@stdext@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00AAV?$allocator@PAVModelAnchorNode@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVModelAnchorNode@Ogre@@@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEPAPAVModelAnchorNode@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVModelAnchorNode@Ogre@@@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEPAPAVModelAnchorNode@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Ucopy<Ogre::ModelAnchorNode * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@stdext@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00AAV?$allocator@PAVModelAnchorNode@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVModelAnchorNode@Ogre@@@?$vector@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@IAEPAPAVModelAnchorNode@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Ucopy<Ogre::ModelAnchorNode * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@@Z
_TEXT	SEGMENT
$T94373 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTriggerDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 8
	mov	BYTE PTR $T94373[ebp], al
	movzx	edx, BYTE PTR $T94373[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@@Z
_TEXT	SEGMENT
$T94376 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSequenceDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 8
	mov	BYTE PTR $T94376[ebp], al
	movzx	edx, BYTE PTR $T94376[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@@Z
_TEXT	SEGMENT
$T94379 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 8
	mov	BYTE PTR $T94379[ebp], al
	movzx	edx, BYTE PTR $T94379[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@@Z
_TEXT	SEGMENT
$T94382 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParamTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
	add	esp, 8
	mov	BYTE PTR $T94382[ebp], al
	movzx	edx, BYTE PTR $T94382[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@@Z
_TEXT	SEGMENT
$T94385 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::AnimPlayTrack *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVAnimPlayTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
	mov	BYTE PTR $T94385[ebp], al
	movzx	edx, BYTE PTR $T94385[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::AnimPlayTrack *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::AnimPlayTrack *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T94389 = -2						; size = 1
$T94388 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T94388[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVAnimPlayTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
	mov	BYTE PTR $T94389[ebp], al
	movzx	eax, BYTE PTR $T94388[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94389[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z
_TEXT	SEGMENT
$T94392 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z PROC ; std::_Destroy_range<std::allocator<char> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
	add	esp, 8
	mov	BYTE PTR $T94392[ebp], al
	movzx	edx, BYTE PTR $T94392[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<char> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z ENDP ; std::_Destroy_range<std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z
_TEXT	SEGMENT
$T94395 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 8
	mov	BYTE PTR $T94395[ebp], al
	movzx	edx, BYTE PTR $T94395[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z
_TEXT	SEGMENT
$T94398 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ; std::_Ptr_cat<unsigned int *,unsigned int *>
	add	esp, 8
	mov	BYTE PTR $T94398[ebp], al
	movzx	edx, BYTE PTR $T94398[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAXPAPAVSubMeshInstance@Ogre@@0AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SubMeshInstance *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAXPAPAVSubMeshInstance@Ogre@@0AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@@Z
_TEXT	SEGMENT
$T94401 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAXPAPAVSubMeshInstance@Ogre@@0AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::SubMeshInstance *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVSubMeshInstance@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSubMeshInstance@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>
	add	esp, 8
	mov	BYTE PTR $T94401[ebp], al
	movzx	edx, BYTE PTR $T94401[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAXPAPAVSubMeshInstance@Ogre@@0AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SubMeshInstance *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAXPAPAVSubMeshInstance@Ogre@@0AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::SubMeshInstance *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAXPAPAVMeshInstance@Ogre@@0AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MeshInstance *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAXPAPAVMeshInstance@Ogre@@0AAV?$allocator@PAVMeshInstance@Ogre@@@0@@Z
_TEXT	SEGMENT
$T94404 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAXPAPAVMeshInstance@Ogre@@0AAV?$allocator@PAVMeshInstance@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::MeshInstance *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVMeshInstance@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMeshInstance@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MeshInstance * *,Ogre::MeshInstance * *>
	add	esp, 8
	mov	BYTE PTR $T94404[ebp], al
	movzx	edx, BYTE PTR $T94404[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAXPAPAVMeshInstance@Ogre@@0AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MeshInstance *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAXPAPAVMeshInstance@Ogre@@0AAV?$allocator@PAVMeshInstance@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::MeshInstance *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAXPAPAVModelAnchorNode@Ogre@@0AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ModelAnchorNode *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAXPAPAVModelAnchorNode@Ogre@@0AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@@Z
_TEXT	SEGMENT
$T94407 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAXPAPAVModelAnchorNode@Ogre@@0AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::ModelAnchorNode *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVModelAnchorNode@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVModelAnchorNode@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>
	add	esp, 8
	mov	BYTE PTR $T94407[ebp], al
	movzx	edx, BYTE PTR $T94407[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAXPAPAVModelAnchorNode@Ogre@@0AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ModelAnchorNode *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAXPAPAVModelAnchorNode@Ogre@@0AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::ModelAnchorNode *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UTriggerDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTriggerDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UTriggerDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTriggerDesc@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TriggerDesc>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UTriggerDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTriggerDesc@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TriggerDesc>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Allocate@UTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@IPAU12@@Z
_TEXT	SEGMENT
$T94412 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@IPAU12@@Z PROC ; std::_Allocate<Ogre::TriggerDesc>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94412[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94412[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@IPAU12@@Z ENDP ; std::_Allocate<Ogre::TriggerDesc>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_alloc@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0
__ehfuncinfo$??1bad_alloc@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_alloc@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 381  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??1bad_alloc@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1bad_alloc@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@28
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@28:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0USequenceDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@USequenceDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0USequenceDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@USequenceDesc@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SequenceDesc>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0USequenceDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@USequenceDesc@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SequenceDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@USequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@IPAU12@@Z
_TEXT	SEGMENT
$T94437 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@USequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@IPAU12@@Z PROC ; std::_Allocate<Ogre::SequenceDesc>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94437[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94437[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@USequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@IPAU12@@Z ENDP ; std::_Allocate<Ogre::SequenceDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVBoneTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVBoneTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVBoneTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVBoneTrack@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BoneTrack *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVBoneTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVBoneTrack@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BoneTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T94442 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::BoneTrack *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94442[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94442[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::BoneTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVMaterialParamTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVMaterialParamTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::MaterialParamTrack *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVMaterialParamTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMaterialParamTrack@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::MaterialParamTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T94447 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::MaterialParamTrack *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94447[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94447[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::MaterialParamTrack *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVAnimPlayTrack@Ogre@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVAnimPlayTrack@Ogre@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Umove<Ogre::AnimPlayTrack * *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAVAnimPlayTrack@Ogre@@@?$vector@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@IAEPAPAVAnimPlayTrack@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Umove<Ogre::AnimPlayTrack * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVAnimPlayTrack@Ogre@@PAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAVAnimPlayTrack@Ogre@@PAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVAnimPlayTrack@Ogre@@PAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0ABQAV12@@Z PROC ; std::fill<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack *>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAPAVAnimPlayTrack@Ogre@@PAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack *>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAPAVAnimPlayTrack@Ogre@@PAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0ABQAV12@@Z ENDP ; std::fill<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVAnimPlayTrack@Ogre@@@Z ; std::_Move_cat<Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T94456 = -3						; size = 1
$T94455 = -2						; size = 1
$T94454 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94454[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVAnimPlayTrack@Ogre@@@Z ; std::_Move_cat<Ogre::AnimPlayTrack * *>
	add	esp, 4
	mov	BYTE PTR $T94455[ebp], al
	movzx	edx, BYTE PTR $T94454[ebp]
	push	edx
	movzx	eax, BYTE PTR $T94455[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T94456[ebp]
	push	eax
	call	??$_Iter_random@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVAnimPlayTrack@Ogre@@0@Z ; std::_Iter_random<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAVAnimPlayTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVAnimPlayTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::AnimPlayTrack *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVAnimPlayTrack@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVAnimPlayTrack@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::AnimPlayTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T94461 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::AnimPlayTrack *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@5
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94461[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94461[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@5:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::AnimPlayTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SurfaceData *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SurfaceData *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T94468 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::SurfaceData *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@6
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94468[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94468[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@6:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::SurfaceData *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$82928 = -1					; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	ecx

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR __Tmp$82928[ebp], dl

; 21   : 
; 22   : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 23   : 		_Right = _Tmp;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR __Tmp$82928[ebp]
	mov	BYTE PTR [eax], cl
$LN2@swap:

; 24   : 		}
; 25   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *><std::pair<unsigned int const ,Ogre::Resource *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *><std::pair<unsigned int const ,Ogre::Resource *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@I@std@@YAPAIIPAI@Z
_TEXT	SEGMENT
$T94477 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@I@std@@YAPAIIPAI@Z PROC			; std::_Allocate<unsigned int>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@7

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@7
$LN3@Allocate@7:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94477[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94477[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@7:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@I@std@@YAPAIIPAI@Z ENDP			; std::_Allocate<unsigned int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned int>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVSubMeshInstance@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVSubMeshInstance@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SubMeshInstance *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVSubMeshInstance@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSubMeshInstance@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SubMeshInstance *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T94484 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::SubMeshInstance *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@8

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@8
$LN3@Allocate@8:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@8

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94484[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94484[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@8:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@8:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::SubMeshInstance *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVMeshInstance@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMeshInstance@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVMeshInstance@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMeshInstance@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::MeshInstance *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVMeshInstance@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVMeshInstance@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::MeshInstance *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T94489 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::MeshInstance *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@9

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@9
$LN3@Allocate@9:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@9

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94489[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94489[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@9:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@9:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::MeshInstance *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVModelAnchorNode@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVModelAnchorNode@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ModelAnchorNode *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVModelAnchorNode@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVModelAnchorNode@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ModelAnchorNode *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T94494 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::ModelAnchorNode *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@10

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@10
$LN3@Allocate@10:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@10

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94494[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94494[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@10:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@10:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::ModelAnchorNode *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *><std::pair<unsigned int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *><std::pair<unsigned int const ,int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHI@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHI@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *><std::pair<int const ,unsigned int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBHI@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *><std::pair<int const ,unsigned int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *><std::pair<Ogre::TextureDataLoader * const,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *><std::pair<Ogre::TextureDataLoader * const,int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *><std::pair<int const ,Ogre::TextureDataLoader *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *><std::pair<int const ,Ogre::TextureDataLoader *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z
_TEXT	SEGMENT
$T94513 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z PROC ; std::_Allocate<std::_Aux_cont>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@11

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@11
$LN3@Allocate@11:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@11

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94513[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94513[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@11:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@11:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node><std::pair<unsigned int const ,Ogre::Resource *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node><std::pair<unsigned int const ,Ogre::Resource *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T94518 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@12

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@12
$LN3@Allocate@12:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate@12

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94518[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94518[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@12:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@12:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T94523 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T94523[ebp], eax
	cmp	DWORD PTR $T94523[ebp], 0
	je	SHORT $LN3@Construct
	mov	edx, DWORD PTR $T94523[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T94523[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct
$LN3@Construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVResource@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::Resource *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::Resource *> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node><std::pair<unsigned int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node><std::pair<unsigned int const ,int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T94530 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@13

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@13
$LN3@Allocate@13:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate@13

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94530[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94530[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@13:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@13:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T94535 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T94535[ebp], eax
	cmp	DWORD PTR $T94535[ebp], 0
	je	SHORT $LN3@Construct@2
	mov	edx, DWORD PTR $T94535[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T94535[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct@2
$LN3@Construct@2:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct@2:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IHU?$less@I@std@@V?$allocator@U?$pair@$$CBIH@std@@@2@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,int> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHI@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHI@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node><std::pair<int const ,unsigned int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBHI@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node><std::pair<int const ,unsigned int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T94542 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@14

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@14
$LN3@Allocate@14:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate@14

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94542[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94542[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@14:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@14:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T94547 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T94547[ebp], eax
	cmp	DWORD PTR $T94547[ebp], 0
	je	SHORT $LN3@Construct@3
	mov	edx, DWORD PTR $T94547[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T94547[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct@3
$LN3@Construct@3:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct@3:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HIU?$less@H@std@@V?$allocator@U?$pair@$$CBHI@std@@@2@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,unsigned int,std::less<int>,std::allocator<std::pair<int const ,unsigned int> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node><std::pair<Ogre::TextureDataLoader * const,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node><std::pair<Ogre::TextureDataLoader * const,int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T94554 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@15

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@15
$LN3@Allocate@15:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate@15

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94554[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94554[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@15:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@15:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T94559 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T94559[ebp], eax
	cmp	DWORD PTR $T94559[ebp], 0
	je	SHORT $LN3@Construct@4
	mov	edx, DWORD PTR $T94559[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T94559[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct@4
$LN3@Construct@4:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct@4:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVTextureDataLoader@Ogre@@HU?$less@PAVTextureDataLoader@Ogre@@@std@@V?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@4@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Ogre::TextureDataLoader *,int,std::less<Ogre::TextureDataLoader *>,std::allocator<std::pair<Ogre::TextureDataLoader * const,int> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node><std::pair<int const ,Ogre::TextureDataLoader *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node><std::pair<int const ,Ogre::TextureDataLoader *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T94566 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@16

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@16
$LN3@Allocate@16:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate@16

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T94566[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T94566[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@16:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@16:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T94571 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T94571[ebp], eax
	cmp	DWORD PTR $T94571[ebp], 0
	je	SHORT $LN3@Construct@5
	mov	edx, DWORD PTR $T94571[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T94571[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct@5
$LN3@Construct@5:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct@5:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVTextureDataLoader@Ogre@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,Ogre::TextureDataLoader *,std::less<int>,std::allocator<std::pair<int const ,Ogre::TextureDataLoader *> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,Ogre::Resource *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIPAVResource@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVResource@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,Ogre::Resource *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIH@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIH@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIH@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIH@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHI@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHI@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<int const ,unsigned int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBHI@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHI@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<int const ,unsigned int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<Ogre::TextureDataLoader * const,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVTextureDataLoader@Ogre@@H@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<Ogre::TextureDataLoader * const,int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<int const ,Ogre::TextureDataLoader *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVTextureDataLoader@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<int const ,Ogre::TextureDataLoader *> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
PUBLIC	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::AnimPlayTrack * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::AnimPlayTrack * *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ; std::_Insertion_sort<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
PUBLIC	??$sort_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ; std::sort_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
PUBLIC	??$make_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ; std::make_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
PUBLIC	??$_Unguarded_partition@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YA?AU?$pair@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@0@PAPAVAnimPlayTrack@Ogre@@0P6A_NPAV23@1@Z@Z ; std::_Unguarded_partition<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAPAVAnimPlayTrack@Ogre@@HP6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0HP6A_NPAV12@1@Z@Z
_TEXT	SEGMENT
__Mid$83282 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Sort@PAPAVAnimPlayTrack@Ogre@@HP6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0HP6A_NPAV12@1@Z@Z PROC ; std::_Sort<Ogre::AnimPlayTrack * *,int,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 3244 : 	{	// order [_First, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
$LN7@Sort:

; 3245 : 	_Diff _Count;
; 3246 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	$LN6@Sort

; 3247 : 		{	// divide and conquer by quicksort
; 3248 : 		pair<_RanIt, _RanIt> _Mid =
; 3249 : 			std::_Unguarded_partition(_First, _Last, _Pred);

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Mid$83282[ebp]
	push	ecx
	call	??$_Unguarded_partition@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YA?AU?$pair@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@0@PAPAVAnimPlayTrack@Ogre@@0P6A_NPAV23@1@Z@Z ; std::_Unguarded_partition<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 16					; 00000010H

; 3250 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3251 : 
; 3252 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	edx, DWORD PTR __Mid$83282[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Mid$83282[ebp+4]
	sar	eax, 2
	cmp	edx, eax
	jge	SHORT $LN5@Sort

; 3253 : 			{	// loop on second half
; 3254 : 			std::_Sort(_First, _Mid.first, _Ideal, _Pred);

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ideal$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$83282[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Sort@PAPAVAnimPlayTrack@Ogre@@HP6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0HP6A_NPAV12@1@Z@Z ; std::_Sort<Ogre::AnimPlayTrack * *,int,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 16					; 00000010H

; 3255 : 			_First = _Mid.second;

	mov	edx, DWORD PTR __Mid$83282[ebp+4]
	mov	DWORD PTR __First$[ebp], edx

; 3256 : 			}
; 3257 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3258 : 			{	// loop on first half
; 3259 : 			std::_Sort(_Mid.second, _Last, _Ideal, _Pred);

	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$83282[ebp+4]
	push	eax
	call	??$_Sort@PAPAVAnimPlayTrack@Ogre@@HP6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0HP6A_NPAV12@1@Z@Z ; std::_Sort<Ogre::AnimPlayTrack * *,int,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 16					; 00000010H

; 3260 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$83282[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort:

; 3261 : 			}
; 3262 : 		}

	jmp	$LN7@Sort
$LN6@Sort:

; 3263 : 
; 3264 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	SHORT $LN3@Sort

; 3265 : 		{	// heap sort if too many divisions
; 3266 : 		std::make_heap(_First, _Last, _Pred);

	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$make_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ; std::make_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 12					; 0000000cH

; 3267 : 		std::sort_heap(_First, _Last, _Pred);

	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$sort_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ; std::sort_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN8@Sort
$LN3@Sort:

; 3268 : 		}
; 3269 : 	else if (1 < _Count)

	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3270 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Insertion_sort@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ; std::_Insertion_sort<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 12					; 0000000cH
$LN8@Sort:

; 3271 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAPAVAnimPlayTrack@Ogre@@HP6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0HP6A_NPAV12@1@Z@Z ENDP ; std::_Sort<Ogre::AnimPlayTrack * *,int,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::TriggerDesc const *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@AAPAUTriggerDesc@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@2@@stdext@@YAPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@4@@Z
_TEXT	SEGMENT
$T94600 = -2						; size = 1
$T94599 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@2@@stdext@@YAPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94599[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@AAPAUTriggerDesc@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *>
	add	esp, 8
	mov	BYTE PTR $T94600[ebp], al
	movzx	eax, BYTE PTR $T94599[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94600[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::TriggerDesc const *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@2@@stdext@@YAPAUTriggerDesc@Ogre@@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z PROC ; std::_Checked_base<Ogre::TriggerDesc *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z ENDP ; std::_Checked_base<Ogre::TriggerDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTriggerDesc@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTriggerDesc@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::TriggerDesc *,Ogre::TriggerDesc *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTriggerDesc@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTriggerDesc@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTriggerDesc@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::TriggerDesc *,Ogre::TriggerDesc *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTriggerDesc@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T94611 = -7						; size = 1
$T94610 = -6						; size = 1
$T94609 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Result$[ebp], edx

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T94609[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T94610[ebp], cl
	movzx	edx, BYTE PTR $T94609[ebp]
	push	edx
	movzx	eax, BYTE PTR $T94610[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94611[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T94615 = -2						; size = 1
$T94614 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94614[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUTriggerDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTriggerDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TriggerDesc *,Ogre::TriggerDesc *>
	add	esp, 8
	mov	BYTE PTR $T94615[ebp], al
	movzx	eax, BYTE PTR $T94614[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94615[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::TriggerDesc *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@stdext@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SequenceDesc const *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@AAPAUSequenceDesc@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@2@@stdext@@YAPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@4@@Z
_TEXT	SEGMENT
$T94619 = -2						; size = 1
$T94618 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@2@@stdext@@YAPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94618[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@AAPAUSequenceDesc@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *>
	add	esp, 8
	mov	BYTE PTR $T94619[ebp], al
	movzx	eax, BYTE PTR $T94618[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94619[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SequenceDesc const *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@2@@stdext@@YAPAUSequenceDesc@Ogre@@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z PROC ; std::_Checked_base<Ogre::SequenceDesc *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z ENDP ; std::_Checked_base<Ogre::SequenceDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSequenceDesc@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSequenceDesc@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::SequenceDesc *,Ogre::SequenceDesc *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSequenceDesc@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSequenceDesc@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSequenceDesc@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::SequenceDesc *,Ogre::SequenceDesc *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSequenceDesc@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T94630 = -7						; size = 1
$T94629 = -6						; size = 1
$T94628 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	shl	eax, 4
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	ecx, ecx
	mov	BYTE PTR $T94628[ebp], cl
	xor	edx, edx
	mov	BYTE PTR $T94629[ebp], dl
	movzx	eax, BYTE PTR $T94628[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94629[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T94630[ebp]
	push	edx
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T94634 = -2						; size = 1
$T94633 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94633[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUSequenceDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSequenceDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SequenceDesc *,Ogre::SequenceDesc *>
	add	esp, 8
	mov	BYTE PTR $T94634[ebp], al
	movzx	eax, BYTE PTR $T94633[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94634[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::SequenceDesc *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@stdext@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BoneTrack * const *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@AAPAPAVBoneTrack@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@2@@stdext@@YAPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@4@@Z
_TEXT	SEGMENT
$T94638 = -2						; size = 1
$T94637 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@2@@stdext@@YAPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94637[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@AAPAPAVBoneTrack@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *>
	add	esp, 8
	mov	BYTE PTR $T94638[ebp], al
	movzx	eax, BYTE PTR $T94637[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94638[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BoneTrack * const *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@2@@stdext@@YAPAPAVBoneTrack@Ogre@@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::BoneTrack * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::BoneTrack * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::BoneTrack * *,Ogre::BoneTrack * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBoneTrack@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::BoneTrack * *,Ogre::BoneTrack * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVBoneTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T94650 = -2						; size = 1
$T94649 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94649[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVBoneTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVBoneTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BoneTrack * *,Ogre::BoneTrack * *>
	add	esp, 8
	mov	BYTE PTR $T94650[ebp], al
	movzx	eax, BYTE PTR $T94649[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94650[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::BoneTrack * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@stdext@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@AAPAPAVMaterialParamTrack@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@2@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@4@@Z
_TEXT	SEGMENT
$T94654 = -2						; size = 1
$T94653 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@2@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94653[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@AAPAPAVMaterialParamTrack@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *>
	add	esp, 8
	mov	BYTE PTR $T94654[ebp], al
	movzx	eax, BYTE PTR $T94653[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94654[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@2@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::MaterialParamTrack * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::MaterialParamTrack * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParamTrack@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParamTrack@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParamTrack@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParamTrack@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParamTrack@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParamTrack@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVMaterialParamTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVMaterialParamTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@2

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@2:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVMaterialParamTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T94666 = -2						; size = 1
$T94665 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94665[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVMaterialParamTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParamTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *>
	add	esp, 8
	mov	BYTE PTR $T94666[ebp], al
	movzx	eax, BYTE PTR $T94665[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94666[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParamTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParamTrack * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@stdext@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@std@@YAPBQAVAnimPlayTrack@Ogre@@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@AAPAPAVAnimPlayTrack@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >,Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@PAPAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@2@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@4@@Z
_TEXT	SEGMENT
$T94670 = -2						; size = 1
$T94669 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@PAPAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@2@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94669[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@AAPAPAVAnimPlayTrack@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >,Ogre::AnimPlayTrack * *>
	add	esp, 8
	mov	BYTE PTR $T94670[ebp], al
	movzx	eax, BYTE PTR $T94669[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94670[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@std@@YAPBQAVAnimPlayTrack@Ogre@@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@std@@YAPBQAVAnimPlayTrack@Ogre@@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@PAPAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@2@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVAnimPlayTrack@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVAnimPlayTrack@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVAnimPlayTrack@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVAnimPlayTrack@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVAnimPlayTrack@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVAnimPlayTrack@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@3

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@3:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T94680 = -2						; size = 1
$T94679 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94679[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVAnimPlayTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
	mov	BYTE PTR $T94680[ebp], al
	movzx	eax, BYTE PTR $T94679[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94680[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<char const *,char *,std::allocator<char> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z ; std::_Ptr_cat<std::_Vector_const_iterator<char,std::allocator<char> >,char *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z
_TEXT	SEGMENT
$T94684 = -2						; size = 1
$T94683 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<char,std::allocator<char> >,char *,std::allocator<char> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94683[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z ; std::_Ptr_cat<std::_Vector_const_iterator<char,std::allocator<char> >,char *>
	add	esp, 8
	mov	BYTE PTR $T94684[ebp], al
	movzx	eax, BYTE PTR $T94683[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94684[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<char const *,char *,std::allocator<char> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<char,std::allocator<char> >,char *,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAD@std@@YAPADAAPAD@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAD@std@@YAPADAAPAD@Z PROC		; std::_Checked_base<char *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<char *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAD@std@@YAPADAAPAD@Z ENDP		; std::_Checked_base<char *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z PROC ; std::_Iter_random<char *,char *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z ENDP ; std::_Iter_random<char *,char *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z PROC ; std::_Ptr_cat<char *,char *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ENDP ; std::_Ptr_cat<char *,char *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@4

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@4:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<char *,char *,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z
_TEXT	SEGMENT
$T94696 = -2						; size = 1
$T94695 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94695[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
	add	esp, 8
	mov	BYTE PTR $T94696[ebp], al
	movzx	eax, BYTE PTR $T94695[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94696[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<char *,char *,std::allocator<char> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SurfaceData * const *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z
_TEXT	SEGMENT
$T94700 = -2						; size = 1
$T94699 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94699[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *>
	add	esp, 8
	mov	BYTE PTR $T94700[ebp], al
	movzx	eax, BYTE PTR $T94699[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94700[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SurfaceData * const *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::SurfaceData * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::SurfaceData * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::SurfaceData * *,Ogre::SurfaceData * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@5

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@5:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T94712 = -2						; size = 1
$T94711 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94711[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 8
	mov	BYTE PTR $T94712[ebp], al
	movzx	eax, BYTE PTR $T94711[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94712[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBIPAIV?$allocator@I@std@@@std@@YAPAIPBI0PAIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int const *,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@AAPAI@Z ; std::_Ptr_cat<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z
_TEXT	SEGMENT
$T94716 = -2						; size = 1
$T94715 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94715[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@AAPAI@Z ; std::_Ptr_cat<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *>
	add	esp, 8
	mov	BYTE PTR $T94716[ebp], al
	movzx	eax, BYTE PTR $T94715[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94716[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBIPAIV?$allocator@I@std@@@std@@YAPAIPBI0PAIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int const *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<unsigned int *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAI@std@@YAPAIAAPAI@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAI@std@@YAPAIAAPAI@Z PROC		; std::_Checked_base<unsigned int *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<unsigned int *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAI@std@@YAPAIAAPAI@Z ENDP		; std::_Checked_base<unsigned int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z PROC ; std::_Iter_random<unsigned int *,unsigned int *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z ENDP ; std::_Iter_random<unsigned int *,unsigned int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z PROC ; std::_Ptr_cat<unsigned int *,unsigned int *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ENDP ; std::_Ptr_cat<unsigned int *,unsigned int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@6

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@6:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
$T94728 = -2						; size = 1
$T94727 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94727[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ; std::_Ptr_cat<unsigned int *,unsigned int *>
	add	esp, 8
	mov	BYTE PTR $T94728[ebp], al
	movzx	eax, BYTE PTR $T94727[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94728[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z	; std::_Checked_base<unsigned int *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z	; std::_Checked_base<unsigned int *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@@std@@YAPBQAVSubMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@PAPAVSubMeshInstance@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@AAPAPAVSubMeshInstance@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >,Ogre::SubMeshInstance * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@PAPAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@2@@stdext@@YAPAPAVSubMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSubMeshInstance@Ogre@@@4@@Z
_TEXT	SEGMENT
$T94732 = -2						; size = 1
$T94731 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@PAPAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@2@@stdext@@YAPAPAVSubMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSubMeshInstance@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94731[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@PAPAVSubMeshInstance@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@AAPAPAVSubMeshInstance@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >,Ogre::SubMeshInstance * *>
	add	esp, 8
	mov	BYTE PTR $T94732[ebp], al
	movzx	eax, BYTE PTR $T94731[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94732[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@@std@@YAPBQAVSubMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@@std@@YAPBQAVSubMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@PAPAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@2@@stdext@@YAPAPAVSubMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSubMeshInstance@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::SubMeshInstance * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::SubMeshInstance * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::SubMeshInstance * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::SubMeshInstance * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVSubMeshInstance@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSubMeshInstance@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVSubMeshInstance@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSubMeshInstance@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVSubMeshInstance@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSubMeshInstance@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVSubMeshInstance@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSubMeshInstance@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVSubMeshInstance@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSubMeshInstance@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVSubMeshInstance@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSubMeshInstance@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVSubMeshInstance@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVSubMeshInstance@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@7

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@7:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVSubMeshInstance@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@stdext@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVSubMeshInstance@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T94744 = -2						; size = 1
$T94743 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@stdext@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVSubMeshInstance@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94743[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVSubMeshInstance@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSubMeshInstance@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *>
	add	esp, 8
	mov	BYTE PTR $T94744[ebp], al
	movzx	eax, BYTE PTR $T94743[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94744[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SubMeshInstance * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SubMeshInstance * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@stdext@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVSubMeshInstance@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAPAPAVMeshInstance@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::MeshInstance * const *,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@@std@@YAPBQAVMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@PAPAVMeshInstance@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@AAPAPAVMeshInstance@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >,Ogre::MeshInstance * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@PAPAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@2@@stdext@@YAPAPAVMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMeshInstance@Ogre@@@4@@Z
_TEXT	SEGMENT
$T94748 = -2						; size = 1
$T94747 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@PAPAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@2@@stdext@@YAPAPAVMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMeshInstance@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94747[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@PAPAVMeshInstance@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@AAPAPAVMeshInstance@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >,Ogre::MeshInstance * *>
	add	esp, 8
	mov	BYTE PTR $T94748[ebp], al
	movzx	eax, BYTE PTR $T94747[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94748[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@@std@@YAPBQAVMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@@std@@YAPBQAVMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAPAPAVMeshInstance@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::MeshInstance * const *,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@PAPAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@2@@stdext@@YAPAPAVMeshInstance@Ogre@@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVMeshInstance@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::MeshInstance * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::MeshInstance * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::MeshInstance * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::MeshInstance * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVMeshInstance@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMeshInstance@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVMeshInstance@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMeshInstance@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::MeshInstance * *,Ogre::MeshInstance * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVMeshInstance@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMeshInstance@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::MeshInstance * *,Ogre::MeshInstance * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVMeshInstance@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMeshInstance@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVMeshInstance@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMeshInstance@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::MeshInstance * *,Ogre::MeshInstance * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVMeshInstance@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMeshInstance@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::MeshInstance * *,Ogre::MeshInstance * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVMeshInstance@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVMeshInstance@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::MeshInstance * *,Ogre::MeshInstance * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@8

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@8:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVMeshInstance@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::MeshInstance * *,Ogre::MeshInstance * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::MeshInstance * *,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@stdext@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVMeshInstance@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T94760 = -2						; size = 1
$T94759 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@stdext@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVMeshInstance@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::MeshInstance * *,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94759[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVMeshInstance@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMeshInstance@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MeshInstance * *,Ogre::MeshInstance * *>
	add	esp, 8
	mov	BYTE PTR $T94760[ebp], al
	movzx	eax, BYTE PTR $T94759[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94760[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MeshInstance * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MeshInstance * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::MeshInstance * *,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@stdext@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVMeshInstance@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::MeshInstance * *,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@@std@@YAPBQAVModelAnchorNode@Ogre@@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@PAPAVModelAnchorNode@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@AAPAPAVModelAnchorNode@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >,Ogre::ModelAnchorNode * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@PAPAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@2@@stdext@@YAPAPAVModelAnchorNode@Ogre@@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVModelAnchorNode@Ogre@@@4@@Z
_TEXT	SEGMENT
$T94764 = -2						; size = 1
$T94763 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@PAPAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@2@@stdext@@YAPAPAVModelAnchorNode@Ogre@@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVModelAnchorNode@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94763[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@PAPAVModelAnchorNode@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@AAPAPAVModelAnchorNode@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >,Ogre::ModelAnchorNode * *>
	add	esp, 8
	mov	BYTE PTR $T94764[ebp], al
	movzx	eax, BYTE PTR $T94763[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94764[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@@std@@YAPBQAVModelAnchorNode@Ogre@@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@@std@@YAPBQAVModelAnchorNode@Ogre@@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@PAPAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@2@@stdext@@YAPAPAVModelAnchorNode@Ogre@@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVModelAnchorNode@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::ModelAnchorNode * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::ModelAnchorNode * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::ModelAnchorNode * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::ModelAnchorNode * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVModelAnchorNode@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVModelAnchorNode@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVModelAnchorNode@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVModelAnchorNode@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVModelAnchorNode@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVModelAnchorNode@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVModelAnchorNode@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVModelAnchorNode@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVModelAnchorNode@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVModelAnchorNode@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVModelAnchorNode@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVModelAnchorNode@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVModelAnchorNode@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVModelAnchorNode@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@9

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@9:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVModelAnchorNode@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@stdext@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00AAV?$allocator@PAVModelAnchorNode@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T94776 = -2						; size = 1
$T94775 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@stdext@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00AAV?$allocator@PAVModelAnchorNode@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94775[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVModelAnchorNode@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVModelAnchorNode@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *>
	add	esp, 8
	mov	BYTE PTR $T94776[ebp], al
	movzx	eax, BYTE PTR $T94775[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94776[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::ModelAnchorNode * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::ModelAnchorNode * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@stdext@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00AAV?$allocator@PAVModelAnchorNode@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@@Z ; std::allocator<Ogre::TriggerDesc>::destroy
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@@Z ; std::allocator<Ogre::TriggerDesc>::destroy
	jmp	SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAXPAUTriggerDesc@Ogre@@0AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::TriggerDesc> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@@Z ; std::allocator<Ogre::SequenceDesc>::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@2

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@@Z ; std::allocator<Ogre::SequenceDesc>::destroy
	jmp	SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAXPAUSequenceDesc@Ogre@@0AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAXPAPAVBoneTrack@Ogre@@0AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAXPAPAVMaterialParamTrack@Ogre@@0AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::AnimPlayTrack *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::AnimPlayTrack *> >
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@stdext@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@stdext@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<char> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<char> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAXPAPAVSubMeshInstance@Ogre@@0AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAXPAPAVSubMeshInstance@Ogre@@0AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::SubMeshInstance *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAXPAPAVSubMeshInstance@Ogre@@0AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::SubMeshInstance *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAXPAPAVMeshInstance@Ogre@@0AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAXPAPAVMeshInstance@Ogre@@0AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::MeshInstance *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAXPAPAVMeshInstance@Ogre@@0AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::MeshInstance *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAXPAPAVModelAnchorNode@Ogre@@0AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAXPAPAVModelAnchorNode@Ogre@@0AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::ModelAnchorNode *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAXPAPAVModelAnchorNode@Ogre@@0AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::ModelAnchorNode *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T94804 = -2						; size = 1
$T94803 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T94803[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVAnimPlayTrack@Ogre@@@Z ; std::_Move_cat<Ogre::AnimPlayTrack * *>
	add	esp, 4
	mov	BYTE PTR $T94804[ebp], al
	movzx	edx, BYTE PTR $T94803[ebp]
	push	edx
	movzx	eax, BYTE PTR $T94804[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAVAnimPlayTrack@Ogre@@PAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVAnimPlayTrack@Ogre@@PAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0ABQAV12@@Z PROC ; std::_Fill<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack *>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill
$LN2@Fill:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill
$LN4@Fill:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAPAVAnimPlayTrack@Ogre@@PAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0ABQAV12@@Z ENDP ; std::_Fill<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVAnimPlayTrack@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVAnimPlayTrack@Ogre@@@Z PROC ; std::_Move_cat<Ogre::AnimPlayTrack * *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVAnimPlayTrack@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::AnimPlayTrack * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T94812 = -2						; size = 1
$T94811 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T94811[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVAnimPlayTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
	mov	BYTE PTR $T94812[ebp], al
	movzx	eax, BYTE PTR $T94811[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T94812[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy@UTriggerDesc@Ogre@@@std@@YAXPAUTriggerDesc@Ogre@@@Z ; std::_Destroy<Ogre::TriggerDesc>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@@Z PROC ; std::allocator<Ogre::TriggerDesc>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UTriggerDesc@Ogre@@@std@@YAXPAUTriggerDesc@Ogre@@@Z ; std::_Destroy<Ogre::TriggerDesc>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@@Z ENDP ; std::allocator<Ogre::TriggerDesc>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@USequenceDesc@Ogre@@@std@@YAXPAUSequenceDesc@Ogre@@@Z ; std::_Destroy<Ogre::SequenceDesc>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@@Z PROC ; std::allocator<Ogre::SequenceDesc>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@USequenceDesc@Ogre@@@std@@YAXPAUSequenceDesc@Ogre@@@Z ; std::_Destroy<Ogre::SequenceDesc>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@@Z ENDP ; std::allocator<Ogre::SequenceDesc>::destroy
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::AnimPlayTrack * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::AnimPlayTrack * *>
_TEXT	ENDS
PUBLIC	??0?$pair@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@QAE@ABQAPAVAnimPlayTrack@Ogre@@0@Z ; std::pair<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>::pair<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
PUBLIC	??$iter_swap@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::iter_swap<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
PUBLIC	??$_Median@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00P6A_NPAV12@1@Z@Z ; std::_Median<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YA?AU?$pair@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@0@PAPAVAnimPlayTrack@Ogre@@0P6A_NPAV23@1@Z@Z
_TEXT	SEGMENT
tv195 = -36						; size = 4
tv181 = -32						; size = 4
tv178 = -28						; size = 4
tv147 = -24						; size = 4
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Unguarded_partition@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YA?AU?$pair@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@0@PAPAVAnimPlayTrack@Ogre@@0P6A_NPAV23@1@Z@Z PROC ; std::_Unguarded_partition<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 3185 : 	{	// partition [_First, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 3186 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Mid$[ebp], edx

; 3187 : 	std::_Median(_First, _Mid, _Last - 1, _Pred);

	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 4
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Median@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00P6A_NPAV12@1@Z@Z ; std::_Median<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 16					; 00000010H

; 3188 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], ecx

; 3189 : 	_RanIt _Plast = _Pfirst + 1;

	mov	edx, DWORD PTR __Pfirst$[ebp]
	add	edx, 4
	mov	DWORD PTR __Plast$[ebp], edx
$LN27@Unguarded_:

; 3190 : 
; 3191 : 	while (_First < _Pfirst
; 3192 : 		&& !_DEBUG_LT_PRED(_Pred, *(_Pfirst - 1), *_Pfirst)
; 3193 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	push	ecx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN25@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	push	ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@Unguarded_

; 3194 : 		--_Pfirst;

	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 4
	mov	DWORD PTR __Pfirst$[ebp], edx
	jmp	SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3195 : 	while (_Plast < _Last
; 3196 : 		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
; 3197 : 		&& !_Pred(*_Pfirst, *_Plast))

	mov	eax, DWORD PTR __Plast$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@Unguarded_

; 3198 : 		++_Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 4
	mov	DWORD PTR __Plast$[ebp], edx
	jmp	SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3199 : 
; 3200 : 	_RanIt _Gfirst = _Plast;

	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], eax

; 3201 : 	_RanIt _Glast = _Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], ecx
$LN23@Unguarded_:

; 3202 : 
; 3203 : 	for (; ; )
; 3204 : 		{	// partition
; 3205 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_
$LN20@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 4
	mov	DWORD PTR __Gfirst$[ebp], edx
$LN21@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jae	SHORT $LN19@Unguarded_

; 3206 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN18@Unguarded_
	jmp	SHORT $LN17@Unguarded_
$LN18@Unguarded_:

; 3207 : 				;
; 3208 : 			else if (_Pred(*_Gfirst, *_Pfirst))

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@Unguarded_

; 3209 : 				break;

	jmp	SHORT $LN19@Unguarded_

; 3210 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3211 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR tv147[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	add	eax, 4
	mov	DWORD PTR __Plast$[ebp], eax
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv147[ebp]
	push	edx
	call	??$iter_swap@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::iter_swap<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
$LN17@Unguarded_:
	jmp	SHORT $LN20@Unguarded_
$LN19@Unguarded_:

; 3212 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_
$LN13@Unguarded_:
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 4
	mov	DWORD PTR __Glast$[ebp], eax
$LN14@Unguarded_:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	jae	SHORT $LN12@Unguarded_

; 3213 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@Unguarded_
	jmp	SHORT $LN10@Unguarded_
$LN11@Unguarded_:

; 3214 : 				;
; 3215 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@Unguarded_

; 3216 : 				break;

	jmp	SHORT $LN12@Unguarded_

; 3217 : 			else

	jmp	SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3218 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 4
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 4
	push	ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	push	edx
	call	??$iter_swap@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::iter_swap<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
$LN10@Unguarded_:
	jmp	SHORT $LN13@Unguarded_
$LN12@Unguarded_:

; 3219 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_

; 3220 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	lea	edx, DWORD PTR __Plast$[ebp]
	push	edx
	lea	eax, DWORD PTR __Pfirst$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@QAE@ABQAPAVAnimPlayTrack@Ogre@@0@Z ; std::pair<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>::pair<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_
$LN7@Unguarded_:

; 3221 : 
; 3222 : 		if (_Glast == _First)

	mov	ecx, DWORD PTR __Glast$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	jne	SHORT $LN6@Unguarded_

; 3223 : 			{	// no room at bottom, rotate pivot upward
; 3224 : 			if (_Plast != _Gfirst)

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_

; 3225 : 				std::iter_swap(_Pfirst, _Plast);

	mov	eax, DWORD PTR __Plast$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	push	ecx
	call	??$iter_swap@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::iter_swap<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
$LN5@Unguarded_:

; 3226 : 			++_Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 4
	mov	DWORD PTR __Plast$[ebp], edx

; 3227 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR tv178[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR tv181[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	add	edx, 4
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	add	eax, 4
	mov	DWORD PTR __Gfirst$[ebp], eax
	mov	ecx, DWORD PTR tv178[ebp]
	push	ecx
	mov	edx, DWORD PTR tv181[ebp]
	push	edx
	call	??$iter_swap@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::iter_swap<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
	jmp	SHORT $LN4@Unguarded_
$LN6@Unguarded_:

; 3228 : 			}
; 3229 : 		else if (_Gfirst == _Last)

	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	SHORT $LN3@Unguarded_

; 3230 : 			{	// no room at top, rotate pivot downward
; 3231 : 			if (--_Glast != --_Pfirst)

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 4
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 4
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	je	SHORT $LN2@Unguarded_

; 3232 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	push	edx
	call	??$iter_swap@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::iter_swap<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
$LN2@Unguarded_:

; 3233 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	eax, DWORD PTR __Plast$[ebp]
	sub	eax, 4
	mov	DWORD PTR __Plast$[ebp], eax
	mov	ecx, DWORD PTR __Plast$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	push	edx
	call	??$iter_swap@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::iter_swap<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8

; 3234 : 			}
; 3235 : 		else

	jmp	SHORT $LN4@Unguarded_
$LN3@Unguarded_:

; 3236 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 4
	mov	DWORD PTR __Glast$[ebp], eax
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR tv195[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	push	edx
	mov	eax, DWORD PTR tv195[ebp]
	push	eax
	call	??$iter_swap@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::iter_swap<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN4@Unguarded_:

; 3237 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3238 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YA?AU?$pair@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@0@PAPAVAnimPlayTrack@Ogre@@0P6A_NPAV23@1@Z@Z ENDP ; std::_Unguarded_partition<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@ZPAH0@Z ; std::_Make_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
PUBLIC	??$_Dist_type@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAHPAPAVAnimPlayTrack@Ogre@@@Z ; std::_Dist_type<Ogre::AnimPlayTrack * *>
PUBLIC	??$_Val_type@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@@Z ; std::_Val_type<Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
;	COMDAT ??$make_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$make_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z PROC ; std::make_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 2203 : 	{	// make [_First, _Last) into a heap, using _Pred

	push	ebp
	mov	ebp, esp

; 2204 : 	_DEBUG_RANGE(_First, _Last);
; 2205 : 	_DEBUG_POINTER(_Pred);
; 2206 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	cmp	eax, 1
	jle	SHORT $LN2@make_heap

; 2207 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Pred,
; 2208 : 			_Dist_type(_First), _Val_type(_First));

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Val_type@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@@Z ; std::_Val_type<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Dist_type@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAHPAPAVAnimPlayTrack@Ogre@@@Z ; std::_Dist_type<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	call	??$_Make_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@ZPAH0@Z ; std::_Make_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 20					; 00000014H
$LN2@make_heap:

; 2209 : 	}

	pop	ebp
	ret	0
??$make_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ENDP ; std::make_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ; std::_Sort_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
; Function compile flags: /Odtp
;	COMDAT ??$sort_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$sort_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z PROC ; std::sort_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 2240 : 	{	// order heap by repeatedly popping, using _Pred

	push	ebp
	mov	ebp, esp

; 2241 : 	_DEBUG_RANGE(_First, _Last);
; 2242 : 	_DEBUG_POINTER(_Pred);
; 2243 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2244 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Pred);

	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	call	??$_Sort_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ; std::_Sort_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 12					; 0000000cH

; 2245 : 	}

	pop	ebp
	ret	0
??$sort_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ENDP ; std::sort_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@ZPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z0@Z ; std::_Insertion_sort1<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *),Ogre::AnimPlayTrack *>
; Function compile flags: /Odtp
;	COMDAT ??$_Insertion_sort@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Insertion_sort@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z PROC ; std::_Insertion_sort<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 3149 : 	{	// insertion sort [_First, _Last), using _Pred

	push	ebp
	mov	ebp, esp

; 3150 : 	std::_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@@Z ; std::_Val_type<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@ZPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z0@Z ; std::_Insertion_sort1<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *),Ogre::AnimPlayTrack *>
	add	esp, 16					; 00000010H

; 3151 : 	}

	pop	ebp
	ret	0
??$_Insertion_sort@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ENDP ; std::_Insertion_sort<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@AAPAUTriggerDesc@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@AAPAUTriggerDesc@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@PAUTriggerDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@AAPAUTriggerDesc@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,Ogre::TriggerDesc *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::TriggerDesc>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::TriggerDesc const *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::TriggerDesc>::construct
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@@Z ; std::allocator<Ogre::TriggerDesc>::destroy
	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::TriggerDesc const *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::TriggerDesc *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUTriggerDesc@Ogre@@@std@@YAPAUTriggerDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::TriggerDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@10
$LN2@Copy_opt@10:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 8
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@10:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@10

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Copy_opt@10
$LN1@Copy_opt@10:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUTriggerDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@2
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::TriggerDesc>::construct
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@@Z ; std::allocator<Ogre::TriggerDesc>::destroy
	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUTriggerDesc@Ogre@@PAU12@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@YAPAUTriggerDesc@Ogre@@PAU12@00AAV?$allocator@UTriggerDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::TriggerDesc *,Ogre::TriggerDesc *,std::allocator<Ogre::TriggerDesc> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@AAPAUSequenceDesc@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@AAPAUSequenceDesc@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@PAUSequenceDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@AAPAUSequenceDesc@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,Ogre::SequenceDesc *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::SequenceDesc>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::SequenceDesc const *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@3
$LN5@Uninit_cop@3:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@3:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@3

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::SequenceDesc>::construct
	jmp	SHORT $LN5@Uninit_cop@3
$LN4@Uninit_cop@3:
	jmp	SHORT $LN10@Uninit_cop@3
__catch$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@3
$LN2@Uninit_cop@3:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@3:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@3

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@@Z ; std::allocator<Ogre::SequenceDesc>::destroy
	jmp	SHORT $LN2@Uninit_cop@3
$LN1@Uninit_cop@3:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@3:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::SequenceDesc const *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::SequenceDesc *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUSequenceDesc@Ogre@@@std@@YAPAUSequenceDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::SequenceDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@11
$LN2@Copy_opt@11:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@11:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@11

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN2@Copy_opt@11
$LN1@Copy_opt@11:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUSequenceDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@4
$LN5@Uninit_cop@4:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@4:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@4

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::SequenceDesc>::construct
	jmp	SHORT $LN5@Uninit_cop@4
$LN4@Uninit_cop@4:
	jmp	SHORT $LN10@Uninit_cop@4
__catch$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@4
$LN2@Uninit_cop@4:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@4:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@4

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@@Z ; std::allocator<Ogre::SequenceDesc>::destroy
	jmp	SHORT $LN2@Uninit_cop@4
$LN1@Uninit_cop@4:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@4:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUSequenceDesc@Ogre@@PAU12@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@YAPAUSequenceDesc@Ogre@@PAU12@00AAV?$allocator@USequenceDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::SequenceDesc *,Ogre::SequenceDesc *,std::allocator<Ogre::SequenceDesc> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@AAPAPAVBoneTrack@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@AAPAPAVBoneTrack@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@PAPAVBoneTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@AAPAPAVBoneTrack@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,Ogre::BoneTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::BoneTrack * const *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@5

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@5:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::BoneTrack * const *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::BoneTrack * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVBoneTrack@Ogre@@@std@@YAPAPAVBoneTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::BoneTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@6

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@6:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVBoneTrack@Ogre@@PAPAV12@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@YAPAPAVBoneTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVBoneTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::BoneTrack * *,Ogre::BoneTrack * *,std::allocator<Ogre::BoneTrack *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@AAPAPAVMaterialParamTrack@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@AAPAPAVMaterialParamTrack@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@PAPAVMaterialParamTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@AAPAPAVMaterialParamTrack@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@7

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@7:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::MaterialParamTrack * const *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::MaterialParamTrack * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVMaterialParamTrack@Ogre@@@std@@YAPAPAVMaterialParamTrack@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::MaterialParamTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@8

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@8:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVMaterialParamTrack@Ogre@@PAPAV12@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@YAPAPAVMaterialParamTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParamTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::MaterialParamTrack * *,Ogre::MaterialParamTrack * *,std::allocator<Ogre::MaterialParamTrack *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVAnimPlayTrack@Ogre@@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@std@@YAPBQAVAnimPlayTrack@Ogre@@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@std@@YAPBQAVAnimPlayTrack@Ogre@@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVAnimPlayTrack@Ogre@@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@@std@@YAPBQAVAnimPlayTrack@Ogre@@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@AAPAPAVAnimPlayTrack@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@AAPAPAVAnimPlayTrack@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >,Ogre::AnimPlayTrack * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@AAPAPAVAnimPlayTrack@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >,Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@9

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@9:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::AnimPlayTrack * const *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@10

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@10:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<char,std::allocator<char> >,char *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<char,std::allocator<char> >,char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<char const *,char *,std::allocator<char> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@11

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@11:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<char const *,char *,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<char *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<char *,char *,std::allocator<char> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@12

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@12:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<char *,char *,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::SurfaceData * const *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@13

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@13:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::SurfaceData * const *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::SurfaceData * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::SurfaceData * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@14

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@14:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@AAPAI@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@AAPAI@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@PAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@AAPAI@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBIPAIV?$allocator@I@std@@@std@@YAPAIPBI0PAIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBIPAIV?$allocator@I@std@@@std@@YAPAIPBI0PAIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned int const *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@15

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@15:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBIPAIV?$allocator@I@std@@@std@@YAPAIPBI0PAIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned int const *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<unsigned int *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<unsigned int *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@16

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@16:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSubMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@@std@@YAPBQAVSubMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@@std@@YAPBQAVSubMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSubMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@@std@@YAPBQAVSubMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@PAPAVSubMeshInstance@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@AAPAPAVSubMeshInstance@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@PAPAVSubMeshInstance@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@AAPAPAVSubMeshInstance@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >,Ogre::SubMeshInstance * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@PAPAVSubMeshInstance@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@AAPAPAVSubMeshInstance@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >,Ogre::SubMeshInstance * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@17

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@17:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::SubMeshInstance * const *,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::SubMeshInstance * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVSubMeshInstance@Ogre@@@std@@YAPAPAVSubMeshInstance@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::SubMeshInstance * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@18

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@18:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVSubMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@YAPAPAVSubMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVSubMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::SubMeshInstance * *,Ogre::SubMeshInstance * *,std::allocator<Ogre::SubMeshInstance *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@@std@@YAPBQAVMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@@std@@YAPBQAVMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@@std@@YAPBQAVMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@PAPAVMeshInstance@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@AAPAPAVMeshInstance@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@PAPAVMeshInstance@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@AAPAPAVMeshInstance@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >,Ogre::MeshInstance * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@PAPAVMeshInstance@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@AAPAPAVMeshInstance@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >,Ogre::MeshInstance * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAPAPAVMeshInstance@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAPAPAVMeshInstance@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::MeshInstance * const *,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@19

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@19:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAPAPAVMeshInstance@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::MeshInstance * const *,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::MeshInstance * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVMeshInstance@Ogre@@@std@@YAPAPAVMeshInstance@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::MeshInstance * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::MeshInstance * *,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@20

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@20:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVMeshInstance@Ogre@@PAPAV12@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@YAPAPAVMeshInstance@Ogre@@PAPAV12@00AAV?$allocator@PAVMeshInstance@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::MeshInstance * *,Ogre::MeshInstance * *,std::allocator<Ogre::MeshInstance *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVModelAnchorNode@Ogre@@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@@std@@YAPBQAVModelAnchorNode@Ogre@@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@@std@@YAPBQAVModelAnchorNode@Ogre@@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVModelAnchorNode@Ogre@@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@@std@@YAPBQAVModelAnchorNode@Ogre@@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@PAPAVModelAnchorNode@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@AAPAPAVModelAnchorNode@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@PAPAVModelAnchorNode@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@AAPAPAVModelAnchorNode@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >,Ogre::ModelAnchorNode * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@PAPAVModelAnchorNode@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@AAPAPAVModelAnchorNode@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >,Ogre::ModelAnchorNode * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@21

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@21:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::ModelAnchorNode * const *,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::ModelAnchorNode * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVModelAnchorNode@Ogre@@@std@@YAPAPAVModelAnchorNode@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::ModelAnchorNode * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@22

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@22:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVModelAnchorNode@Ogre@@PAPAV12@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@YAPAPAVModelAnchorNode@Ogre@@PAPAV12@00AAV?$allocator@PAVModelAnchorNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::ModelAnchorNode * *,Ogre::ModelAnchorNode * *,std::allocator<Ogre::ModelAnchorNode *> >
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *>
PUBLIC	??$_Iter_cat@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVAnimPlayTrack@Ogre@@@Z ; std::_Iter_cat<Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@stdext@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@@Z
_TEXT	SEGMENT
$T94994 = -2						; size = 1
$T94993 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@stdext@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@@Z PROC ; stdext::unchecked_fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T94993[ebp], al
	movzx	ecx, BYTE PTR $T94993[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T94994[ebp]
	push	eax
	call	??$_Iter_cat@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVAnimPlayTrack@Ogre@@@Z ; std::_Iter_cat<Ogre::AnimPlayTrack * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@stdext@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@@Z ENDP ; stdext::unchecked_fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAPAVAnimPlayTrack@Ogre@@PAPAV12@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00AAV?$allocator@PAVAnimPlayTrack@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::allocator<Ogre::AnimPlayTrack *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Result$[ebp], edx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR __Result$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@UTriggerDesc@Ogre@@@std@@YAXPAUTriggerDesc@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UTriggerDesc@Ogre@@@std@@YAXPAUTriggerDesc@Ogre@@@Z PROC ; std::_Destroy<Ogre::TriggerDesc>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UTriggerDesc@Ogre@@@std@@YAXPAUTriggerDesc@Ogre@@@Z ENDP ; std::_Destroy<Ogre::TriggerDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@USequenceDesc@Ogre@@@std@@YAXPAUSequenceDesc@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@USequenceDesc@Ogre@@@std@@YAXPAUSequenceDesc@Ogre@@@Z PROC ; std::_Destroy<Ogre::SequenceDesc>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@USequenceDesc@Ogre@@@std@@YAXPAUSequenceDesc@Ogre@@@Z ENDP ; std::_Destroy<Ogre::SequenceDesc>
_TEXT	ENDS
PUBLIC	??$_Construct@UTriggerDesc@Ogre@@U12@@std@@YAXPAUTriggerDesc@Ogre@@ABU12@@Z ; std::_Construct<Ogre::TriggerDesc,Ogre::TriggerDesc>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@ABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@ABU34@@Z PROC ; std::allocator<Ogre::TriggerDesc>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UTriggerDesc@Ogre@@U12@@std@@YAXPAUTriggerDesc@Ogre@@ABU12@@Z ; std::_Construct<Ogre::TriggerDesc,Ogre::TriggerDesc>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UTriggerDesc@Ogre@@@std@@QAEXPAUTriggerDesc@Ogre@@ABU34@@Z ENDP ; std::allocator<Ogre::TriggerDesc>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@USequenceDesc@Ogre@@U12@@std@@YAXPAUSequenceDesc@Ogre@@ABU12@@Z ; std::_Construct<Ogre::SequenceDesc,Ogre::SequenceDesc>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@ABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@ABU34@@Z PROC ; std::allocator<Ogre::SequenceDesc>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@USequenceDesc@Ogre@@U12@@std@@YAXPAUSequenceDesc@Ogre@@ABU12@@Z ; std::_Construct<Ogre::SequenceDesc,Ogre::SequenceDesc>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@USequenceDesc@Ogre@@@std@@QAEXPAUSequenceDesc@Ogre@@ABU34@@Z ENDP ; std::allocator<Ogre::SequenceDesc>::construct
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@QAE@ABQAPAVAnimPlayTrack@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@QAE@ABQAPAVAnimPlayTrack@Ogre@@0@Z PROC ; std::pair<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>::pair<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val1$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val2$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$pair@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@QAE@ABQAPAVAnimPlayTrack@Ogre@@0@Z ENDP ; std::pair<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>::pair<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00P6A_NPAV12@1@Z@Z ; std::_Med3<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00P6A_NPAV12@1@Z@Z
_TEXT	SEGMENT
__Step$86460 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Median@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00P6A_NPAV12@1@Z@Z PROC ; std::_Median<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 3168 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	push	ecx

; 3169 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3170 : 		{	// median of nine
; 3171 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$86460[ebp], eax

; 3172 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Step$86460[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR __Step$86460[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Med3@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00P6A_NPAV12@1@Z@Z ; std::_Med3<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 16					; 00000010H

; 3173 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$86460[ebp]
	mov	edx, DWORD PTR __Mid$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Step$86460[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Mid$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00P6A_NPAV12@1@Z@Z ; std::_Med3<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 16					; 00000010H

; 3174 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$86460[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Step$86460[ebp]
	shl	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00P6A_NPAV12@1@Z@Z ; std::_Med3<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 16					; 00000010H

; 3175 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Step$86460[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Step$86460[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	??$_Med3@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00P6A_NPAV12@1@Z@Z ; std::_Med3<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 16					; 00000010H

; 3176 : 		}
; 3177 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3178 : 		std::_Med3(_First, _Mid, _Last, _Pred);

	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Med3@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00P6A_NPAV12@1@Z@Z ; std::_Med3<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 16					; 00000010H
$LN3@Median:

; 3179 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00P6A_NPAV12@1@Z@Z ENDP ; std::_Median<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
_TEXT	ENDS
PUBLIC	??$swap@PAVAnimPlayTrack@Ogre@@@std@@YAXAAPAVAnimPlayTrack@Ogre@@0@Z ; std::swap<Ogre::AnimPlayTrack *>
; Function compile flags: /Odtp
;	COMDAT ??$iter_swap@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0@Z PROC ; std::iter_swap<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>, COMDAT

; 593  : 	{	// swap *_Left and *_Right

	push	ebp
	mov	ebp, esp

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$swap@PAVAnimPlayTrack@Ogre@@@std@@YAXAAPAVAnimPlayTrack@Ogre@@0@Z ; std::swap<Ogre::AnimPlayTrack *>
	add	esp, 8

; 595  : 	}

	pop	ebp
	ret	0
??$iter_swap@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0@Z ENDP ; std::iter_swap<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Dist_type@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAHPAPAVAnimPlayTrack@Ogre@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAHPAPAVAnimPlayTrack@Ogre@@@Z PROC ; std::_Dist_type<Ogre::AnimPlayTrack * *>, COMDAT

; 1830 : 	{	// return distance type from arbitrary argument

	push	ebp
	mov	ebp, esp

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	pop	ebp
	ret	0
??$_Dist_type@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAHPAPAVAnimPlayTrack@Ogre@@@Z ENDP ; std::_Dist_type<Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@@Z PROC ; std::_Val_type<Ogre::AnimPlayTrack * *>, COMDAT

; 1765 : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	pop	ebp
	ret	0
??$_Val_type@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@@Z ENDP ; std::_Val_type<Ogre::AnimPlayTrack * *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@HHPAV12@P6A_N11@Z@Z ; std::_Adjust_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Make_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@ZPAH0@Z
_TEXT	SEGMENT
__Hole$86480 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Make_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@ZPAH0@Z PROC ; std::_Make_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 2190 : 	{	// make nontrivial [_First, _Last) into a heap, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2191 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Bottom$[ebp], eax

; 2192 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$86480[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$86480[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2193 : 		{	// reheap top half, bottom to top
; 2194 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$86480[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$86480[ebp], ecx

; 2195 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2196 : 			_Ty(*(_First + _Hole)), _Pred);

	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$86480[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Bottom$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Hole$86480[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@HHPAV12@P6A_N11@Z@Z ; std::_Adjust_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 20					; 00000014H

; 2197 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2198 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@ZPAH0@Z ENDP ; std::_Make_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ; std::pop_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
; Function compile flags: /Odtp
;	COMDAT ??$_Sort_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Sort_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z PROC ; std::_Sort_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 2232 : 	{	// order heap by repeatedly popping, using _Pred

	push	ebp
	mov	ebp, esp

; 2233 : 	for (; 1 < _Last - _First; --_Last)

	jmp	SHORT $LN3@Sort_heap
$LN2@Sort_heap:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 4
	mov	DWORD PTR __Last$[ebp], eax
$LN3@Sort_heap:
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 2
	cmp	ecx, 1
	jle	SHORT $LN4@Sort_heap

; 2234 : 		std::pop_heap(_First, _Last, _Pred);

	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$pop_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ; std::pop_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@Sort_heap
$LN4@Sort_heap:

; 2235 : 	}

	pop	ebp
	ret	0
??$_Sort_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ENDP ; std::_Sort_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy_backward<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Insertion_sort1@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@ZPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z0@Z
_TEXT	SEGMENT
__First1$86523 = -16					; size = 4
__Val$86513 = -12					; size = 4
__Next1$86512 = -8					; size = 4
__Next$86508 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@ZPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z0@Z PROC ; std::_Insertion_sort1<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *),Ogre::AnimPlayTrack *>, COMDAT

; 3123 : 	{	// insertion sort [_First, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3124 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$86508[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$86508[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$86508[ebp], edx
	mov	eax, DWORD PTR __Next$86508[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$86508[ebp]
	mov	DWORD PTR __Next1$86512[ebp], ecx

; 3128 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$86508[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$86513[ebp], eax

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Val$86513[ebp]
	push	eax
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@Insertion_

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	edx, DWORD PTR __Next1$86512[ebp]
	add	edx, 4
	mov	DWORD PTR __Next1$86512[ebp], edx
	mov	eax, DWORD PTR __Next1$86512[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$86508[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_copy_backward@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy_backward<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 12					; 0000000cH

; 3133 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$86513[ebp]
	mov	DWORD PTR [eax], ecx

; 3134 : 				}
; 3135 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;

	mov	edx, DWORD PTR __Next1$86512[ebp]
	mov	DWORD PTR __First1$86523[ebp], edx

; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	eax, DWORD PTR __First1$86523[ebp]
	mov	DWORD PTR __Next1$86512[ebp], eax
$LN3@Insertion_:
	mov	ecx, DWORD PTR __First1$86523[ebp]
	sub	ecx, 4
	mov	DWORD PTR __First1$86523[ebp], ecx
	mov	edx, DWORD PTR __First1$86523[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Val$86513[ebp]
	push	ecx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@Insertion_

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	eax, DWORD PTR __Next1$86512[ebp]
	mov	ecx, DWORD PTR __First1$86523[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	eax, DWORD PTR __Next1$86512[ebp]
	mov	ecx, DWORD PTR __Val$86513[ebp]
	mov	DWORD PTR [eax], ecx
$LN4@Insertion_:

; 3142 : 				}
; 3143 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 3144 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@ZPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z0@Z ENDP ; std::_Insertion_sort1<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *),Ogre::AnimPlayTrack *>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEPBUTriggerDesc@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Checked_iterator_base
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEPBUTriggerDesc@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTriggerDesc@Ogre@@AAV?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEPBUSequenceDesc@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEPBUSequenceDesc@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUSequenceDesc@Ogre@@AAV?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEPBQAVBoneTrack@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEPBQAVBoneTrack@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVBoneTrack@Ogre@@AAV?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEPBQAVMaterialParamTrack@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEPBQAVMaterialParamTrack@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMaterialParamTrack@Ogre@@AAV?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEPBQAVAnimPlayTrack@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVAnimPlayTrack@Ogre@@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVAnimPlayTrack@Ogre@@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEPBQAVAnimPlayTrack@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVAnimPlayTrack@Ogre@@AAV?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ ; std::_Vector_const_iterator<char,std::allocator<char> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ ; std::_Vector_const_iterator<char,std::allocator<char> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEPBIXZ ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEPBIXZ ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBIAAV?$_Vector_const_iterator@IV?$allocator@I@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEPBQAVSubMeshInstance@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSubMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSubMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEPBQAVSubMeshInstance@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSubMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEPBQAVMeshInstance@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEPBQAVMeshInstance@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVMeshInstance@Ogre@@AAV?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEPBQAVModelAnchorNode@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVModelAnchorNode@Ogre@@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVModelAnchorNode@Ogre@@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEPBQAVModelAnchorNode@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVModelAnchorNode@Ogre@@AAV?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVAnimPlayTrack@Ogre@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVAnimPlayTrack@Ogre@@@Z PROC ; std::_Iter_cat<Ogre::AnimPlayTrack * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAVAnimPlayTrack@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVAnimPlayTrack@Ogre@@@Z ENDP ; std::_Iter_cat<Ogre::AnimPlayTrack * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T95049 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T95049[ebp], al
	movzx	ecx, BYTE PTR $T95049[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@UTriggerDesc@Ogre@@U12@@std@@YAXPAUTriggerDesc@Ogre@@ABU12@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T95052 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UTriggerDesc@Ogre@@U12@@std@@YAXPAUTriggerDesc@Ogre@@ABU12@@Z PROC ; std::_Construct<Ogre::TriggerDesc,Ogre::TriggerDesc>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T95052[ebp], eax
	cmp	DWORD PTR $T95052[ebp], 0
	je	SHORT $LN3@Construct@6
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T95052[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T95052[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@6
$LN3@Construct@6:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@6:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UTriggerDesc@Ogre@@U12@@std@@YAXPAUTriggerDesc@Ogre@@ABU12@@Z ENDP ; std::_Construct<Ogre::TriggerDesc,Ogre::TriggerDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@USequenceDesc@Ogre@@U12@@std@@YAXPAUSequenceDesc@Ogre@@ABU12@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T95057 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@USequenceDesc@Ogre@@U12@@std@@YAXPAUSequenceDesc@Ogre@@ABU12@@Z PROC ; std::_Construct<Ogre::SequenceDesc,Ogre::SequenceDesc>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T95057[ebp], eax
	cmp	DWORD PTR $T95057[ebp], 0
	je	SHORT $LN3@Construct@7
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T95057[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T95057[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@7
$LN3@Construct@7:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@7:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@USequenceDesc@Ogre@@U12@@std@@YAXPAUSequenceDesc@Ogre@@ABU12@@Z ENDP ; std::_Construct<Ogre::SequenceDesc,Ogre::SequenceDesc>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEPBUTriggerDesc@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEPBUTriggerDesc@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UTriggerDesc@Ogre@@V?$allocator@UTriggerDesc@Ogre@@@std@@@std@@QBEPBUTriggerDesc@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::TriggerDesc,std::allocator<Ogre::TriggerDesc> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEPBUSequenceDesc@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEPBUSequenceDesc@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@USequenceDesc@Ogre@@V?$allocator@USequenceDesc@Ogre@@@std@@@std@@QBEPBUSequenceDesc@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::SequenceDesc,std::allocator<Ogre::SequenceDesc> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEPBQAVBoneTrack@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEPBQAVBoneTrack@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVBoneTrack@Ogre@@V?$allocator@PAVBoneTrack@Ogre@@@std@@@std@@QBEPBQAVBoneTrack@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::BoneTrack *,std::allocator<Ogre::BoneTrack *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEPBQAVMaterialParamTrack@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEPBQAVMaterialParamTrack@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVMaterialParamTrack@Ogre@@V?$allocator@PAVMaterialParamTrack@Ogre@@@std@@@std@@QBEPBQAVMaterialParamTrack@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::MaterialParamTrack *,std::allocator<Ogre::MaterialParamTrack *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEPBQAVAnimPlayTrack@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEPBQAVAnimPlayTrack@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVAnimPlayTrack@Ogre@@V?$allocator@PAVAnimPlayTrack@Ogre@@@std@@@std@@QBEPBQAVAnimPlayTrack@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::AnimPlayTrack *,std::allocator<Ogre::AnimPlayTrack *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEPBIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEPBIXZ PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEPBIXZ ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEPBQAVSubMeshInstance@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEPBQAVSubMeshInstance@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVSubMeshInstance@Ogre@@V?$allocator@PAVSubMeshInstance@Ogre@@@std@@@std@@QBEPBQAVSubMeshInstance@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::SubMeshInstance *,std::allocator<Ogre::SubMeshInstance *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEPBQAVMeshInstance@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEPBQAVMeshInstance@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVMeshInstance@Ogre@@V?$allocator@PAVMeshInstance@Ogre@@@std@@@std@@QBEPBQAVMeshInstance@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::MeshInstance *,std::allocator<Ogre::MeshInstance *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEPBQAVModelAnchorNode@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEPBQAVModelAnchorNode@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVModelAnchorNode@Ogre@@V?$allocator@PAVModelAnchorNode@Ogre@@@std@@@std@@QBEPBQAVModelAnchorNode@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::ModelAnchorNode *,std::allocator<Ogre::ModelAnchorNode *> >::_Checked_iterator_base
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Med3@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00P6A_NPAV12@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Med3@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00P6A_NPAV12@1@Z@Z PROC ; std::_Med3<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 3156 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp

; 3157 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@Med3

; 3158 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	call	??$iter_swap@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::iter_swap<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
$LN3@Med3:

; 3159 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@Med3

; 3160 : 		std::iter_swap(_Last, _Mid);

	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$iter_swap@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::iter_swap<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
$LN2@Med3:

; 3161 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Med3

; 3162 : 		std::iter_swap(_Mid, _First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	call	??$iter_swap@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@0@Z ; std::iter_swap<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
$LN4@Med3:

; 3163 : 	}

	pop	ebp
	ret	0
??$_Med3@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00P6A_NPAV12@1@Z@Z ENDP ; std::_Med3<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@PAVAnimPlayTrack@Ogre@@@std@@YAXAAPAVAnimPlayTrack@Ogre@@0@Z
_TEXT	SEGMENT
__Tmp$86590 = -4					; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAVAnimPlayTrack@Ogre@@@std@@YAXAAPAVAnimPlayTrack@Ogre@@0@Z PROC ; std::swap<Ogre::AnimPlayTrack *>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	ecx

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$86590[ebp], edx

; 21   : 
; 22   : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 23   : 		_Right = _Tmp;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Tmp$86590[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@swap@2:

; 24   : 		}
; 25   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@PAVAnimPlayTrack@Ogre@@@std@@YAXAAPAVAnimPlayTrack@Ogre@@0@Z ENDP ; std::swap<Ogre::AnimPlayTrack *>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@HHPAV12@P6A_N11@Z@Z ; std::_Push_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Adjust_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@HHPAV12@P6A_N11@Z@Z
_TEXT	SEGMENT
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Adjust_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@HHPAV12@P6A_N11@Z@Z PROC ; std::_Adjust_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 2108 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 2109 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2110 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2111 : 
; 2112 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea

; 2113 : 		{	// move _Hole down to larger child
; 2114 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4-4]
	push	edx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Adjust_hea

; 2115 : 			--_Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Idx$[ebp], ecx
$LN2@Adjust_hea:

; 2116 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	edx, DWORD PTR __Hole$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], edx

; 2117 : 		}

	jmp	SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2118 : 
; 2119 : 	if (_Idx == _Bottom)

	mov	eax, DWORD PTR __Idx$[ebp]
	cmp	eax, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2120 : 		{	// only child at bottom, move _Hole down to it
; 2121 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Bottom$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [esi+eax*4-4]
	mov	DWORD PTR [edx+ecx*4], eax

; 2122 : 		_Hole = _Bottom - 1;

	mov	ecx, DWORD PTR __Bottom$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$[ebp], ecx
$LN1@Adjust_hea:

; 2123 : 		}
; 2124 : 	std::_Push_heap(_First, _Hole, _Top, _Val, _Pred);

	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Top$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Hole$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Push_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@HHPAV12@P6A_N11@Z@Z ; std::_Push_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 20					; 00000014H

; 2125 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@HHPAV12@P6A_N11@Z@Z ENDP ; std::_Adjust_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAPAVAnimPlayTrack@Ogre@@PAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z0@Z ; std::_Pop_heap_0<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
; Function compile flags: /Odtp
;	COMDAT ??$pop_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$pop_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z PROC ; std::pop_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 2151 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

	push	ebp
	mov	ebp, esp

; 2152 : 	_DEBUG_RANGE(_First, _Last);
; 2153 : 	_DEBUG_POINTER(_Pred);
; 2154 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2155 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	cmp	eax, 1
	jle	SHORT $LN2@pop_heap

; 2156 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Pred, _Val_type(_First));

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Val_type@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@@Z ; std::_Val_type<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Pred$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	call	??$_Pop_heap_0@PAPAVAnimPlayTrack@Ogre@@PAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z0@Z ; std::_Pop_heap_0<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 16					; 00000010H
$LN2@pop_heap:

; 2157 : 	}

	pop	ebp
	ret	0
??$pop_heap@PAPAVAnimPlayTrack@Ogre@@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z@Z ENDP ; std::pop_heap<Ogre::AnimPlayTrack * *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy_backward@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T95094 = -3						; size = 1
$T95093 = -2						; size = 1
$T95092 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy_backward<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T95092[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVAnimPlayTrack@Ogre@@0@Z ; std::_Ptr_cat<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 8
	mov	BYTE PTR $T95093[ebp], al
	movzx	eax, BYTE PTR $T95092[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T95093[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T95094[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVAnimPlayTrack@Ogre@@0@Z ; std::_Iter_random<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAPAVAnimPlayTrack@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	call	??$_Copy_backward_opt@PAPAVAnimPlayTrack@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3639 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy_backward@PAPAVAnimPlayTrack@Ogre@@PAPAV12@@stdext@@YAPAPAVAnimPlayTrack@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy_backward<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n
$LN2@Fill_n:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n
$LN4@Fill_n:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAVAnimPlayTrack@Ogre@@IPAV12@@std@@YAXPAPAVAnimPlayTrack@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::AnimPlayTrack * *,unsigned int,Ogre::AnimPlayTrack *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Push_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@HHPAV12@P6A_N11@Z@Z
_TEXT	SEGMENT
__Idx$86630 = -4					; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Push_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@HHPAV12@P6A_N11@Z@Z PROC ; std::_Push_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 2013 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2014 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	eax, DWORD PTR __Hole$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$86630[ebp], eax

; 2015 : 		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);
; 2016 : 		_Idx = (_Hole - 1) / 2)

	jmp	SHORT $LN3@Push_heap
$LN2@Push_heap:
	mov	eax, DWORD PTR __Hole$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$86630[ebp], eax
$LN3@Push_heap:
	mov	eax, DWORD PTR __Top$[ebp]
	cmp	eax, DWORD PTR __Hole$[ebp]
	jge	SHORT $LN1@Push_heap
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Idx$86630[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@Push_heap

; 2017 : 		{	// move _Hole up to parent
; 2018 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Idx$86630[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 2019 : 		_Hole = _Idx;

	mov	eax, DWORD PTR __Idx$86630[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2020 : 		}

	jmp	SHORT $LN2@Push_heap
$LN1@Push_heap:

; 2021 : 
; 2022 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 2023 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Push_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@HHPAV12@P6A_N11@Z@Z ENDP ; std::_Push_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00PAV12@P6A_N11@ZPAH@Z ; std::_Pop_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
; Function compile flags: /Odtp
;	COMDAT ??$_Pop_heap_0@PAPAVAnimPlayTrack@Ogre@@PAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Pop_heap_0@PAPAVAnimPlayTrack@Ogre@@PAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z0@Z PROC ; std::_Pop_heap_0<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 2143 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

	push	ebp
	mov	ebp, esp

; 2144 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2145 : 		_Ty(*(_Last - 1)), _Pred, _Dist_type(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Dist_type@PAPAVAnimPlayTrack@Ogre@@@std@@YAPAHPAPAVAnimPlayTrack@Ogre@@@Z ; std::_Dist_type<Ogre::AnimPlayTrack * *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx-4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 4
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, 4
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Pop_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00PAV12@P6A_N11@ZPAH@Z ; std::_Pop_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 24					; 00000018H

; 2146 : 	}

	pop	ebp
	ret	0
??$_Pop_heap_0@PAPAVAnimPlayTrack@Ogre@@PAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@0P6A_NPAV12@1@Z0@Z ENDP ; std::_Pop_heap_0<Ogre::AnimPlayTrack * *,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00PAV12@P6A_N11@ZPAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 4
___formal$ = 28						; size = 4
??$_Pop_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00PAV12@P6A_N11@ZPAH@Z PROC ; std::_Pop_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>, COMDAT

; 2133 : 	{	// pop *_First to *_Dest and reheap, using _Pred

	push	ebp
	mov	ebp, esp

; 2134 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 2135 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2136 : 		_Val, _Pred);

	mov	eax, DWORD PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Adjust_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@HHPAV12@P6A_N11@Z@Z ; std::_Adjust_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
	add	esp, 20					; 00000014H

; 2137 : 	}

	pop	ebp
	ret	0
??$_Pop_heap@PAPAVAnimPlayTrack@Ogre@@HPAV12@P6A_NPAV12@0@Z@std@@YAXPAPAVAnimPlayTrack@Ogre@@00PAV12@P6A_N11@ZPAH@Z ENDP ; std::_Pop_heap<Ogre::AnimPlayTrack * *,int,Ogre::AnimPlayTrack *,bool (__cdecl*)(Ogre::AnimPlayTrack *,Ogre::AnimPlayTrack *)>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EModel@Ogre@@OBBI@AEPAXI@Z
_TEXT	SEGMENT
??_EModel@Ogre@@OBBI@AEPAXI@Z PROC			; [thunk]:Ogre::Model::`vector deleting destructor', COMDAT
	sub	ecx, 280				; 00000118H
	jmp	??_EModel@Ogre@@MAEPAXI@Z
??_EModel@Ogre@@OBBI@AEPAXI@Z ENDP			; [thunk]:Ogre::Model::`vector deleting destructor'
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
_TEXT	ENDS
;	COMDAT ??__ETWO_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__ETWO_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'TWO_PI'', COMDAT

; 10   : 	const float TWO_PI = ONE_PI*2;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _TWO_PI
	pop	ebp
	ret	0
??__ETWO_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'TWO_PI''
text$yc	ENDS
PUBLIC	__real@3fe0000000000000
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??__EHALF_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__EHALF_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'HALF_PI'', COMDAT

; 11   : 	const float	HALF_PI = ONE_PI*0.5f;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	DWORD PTR _HALF_PI
	pop	ebp
	ret	0
??__EHALF_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'HALF_PI''
text$yc	ENDS
_BSS	SEGMENT
_TWO_PI	DD	01H DUP (?)
_HALF_PI DD	01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_TWO_PI$initializer$ DD FLAT:??__ETWO_PI@Ogre@@YAXXZ
_HALF_PI$initializer$ DD FLAT:??__EHALF_PI@Ogre@@YAXXZ
CRT$XCU	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\OgreInputManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?_EEM_DS@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@2HB ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_EEM_DS
PUBLIC	?ms_Singleton@?$Singleton@VInputManager@Ogre@@@Ogre@@1PAVInputManager@2@A ; Ogre::Singleton<Ogre::InputManager>::ms_Singleton
;	COMDAT ?ms_Singleton@?$Singleton@VInputManager@Ogre@@@Ogre@@1PAVInputManager@2@A
_BSS	SEGMENT
?ms_Singleton@?$Singleton@VInputManager@Ogre@@@Ogre@@1PAVInputManager@2@A DD 01H DUP (?) ; Ogre::Singleton<Ogre::InputManager>::ms_Singleton
_BSS	ENDS
;	COMDAT ?_EEM_DS@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@2HB DD 01H ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_EEM_DS
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG68011
_DATA	ENDS
CONST	SEGMENT
$SG68011 DB	'bad allocation', 00H
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
PUBLIC	?setSelfHandler@InputManager@Ogre@@QAEXPAVInputHandler@2@@Z ; Ogre::InputManager::setSelfHandler
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreinputmanager.h
;	COMDAT ?setSelfHandler@InputManager@Ogre@@QAEXPAVInputHandler@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pHandler$ = 8						; size = 4
?setSelfHandler@InputManager@Ogre@@QAEXPAVInputHandler@2@@Z PROC ; Ogre::InputManager::setSelfHandler, COMDAT
; _this$ = ecx

; 23   : 		void setSelfHandler(InputHandler* pHandler) { m_pSelfHandler = pHandler; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pHandler$[ebp]
	mov	DWORD PTR [eax+68], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?setSelfHandler@InputManager@Ogre@@QAEXPAVInputHandler@2@@Z ENDP ; Ogre::InputManager::setSelfHandler
_TEXT	ENDS
PUBLIC	??4?$Singleton@VInputManager@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::Singleton<Ogre::InputManager>::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$Singleton@VInputManager@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Singleton@VInputManager@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z PROC ; Ogre::Singleton<Ogre::InputManager>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Singleton@VInputManager@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z ENDP ; Ogre::Singleton<Ogre::InputManager>::operator=
_TEXT	ENDS
PUBLIC	??1?$Singleton@VInputManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::InputManager>::~Singleton<Ogre::InputManager>
PUBLIC	??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::~deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
PUBLIC	??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::~vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
PUBLIC	??1InputManager@Ogre@@QAE@XZ			; Ogre::InputManager::~InputManager
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1InputManager@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1InputManager@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1InputManager@Ogre@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1InputManager@Ogre@@QAE@XZ$2
__ehfuncinfo$??1InputManager@Ogre@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1InputManager@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1InputManager@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1InputManager@Ogre@@QAE@XZ PROC			; Ogre::InputManager::~InputManager, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1InputManager@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::~vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::~deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$Singleton@VInputManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::InputManager>::~Singleton<Ogre::InputManager>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1InputManager@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$Singleton@VInputManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::InputManager>::~Singleton<Ogre::InputManager>
__unwindfunclet$??1InputManager@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::~deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
__unwindfunclet$??1InputManager@Ogre@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::~vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
__ehhandler$??1InputManager@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1InputManager@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1InputManager@Ogre@@QAE@XZ ENDP			; Ogre::InputManager::~InputManager
PUBLIC	??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
PUBLIC	??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
PUBLIC	??0InputManager@Ogre@@QAE@ABV01@@Z		; Ogre::InputManager::InputManager
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0InputManager@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0InputManager@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0InputManager@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0InputManager@Ogre@@QAE@ABV01@@Z$2
__ehfuncinfo$??0InputManager@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0InputManager@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0InputManager@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0InputManager@Ogre@@QAE@ABV01@@Z PROC			; Ogre::InputManager::InputManager, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0InputManager@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR [edx+56], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+60], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+64]
	mov	BYTE PTR [edx+64], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+65]
	mov	BYTE PTR [edx+65], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [edx+68], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0InputManager@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$Singleton@VInputManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::InputManager>::~Singleton<Ogre::InputManager>
__unwindfunclet$??0InputManager@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::~deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
__unwindfunclet$??0InputManager@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::~vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
__ehhandler$??0InputManager@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0InputManager@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0InputManager@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::InputManager::InputManager
PUBLIC	??4?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator=
PUBLIC	??4?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::operator=
PUBLIC	??4InputManager@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::InputManager::operator=
; Function compile flags: /Odtp
;	COMDAT ??4InputManager@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4InputManager@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::InputManager::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR [edx+56], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+60], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+64]
	mov	BYTE PTR [edx+64], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+65]
	mov	BYTE PTR [edx+65], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [edx+68], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4InputManager@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::InputManager::operator=
_TEXT	ENDS
PUBLIC	??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
PUBLIC	??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
PUBLIC	??0?$Singleton@VInputManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::InputManager>::Singleton<Ogre::InputManager>
PUBLIC	??0InputManager@Ogre@@QAE@XZ			; Ogre::InputManager::InputManager
xdata$x	SEGMENT
__unwindtable$??0InputManager@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0InputManager@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0InputManager@Ogre@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0InputManager@Ogre@@QAE@XZ$2
__ehfuncinfo$??0InputManager@Ogre@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0InputManager@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreinputmanager.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0InputManager@Ogre@@QAE@XZ PROC			; Ogre::InputManager::InputManager
; _this$ = ecx

; 16   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0InputManager@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$Singleton@VInputManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::InputManager>::Singleton<Ogre::InputManager>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+64], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+65], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 17   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0InputManager@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$Singleton@VInputManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::InputManager>::~Singleton<Ogre::InputManager>
__unwindfunclet$??0InputManager@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::~deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
__unwindfunclet$??0InputManager@Ogre@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::~vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
__ehhandler$??0InputManager@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0InputManager@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0InputManager@Ogre@@QAE@XZ ENDP			; Ogre::InputManager::InputManager
PUBLIC	?push_back@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEXABQAVInputHandler@Ogre@@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::push_back
PUBLIC	?RegisterInputHandler@InputManager@Ogre@@QAEXPAVInputHandler@2@@Z ; Ogre::InputManager::RegisterInputHandler
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_phandler$ = 8						; size = 4
?RegisterInputHandler@InputManager@Ogre@@QAEXPAVInputHandler@2@@Z PROC ; Ogre::InputManager::RegisterInputHandler
; _this$ = ecx

; 20   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 21   : 		m_Handles.push_back(phandler);

	lea	eax, DWORD PTR _phandler$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?push_back@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEXABQAVInputHandler@Ogre@@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::push_back

; 22   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?RegisterInputHandler@InputManager@Ogre@@QAEXPAVInputHandler@2@@Z ENDP ; Ogre::InputManager::RegisterInputHandler
_TEXT	ENDS
PUBLIC	?IsKeyDown@InputManager@Ogre@@QAE_NH@Z		; Ogre::InputManager::IsKeyDown
EXTRN	__imp__GetAsyncKeyState@4:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vkey$ = 8						; size = 4
?IsKeyDown@InputManager@Ogre@@QAE_NH@Z PROC		; Ogre::InputManager::IsKeyDown
; _this$ = ecx

; 49   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 		return (GetAsyncKeyState(vkey)&0xff00) != 0;

	mov	eax, DWORD PTR _vkey$[ebp]
	push	eax
	call	DWORD PTR __imp__GetAsyncKeyState@4
	cwde
	and	eax, 65280				; 0000ff00H
	neg	eax
	sbb	eax, eax
	neg	eax

; 51   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?IsKeyDown@InputManager@Ogre@@QAE_NH@Z ENDP		; Ogre::InputManager::IsKeyDown
_TEXT	ENDS
PUBLIC	?ShowSystemCursor@InputManager@Ogre@@QAEX_N@Z	; Ogre::InputManager::ShowSystemCursor
EXTRN	__imp__ShowCursor@4:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_b$ = 8							; size = 1
?ShowSystemCursor@InputManager@Ogre@@QAEX_N@Z PROC	; Ogre::InputManager::ShowSystemCursor
; _this$ = ecx

; 54   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 		if(b)

	movzx	eax, BYTE PTR _b$[ebp]
	test	eax, eax
	je	SHORT $LN2@ShowSystem
$LN5@ShowSystem:

; 56   : 		{
; 57   : 			while(ShowCursor(TRUE) < 0);

	push	1
	call	DWORD PTR __imp__ShowCursor@4
	test	eax, eax
	jge	SHORT $LN4@ShowSystem
	jmp	SHORT $LN5@ShowSystem
$LN4@ShowSystem:

; 58   : 		}
; 59   : 		else

	jmp	SHORT $LN7@ShowSystem
$LN2@ShowSystem:

; 60   : 		{
; 61   : 			while(ShowCursor(FALSE) >= 0);

	push	0
	call	DWORD PTR __imp__ShowCursor@4
	test	eax, eax
	jl	SHORT $LN7@ShowSystem
	jmp	SHORT $LN2@ShowSystem
$LN7@ShowSystem:

; 62   : 		}
; 63   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?ShowSystemCursor@InputManager@Ogre@@QAEX_N@Z ENDP	; Ogre::InputManager::ShowSystemCursor
_TEXT	ENDS
PUBLIC	??A?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAPAVInputHandler@Ogre@@I@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator[]
PUBLIC	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
PUBLIC	__real@405e000000000000
PUBLIC	?push_back@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXABUInputEvent@Ogre@@@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::push_back
PUBLIC	?IsPointIn@InputManager@Ogre@@QAE_NHH@Z		; Ogre::InputManager::IsPointIn
PUBLIC	??$find@PAHI@std@@YAPAHPAH0ABI@Z		; std::find<int *,unsigned int>
PUBLIC	?OnWindowMessage@InputManager@Ogre@@QAEXPAXIII@Z ; Ogre::InputManager::OnWindowMessage
EXTRN	__fltused:DWORD
;	COMDAT __real@405e000000000000
CONST	SEGMENT
__real@405e000000000000 DQ 0405e000000000000r	; 120
CONST	ENDS
;	COMDAT ?s_canKeepKeyDown@?4??OnWindowMessage@InputManager@Ogre@@QAEXPAXIII@Z@4PAHA
_DATA	SEGMENT
?s_canKeepKeyDown@?4??OnWindowMessage@InputManager@Ogre@@QAEXPAXIII@Z@4PAHA DD 025H ; `Ogre::InputManager::OnWindowMessage'::`5'::s_canKeepKeyDown
	DD	027H
; Function compile flags: /Odtp
_DATA	ENDS
_TEXT	SEGMENT
tv236 = -60						; size = 4
tv301 = -56						; size = 4
tv64 = -52						; size = 4
_this$ = -48						; size = 4
_i$117713 = -44						; size = 4
_ev2$117692 = -40					; size = 16
_new_mousein$117686 = -21				; size = 1
_pEnd$117664 = -20					; size = 4
_ev$ = -16						; size = 16
_hwnd$ = 8						; size = 4
_msgid$ = 12						; size = 4
_wparam$ = 16						; size = 4
_lparam$ = 20						; size = 4
?OnWindowMessage@InputManager@Ogre@@QAEXPAXIII@Z PROC	; Ogre::InputManager::OnWindowMessage
; _this$ = ecx

; 66   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 		InputEvent ev;
; 68   : 		ev.msg = MAX_INPUT_EVENT;

	mov	DWORD PTR _ev$[ebp], 16			; 00000010H

; 69   : 		switch(msgid)

	mov	eax, DWORD PTR _msgid$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 512		; 00000200H
	ja	SHORT $LN33@OnWindowMe
	cmp	DWORD PTR tv64[ebp], 512		; 00000200H
	je	$LN14@OnWindowMe
	cmp	DWORD PTR tv64[ebp], 256		; 00000100H
	ja	SHORT $LN34@OnWindowMe
	cmp	DWORD PTR tv64[ebp], 256		; 00000100H
	je	SHORT $LN27@OnWindowMe
	cmp	DWORD PTR tv64[ebp], 5
	je	$LN10@OnWindowMe
	cmp	DWORD PTR tv64[ebp], 7
	je	$LN9@OnWindowMe
	cmp	DWORD PTR tv64[ebp], 8
	je	$LN8@OnWindowMe
	jmp	$LN7@OnWindowMe
$LN34@OnWindowMe:
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 257				; 00000101H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 4
	ja	$LN7@OnWindowMe
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN35@OnWindowMe[edx*4]
$LN33@OnWindowMe:
	mov	eax, DWORD PTR tv64[ebp]
	sub	eax, 513				; 00000201H
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 9
	ja	$LN7@OnWindowMe
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN36@OnWindowMe[ecx*4]
$LN28@OnWindowMe:

; 70   : 		{
; 71   : 		case WM_CHAR:
; 72   : 			ev.msg = GIE_CHAR;

	mov	DWORD PTR _ev$[ebp], 0

; 73   : 			ev.chars.str[0] = (char)wparam;

	mov	dl, BYTE PTR _wparam$[ebp]
	mov	BYTE PTR _ev$[ebp+4], dl

; 74   : 			ev.chars.str[1] = 0;

	mov	BYTE PTR _ev$[ebp+5], 0

; 75   : 			break;

	jmp	$LN29@OnWindowMe
$LN27@OnWindowMe:

; 76   : 
; 77   : 		case WM_SYSKEYDOWN:
; 78   : 		case WM_KEYDOWN:
; 79   : 			{
; 80   : 				static int s_canKeepKeyDown[] = { VK_LEFT, VK_RIGHT };
; 81   : 				int* pEnd = s_canKeepKeyDown + sizeof( s_canKeepKeyDown ) / sizeof( int );

	mov	DWORD PTR _pEnd$117664[ebp], OFFSET ?s_canKeepKeyDown@?4??OnWindowMessage@InputManager@Ogre@@QAEXPAXIII@Z@4PAHA+8

; 82   : 				if ( std::find( s_canKeepKeyDown, pEnd, wparam ) == pEnd &&
; 83   : 					( lparam & PREV_KEYDOWN ) != 0 )

	lea	eax, DWORD PTR _wparam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEnd$117664[ebp]
	push	ecx
	push	OFFSET ?s_canKeepKeyDown@?4??OnWindowMessage@InputManager@Ogre@@QAEXPAXIII@Z@4PAHA
	call	??$find@PAHI@std@@YAPAHPAH0ABI@Z	; std::find<int *,unsigned int>
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _pEnd$117664[ebp]
	jne	SHORT $LN26@OnWindowMe
	mov	edx, DWORD PTR _lparam$[ebp]
	and	edx, 1073741824				; 40000000H
	je	SHORT $LN26@OnWindowMe

; 84   : 				{
; 85   : 
; 86   : 					return;

	jmp	$LN31@OnWindowMe
$LN26@OnWindowMe:

; 87   : 				}
; 88   : 				
; 89   : 				ev.msg = GIE_KEYDOWN;

	mov	DWORD PTR _ev$[ebp], 1

; 90   : 				ev.key.vkey = wparam;

	mov	eax, DWORD PTR _wparam$[ebp]
	mov	DWORD PTR _ev$[ebp+4], eax

; 91   : 				ev.key.flags = GetKeyFlags();

	call	?GetKeyFlags@Ogre@@YAIXZ		; Ogre::GetKeyFlags
	mov	DWORD PTR _ev$[ebp+8], eax

; 92   : 				break;

	jmp	$LN29@OnWindowMe
$LN25@OnWindowMe:

; 93   : 			}
; 94   : 
; 95   : 		case WM_SYSKEYUP:
; 96   : 		case WM_KEYUP:
; 97   : 			ev.msg = GIE_KEYUP;

	mov	DWORD PTR _ev$[ebp], 2

; 98   : 			ev.key.vkey = wparam;

	mov	ecx, DWORD PTR _wparam$[ebp]
	mov	DWORD PTR _ev$[ebp+4], ecx

; 99   : 			ev.key.flags = GetKeyFlags();

	call	?GetKeyFlags@Ogre@@YAIXZ		; Ogre::GetKeyFlags
	mov	DWORD PTR _ev$[ebp+8], eax

; 100  : 			break;

	jmp	$LN29@OnWindowMe
$LN24@OnWindowMe:

; 101  : 
; 102  : 		case WM_LBUTTONDOWN:
; 103  : 			ev.msg = GIE_LBTNDOWN;

	mov	DWORD PTR _ev$[ebp], 3

; 104  : 			GetMouseEventData(ev, wparam, lparam);

	mov	edx, DWORD PTR _lparam$[ebp]
	push	edx
	mov	eax, DWORD PTR _wparam$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ev$[ebp]
	push	ecx
	call	?GetMouseEventData@Ogre@@YAXAAUInputEvent@1@II@Z ; Ogre::GetMouseEventData
	add	esp, 12					; 0000000cH

; 105  : 			if(!IsPointIn(ev.mouse.x, ev.mouse.y)) return;

	movsx	edx, WORD PTR _ev$[ebp+6]
	push	edx
	movsx	eax, WORD PTR _ev$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPointIn@InputManager@Ogre@@QAE_NHH@Z	; Ogre::InputManager::IsPointIn
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN23@OnWindowMe
	jmp	$LN31@OnWindowMe
$LN23@OnWindowMe:

; 106  : 			break;

	jmp	$LN29@OnWindowMe
$LN22@OnWindowMe:

; 107  : 
; 108  : 		case WM_LBUTTONUP:
; 109  : 			ev.msg = GIE_LBTNUP;

	mov	DWORD PTR _ev$[ebp], 4

; 110  : 			GetMouseEventData(ev, wparam, lparam);

	mov	edx, DWORD PTR _lparam$[ebp]
	push	edx
	mov	eax, DWORD PTR _wparam$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ev$[ebp]
	push	ecx
	call	?GetMouseEventData@Ogre@@YAXAAUInputEvent@1@II@Z ; Ogre::GetMouseEventData
	add	esp, 12					; 0000000cH

; 111  : 			break;

	jmp	$LN29@OnWindowMe
$LN21@OnWindowMe:

; 112  : 
; 113  : 		case WM_LBUTTONDBLCLK:
; 114  : 			ev.msg = GIE_LBTNDBLCLK;

	mov	DWORD PTR _ev$[ebp], 5

; 115  : 			GetMouseEventData(ev, wparam, lparam);

	mov	edx, DWORD PTR _lparam$[ebp]
	push	edx
	mov	eax, DWORD PTR _wparam$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ev$[ebp]
	push	ecx
	call	?GetMouseEventData@Ogre@@YAXAAUInputEvent@1@II@Z ; Ogre::GetMouseEventData
	add	esp, 12					; 0000000cH

; 116  : 			if(!IsPointIn(ev.mouse.x, ev.mouse.y)) return;

	movsx	edx, WORD PTR _ev$[ebp+6]
	push	edx
	movsx	eax, WORD PTR _ev$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPointIn@InputManager@Ogre@@QAE_NHH@Z	; Ogre::InputManager::IsPointIn
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN20@OnWindowMe
	jmp	$LN31@OnWindowMe
$LN20@OnWindowMe:

; 117  : 			break;

	jmp	$LN29@OnWindowMe
$LN19@OnWindowMe:

; 118  : 
; 119  : 		case WM_RBUTTONDOWN:
; 120  : 			ev.msg = GIE_RBTNDOWN;

	mov	DWORD PTR _ev$[ebp], 6

; 121  : 			GetMouseEventData(ev, wparam, lparam);

	mov	edx, DWORD PTR _lparam$[ebp]
	push	edx
	mov	eax, DWORD PTR _wparam$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ev$[ebp]
	push	ecx
	call	?GetMouseEventData@Ogre@@YAXAAUInputEvent@1@II@Z ; Ogre::GetMouseEventData
	add	esp, 12					; 0000000cH

; 122  : 			if(!IsPointIn(ev.mouse.x, ev.mouse.y)) return;

	movsx	edx, WORD PTR _ev$[ebp+6]
	push	edx
	movsx	eax, WORD PTR _ev$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPointIn@InputManager@Ogre@@QAE_NHH@Z	; Ogre::InputManager::IsPointIn
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN18@OnWindowMe
	jmp	$LN31@OnWindowMe
$LN18@OnWindowMe:

; 123  : 			break;

	jmp	$LN29@OnWindowMe
$LN17@OnWindowMe:

; 124  : 
; 125  : 		case WM_RBUTTONUP:
; 126  : 			ev.msg = GIE_RBTNUP;

	mov	DWORD PTR _ev$[ebp], 7

; 127  : 			GetMouseEventData(ev, wparam, lparam);

	mov	edx, DWORD PTR _lparam$[ebp]
	push	edx
	mov	eax, DWORD PTR _wparam$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ev$[ebp]
	push	ecx
	call	?GetMouseEventData@Ogre@@YAXAAUInputEvent@1@II@Z ; Ogre::GetMouseEventData
	add	esp, 12					; 0000000cH

; 128  : 			break;

	jmp	$LN29@OnWindowMe
$LN16@OnWindowMe:

; 129  : 
; 130  : 		case WM_RBUTTONDBLCLK:
; 131  : 			ev.msg = GIE_RBTNDBLCLK;

	mov	DWORD PTR _ev$[ebp], 8

; 132  : 			GetMouseEventData(ev, wparam, lparam);

	mov	edx, DWORD PTR _lparam$[ebp]
	push	edx
	mov	eax, DWORD PTR _wparam$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ev$[ebp]
	push	ecx
	call	?GetMouseEventData@Ogre@@YAXAAUInputEvent@1@II@Z ; Ogre::GetMouseEventData
	add	esp, 12					; 0000000cH

; 133  : 			if(!IsPointIn(ev.mouse.x, ev.mouse.y)) return;

	movsx	edx, WORD PTR _ev$[ebp+6]
	push	edx
	movsx	eax, WORD PTR _ev$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPointIn@InputManager@Ogre@@QAE_NHH@Z	; Ogre::InputManager::IsPointIn
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN15@OnWindowMe
	jmp	$LN31@OnWindowMe
$LN15@OnWindowMe:

; 134  : 			break;

	jmp	$LN29@OnWindowMe
$LN14@OnWindowMe:

; 135  : 
; 136  : 		case WM_MOUSEMOVE:
; 137  : 			{
; 138  : 				bool new_mousein = IsPointIn(LOWORD(lparam), HIWORD(lparam));

	mov	edx, DWORD PTR _lparam$[ebp]
	shr	edx, 16					; 00000010H
	and	edx, 65535				; 0000ffffH
	movzx	eax, dx
	push	eax
	mov	ecx, DWORD PTR _lparam$[ebp]
	and	ecx, 65535				; 0000ffffH
	movzx	edx, cx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPointIn@InputManager@Ogre@@QAE_NHH@Z	; Ogre::InputManager::IsPointIn
	mov	BYTE PTR _new_mousein$117686[ebp], al

; 139  : 				if(m_IsMouseIn != new_mousein)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+64]
	movzx	edx, BYTE PTR _new_mousein$117686[ebp]
	cmp	ecx, edx
	je	SHORT $LN12@OnWindowMe

; 140  : 				{
; 141  : 					//ShowSystemCursor(!new_mousein);
; 142  : 					//if(!new_mousein) ::ReleaseCapture();
; 143  : 					//else ::SetCapture((HWND)hwnd);
; 144  : 
; 145  : 					m_IsMouseIn = new_mousein;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _new_mousein$117686[ebp]
	mov	BYTE PTR [eax+64], cl

; 146  : 
; 147  : 					InputEvent ev2;
; 148  : 					ev2.msg = new_mousein?GIE_MOUSEIN:GIE_MOUSEOUT;

	movzx	edx, BYTE PTR _new_mousein$117686[ebp]
	neg	edx
	sbb	edx, edx
	neg	edx
	add	edx, 11					; 0000000bH
	mov	DWORD PTR _ev2$117692[ebp], edx

; 149  : 					m_EventQue.push_back(ev2);

	lea	eax, DWORD PTR _ev2$117692[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXABUInputEvent@Ogre@@@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::push_back

; 150  : 					if(!new_mousein) return;

	movzx	ecx, BYTE PTR _new_mousein$117686[ebp]
	test	ecx, ecx
	jne	SHORT $LN12@OnWindowMe
	jmp	$LN31@OnWindowMe
$LN12@OnWindowMe:

; 151  : 				}
; 152  : 
; 153  : 				ev.msg = GIE_MOUSEMOVE;

	mov	DWORD PTR _ev$[ebp], 9

; 154  : 				GetMouseEventData(ev, wparam, lparam);

	mov	edx, DWORD PTR _lparam$[ebp]
	push	edx
	mov	eax, DWORD PTR _wparam$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ev$[ebp]
	push	ecx
	call	?GetMouseEventData@Ogre@@YAXAAUInputEvent@1@II@Z ; Ogre::GetMouseEventData
	add	esp, 12					; 0000000cH

; 155  : 			}
; 156  : 			break;

	jmp	$LN29@OnWindowMe
$LN11@OnWindowMe:

; 157  : 
; 158  : 		case WM_MOUSEWHEEL:
; 159  : 			ev.msg = GIE_MOUSEWHEEL;

	mov	DWORD PTR _ev$[ebp], 10			; 0000000aH

; 160  : 			ev.wheel.flags = LOWORD(wparam);

	mov	edx, DWORD PTR _wparam$[ebp]
	and	edx, 65535				; 0000ffffH
	movzx	eax, dx
	mov	DWORD PTR _ev$[ebp+8], eax

; 161  : 			ev.wheel.dist = float(GET_WHEEL_DELTA_WPARAM(wparam)) / WHEEL_DELTA;

	mov	ecx, DWORD PTR _wparam$[ebp]
	shr	ecx, 16					; 00000010H
	and	ecx, 65535				; 0000ffffH
	movsx	edx, cx
	mov	DWORD PTR tv301[ebp], edx
	fild	DWORD PTR tv301[ebp]
	fdiv	QWORD PTR __real@405e000000000000
	fstp	DWORD PTR _ev$[ebp+4]

; 162  : 			ev.wheel.x = LOWORD(lparam);

	mov	eax, DWORD PTR _lparam$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	WORD PTR _ev$[ebp+12], ax

; 163  : 			ev.wheel.y = HIWORD(lparam);

	mov	ecx, DWORD PTR _lparam$[ebp]
	shr	ecx, 16					; 00000010H
	and	ecx, 65535				; 0000ffffH
	mov	WORD PTR _ev$[ebp+14], cx

; 164  : 			break;

	jmp	SHORT $LN29@OnWindowMe
$LN10@OnWindowMe:

; 165  : 
; 166  : 		case WM_SIZE:
; 167  : 			ev.msg = GIE_WINSIZE;

	mov	DWORD PTR _ev$[ebp], 13			; 0000000dH

; 168  : 			ev.winsize.sizex = LOWORD(lparam);

	mov	edx, DWORD PTR _lparam$[ebp]
	and	edx, 65535				; 0000ffffH
	movzx	eax, dx
	mov	DWORD PTR _ev$[ebp+4], eax

; 169  : 			ev.winsize.sizey = HIWORD(lparam);

	mov	ecx, DWORD PTR _lparam$[ebp]
	shr	ecx, 16					; 00000010H
	and	ecx, 65535				; 0000ffffH
	movzx	edx, cx
	mov	DWORD PTR _ev$[ebp+8], edx

; 170  : 			m_ClientWidth = ev.winsize.sizex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ev$[ebp+4]
	mov	DWORD PTR [eax+56], ecx

; 171  : 			m_ClientHeight = ev.winsize.sizey;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _ev$[ebp+8]
	mov	DWORD PTR [edx+60], eax

; 172  : 			break;

	jmp	SHORT $LN29@OnWindowMe
$LN9@OnWindowMe:

; 173  : 
; 174  : 		case WM_SETFOCUS:
; 175  : 			m_bIsFocus	= true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+65], 1

; 176  : 			//::SetCapture((HWND)hwnd);
; 177  : 			break;

	jmp	SHORT $LN29@OnWindowMe
$LN8@OnWindowMe:

; 178  : 
; 179  : 		case WM_KILLFOCUS:
; 180  : 			//::ReleaseCapture();
; 181  : 			m_bIsFocus	= false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+65], 0

; 182  : 			m_IsMouseIn = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+64], 0

; 183  : 			//ShowSystemCursor(true);
; 184  : 			ev.msg = GIE_MOUSEOUT;

	mov	DWORD PTR _ev$[ebp], 11			; 0000000bH

; 185  : 			break;

	jmp	SHORT $LN29@OnWindowMe
$LN7@OnWindowMe:

; 186  : 
; 187  : 		default:
; 188  : 			return;

	jmp	SHORT $LN31@OnWindowMe
$LN29@OnWindowMe:

; 189  : 		}
; 190  : 		
; 191  : 		if( m_pSelfHandler == NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $LN6@OnWindowMe

; 192  : 		{
; 193  : 			for(size_t i=0; i<m_Handles.size(); i++)

	mov	DWORD PTR _i$117713[ebp], 0
	jmp	SHORT $LN5@OnWindowMe
$LN4@OnWindowMe:
	mov	edx, DWORD PTR _i$117713[ebp]
	add	edx, 1
	mov	DWORD PTR _i$117713[ebp], edx
$LN5@OnWindowMe:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	cmp	DWORD PTR _i$117713[ebp], eax
	jae	SHORT $LN3@OnWindowMe

; 194  : 			{
; 195  : 				if(m_Handles[i]->HandleInput(ev) != 0) break;//已经被前面的handler处理完了

	mov	eax, DWORD PTR _i$117713[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAPAVInputHandler@Ogre@@I@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv236[ebp], ecx
	lea	edx, DWORD PTR _ev$[ebp]
	push	edx
	mov	eax, DWORD PTR tv236[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv236[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	test	eax, eax
	je	SHORT $LN2@OnWindowMe
	jmp	SHORT $LN3@OnWindowMe
$LN2@OnWindowMe:

; 196  : 			}

	jmp	SHORT $LN4@OnWindowMe
$LN3@OnWindowMe:
	jmp	SHORT $LN1@OnWindowMe
$LN6@OnWindowMe:

; 197  : 		}else{
; 198  : 			m_pSelfHandler->HandleInput(ev);

	lea	ecx, DWORD PTR _ev$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+68]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx]
	call	eax
$LN1@OnWindowMe:
$LN31@OnWindowMe:

; 199  : 		}
; 200  : 		
; 201  : 
; 202  : 		//m_EventQue.push_back(ev);
; 203  : 	}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN35@OnWindowMe:
	DD	$LN25@OnWindowMe
	DD	$LN28@OnWindowMe
	DD	$LN7@OnWindowMe
	DD	$LN27@OnWindowMe
	DD	$LN25@OnWindowMe
$LN36@OnWindowMe:
	DD	$LN24@OnWindowMe
	DD	$LN22@OnWindowMe
	DD	$LN21@OnWindowMe
	DD	$LN19@OnWindowMe
	DD	$LN17@OnWindowMe
	DD	$LN16@OnWindowMe
	DD	$LN7@OnWindowMe
	DD	$LN7@OnWindowMe
	DD	$LN7@OnWindowMe
	DD	$LN11@OnWindowMe
?OnWindowMessage@InputManager@Ogre@@QAEXPAXIII@Z ENDP	; Ogre::InputManager::OnWindowMessage
; Function compile flags: /Odtp
_ev$ = 8						; size = 4
_wparam$ = 12						; size = 4
_lparam$ = 16						; size = 4
?GetMouseEventData@Ogre@@YAXAAUInputEvent@1@II@Z PROC	; Ogre::GetMouseEventData

; 25   : 	{

	push	ebp
	mov	ebp, esp

; 26   : 		ev.mouse.x = LOWORD(lparam);

	mov	eax, DWORD PTR _lparam$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _ev$[ebp]
	mov	WORD PTR [ecx+4], ax

; 27   : 		ev.mouse.y = HIWORD(lparam);

	mov	edx, DWORD PTR _lparam$[ebp]
	shr	edx, 16					; 00000010H
	and	edx, 65535				; 0000ffffH
	mov	eax, DWORD PTR _ev$[ebp]
	mov	WORD PTR [eax+6], dx

; 28   : 
; 29   : 		ev.mouse.flags = wparam;

	mov	ecx, DWORD PTR _ev$[ebp]
	mov	edx, DWORD PTR _wparam$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 30   : 	}

	pop	ebp
	ret	0
?GetMouseEventData@Ogre@@YAXAAUInputEvent@1@II@Z ENDP	; Ogre::GetMouseEventData
; Function compile flags: /Odtp
_flags$ = -4						; size = 4
?GetKeyFlags@Ogre@@YAIXZ PROC				; Ogre::GetKeyFlags

; 38   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 39   : 		unsigned int flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 40   : 		if(IsKeyDown(VK_CONTROL)) flags |= MK_CONTROL;

	push	17					; 00000011H
	call	?IsKeyDown@Ogre@@YA_NH@Z		; Ogre::IsKeyDown
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@GetKeyFlag
	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 8
	mov	DWORD PTR _flags$[ebp], ecx
$LN4@GetKeyFlag:

; 41   : 		if(IsKeyDown(VK_SHIFT)) flags |= MK_SHIFT;

	push	16					; 00000010H
	call	?IsKeyDown@Ogre@@YA_NH@Z		; Ogre::IsKeyDown
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@GetKeyFlag
	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 4
	mov	DWORD PTR _flags$[ebp], eax
$LN3@GetKeyFlag:

; 42   : 		if(IsKeyDown(VK_MBUTTON)) flags |= MK_MBUTTON;

	push	4
	call	?IsKeyDown@Ogre@@YA_NH@Z		; Ogre::IsKeyDown
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetKeyFlag
	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 16					; 00000010H
	mov	DWORD PTR _flags$[ebp], edx
$LN2@GetKeyFlag:

; 43   : 		if(IsKeyDown(VK_MENU)) flags |= MK_ALT;

	push	18					; 00000012H
	call	?IsKeyDown@Ogre@@YA_NH@Z		; Ogre::IsKeyDown
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@GetKeyFlag
	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 32					; 00000020H
	mov	DWORD PTR _flags$[ebp], ecx
$LN1@GetKeyFlag:

; 44   : 
; 45   : 		return flags;

	mov	eax, DWORD PTR _flags$[ebp]

; 46   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetKeyFlags@Ogre@@YAIXZ ENDP				; Ogre::GetKeyFlags
; Function compile flags: /Odtp
_vkey$ = 8						; size = 4
?IsKeyDown@Ogre@@YA_NH@Z PROC				; Ogre::IsKeyDown

; 33   : 	{

	push	ebp
	mov	ebp, esp

; 34   : 		return (GetAsyncKeyState(vkey)&0xff00) != 0;

	mov	eax, DWORD PTR _vkey$[ebp]
	push	eax
	call	DWORD PTR __imp__GetAsyncKeyState@4
	cwde
	and	eax, 65280				; 0000ff00H
	neg	eax
	sbb	eax, eax
	neg	eax

; 35   : 	}

	pop	ebp
	ret	0
?IsKeyDown@Ogre@@YA_NH@Z ENDP				; Ogre::IsKeyDown
_TEXT	ENDS
PUBLIC	?Dispatch@InputManager@Ogre@@QAEXXZ		; Ogre::InputManager::Dispatch
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Dispatch@InputManager@Ogre@@QAEXXZ PROC		; Ogre::InputManager::Dispatch
; _this$ = ecx

; 206  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		//while(!m_EventQue.empty())
; 208  : 		//{
; 209  : 		//	InputEvent &ev = m_EventQue.front();
; 210  : 
; 211  : 		//	for(size_t i=0; i<m_Handles.size(); i++)
; 212  : 		//	{
; 213  : 		//		if(m_Handles[i]->HandleInput(ev) != 0) break;//已经被前面的handler处理完了
; 214  : 		//	}
; 215  : 
; 216  : 		//	m_EventQue.pop_front();
; 217  : 		//}
; 218  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?Dispatch@InputManager@Ogre@@QAEXXZ ENDP		; Ogre::InputManager::Dispatch
; Function compile flags: /Odtp
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?IsPointIn@InputManager@Ogre@@QAE_NHH@Z PROC		; Ogre::InputManager::IsPointIn
; _this$ = ecx

; 221  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 222  : 		return x>=0&&x<m_ClientWidth&&y>=0&&y<m_ClientHeight;

	cmp	DWORD PTR _x$[ebp], 0
	jl	SHORT $LN3@IsPointIn
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	cmp	ecx, DWORD PTR [eax+56]
	jge	SHORT $LN3@IsPointIn
	cmp	DWORD PTR _y$[ebp], 0
	jl	SHORT $LN3@IsPointIn
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR [edx+60]
	jge	SHORT $LN3@IsPointIn
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@IsPointIn
$LN3@IsPointIn:
	mov	DWORD PTR tv70[ebp], 0
$LN4@IsPointIn:
	mov	al, BYTE PTR tv70[ebp]

; 223  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?IsPointIn@InputManager@Ogre@@QAE_NHH@Z ENDP		; Ogre::InputManager::IsPointIn
_TEXT	ENDS
PUBLIC	?isFocus@InputManager@Ogre@@QAE_NXZ		; Ogre::InputManager::isFocus
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isFocus@InputManager@Ogre@@QAE_NXZ PROC		; Ogre::InputManager::isFocus
; _this$ = ecx

; 226  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 227  : 		return m_bIsFocus;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+65]

; 228  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isFocus@InputManager@Ogre@@QAE_NXZ ENDP		; Ogre::InputManager::isFocus
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogresingleton.h
_TEXT	ENDS
;	COMDAT ??0?$Singleton@VInputManager@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Singleton@VInputManager@Ogre@@@Ogre@@QAE@XZ PROC	; Ogre::Singleton<Ogre::InputManager>::Singleton<Ogre::InputManager>, COMDAT
; _this$ = ecx

; 64   : 		Singleton( void )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 		{
; 66   : 			assert( !ms_Singleton );
; 67   : #if defined( _MSC_VER ) && _MSC_VER < 1200	 
; 68   : 			int offset = (int)(T*)1 - (int)(Singleton <T>*)(T*)1;
; 69   : 			ms_Singleton = (T*)((int)this + offset);
; 70   : #else
; 71   : 			ms_Singleton = static_cast< T* >( this );

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR ?ms_Singleton@?$Singleton@VInputManager@Ogre@@@Ogre@@1PAVInputManager@2@A, eax ; Ogre::Singleton<Ogre::InputManager>::ms_Singleton

; 72   : #endif
; 73   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Singleton@VInputManager@Ogre@@@Ogre@@QAE@XZ ENDP	; Ogre::Singleton<Ogre::InputManager>::Singleton<Ogre::InputManager>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$Singleton@VInputManager@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$Singleton@VInputManager@Ogre@@@Ogre@@QAE@XZ PROC	; Ogre::Singleton<Ogre::InputManager>::~Singleton<Ogre::InputManager>, COMDAT
; _this$ = ecx

; 75   : 		{  assert( ms_Singleton );  ms_Singleton = 0;  }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR ?ms_Singleton@?$Singleton@VInputManager@Ogre@@@Ogre@@1PAVInputManager@2@A, 0 ; Ogre::Singleton<Ogre::InputManager>::ms_Singleton
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$Singleton@VInputManager@Ogre@@@Ogre@@QAE@XZ ENDP	; Ogre::Singleton<Ogre::InputManager>::~Singleton<Ogre::InputManager>
_TEXT	ENDS
PUBLIC	?getSingleton@?$Singleton@VInputManager@Ogre@@@Ogre@@SAAAVInputManager@2@XZ ; Ogre::Singleton<Ogre::InputManager>::getSingleton
; Function compile flags: /Odtp
;	COMDAT ?getSingleton@?$Singleton@VInputManager@Ogre@@@Ogre@@SAAAVInputManager@2@XZ
_TEXT	SEGMENT
?getSingleton@?$Singleton@VInputManager@Ogre@@@Ogre@@SAAAVInputManager@2@XZ PROC ; Ogre::Singleton<Ogre::InputManager>::getSingleton, COMDAT

; 77   : 		{	assert( ms_Singleton );  return ( *ms_Singleton ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?ms_Singleton@?$Singleton@VInputManager@Ogre@@@Ogre@@1PAVInputManager@2@A ; Ogre::Singleton<Ogre::InputManager>::ms_Singleton
	pop	ebp
	ret	0
?getSingleton@?$Singleton@VInputManager@Ogre@@@Ogre@@SAAAVInputManager@2@XZ ENDP ; Ogre::Singleton<Ogre::InputManager>::getSingleton
_TEXT	ENDS
PUBLIC	?getSingletonPtr@?$Singleton@VInputManager@Ogre@@@Ogre@@SAPAVInputManager@2@XZ ; Ogre::Singleton<Ogre::InputManager>::getSingletonPtr
; Function compile flags: /Odtp
;	COMDAT ?getSingletonPtr@?$Singleton@VInputManager@Ogre@@@Ogre@@SAPAVInputManager@2@XZ
_TEXT	SEGMENT
?getSingletonPtr@?$Singleton@VInputManager@Ogre@@@Ogre@@SAPAVInputManager@2@XZ PROC ; Ogre::Singleton<Ogre::InputManager>::getSingletonPtr, COMDAT

; 79   : 		{ return ms_Singleton; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?ms_Singleton@?$Singleton@VInputManager@Ogre@@@Ogre@@1PAVInputManager@2@A ; Ogre::Singleton<Ogre::InputManager>::ms_Singleton
	pop	ebp
	ret	0
?getSingletonPtr@?$Singleton@VInputManager@Ogre@@@Ogre@@SAPAVInputManager@2@XZ ENDP ; Ogre::Singleton<Ogre::InputManager>::getSingletonPtr
_TEXT	ENDS
PUBLIC	??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ ; std::_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::~_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
PUBLIC	??0?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z ; std::_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
PUBLIC	??0?$allocator@UInputEvent@Ogre@@@std@@QAE@XZ	; std::allocator<Ogre::InputEvent>::allocator<Ogre::InputEvent>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
xdata$x	SEGMENT
__unwindtable$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T125501 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >, COMDAT
; _this$ = ecx

; 554  : 		{	// construct empty deque

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T125501[ebp], esp
	call	??0?$allocator@UInputEvent@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::InputEvent>::allocator<Ogre::InputEvent>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z ; std::_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 555  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
PUBLIC	?_Tidy@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAEXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Tidy
PUBLIC	??$insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::insert<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
PUBLIC	?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
PUBLIC	?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::end
PUBLIC	?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
PUBLIC	??0?$allocator@UInputEvent@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::InputEvent>::allocator<Ogre::InputEvent>
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T125515 = -52						; size = 8
$T125514 = -44						; size = 8
$T125513 = -36						; size = 8
$T125512 = -28						; size = 8
$T125511 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >, COMDAT
; _this$ = ecx

; 587  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 12					; 0000000cH
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T125511[ebp], esp
	push	eax
	call	??0?$allocator@UInputEvent@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::InputEvent>::allocator<Ogre::InputEvent>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z ; std::_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 588  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 589  : 		insert(begin(), _Right.begin(), _Right.end());

	lea	edx, DWORD PTR $T125515[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T125514[ebp], ecx
	mov	DWORD PTR $T125514[ebp+4], edx
	lea	eax, DWORD PTR $T125512[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T125513[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR $T125514[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T125514[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::insert<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	jmp	SHORT $LN4@deque
__catch$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 590  : 		_CATCH_ALL
; 591  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAEXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Tidy

; 592  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 593  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@deque
	ret	0
$LN4@deque:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@deque:

; 594  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@deque:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::~deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >, COMDAT
; _this$ = ecx

; 640  : 		{	// destroy the deque

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 641  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAEXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Tidy

; 642  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::~deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
PUBLIC	??H?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+
PUBLIC	?erase@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@0@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::erase
PUBLIC	?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::end
PUBLIC	??$copy@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
PUBLIC	?clear@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -132						; size = 4
$T125555 = -128						; size = 8
$T125554 = -120						; size = 8
$T125553 = -112						; size = 8
$T125552 = -104						; size = 8
$T125551 = -96						; size = 8
$T125550 = -88						; size = 8
$T125549 = -80						; size = 8
$T125548 = -72						; size = 8
$T125547 = -64						; size = 8
$T125546 = -56						; size = 8
$T125545 = -48						; size = 8
$T125544 = -40						; size = 8
$T125543 = -32						; size = 8
$T125542 = -24						; size = 8
__Mid$119401 = -16					; size = 8
__Mid$119341 = -8					; size = 8
__Right$ = 8						; size = 4
??4?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::operator=, COMDAT
; _this$ = ecx

; 645  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN6@operator
	jmp	$LN5@operator
$LN6@operator:

; 647  : 			;
; 648  : 		else if (_Right._Mysize == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN4@operator

; 649  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::clear
	jmp	$LN5@operator
$LN4@operator:

; 650  : 		else if (_Right._Mysize <= _Mysize)

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	cmp	ecx, DWORD PTR [eax+28]
	ja	$LN2@operator

; 651  : 			{	// new sequence not longer, assign elements and erase unused
; 652  : 			iterator _Mid = std::copy(_Right.begin(), _Right.end(), begin());

	lea	edx, DWORD PTR $T125542[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T125543[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T125544[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __Mid$119341[ebp]
	push	eax
	call	??$copy@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 28					; 0000001cH

; 653  : 			erase(_Mid, end());

	lea	ecx, DWORD PTR $T125546[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T125545[ebp], edx
	mov	DWORD PTR $T125545[ebp+4], eax
	mov	ecx, DWORD PTR __Mid$119341[ebp]
	mov	DWORD PTR $T125547[ebp], ecx
	mov	edx, DWORD PTR __Mid$119341[ebp+4]
	mov	DWORD PTR $T125547[ebp+4], edx
	mov	eax, DWORD PTR $T125545[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T125545[ebp]
	push	ecx
	mov	edx, DWORD PTR $T125547[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T125547[ebp]
	push	eax
	lea	ecx, DWORD PTR $T125548[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@0@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::erase

; 654  : 			}
; 655  : 		else

	jmp	$LN5@operator
$LN2@operator:

; 656  : 			{	// new sequence longer, assign elements and append rest
; 657  : 			const_iterator _Mid = _Right.begin() + _Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	lea	ecx, DWORD PTR __Mid$119401[ebp]
	push	ecx
	lea	edx, DWORD PTR $T125549[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
	mov	ecx, eax
	call	??H?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+

; 658  : 			std::copy(_Right.begin(), _Mid, begin());

	lea	eax, DWORD PTR $T125550[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Mid$119401[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Mid$119401[ebp]
	push	ecx
	lea	edx, DWORD PTR $T125551[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T125552[ebp]
	push	eax
	call	??$copy@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 28					; 0000001cH

; 659  : 			insert(end(), _Mid, _Right.end());

	lea	ecx, DWORD PTR $T125555[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T125554[ebp], edx
	mov	DWORD PTR $T125554[ebp+4], eax
	lea	ecx, DWORD PTR $T125553[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR __Mid$119401[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Mid$119401[ebp]
	push	edx
	mov	eax, DWORD PTR $T125554[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T125554[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::insert<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
$LN5@operator:

; 660  : 			}
; 661  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::operator=
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@ABU34@@Z ; std::allocator<Ogre::InputEvent>::construct
PUBLIC	?allocate@?$allocator@UInputEvent@Ogre@@@std@@QAEPAUInputEvent@Ogre@@I@Z ; std::allocator<Ogre::InputEvent>::allocate
PUBLIC	?_Growmap@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAEXI@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Growmap
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXABUInputEvent@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Block$ = -8						; size = 4
__Newoff$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXABUInputEvent@Ogre@@@Z PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::push_back, COMDAT
; _this$ = ecx

; 843  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 844  : 
; 845  :  #if _HAS_ITERATOR_DEBUGGING
; 846  : 		this->_Orphan_all();
; 847  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 848  : 
; 849  : 		if ((_Myoff + _Mysize) % _DEQUESIZ == 0
; 850  : 			&& _Mapsize <= (_Mysize + _DEQUESIZ) / _DEQUESIZ)

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	xor	edx, edx
	mov	ecx, 1
	div	ecx
	test	edx, edx
	jne	SHORT $LN3@push_back
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN3@push_back

; 851  : 			_Growmap(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAEXI@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Growmap
$LN3@push_back:

; 852  : 		size_type _Newoff = _Myoff + _Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR __Newoff$[ebp], eax

; 853  : 		size_type _Block = _Newoff / _DEQUESIZ;

	mov	edx, DWORD PTR __Newoff$[ebp]
	mov	DWORD PTR __Block$[ebp], edx

; 854  : 		if (_Mapsize <= _Block)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Block$[ebp]
	ja	SHORT $LN2@push_back

; 855  : 			_Block -= _Mapsize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Block$[ebp]
	sub	eax, DWORD PTR [edx+20]
	mov	DWORD PTR __Block$[ebp], eax
$LN2@push_back:

; 856  : 		if (_Map[_Block] == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	SHORT $LN1@push_back

; 857  : 			_Map[_Block] = this->_Alval.allocate(_DEQUESIZ);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@UInputEvent@Ogre@@@std@@QAEPAUInputEvent@Ogre@@I@Z ; std::allocator<Ogre::InputEvent>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@push_back:

; 858  : 		this->_Alval.construct(_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 1
	div	esi
	shl	edx, 4
	mov	eax, DWORD PTR __Block$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?construct@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@ABU34@@Z ; std::allocator<Ogre::InputEvent>::construct

; 859  : 		++_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx

; 860  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXABUInputEvent@Ogre@@@Z ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::~_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
PUBLIC	?_Buy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Buy
PUBLIC	??0?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z ; std::_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
PUBLIC	??0?$allocator@PAVInputHandler@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::InputHandler *>::allocator<Ogre::InputHandler *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T125560 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T125560[ebp], esp
	call	??0?$allocator@PAVInputHandler@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::InputHandler *>::allocator<Ogre::InputHandler *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z ; std::_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
PUBLIC	?_Tidy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ucopy<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> > >
PUBLIC	?begin@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::begin
PUBLIC	?end@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::end
PUBLIC	??0?$allocator@PAVInputHandler@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::InputHandler *>::allocator<Ogre::InputHandler *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T125572 = -36						; size = 8
$T125571 = -28						; size = 8
$T125570 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T125570[ebp], esp
	push	eax
	call	??0?$allocator@PAVInputHandler@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::InputHandler *>::allocator<Ogre::InputHandler *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z ; std::_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T125571[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T125572[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ucopy<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector
__catch$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector
	ret	0
$LN5@vector:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::~vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::~vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
PUBLIC	?deallocate@?$allocator@PAVInputHandler@Ogre@@@std@@QAEXPAPAVInputHandler@Ogre@@I@Z ; std::allocator<Ogre::InputHandler *>::deallocate
PUBLIC	??$_Ucopy@PAPAVInputHandler@Ogre@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ucopy<Ogre::InputHandler * *>
PUBLIC	?capacity@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXPAPAVInputHandler@Ogre@@0@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVInputHandler@Ogre@@PAPAV12@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::InputHandler * *,Ogre::InputHandler * *>
PUBLIC	?clear@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$119591 = -8					; size = 4
__Ptr$119581 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@2

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@2

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::clear
	jmp	$LN9@operator@2
$LN8@operator@2:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@2

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVInputHandler@Ogre@@PAPAV12@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::InputHandler * *,Ogre::InputHandler * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$119581[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$119581[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXPAPAVInputHandler@Ogre@@0@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@2
$LN6@operator@2:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@2

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$119591[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$119591[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVInputHandler@Ogre@@PAPAV12@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::InputHandler * *,Ogre::InputHandler * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$119591[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVInputHandler@Ogre@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ucopy<Ogre::InputHandler * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@2
$LN4@operator@2:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@2

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXPAPAVInputHandler@Ogre@@0@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVInputHandler@Ogre@@@std@@QAEXPAPAVInputHandler@Ogre@@I@Z ; std::allocator<Ogre::InputHandler *>::deallocate
$LN2@operator@2:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@2

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVInputHandler@Ogre@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ucopy<Ogre::InputHandler * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@2:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
_TEXT	ENDS
EXTRN	__imp___invalid_parameter_noinfo:PROC
; Function compile flags: /Odtp
;	COMDAT ??A?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAPAVInputHandler@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAPAVInputHandler@Ogre@@I@Z PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN2@operator@3
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@3:
	xor	eax, eax
	jne	SHORT $LN2@operator@3

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [edx+eax*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAPAVInputHandler@Ogre@@I@Z ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@ABQAVInputHandler@Ogre@@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::insert
PUBLIC	?end@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::end
PUBLIC	?_Ufill@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ufill
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEXABQAVInputHandler@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T125606 = -24						; size = 8
$T125605 = -16						; size = 8
$T125604 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEXABQAVInputHandler@Ogre@@@Z PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@2
$LN2@push_back@2:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T125605[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T125604[ebp], ecx
	mov	DWORD PTR $T125604[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T125604[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T125604[ebp]
	push	edx
	lea	eax, DWORD PTR $T125606[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@ABQAVInputHandler@Ogre@@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::insert
$LN3@push_back@2:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEXABQAVInputHandler@Ogre@@@Z ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ ; std::_Deque_map<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::~_Deque_map<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::~_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::~_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::~_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >
__ehhandler$??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::~_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Deque_map<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::~_Deque_map<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >
__ehhandler$??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_map<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::~_Deque_map<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
PUBLIC	??0?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
;	COMDAT ?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin, COMDAT
; _this$ = ecx

; 665  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 666  : 		return (iterator(_Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 667  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
_TEXT	ENDS
PUBLIC	??0?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>
; Function compile flags: /Odtp
;	COMDAT ?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin, COMDAT
; _this$ = ecx

; 670  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  : 		return (const_iterator(_Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 672  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::end, COMDAT
; _this$ = ecx

; 675  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 676  : 		return (iterator(_Myoff + _Mysize, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+28]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 677  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::end, COMDAT
; _this$ = ecx

; 680  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 681  : 		return (const_iterator(_Myoff + _Mysize, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+28]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 682  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::end
_TEXT	ENDS
PUBLIC	??H?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+
PUBLIC	?pop_back@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::pop_back
PUBLIC	??$copy@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V10@00@Z ; std::copy<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
PUBLIC	?pop_front@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::pop_front
PUBLIC	??$copy_backward@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V10@00@Z ; std::copy_backward<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
PUBLIC	??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-
PUBLIC	?_Make_iter@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@0@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T125650 = -80						; size = 8
$T125649 = -72						; size = 8
$T125648 = -64						; size = 8
$T125647 = -56						; size = 8
$T125646 = -48						; size = 8
$T125645 = -40						; size = 8
$T125644 = -32						; size = 8
__Off$ = -24						; size = 4
__Last$ = -20						; size = 8
__First$ = -12						; size = 8
__Count$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@0@Z PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::erase, COMDAT
; _this$ = ecx

; 1044 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	DWORD PTR _this$[ebp], ecx

; 1045 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Make_iter

; 1046 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Make_iter

; 1047 : 
; 1048 :  #if _HAS_ITERATOR_DEBUGGING
; 1049 : 		if (_Last < _First
; 1050 : 			|| _First < begin() || end() < _Last)
; 1051 : 			_DEBUG_ERROR("deque erase iterator outside range");
; 1052 : 		_DEBUG_RANGE(_First, _Last);
; 1053 : 
; 1054 : 		size_type _Off = _First - begin();
; 1055 : 		size_type _Count = _Last - _First;
; 1056 : 		bool _Moved = 0 < _Off && _Off + _Count < _Mysize;
; 1057 : 
; 1058 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1059 : 		size_type _Off = _First - begin();

	lea	eax, DWORD PTR $T125644[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-
	mov	DWORD PTR __Off$[ebp], eax

; 1060 : 		size_type _Count = _Last - _First;

	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-
	mov	DWORD PTR __Count$[ebp], eax

; 1061 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1062 : 
; 1063 : 		if (_Off < (size_type)(end() - _Last))

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T125645[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-
	cmp	DWORD PTR __Off$[ebp], eax
	jae	SHORT $LN8@erase

; 1064 : 			{	// closer to front
; 1065 : 			std::copy_backward(begin(), _First, _Last);	// copy over hole

	mov	ecx, DWORD PTR __Last$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T125646[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T125647[ebp]
	push	eax
	call	??$copy_backward@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V10@00@Z ; std::copy_backward<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 28					; 0000001cH

; 1066 : 			for (; 0 < _Count; --_Count)

	jmp	SHORT $LN7@erase
$LN6@erase:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
$LN7@erase:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN5@erase

; 1067 : 				pop_front();	// pop copied elements

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_front@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::pop_front
	jmp	SHORT $LN6@erase
$LN5@erase:

; 1068 : 			}
; 1069 : 		else

	jmp	SHORT $LN4@erase
$LN8@erase:

; 1070 : 			{	// closer to back
; 1071 : 			std::copy(_Last, end(), _First);	// copy over hole

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T125648[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T125649[ebp]
	push	eax
	call	??$copy@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V10@00@Z ; std::copy<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 28					; 0000001cH

; 1072 : 			for (; 0 < _Count; --_Count)

	jmp	SHORT $LN3@erase
$LN2@erase:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
$LN3@erase:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@erase

; 1073 : 				pop_back();	// pop copied elements

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::pop_back
	jmp	SHORT $LN2@erase
$LN4@erase:

; 1074 : 			}
; 1075 : 
; 1076 :  #if _HAS_ITERATOR_DEBUGGING
; 1077 : 		if (_Moved)
; 1078 : 			this->_Orphan_all();
; 1079 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1080 : 
; 1081 : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T125650[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1082 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@0@Z ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?clear@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::clear, COMDAT
; _this$ = ecx

; 1085 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1086 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAEXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Tidy

; 1087 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::clear
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAUInputEvent@Ogre@@@std@@QAEXPAPAUInputEvent@Ogre@@I@Z ; std::allocator<Ogre::InputEvent *>::deallocate
PUBLIC	??$_Destroy_range@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@0AAV?$allocator@PAUInputEvent@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::InputEvent *> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAUInputEvent@Ogre@@IPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAXPAPAUInputEvent@Ogre@@IABQAU12@AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *,std::allocator<Ogre::InputEvent *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAUInputEvent@Ogre@@PAPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAPAPAUInputEvent@Ogre@@PAPAU12@00AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::InputEvent * *,Ogre::InputEvent * *,std::allocator<Ogre::InputEvent *> >
PUBLIC	?allocate@?$allocator@PAUInputEvent@Ogre@@@std@@QAEPAPAUInputEvent@Ogre@@I@Z ; std::allocator<Ogre::InputEvent *>::allocate
PUBLIC	?_Xlen@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@KAXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Xlen
PUBLIC	?max_size@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBEIXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Growmap@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T125657 = -28						; size = 4
$T125656 = -24						; size = 4
$T125655 = -20						; size = 4
__Newmap$ = -16						; size = 4
__Myptr$ = -12						; size = 4
__Inc$ = -8						; size = 4
__Myboff$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Growmap@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAEXI@Z PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Growmap, COMDAT
; _this$ = ecx

; 1225 : 		{	// grow map by _Count pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1226 : 		if (max_size() / _DEQUESIZ - _Mapsize < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBEIXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::max_size
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN6@Growmap

; 1227 : 			_Xlen();	// result too long

	call	?_Xlen@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@KAXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Xlen
$LN6@Growmap:

; 1228 : 
; 1229 : 		size_type _Inc = _Mapsize / 2;	// try to grow by 50%

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	DWORD PTR __Inc$[ebp], eax

; 1230 : 		if (_Inc < _DEQUEMAPSIZ)

	cmp	DWORD PTR __Inc$[ebp], 8
	jae	SHORT $LN5@Growmap

; 1231 : 			_Inc = _DEQUEMAPSIZ;

	mov	DWORD PTR __Inc$[ebp], 8
$LN5@Growmap:

; 1232 : 		if (_Count < _Inc && _Mapsize <= max_size() / _DEQUESIZ - _Inc)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, DWORD PTR __Inc$[ebp]
	jae	SHORT $LN4@Growmap
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBEIXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::max_size
	sub	eax, DWORD PTR __Inc$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], eax
	ja	SHORT $LN4@Growmap

; 1233 : 			_Count = _Inc;

	mov	eax, DWORD PTR __Inc$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Growmap:

; 1234 : 		size_type _Myboff = _Myoff / _DEQUESIZ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Myboff$[ebp], edx

; 1235 : 		_Mapptr _Newmap = this->_Almap.allocate(_Mapsize + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAUInputEvent@Ogre@@@std@@QAEPAPAUInputEvent@Ogre@@I@Z ; std::allocator<Ogre::InputEvent *>::allocate
	mov	DWORD PTR __Newmap$[ebp], eax

; 1236 : 		_Mapptr _Myptr = _Newmap + _Myboff;

	mov	edx, DWORD PTR __Myboff$[ebp]
	mov	eax, DWORD PTR __Newmap$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Myptr$[ebp], ecx

; 1237 : 
; 1238 : 		_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Myboff,
; 1239 : 			_Map + _Mapsize, _Myptr, this->_Almap);	// copy initial to end

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR __Myptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Myboff$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAUInputEvent@Ogre@@PAPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAPAPAUInputEvent@Ogre@@PAPAU12@00AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::InputEvent * *,Ogre::InputEvent * *,std::allocator<Ogre::InputEvent *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1240 : 		if (_Myboff <= _Count)

	mov	ecx, DWORD PTR __Myboff$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@Growmap

; 1241 : 			{	// increment greater than offset of initial block
; 1242 : 			_Myptr = _STDEXT unchecked_uninitialized_copy(_Map,
; 1243 : 				_Map + _Myboff, _Myptr, this->_Almap);	// copy rest of old

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR __Myptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Myboff$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAUInputEvent@Ogre@@PAPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAPAPAUInputEvent@Ogre@@PAPAU12@00AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::InputEvent * *,Ogre::InputEvent * *,std::allocator<Ogre::InputEvent *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1244 : 			_STDEXT unchecked_uninitialized_fill_n(_Myptr, _Count - _Myboff,
; 1245 : 				(_Tptr)0, this->_Almap);	// clear suffix of new

	mov	DWORD PTR $T125655[ebp], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	lea	edx, DWORD PTR $T125655[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Myboff$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myptr$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_fill_n@PAPAUInputEvent@Ogre@@IPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAXPAPAUInputEvent@Ogre@@IABQAU12@AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *,std::allocator<Ogre::InputEvent *> >
	add	esp, 16					; 00000010H

; 1246 : 			_STDEXT unchecked_uninitialized_fill_n(_Newmap, _Myboff,
; 1247 : 				(_Tptr)0, this->_Almap);	// clear prefix of new

	mov	DWORD PTR $T125656[ebp], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	lea	eax, DWORD PTR $T125656[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myboff$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newmap$[ebp]
	push	edx
	call	??$unchecked_uninitialized_fill_n@PAPAUInputEvent@Ogre@@IPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAXPAPAUInputEvent@Ogre@@IABQAU12@AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *,std::allocator<Ogre::InputEvent *> >
	add	esp, 16					; 00000010H

; 1248 : 			}
; 1249 : 		else

	jmp	SHORT $LN2@Growmap
$LN3@Growmap:

; 1250 : 			{	// increment not greater than offset of initial block
; 1251 : 			_STDEXT unchecked_uninitialized_copy(_Map,
; 1252 : 				_Map + _Count, _Myptr, this->_Almap);	// copy more old

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Myptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAPAUInputEvent@Ogre@@PAPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAPAPAUInputEvent@Ogre@@PAPAU12@00AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::InputEvent * *,Ogre::InputEvent * *,std::allocator<Ogre::InputEvent *> >
	add	esp, 16					; 00000010H

; 1253 : 			_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Count,
; 1254 : 				_Map + _Myboff, _Newmap, this->_Almap);	// copy rest of old

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR __Newmap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Myboff$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	??$unchecked_uninitialized_copy@PAPAUInputEvent@Ogre@@PAPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAPAPAUInputEvent@Ogre@@PAPAU12@00AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::InputEvent * *,Ogre::InputEvent * *,std::allocator<Ogre::InputEvent *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1255 : 			_STDEXT unchecked_uninitialized_fill_n(_Myptr, _Count,
; 1256 : 				(_Tptr)0, this->_Almap);	// clear rest to initial block

	mov	DWORD PTR $T125657[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR $T125657[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Myptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAUInputEvent@Ogre@@IPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAXPAPAUInputEvent@Ogre@@IABQAU12@AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *,std::allocator<Ogre::InputEvent *> >
	add	esp, 16					; 00000010H
$LN2@Growmap:

; 1257 : 			}
; 1258 : 
; 1259 : 		_Destroy_range(_Map + _Myboff, _Map + _Mapsize, this->_Almap);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Myboff$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	??$_Destroy_range@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@0AAV?$allocator@PAUInputEvent@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::InputEvent *> >
	add	esp, 12					; 0000000cH

; 1260 : 		if (_Map)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN1@Growmap

; 1261 : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for old

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAUInputEvent@Ogre@@@std@@QAEXPAPAUInputEvent@Ogre@@I@Z ; std::allocator<Ogre::InputEvent *>::deallocate
$LN1@Growmap:

; 1262 : 
; 1263 : 		_Map = _Newmap;	// point at new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Newmap$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1264 : 		_Mapsize += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1265 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Growmap@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAEXI@Z ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Growmap
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAUInputEvent@Ogre@@@std@@QAEXPAPAUInputEvent@Ogre@@@Z ; std::allocator<Ogre::InputEvent *>::destroy
PUBLIC	?deallocate@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@I@Z ; std::allocator<Ogre::InputEvent>::deallocate
PUBLIC	?empty@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE_NXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::empty
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$120693 = -4					; size = 4
?_Tidy@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAEXXZ PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Tidy, COMDAT
; _this$ = ecx

; 1268 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
$LN6@Tidy:

; 1269 : 		while (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE_NXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Tidy

; 1270 : 			pop_back();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::pop_back
	jmp	SHORT $LN6@Tidy
$LN5@Tidy:

; 1271 : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR __Count$120693[ebp], edx
$LN4@Tidy:
	cmp	DWORD PTR __Count$120693[ebp], 0
	jbe	SHORT $LN3@Tidy

; 1272 : 			{	// free storage for a block and destroy pointer
; 1273 : 			if (*(_Map + --_Count) != 0)

	mov	eax, DWORD PTR __Count$120693[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$120693[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Count$120693[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN2@Tidy

; 1274 : 				this->_Alval.deallocate(*(_Map + _Count), _DEQUESIZ);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Count$120693[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@I@Z ; std::allocator<Ogre::InputEvent>::deallocate
$LN2@Tidy:

; 1275 : 			this->_Almap.destroy(_Map + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$120693[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?destroy@?$allocator@PAUInputEvent@Ogre@@@std@@QAEXPAPAUInputEvent@Ogre@@@Z ; std::allocator<Ogre::InputEvent *>::destroy

; 1276 : 			}

	jmp	SHORT $LN4@Tidy
$LN3@Tidy:

; 1277 : 
; 1278 : 		if (_Map)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN1@Tidy

; 1279 : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for map

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAUInputEvent@Ogre@@@std@@QAEXPAPAUInputEvent@Ogre@@I@Z ; std::allocator<Ogre::InputEvent *>::deallocate
$LN1@Tidy:

; 1280 : 		_Mapsize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1281 : 		_Map = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 1282 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z ; std::_Deque_map<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Deque_map<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T125662 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z PROC ; std::_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct allocator and base from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T125662[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UInputEvent@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::InputEvent>::allocator<Ogre::InputEvent>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z ; std::_Deque_map<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Deque_map<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$allocator@UInputEvent@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::InputEvent>::allocator<Ogre::InputEvent>

; 501  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Deque_val@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z ENDP ; std::_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Deque_val<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
PUBLIC	??1_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::~_Container_base_aux
PUBLIC	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >
; Function compile flags: /Odtp
;	COMDAT ??1_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::~_Container_base_aux, COMDAT
; _this$ = ecx

; 402  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 		// Do nothing: ~_Container_base_aux_alloc_real() previously destroyed the aux object.
; 404  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::~_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UInputEvent@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UInputEvent@Ogre@@@std@@QAE@XZ PROC	; std::allocator<Ogre::InputEvent>::allocator<Ogre::InputEvent>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@UInputEvent@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<Ogre::InputEvent>::allocator<Ogre::InputEvent>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@UInputEvent@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UInputEvent@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::InputEvent>::allocator<Ogre::InputEvent>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UInputEvent@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::InputEvent>::allocator<Ogre::InputEvent>
_TEXT	ENDS
PUBLIC	??$_Allocate@UInputEvent@Ogre@@@std@@YAPAUInputEvent@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::InputEvent>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@UInputEvent@Ogre@@@std@@QAEPAUInputEvent@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UInputEvent@Ogre@@@std@@QAEPAUInputEvent@Ogre@@I@Z PROC ; std::allocator<Ogre::InputEvent>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UInputEvent@Ogre@@@std@@YAPAUInputEvent@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::InputEvent>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UInputEvent@Ogre@@@std@@QAEPAUInputEvent@Ogre@@I@Z ENDP ; std::allocator<Ogre::InputEvent>::allocate
_TEXT	ENDS
PUBLIC	??$_Construct@UInputEvent@Ogre@@U12@@std@@YAXPAUInputEvent@Ogre@@ABU12@@Z ; std::_Construct<Ogre::InputEvent,Ogre::InputEvent>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@ABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@ABU34@@Z PROC ; std::allocator<Ogre::InputEvent>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UInputEvent@Ogre@@U12@@std@@YAXPAUInputEvent@Ogre@@ABU12@@Z ; std::_Construct<Ogre::InputEvent,Ogre::InputEvent>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@ABU34@@Z ENDP ; std::allocator<Ogre::InputEvent>::construct
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity
$LN3@capacity:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@PAPAVInputHandler@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@PAPAVInputHandler@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::begin
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@PAPAVInputHandler@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@PAPAVInputHandler@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@PAPAVInputHandler@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator+
PUBLIC	?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator-
PUBLIC	?begin@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@ABQAVInputHandler@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T125704 = -20						; size = 8
$T125701 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@ABQAVInputHandler@Ogre@@@Z PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	lea	eax, DWORD PTR $T125701[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T125704[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@ABQAVInputHandler@Ogre@@@Z ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T125711 = -40						; size = 8
$T125710 = -32						; size = 8
$T125709 = -24						; size = 8
$T125708 = -16						; size = 8
$T125707 = -8						; size = 8
?clear@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T125708[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T125707[ebp], ecx
	mov	DWORD PTR $T125707[ebp+4], edx
	lea	eax, DWORD PTR $T125710[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T125709[ebp], ecx
	mov	DWORD PTR $T125709[ebp+4], edx
	mov	eax, DWORD PTR $T125707[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T125707[ebp]
	push	ecx
	mov	edx, DWORD PTR $T125709[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T125709[ebp]
	push	eax
	lea	ecx, DWORD PTR $T125711[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVInputHandler@Ogre@@@std@@QAEPAPAVInputHandler@Ogre@@I@Z ; std::allocator<Ogre::InputHandler *>::allocate
PUBLIC	?_Xlen@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVInputHandler@Ogre@@@std@@QAEPAPAVInputHandler@Ogre@@I@Z ; std::allocator<Ogre::InputHandler *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@0AAV?$allocator@PAVInputHandler@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXPAPAVInputHandler@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXPAPAVInputHandler@Ogre@@0@Z PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@0AAV?$allocator@PAVInputHandler@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::InputHandler *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXPAPAVInputHandler@Ogre@@0@Z ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXPAPAVInputHandler@Ogre@@0@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVInputHandler@Ogre@@@std@@QAEXPAPAVInputHandler@Ogre@@I@Z ; std::allocator<Ogre::InputHandler *>::deallocate
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVInputHandler@Ogre@@IPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAXPAPAVInputHandler@Ogre@@IABQAV12@AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV34@IABQAV34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV34@IABQAV34@@Z PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAVInputHandler@Ogre@@IPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAXPAPAVInputHandler@Ogre@@IABQAV12@AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV34@IABQAV34@@Z ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T125722 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T125722[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVInputHandler@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::InputHandler *>::allocator<Ogre::InputHandler *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVInputHandler@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::InputHandler *>::allocator<Ogre::InputHandler *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >
__ehhandler$??0?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_val<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVInputHandler@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVInputHandler@Ogre@@@std@@QAE@XZ PROC	; std::allocator<Ogre::InputHandler *>::allocator<Ogre::InputHandler *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVInputHandler@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<Ogre::InputHandler *>::allocator<Ogre::InputHandler *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVInputHandler@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVInputHandler@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::InputHandler *>::allocator<Ogre::InputHandler *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVInputHandler@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::InputHandler *>::allocator<Ogre::InputHandler *>
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ?deallocate@?$allocator@PAVInputHandler@Ogre@@@std@@QAEXPAPAVInputHandler@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVInputHandler@Ogre@@@std@@QAEXPAPAVInputHandler@Ogre@@I@Z PROC ; std::allocator<Ogre::InputHandler *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVInputHandler@Ogre@@@std@@QAEXPAPAVInputHandler@Ogre@@I@Z ENDP ; std::allocator<Ogre::InputHandler *>::deallocate
_TEXT	ENDS
PUBLIC	??Y?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+=
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
;	COMDAT ??H?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+, COMDAT
; _this$ = ecx

; 208  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 209  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 210  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@Z PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Make_iter, COMDAT
; _this$ = ecx

; 685  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 686  : 		return (iterator(_Where._Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 687  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@Z ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UInputEvent@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::InputEvent>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBEIXZ PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::max_size, COMDAT
; _this$ = ecx

; 728  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 729  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?max_size@?$allocator@UInputEvent@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::InputEvent>::max_size

; 730  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?empty@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE_NXZ PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::empty, COMDAT
; _this$ = ecx

; 733  : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 734  : 		return (_Mysize == 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+28], 0
	sete	cl
	mov	al, cl

; 735  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE_NXZ ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::empty
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@@Z ; std::allocator<Ogre::InputEvent>::destroy
; Function compile flags: /Odtp
;	COMDAT ?pop_front@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Block$121015 = -4					; size = 4
?pop_front@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::pop_front, COMDAT
; _this$ = ecx

; 819  : 		{	// erase element at beginning

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 820  : 
; 821  :  #if _HAS_ITERATOR_DEBUGGING
; 822  : 		if (empty())
; 823  : 			_DEBUG_ERROR("deque empty before pop");
; 824  : 		else
; 825  : 			{	// something to erase, do it
; 826  : 			_Orphan_off(_Myoff);
; 827  : 
; 828  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 829  : 		if (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE_NXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@pop_front

; 830  : 			{	// something to erase, do it
; 831  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 832  : 
; 833  : 			size_type _Block = _Myoff / _DEQUESIZ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Block$121015[ebp], edx

; 834  : 			this->_Alval.destroy(_Map[_Block] + _Myoff % _DEQUESIZ);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	xor	edx, edx
	mov	esi, 1
	div	esi
	shl	edx, 4
	mov	eax, DWORD PTR __Block$121015[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@@Z ; std::allocator<Ogre::InputEvent>::destroy

; 835  : 			if (_Mapsize * _DEQUESIZ <= ++_Myoff)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR [edx+24]
	ja	SHORT $LN2@pop_front

; 836  : 				_Myoff = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
$LN2@pop_front:

; 837  : 			if (--_Mysize == 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $LN4@pop_front

; 838  : 				_Myoff = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
$LN4@pop_front:

; 839  : 			}
; 840  : 			}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?pop_front@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::pop_front
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Block$121034 = -8					; size = 4
__Newoff$121033 = -4					; size = 4
?pop_back@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::pop_back, COMDAT
; _this$ = ecx

; 863  : 		{	// erase element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 864  : 
; 865  :  #if _HAS_ITERATOR_DEBUGGING
; 866  : 		if (empty())
; 867  : 			_DEBUG_ERROR("deque empty before pop");
; 868  : 		else
; 869  : 			{	// something to erase, do it
; 870  : 			_Orphan_off(_Myoff + _Mysize - 1);
; 871  : 
; 872  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 873  : 		if (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QBE_NXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@pop_back

; 874  : 			{	// something to erase, do it
; 875  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 876  : 
; 877  : 			size_type _Newoff = _Mysize + _Myoff - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	lea	edx, DWORD PTR [edx+ecx-1]
	mov	DWORD PTR __Newoff$121033[ebp], edx

; 878  : 			size_type _Block = _Newoff / _DEQUESIZ;

	mov	eax, DWORD PTR __Newoff$121033[ebp]
	mov	DWORD PTR __Block$121034[ebp], eax

; 879  : 			if (_Mapsize <= _Block)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR __Block$121034[ebp]
	ja	SHORT $LN2@pop_back

; 880  : 				_Block -= _Mapsize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Block$121034[ebp]
	sub	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Block$121034[ebp], ecx
$LN2@pop_back:

; 881  : 			this->_Alval.destroy(_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR __Newoff$121033[ebp]
	xor	edx, edx
	mov	esi, 1
	div	esi
	shl	edx, 4
	mov	eax, DWORD PTR __Block$121034[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@@Z ; std::allocator<Ogre::InputEvent>::destroy

; 882  : 			if (--_Mysize == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN4@pop_back

; 883  : 				_Myoff = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0
$LN4@pop_back:

; 884  : 			}
; 885  : 			}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?pop_back@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::pop_back
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T125760 = -80						; size = 28
$T125759 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@KAXXZ PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Xlen, COMDAT

; 1210 : 		{	// report length error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1211 : 		_THROW(length_error, "deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T125760[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T125760[ebp]
	push	eax
	lea	ecx, DWORD PTR $T125759[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T125759[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T125760[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1212 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T125760[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@KAXXZ ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Xlen
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1logic_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$1
__ehfuncinfo$??1logic_error@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1logic_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 31   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1logic_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??1logic_error@std@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1logic_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1length_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1length_error@std@@UAE@XZ$0
__ehfuncinfo$??1length_error@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1length_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1length_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1length_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1length_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1length_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??$?0UInputEvent@Ogre@@@?$allocator@PAUInputEvent@Ogre@@@std@@QAE@ABV?$allocator@UInputEvent@Ogre@@@1@@Z ; std::allocator<Ogre::InputEvent *>::allocator<Ogre::InputEvent *><Ogre::InputEvent>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >::_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
xdata$x	SEGMENT
__unwindtable$??0?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T125824 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z PROC ; std::_Deque_map<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Deque_map<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >, COMDAT
; _this$ = ecx

; 478  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T125824[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UInputEvent@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::InputEvent>::allocator<Ogre::InputEvent>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >::_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??$?0UInputEvent@Ogre@@@?$allocator@PAUInputEvent@Ogre@@@std@@QAE@ABV?$allocator@UInputEvent@Ogre@@@1@@Z ; std::allocator<Ogre::InputEvent *>::allocator<Ogre::InputEvent *><Ogre::InputEvent>

; 479  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >
__ehhandler$??0?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Deque_map@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z ENDP ; std::_Deque_map<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Deque_map<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@I@Z PROC ; std::allocator<Ogre::InputEvent>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@I@Z ENDP ; std::allocator<Ogre::InputEvent>::deallocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::deallocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUInputEvent@Ogre@@@std@@QAEXPAPAUInputEvent@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAUInputEvent@Ogre@@@std@@QAEXPAPAUInputEvent@Ogre@@I@Z PROC ; std::allocator<Ogre::InputEvent *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAUInputEvent@Ogre@@@std@@QAEXPAPAUInputEvent@Ogre@@I@Z ENDP ; std::allocator<Ogre::InputEvent *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@IPAPAU12@@Z ; std::_Allocate<Ogre::InputEvent *>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@PAUInputEvent@Ogre@@@std@@QAEPAPAUInputEvent@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAUInputEvent@Ogre@@@std@@QAEPAPAUInputEvent@Ogre@@I@Z PROC ; std::allocator<Ogre::InputEvent *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@IPAPAU12@@Z ; std::_Allocate<Ogre::InputEvent *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAUInputEvent@Ogre@@@std@@QAEPAPAUInputEvent@Ogre@@I@Z ENDP ; std::allocator<Ogre::InputEvent *>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy@PAUInputEvent@Ogre@@@std@@YAXPAPAUInputEvent@Ogre@@@Z ; std::_Destroy<Ogre::InputEvent *>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@PAUInputEvent@Ogre@@@std@@QAEXPAPAUInputEvent@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAUInputEvent@Ogre@@@std@@QAEXPAPAUInputEvent@Ogre@@@Z PROC ; std::allocator<Ogre::InputEvent *>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAUInputEvent@Ogre@@@std@@YAXPAPAUInputEvent@Ogre@@@Z ; std::_Destroy<Ogre::InputEvent *>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAUInputEvent@Ogre@@@std@@QAEXPAPAUInputEvent@Ogre@@@Z ENDP ; std::allocator<Ogre::InputEvent *>::destroy
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@PAPAVInputHandler@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVInputHandler@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::InputHandler *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVInputHandler@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::InputHandler *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$121097 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVInputHandler@Ogre@@PAPAV12@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::InputHandler * *,Ogre::InputHandler * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$121097[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$121097[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXPAPAVInputHandler@Ogre@@0@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$121097[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::erase
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVInputHandler@Ogre@@PAPAV12@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::InputHandler * *,Ogre::InputHandler * *>
PUBLIC	??$fill@PAPAVInputHandler@Ogre@@PAV12@@std@@YAXPAPAVInputHandler@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::InputHandler * *,Ogre::InputHandler *>
PUBLIC	??$_Umove@PAPAVInputHandler@Ogre@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Umove<Ogre::InputHandler * *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$121132 = -44					; size = 4
__Oldend$121133 = -40					; size = 4
__Tmp$121122 = -36					; size = 4
__Ncopied$121109 = -32					; size = 4
__Newvec$121107 = -28					; size = 4
__Whereoff$121108 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Xlen
	jmp	$LN16@Insert_n
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVInputHandler@Ogre@@@std@@QAEPAPAVInputHandler@Ogre@@I@Z ; std::allocator<Ogre::InputHandler *>::allocate
	mov	DWORD PTR __Newvec$121107[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$121108[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$121109[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$121108[ebp]
	mov	ecx, DWORD PTR __Newvec$121107[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$121109[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$121109[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$121107[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVInputHandler@Ogre@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Umove<Ogre::InputHandler * *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$121109[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$121109[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$121108[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$121107[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVInputHandler@Ogre@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Umove<Ogre::InputHandler * *>
	jmp	SHORT $LN19@Insert_n
__catch$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$121109[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$121108[ebp]
	mov	ecx, DWORD PTR __Newvec$121107[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$121107[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXPAPAVInputHandler@Ogre@@0@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Destroy
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$121109[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$121108[ebp]
	mov	edx, DWORD PTR __Newvec$121107[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$121108[ebp]
	mov	ecx, DWORD PTR __Newvec$121107[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXPAPAVInputHandler@Ogre@@0@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Destroy
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$121107[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVInputHandler@Ogre@@@std@@QAEXPAPAVInputHandler@Ogre@@I@Z ; std::allocator<Ogre::InputHandler *>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z$1
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXPAPAVInputHandler@Ogre@@0@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVInputHandler@Ogre@@@std@@QAEXPAPAVInputHandler@Ogre@@I@Z ; std::allocator<Ogre::InputHandler *>::deallocate
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$121107[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$121107[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$121107[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$121122[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVInputHandler@Ogre@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Umove<Ogre::InputHandler * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$121122[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ufill
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXPAPAVInputHandler@Ogre@@0@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$121122[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAPAVInputHandler@Ogre@@PAV12@@std@@YAXPAPAVInputHandler@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::InputHandler * *,Ogre::InputHandler *>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$121132[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$121133[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$121133[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$121133[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVInputHandler@Ogre@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Umove<Ogre::InputHandler * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$121133[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$121133[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAPAVInputHandler@Ogre@@PAPAV12@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::InputHandler * *,Ogre::InputHandler * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$121132[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAPAVInputHandler@Ogre@@PAV12@@std@@YAXPAPAVInputHandler@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::InputHandler * *,Ogre::InputHandler *>
	add	esp, 12					; 0000000cH
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@IABQAVInputHandler@Ogre@@@Z ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Insert_n
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T125874 = -80						; size = 28
$T125873 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T125874[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T125874[ebp]
	push	eax
	lea	ecx, DWORD PTR $T125873[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T125873[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T125874[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T125874[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Xlen
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
PUBLIC	??$?0PAVInputHandler@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVInputHandler@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::InputHandler *>
PUBLIC	??0_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::_Container_base_aux
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T125886 = -24						; size = 4
$T125885 = -20						; size = 4
$T125884 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVInputHandler@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVInputHandler@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::InputHandler *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T125886[ebp], eax
	mov	ecx, DWORD PTR $T125886[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T125885[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T125885[ebp], 0
	je	SHORT $LN3@Container_
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T125885[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_
$LN3@Container_:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T125884[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T125884[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T125886[ebp]
	push	eax
	mov	ecx, DWORD PTR $T125885[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAE@V?$allocator@PAVInputHandler@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
;	COMDAT ??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z PROC	; std::_Aux_cont::_Aux_cont, COMDAT
; _this$ = ecx

; 364  : 	explicit _Aux_cont(const _Container_base_aux * const _Pcont)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ENDP	; std::_Aux_cont::_Aux_cont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::_Container_base_aux, COMDAT
; _this$ = ecx

; 379  : 	_Container_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		{
; 381  : 		// Do nothing: _Container_base_aux_alloc_real() will construct the aux object.
; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\new
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 58   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 60   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::InputHandler *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVInputHandler@Ogre@@@std@@QAEPAPAVInputHandler@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVInputHandler@Ogre@@@std@@QAEPAPAVInputHandler@Ogre@@I@Z PROC ; std::allocator<Ogre::InputHandler *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::InputHandler *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVInputHandler@Ogre@@@std@@QAEPAPAVInputHandler@Ogre@@I@Z ENDP ; std::allocator<Ogre::InputHandler *>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>, COMDAT
; _this$ = ecx

; 381  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>

; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>
_TEXT	ENDS
PUBLIC	??Y?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+, COMDAT
; _this$ = ecx

; 427  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 428  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 429  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 430  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+
_TEXT	ENDS
PUBLIC	??G?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-
; Function compile flags: /Odtp
;	COMDAT ??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@@Z PROC ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-, COMDAT
; _this$ = ecx

; 444  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 445  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-

; 446  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@@Z ENDP ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-
_TEXT	ENDS
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
PUBLIC	??0?$_Ranit@UInputEvent@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Ranit<Ogre::InputEvent,int,Ogre::InputEvent const *,Ogre::InputEvent const &>::_Ranit<Ogre::InputEvent,int,Ogre::InputEvent const *,Ogre::InputEvent const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>, COMDAT
; _this$ = ecx

; 125  : 		_Deque_const_iterator(size_type _Off, const _Mydequebase *_Pdeque)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UInputEvent@Ogre@@HPBU12@ABU12@@std@@QAE@XZ

; 126  : 			{	// construct with offset _Off in *_Pdeque
; 127  : 			_SCL_SECURE_TRAITS_VALIDATE(
; 128  : 				_Pdeque != NULL &&
; 129  : 				((_Mydeque *)_Pdeque)->_Myoff <= _Off && _Off <= (((_Mydeque *)_Pdeque)->_Myoff + ((_Mydeque *)_Pdeque)->_Mysize));

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN6@Deque_cons
	cmp	DWORD PTR __Pdeque$[ebp], 0
	je	SHORT $LN4@Deque_cons
	mov	ecx, DWORD PTR __Pdeque$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR __Off$[ebp]
	ja	SHORT $LN4@Deque_cons
	mov	eax, DWORD PTR __Pdeque$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Pdeque$[ebp]
	add	ecx, DWORD PTR [edx+28]
	cmp	DWORD PTR __Off$[ebp], ecx
	jbe	SHORT $LN2@Deque_cons
$LN4@Deque_cons:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Deque_cons:
	xor	eax, eax
	jne	SHORT $LN2@Deque_cons
$LN6@Deque_cons:

; 130  : 				
; 131  : 			this->_Set_container(_Pdeque);

	mov	ecx, DWORD PTR __Pdeque$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 132  : 			_Myoff = _Off;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [edx+4], eax

; 133  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = ecx

; 452  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 454  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
_TEXT	ENDS
PUBLIC	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
;	COMDAT ??Y?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+=, COMDAT
; _this$ = ecx

; 198  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 199  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN11@operator@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@operator@4
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN8@operator@4:
	xor	edx, edx
	jne	SHORT $LN8@operator@4
$LN11@operator@4:

; 200  : 		_SCL_SECURE_TRAITS_VALIDATE_RANGE(
; 201  : 			_Myoff + _Off <= ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize &&
; 202  : 			_Myoff + _Off >= ((_Mydeque *)(this->_Getmycont()))->_Myoff);

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN6@operator@4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+4]
	add	esi, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	edi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	edx, DWORD PTR [edi+24]
	add	edx, DWORD PTR [eax+28]
	cmp	esi, edx
	ja	SHORT $LN4@operator@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+4]
	add	esi, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+24]
	jae	SHORT $LN2@operator@4
$LN4@operator@4:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@4:
	xor	ecx, ecx
	jne	SHORT $LN2@operator@4
$LN6@operator@4:

; 203  : 		_Myoff += _Off;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 204  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 205  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+=
_TEXT	ENDS
PUBLIC	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Iterator_base_aux::_Getmycont, COMDAT
; _this$ = ecx

; 457  : 		{	// Go through the aux object to get the container

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		return _Myaux ? _Myaux->_Getcont() : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN4@Getmycont
$LN3@Getmycont:
	mov	DWORD PTR tv67[ebp], 0
$LN4@Getmycont:
	mov	eax, DWORD PTR tv67[ebp]

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Aux_cont::_Getcont, COMDAT
; _this$ = ecx

; 368  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 		return _Mycontainer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 467  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 		return _Myaux != 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	al, cl

; 469  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVInputHandler@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::InputHandler *,int,Ogre::InputHandler * const *,Ogre::InputHandler * const &>::_Ranit<Ogre::InputHandler *,int,Ogre::InputHandler * const *,Ogre::InputHandler * const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@PAPAVInputHandler@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@PAPAVInputHandler@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVInputHandler@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN4@Vector_con
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN4@Vector_con
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con
$LN4@Vector_con:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con:
	xor	ecx, ecx
	jne	SHORT $LN2@Vector_con

; 79   : 		this->_Set_container(_Pvector);

	mov	edx, DWORD PTR __Pvector$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@PAPAVInputHandler@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
_TEXT	ENDS
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Odtp
;	COMDAT ??G?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@operator@5
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@5
$LN4@operator@5:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@5:
	xor	eax, eax
	jne	SHORT $LN2@operator@5

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator-
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = ecx

; 462  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Other$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al

; 464  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@PAPAVInputHandler@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@PAPAVInputHandler@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@PAPAVInputHandler@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@PAPAVInputHandler@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator+
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UInputEvent@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::InputEvent,int,Ogre::InputEvent const *,Ogre::InputEvent const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::InputEvent,int,Ogre::InputEvent const *,Ogre::InputEvent const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UInputEvent@Ogre@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UInputEvent@Ogre@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::InputEvent,int,Ogre::InputEvent const *,Ogre::InputEvent const &>::_Ranit<Ogre::InputEvent,int,Ogre::InputEvent const *,Ogre::InputEvent const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UInputEvent@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UInputEvent@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::InputEvent,int,Ogre::InputEvent const *,Ogre::InputEvent const &>::_Ranit<Ogre::InputEvent,int,Ogre::InputEvent const *,Ogre::InputEvent const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVInputHandler@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::InputHandler *,int,Ogre::InputHandler * const *,Ogre::InputHandler * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::InputHandler *,int,Ogre::InputHandler * const *,Ogre::InputHandler * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVInputHandler@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVInputHandler@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::InputHandler *,int,Ogre::InputHandler * const *,Ogre::InputHandler * const &>::_Ranit<Ogre::InputHandler *,int,Ogre::InputHandler * const *,Ogre::InputHandler * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVInputHandler@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVInputHandler@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::InputHandler *,int,Ogre::InputHandler * const *,Ogre::InputHandler * const &>::_Ranit<Ogre::InputHandler *,int,Ogre::InputHandler * const *,Ogre::InputHandler * const &>
_TEXT	ENDS
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UInputEvent@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UInputEvent@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::InputEvent,int,Ogre::InputEvent const *,Ogre::InputEvent const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::InputEvent,int,Ogre::InputEvent const *,Ogre::InputEvent const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UInputEvent@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::InputEvent,int,Ogre::InputEvent const *,Ogre::InputEvent const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::InputEvent,int,Ogre::InputEvent const *,Ogre::InputEvent const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = ecx

; 448  : 	_Iterator_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVInputHandler@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVInputHandler@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::InputHandler *,int,Ogre::InputHandler * const *,Ogre::InputHandler * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::InputHandler *,int,Ogre::InputHandler * const *,Ogre::InputHandler * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVInputHandler@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::InputHandler *,int,Ogre::InputHandler * const *,Ogre::InputHandler * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::InputHandler *,int,Ogre::InputHandler * const *,Ogre::InputHandler * const &,std::_Iterator_base_aux>
_TEXT	ENDS
PUBLIC	??$?0UInputEvent@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UInputEvent@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::InputEvent>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T125960 = -24						; size = 4
$T125959 = -20						; size = 4
$T125958 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >::_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UInputEvent@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UInputEvent@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::InputEvent>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T125960[ebp], eax
	mov	ecx, DWORD PTR $T125960[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T125959[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T125959[ebp], 0
	je	SHORT $LN3@Container_@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T125959[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@2
$LN3@Container_@2:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@2:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T125958[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T125958[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T125960[ebp]
	push	eax
	mov	ecx, DWORD PTR $T125959[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAE@V?$allocator@UInputEvent@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >::_Container_base_aux_alloc_real<std::allocator<Ogre::InputEvent> >
PUBLIC	??$_Destroy@UInputEvent@Ogre@@@std@@YAXPAUInputEvent@Ogre@@@Z ; std::_Destroy<Ogre::InputEvent>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@@Z PROC ; std::allocator<Ogre::InputEvent>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UInputEvent@Ogre@@@std@@YAXPAUInputEvent@Ogre@@@Z ; std::_Destroy<Ogre::InputEvent>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@@Z ENDP ; std::allocator<Ogre::InputEvent>::destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UInputEvent@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UInputEvent@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::InputEvent>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 268435455	; 0fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UInputEvent@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::InputEvent>::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAE@PAPAVInputHandler@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVInputHandler@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVInputHandler@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::InputHandler *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@2
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@2
$LN3@max_size@2:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVInputHandler@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::InputHandler *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??Y?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+=, COMDAT
; _this$ = ecx

; 421  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 422  : 		*(_Mybase *)this += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+=

; 423  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 424  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEHABV01@@Z
_TEXT	SEGMENT
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEHABV01@@Z PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-, COMDAT
; _this$ = ecx

; 225  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 
; 227  :  #if _HAS_ITERATOR_DEBUGGING
; 228  : 		_Compat(_Right);
; 229  :  #else
; 230  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN6@operator@6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@operator@6
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@6
$LN4@operator@6:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@6:
	xor	ecx, ecx
	jne	SHORT $LN2@operator@6
$LN6@operator@6:

; 231  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 232  : 
; 233  : 		return (_Right._Myoff <= _Myoff ? _Myoff - _Right._Myoff
; 234  : 			: -(difference_type)(_Right._Myoff - _Myoff));

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	ja	SHORT $LN9@operator@6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	sub	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv129[ebp], ecx
	jmp	SHORT $LN10@operator@6
$LN9@operator@6:
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	sub	ecx, DWORD PTR [eax+4]
	neg	ecx
	mov	DWORD PTR tv129[ebp], ecx
$LN10@operator@6:
	mov	eax, DWORD PTR tv129[ebp]

; 235  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEHABV01@@Z ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator!=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@operator@7
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@operator@7:
	xor	ecx, ecx
	jne	SHORT $LN7@operator@7

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN4@operator@7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@7
$LN4@operator@7:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@7:
	xor	edx, edx
	jne	SHORT $LN2@operator@7

; 164  : 		_Myptr += _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@operator@8
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@8
$LN4@operator@8:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@8:
	xor	eax, eax
	jne	SHORT $LN2@operator@8

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::operator==
_TEXT	ENDS
PUBLIC	??$_Checked_assign_from_base@PAH@std@@YAXAAPAHABQAH@Z ; std::_Checked_assign_from_base<int *>
PUBLIC	??$_Find@PAHI@std@@YAPAHPAH0ABI@Z		; std::_Find<int *,unsigned int>
PUBLIC	??$_Checked_base@PAH@std@@YAPAHAAPAH@Z		; std::_Checked_base<int *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$find@PAHI@std@@YAPAHPAH0ABI@Z
_TEXT	SEGMENT
$T126001 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$find@PAHI@std@@YAPAHPAH0ABI@Z PROC			; std::find<int *,unsigned int>, COMDAT

; 73   : 	{	// find first matching _Val

	push	ebp
	mov	ebp, esp
	push	ecx

; 74   : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAH@std@@YAPAHAAPAH@Z	; std::_Checked_base<int *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAH@std@@YAPAHAAPAH@Z	; std::_Checked_base<int *>
	add	esp, 4
	push	eax
	call	??$_Find@PAHI@std@@YAPAHPAH0ABI@Z	; std::_Find<int *,unsigned int>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T126001[ebp], eax
	lea	eax, DWORD PTR $T126001[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_assign_from_base@PAH@std@@YAXAAPAHABQAH@Z ; std::_Checked_assign_from_base<int *>
	add	esp, 8

; 75   : 		_Find(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val));
; 76   : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 77   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$find@PAHI@std@@YAPAHPAH0ABI@Z ENDP			; std::find<int *,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Insert<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
PUBLIC	??$_Iter_cat@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Iter_cat<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
;	COMDAT ??$insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T126005 = -2						; size = 1
$T126004 = -1						; size = 1
__Where$ = 8						; size = 8
__First$ = 16						; size = 8
__Last$ = 24						; size = 8
??$insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00@Z PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::insert<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT
; _this$ = ecx

; 958  : 		void insert(const_iterator _Where, _It _First, _It _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 959  : 		{	// insert [_First, _Last) at _Where
; 960  : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T126004[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Iter_cat<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 8
	movzx	edx, BYTE PTR $T126005[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Insert<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >

; 961  : 		}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??$insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00@Z ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::insert<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
PUBLIC	??$_Checked_base@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
PUBLIC	??$_Iter_random@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@ABV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Iter_random<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
PUBLIC	??$_Ptr_cat@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Ptr_cat<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$copy@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0V10@@Z
_TEXT	SEGMENT
$T126012 = -20						; size = 8
$T126011 = -12						; size = 8
$T126010 = -3						; size = 1
$T126009 = -2						; size = 1
$T126008 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0V10@@Z PROC ; std::copy<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT

; 2561 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2562 : 	return (_Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, 
; 2563 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T126008[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Ptr_cat<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 8
	mov	BYTE PTR $T126009[ebp], al
	movzx	eax, BYTE PTR $T126008[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T126009[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T126010[ebp]
	push	ecx
	call	??$_Iter_random@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@ABV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Iter_random<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T126011[ebp]
	push	eax
	call	??$_Checked_base@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T126012[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 8
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2564 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$copy@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0V10@@Z ENDP ; std::copy<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@PAPAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@2@@stdext@@YAPAPAVInputHandler@Ogre@@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVInputHandler@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ucopy<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@PAPAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@2@@stdext@@YAPAPAVInputHandler@Ogre@@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVInputHandler@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ucopy<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::InputHandler * *,Ogre::InputHandler * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::InputHandler * *>
PUBLIC	??$_Iter_random@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVInputHandler@Ogre@@0@Z ; std::_Iter_random<Ogre::InputHandler * *,Ogre::InputHandler * *>
PUBLIC	??$_Ptr_cat@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVInputHandler@Ogre@@0@Z ; std::_Ptr_cat<Ogre::InputHandler * *,Ogre::InputHandler * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVInputHandler@Ogre@@PAPAV12@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T126019 = -3						; size = 1
$T126018 = -2						; size = 1
$T126017 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVInputHandler@Ogre@@PAPAV12@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::InputHandler * *,Ogre::InputHandler * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T126017[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVInputHandler@Ogre@@0@Z ; std::_Ptr_cat<Ogre::InputHandler * *,Ogre::InputHandler * *>
	add	esp, 8
	mov	BYTE PTR $T126018[ebp], al
	movzx	eax, BYTE PTR $T126017[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T126018[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T126019[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVInputHandler@Ogre@@0@Z ; std::_Iter_random<Ogre::InputHandler * *,Ogre::InputHandler * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::InputHandler * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::InputHandler * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::InputHandler * *,Ogre::InputHandler * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVInputHandler@Ogre@@PAPAV12@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::InputHandler * *,Ogre::InputHandler * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVInputHandler@Ogre@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVInputHandler@Ogre@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ucopy<Ogre::InputHandler * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVInputHandler@Ogre@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Ucopy<Ogre::InputHandler * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
PUBLIC	??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
PUBLIC	??$_Iter_random@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0@Z ; std::_Iter_random<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
PUBLIC	??$_Ptr_cat@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$copy_backward@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V10@00@Z
_TEXT	SEGMENT
$T126028 = -20						; size = 8
$T126027 = -12						; size = 8
$T126026 = -3						; size = 1
$T126025 = -2						; size = 1
$T126024 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy_backward@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V10@00@Z PROC ; std::copy_backward<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT

; 2721 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2722 : 	return _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 2723 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T126024[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 8
	mov	BYTE PTR $T126025[ebp], al
	movzx	eax, BYTE PTR $T126024[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T126025[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T126026[ebp]
	push	ecx
	call	??$_Iter_random@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0@Z ; std::_Iter_random<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T126027[ebp]
	push	eax
	call	??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T126028[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 8
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Copy_backward_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2724 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$copy_backward@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V10@00@Z ENDP ; std::copy_backward<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
; Function compile flags: /Odtp
;	COMDAT ??$copy@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V10@00@Z
_TEXT	SEGMENT
$T126035 = -20						; size = 8
$T126034 = -12						; size = 8
$T126033 = -3						; size = 1
$T126032 = -2						; size = 1
$T126031 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V10@00@Z PROC ; std::copy<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT

; 2561 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2562 : 	return (_Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, 
; 2563 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T126031[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 8
	mov	BYTE PTR $T126032[ebp], al
	movzx	eax, BYTE PTR $T126031[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T126032[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T126033[ebp]
	push	ecx
	call	??$_Iter_random@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0@Z ; std::_Iter_random<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T126034[ebp]
	push	eax
	call	??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T126035[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 8
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2564 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$copy@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V10@00@Z ENDP ; std::copy<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAUInputEvent@Ogre@@PAPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAPAPAUInputEvent@Ogre@@PAPAU12@00AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::InputEvent * *,Ogre::InputEvent * *,std::allocator<Ogre::InputEvent *> >
PUBLIC	??$_Checked_base@PAPAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::InputEvent * *>
PUBLIC	??$_Ptr_cat@PAPAUInputEvent@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUInputEvent@Ogre@@0@Z ; std::_Ptr_cat<Ogre::InputEvent * *,Ogre::InputEvent * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAUInputEvent@Ogre@@PAPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAPAPAUInputEvent@Ogre@@PAPAU12@00AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T126039 = -2						; size = 1
$T126038 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAUInputEvent@Ogre@@PAPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAPAPAUInputEvent@Ogre@@PAPAU12@00AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::InputEvent * *,Ogre::InputEvent * *,std::allocator<Ogre::InputEvent *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T126038[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAUInputEvent@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUInputEvent@Ogre@@0@Z ; std::_Ptr_cat<Ogre::InputEvent * *,Ogre::InputEvent * *>
	add	esp, 8
	mov	BYTE PTR $T126039[ebp], al
	movzx	eax, BYTE PTR $T126038[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T126039[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::InputEvent * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::InputEvent * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAUInputEvent@Ogre@@PAPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAPAPAUInputEvent@Ogre@@PAPAU12@00AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::InputEvent * *,Ogre::InputEvent * *,std::allocator<Ogre::InputEvent *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAUInputEvent@Ogre@@PAPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAPAPAUInputEvent@Ogre@@PAPAU12@00AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::InputEvent * *,Ogre::InputEvent * *,std::allocator<Ogre::InputEvent *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAUInputEvent@Ogre@@IPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *,std::allocator<Ogre::InputEvent *> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAUInputEvent@Ogre@@IPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAXPAPAUInputEvent@Ogre@@IABQAU12@AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T126043 = -2						; size = 1
$T126042 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAUInputEvent@Ogre@@IPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAXPAPAUInputEvent@Ogre@@IABQAU12@AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *,std::allocator<Ogre::InputEvent *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T126042[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAUInputEvent@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUInputEvent@Ogre@@0@Z ; std::_Ptr_cat<Ogre::InputEvent * *,Ogre::InputEvent * *>
	add	esp, 8
	mov	BYTE PTR $T126043[ebp], al
	movzx	eax, BYTE PTR $T126042[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T126043[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAUInputEvent@Ogre@@IPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *,std::allocator<Ogre::InputEvent *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAUInputEvent@Ogre@@IPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@stdext@@YAXPAPAUInputEvent@Ogre@@IABQAU12@AAV?$allocator@PAUInputEvent@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *,std::allocator<Ogre::InputEvent *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@0AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::InputEvent *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@0AAV?$allocator@PAUInputEvent@Ogre@@@0@@Z
_TEXT	SEGMENT
$T126046 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@0AAV?$allocator@PAUInputEvent@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::InputEvent *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAUInputEvent@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUInputEvent@Ogre@@0@Z ; std::_Ptr_cat<Ogre::InputEvent * *,Ogre::InputEvent * *>
	add	esp, 8
	mov	BYTE PTR $T126046[ebp], al
	movzx	edx, BYTE PTR $T126046[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@0AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::InputEvent *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@0AAV?$allocator@PAUInputEvent@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::InputEvent *> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Allocate@UInputEvent@Ogre@@@std@@YAPAUInputEvent@Ogre@@IPAU12@@Z
_TEXT	SEGMENT
$T126049 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UInputEvent@Ogre@@@std@@YAPAUInputEvent@Ogre@@IPAU12@@Z PROC ; std::_Allocate<Ogre::InputEvent>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T126049[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T126049[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UInputEvent@Ogre@@@std@@YAPAUInputEvent@Ogre@@IPAU12@@Z ENDP ; std::_Allocate<Ogre::InputEvent>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_alloc@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0
__ehfuncinfo$??1bad_alloc@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_alloc@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 381  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??1bad_alloc@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1bad_alloc@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@UInputEvent@Ogre@@U12@@std@@YAXPAUInputEvent@Ogre@@ABU12@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T126072 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UInputEvent@Ogre@@U12@@std@@YAXPAUInputEvent@Ogre@@ABU12@@Z PROC ; std::_Construct<Ogre::InputEvent,Ogre::InputEvent>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T126072[ebp], eax
	cmp	DWORD PTR $T126072[ebp], 0
	je	SHORT $LN3@Construct
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T126072[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T126072[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct
$LN3@Construct:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UInputEvent@Ogre@@U12@@std@@YAXPAUInputEvent@Ogre@@ABU12@@Z ENDP ; std::_Construct<Ogre::InputEvent,Ogre::InputEvent>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@0AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@0AAV?$allocator@PAVInputHandler@Ogre@@@0@@Z
_TEXT	SEGMENT
$T126077 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@0AAV?$allocator@PAVInputHandler@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::InputHandler *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVInputHandler@Ogre@@0@Z ; std::_Ptr_cat<Ogre::InputHandler * *,Ogre::InputHandler * *>
	add	esp, 8
	mov	BYTE PTR $T126077[ebp], al
	movzx	edx, BYTE PTR $T126077[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@0AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::InputHandler *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@0AAV?$allocator@PAVInputHandler@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::InputHandler *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVInputHandler@Ogre@@IPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVInputHandler@Ogre@@IPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAXPAPAVInputHandler@Ogre@@IABQAV12@AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T126081 = -2						; size = 1
$T126080 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVInputHandler@Ogre@@IPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAXPAPAVInputHandler@Ogre@@IABQAV12@AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T126080[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVInputHandler@Ogre@@0@Z ; std::_Ptr_cat<Ogre::InputHandler * *,Ogre::InputHandler * *>
	add	esp, 8
	mov	BYTE PTR $T126081[ebp], al
	movzx	eax, BYTE PTR $T126080[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T126081[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAVInputHandler@Ogre@@IPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAVInputHandler@Ogre@@IPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAXPAPAVInputHandler@Ogre@@IABQAV12@AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0UInputEvent@Ogre@@@?$allocator@PAUInputEvent@Ogre@@@std@@QAE@ABV?$allocator@UInputEvent@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UInputEvent@Ogre@@@?$allocator@PAUInputEvent@Ogre@@@std@@QAE@ABV?$allocator@UInputEvent@Ogre@@@1@@Z PROC ; std::allocator<Ogre::InputEvent *>::allocator<Ogre::InputEvent *><Ogre::InputEvent>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UInputEvent@Ogre@@@?$allocator@PAUInputEvent@Ogre@@@std@@QAE@ABV?$allocator@UInputEvent@Ogre@@@1@@Z ENDP ; std::allocator<Ogre::InputEvent *>::allocator<Ogre::InputEvent *><Ogre::InputEvent>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@IPAPAU12@@Z
_TEXT	SEGMENT
$T126086 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@IPAPAU12@@Z PROC ; std::_Allocate<Ogre::InputEvent *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T126086[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T126086[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@IPAPAU12@@Z ENDP ; std::_Allocate<Ogre::InputEvent *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUInputEvent@Ogre@@@std@@YAXPAPAUInputEvent@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAUInputEvent@Ogre@@@std@@YAXPAPAUInputEvent@Ogre@@@Z PROC ; std::_Destroy<Ogre::InputEvent *>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAUInputEvent@Ogre@@@std@@YAXPAPAUInputEvent@Ogre@@@Z ENDP ; std::_Destroy<Ogre::InputEvent *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVInputHandler@Ogre@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVInputHandler@Ogre@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Umove<Ogre::InputHandler * *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAVInputHandler@Ogre@@@?$vector@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@IAEPAPAVInputHandler@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Umove<Ogre::InputHandler * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVInputHandler@Ogre@@PAV12@@std@@YAXPAPAVInputHandler@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::InputHandler * *,Ogre::InputHandler *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAVInputHandler@Ogre@@PAV12@@std@@YAXPAPAVInputHandler@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVInputHandler@Ogre@@PAV12@@std@@YAXPAPAVInputHandler@Ogre@@0ABQAV12@@Z PROC ; std::fill<Ogre::InputHandler * *,Ogre::InputHandler *>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::InputHandler * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::InputHandler * *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAPAVInputHandler@Ogre@@PAV12@@std@@YAXPAPAVInputHandler@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::InputHandler * *,Ogre::InputHandler *>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAPAVInputHandler@Ogre@@PAV12@@std@@YAXPAPAVInputHandler@Ogre@@0ABQAV12@@Z ENDP ; std::fill<Ogre::InputHandler * *,Ogre::InputHandler *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::InputHandler * *,Ogre::InputHandler * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAPAVInputHandler@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVInputHandler@Ogre@@@Z ; std::_Move_cat<Ogre::InputHandler * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAPAVInputHandler@Ogre@@PAPAV12@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T126097 = -3						; size = 1
$T126096 = -2						; size = 1
$T126095 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVInputHandler@Ogre@@PAPAV12@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::InputHandler * *,Ogre::InputHandler * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T126095[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVInputHandler@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVInputHandler@Ogre@@@Z ; std::_Move_cat<Ogre::InputHandler * *>
	add	esp, 4
	mov	BYTE PTR $T126096[ebp], al
	movzx	edx, BYTE PTR $T126095[ebp]
	push	edx
	movzx	eax, BYTE PTR $T126096[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T126097[ebp]
	push	eax
	call	??$_Iter_random@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVInputHandler@Ogre@@0@Z ; std::_Iter_random<Ogre::InputHandler * *,Ogre::InputHandler * *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::InputHandler * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::InputHandler * *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::InputHandler * *,Ogre::InputHandler * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAVInputHandler@Ogre@@PAPAV12@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::InputHandler * *,Ogre::InputHandler * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAVInputHandler@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVInputHandler@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVInputHandler@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVInputHandler@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::InputHandler *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVInputHandler@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVInputHandler@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::InputHandler *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T126102 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::InputHandler *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T126102[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T126102[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::InputHandler *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UInputEvent@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UInputEvent@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UInputEvent@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UInputEvent@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::InputEvent>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UInputEvent@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UInputEvent@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::InputEvent>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UInputEvent@Ogre@@@std@@YAXPAUInputEvent@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UInputEvent@Ogre@@@std@@YAXPAUInputEvent@Ogre@@@Z PROC ; std::_Destroy<Ogre::InputEvent>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UInputEvent@Ogre@@@std@@YAXPAUInputEvent@Ogre@@@Z ENDP ; std::_Destroy<Ogre::InputEvent>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z
_TEXT	SEGMENT
$T126109 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z PROC ; std::_Allocate<std::_Aux_cont>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T126109[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T126109[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Aux_cont>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
PUBLIC	??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<int *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAH@std@@YAPAHAAPAH@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAH@std@@YAPAHAAPAH@Z PROC		; std::_Checked_base<int *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<int *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAH@std@@YAPAHAAPAH@Z ENDP		; std::_Checked_base<int *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Find@PAHI@std@@YAPAHPAH0ABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find@PAHI@std@@YAPAHPAH0ABI@Z PROC			; std::_Find<int *,unsigned int>, COMDAT

; 37   : 	{	// find first matching _Val

	push	ebp
	mov	ebp, esp

; 38   : 	_DEBUG_RANGE(_First, _Last);
; 39   : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN4@Find
$LN3@Find:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN4@Find:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN2@Find

; 40   : 		if (*_First == _Val)

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@Find

; 41   : 			break;

	jmp	SHORT $LN2@Find
$LN1@Find:

; 42   : 	return (_First);

	jmp	SHORT $LN3@Find
$LN2@Find:
	mov	eax, DWORD PTR __First$[ebp]

; 43   : 	}

	pop	ebp
	ret	0
??$_Find@PAHI@std@@YAPAHPAH0ABI@Z ENDP			; std::_Find<int *,unsigned int>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_assign_from_base@PAH@std@@YAXAAPAHABQAH@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Checked_assign_from_base@PAH@std@@YAXAAPAHABQAH@Z PROC ; std::_Checked_assign_from_base<int *>, COMDAT

; 1180 : 	{

	push	ebp
	mov	ebp, esp

; 1181 : 		_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1182 : 	}

	pop	ebp
	ret	0
??$_Checked_assign_from_base@PAH@std@@YAXAAPAHABQAH@Z ENDP ; std::_Checked_assign_from_base<int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z PROC ; std::_Iter_cat<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ENDP ; std::_Iter_cat<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
_TEXT	ENDS
PUBLIC	?_Reverse@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXII@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Reverse
PUBLIC	?push_front@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXABUInputEvent@Ogre@@@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::push_front
PUBLIC	??D?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEABUInputEvent@Ogre@@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator*
PUBLIC	??9?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator!=
PUBLIC	??E?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator++
PUBLIC	??8?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator==
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
xdata$x	SEGMENT
__catchsym$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$2
__catchsym$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$0
__unwindtable$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
	DD	02H
	DD	FLAT:__tryblocktable$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T126131 = -72						; size = 16
$T126130 = -56						; size = 16
$T126129 = -40						; size = 8
__Num$123164 = -32					; size = 4
__Off$ = -28						; size = 4
__Rem$ = -24						; size = 4
__Oldsize$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__First$ = 16						; size = 8
__Last$ = 24						; size = 8
___formal$ = 32						; size = 1
??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Insert<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT
; _this$ = ecx

; 971  : 		void _Insert(const_iterator _Where,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 60					; 0000003cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 972  : 			_It _First, _It _Last, input_iterator_tag)
; 973  : 		{	// insert [_First, _Last) at _Where, input iterators
; 974  : 		size_type _Off = _Where - begin();

	lea	eax, DWORD PTR $T126129[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-
	mov	DWORD PTR __Off$[ebp], eax

; 975  : 
; 976  :  #if _HAS_ITERATOR_DEBUGGING
; 977  : 		if (_Mysize < _Off)
; 978  : 			_DEBUG_ERROR("deque insert iterator outside range");
; 979  : 		_DEBUG_RANGE(_First, _Last);
; 980  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 981  : 
; 982  : 		size_type _Rem = _Mysize - _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Rem$[ebp], edx

; 983  : 		size_type _Oldsize = _Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR __Oldsize$[ebp], ecx

; 984  : 
; 985  : 		if (_First == _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@Insert
	jmp	$LN21@Insert
$LN19@Insert:

; 986  : 			;
; 987  : 		else if (_Off < _Rem)

	mov	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR __Rem$[ebp]
	jae	$LN17@Insert

; 988  : 			{	// closer to front
; 989  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 990  : 			for (; _First != _Last; ++_First)

	jmp	SHORT $LN15@Insert
$LN14@Insert:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator++
$LN15@Insert:
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@Insert

; 991  : 				push_front((value_type)*_First);	// prepend flipped

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEABUInputEvent@Ogre@@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T126130[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T126130[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T126130[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR $T126130[ebp+12], edx
	lea	eax, DWORD PTR $T126130[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_front@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXABUInputEvent@Ogre@@@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::push_front
	jmp	SHORT $LN14@Insert
$LN13@Insert:
	jmp	SHORT $LN22@Insert
__catch$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$0:
$LN12@Insert:

; 992  : 
; 993  : 			_CATCH_ALL
; 994  : 			for (; _Oldsize < _Mysize; )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Oldsize$[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jae	SHORT $LN11@Insert

; 995  : 				pop_front();	// restore old size, at least

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_front@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::pop_front
	jmp	SHORT $LN12@Insert
$LN11@Insert:

; 996  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 997  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$1
	ret	0
$LN22@Insert:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$1:

; 998  : 
; 999  : 			size_type _Num = _Mysize - _Oldsize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	sub	ecx, DWORD PTR __Oldsize$[ebp]
	mov	DWORD PTR __Num$123164[ebp], ecx

; 1000 : 
; 1001 : 			if (0 < _Off)

	cmp	DWORD PTR __Off$[ebp], 0
	jbe	SHORT $LN10@Insert

; 1002 : 				{	// insert not at beginning, flip new stuff into place
; 1003 : 				_Reverse(_Num, _Num + _Off);

	mov	edx, DWORD PTR __Num$123164[ebp]
	add	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR __Num$123164[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXII@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Reverse

; 1004 : 				_Reverse(0, _Num + _Off);

	mov	ecx, DWORD PTR __Num$123164[ebp]
	add	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXII@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Reverse

; 1005 : 				}
; 1006 : 			else

	jmp	SHORT $LN9@Insert
$LN10@Insert:

; 1007 : 				_Reverse(0, _Num);	// flip new stuff in place

	mov	edx, DWORD PTR __Num$123164[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXII@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Reverse
$LN9@Insert:

; 1008 : 			}
; 1009 : 		else

	jmp	$LN21@Insert
$LN17@Insert:

; 1010 : 			{	// closer to back
; 1011 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1012 : 			for (; _First != _Last; ++_First)

	jmp	SHORT $LN6@Insert
$LN5@Insert:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator++
$LN6@Insert:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Insert

; 1013 : 				push_back((value_type)*_First);	// append

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEABUInputEvent@Ogre@@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator*
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T126131[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T126131[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T126131[ebp+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR $T126131[ebp+12], eax
	lea	ecx, DWORD PTR $T126131[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXABUInputEvent@Ogre@@@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::push_back
	jmp	SHORT $LN5@Insert
$LN4@Insert:
	jmp	SHORT $LN24@Insert
__catch$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$2:
$LN3@Insert:

; 1014 : 
; 1015 : 			_CATCH_ALL
; 1016 : 			for (; _Oldsize < _Mysize; )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Oldsize$[ebp]
	cmp	eax, DWORD PTR [edx+28]
	jae	SHORT $LN2@Insert

; 1017 : 				pop_back();	// restore old size, at least

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXXZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::pop_back
	jmp	SHORT $LN3@Insert
$LN2@Insert:

; 1018 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1019 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$3
	ret	0
$LN24@Insert:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$3:

; 1020 : 
; 1021 : 			if (_Off < _Oldsize)

	mov	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR __Oldsize$[ebp]
	jae	SHORT $LN21@Insert

; 1022 : 				{	// insert not at end, flip new stuff into place
; 1023 : 				_Reverse(_Off, _Oldsize);

	mov	edx, DWORD PTR __Oldsize$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXII@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Reverse

; 1024 : 				_Reverse(_Oldsize, _Mysize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR __Oldsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXII@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Reverse

; 1025 : 				_Reverse(_Off, _Mysize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXII@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Reverse
$LN21@Insert:

; 1026 : 				}
; 1027 : 			}
; 1028 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@1@00Uinput_iterator_tag@1@@Z ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Insert<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
PUBLIC	??$_Checked_base@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
??$_Checked_base@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z PROC ; std::_Checked_base<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Different_checked_iterator_base_type_tag>
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ENDP ; std::_Checked_base<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@ABV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@ABV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z PROC ; std::_Iter_random<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@ABV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ENDP ; std::_Iter_random<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z PROC ; std::_Ptr_cat<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ENDP ; std::_Ptr_cat<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::forward_iterator_tag>
PUBLIC	??G?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator-
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T126163 = -28						; size = 8
$T126162 = -20						; size = 8
$T126161 = -11						; size = 1
$T126160 = -10						; size = 1
$T126159 = -9						; size = 1
__Result$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator-
	push	eax
	lea	ecx, DWORD PTR __Result$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??H?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T126159[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T126160[ebp], al
	movzx	ecx, BYTE PTR $T126159[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T126160[ebp]
	push	edx
	movzx	eax, BYTE PTR $T126161[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T126162[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T126163[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::forward_iterator_tag>
	add	esp, 40					; 00000028H

; 2486 : 	return _Result;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Result$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAPAPAVInputHandler@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::InputHandler * const *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@@std@@YAPBQAVInputHandler@Ogre@@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@PAPAVInputHandler@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@AAPAPAVInputHandler@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >,Ogre::InputHandler * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@PAPAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@2@@stdext@@YAPAPAVInputHandler@Ogre@@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVInputHandler@Ogre@@@4@@Z
_TEXT	SEGMENT
$T126167 = -2						; size = 1
$T126166 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@PAPAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@2@@stdext@@YAPAPAVInputHandler@Ogre@@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVInputHandler@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T126166[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@PAPAVInputHandler@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@AAPAPAVInputHandler@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >,Ogre::InputHandler * *>
	add	esp, 8
	mov	BYTE PTR $T126167[ebp], al
	movzx	eax, BYTE PTR $T126166[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T126167[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@@std@@YAPBQAVInputHandler@Ogre@@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@@std@@YAPBQAVInputHandler@Ogre@@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAPAPAVInputHandler@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::InputHandler * const *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@PAPAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@2@@stdext@@YAPAPAVInputHandler@Ogre@@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVInputHandler@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::InputHandler * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::InputHandler * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::InputHandler * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::InputHandler * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVInputHandler@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVInputHandler@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::InputHandler * *,Ogre::InputHandler * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVInputHandler@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::InputHandler * *,Ogre::InputHandler * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVInputHandler@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVInputHandler@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::InputHandler * *,Ogre::InputHandler * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVInputHandler@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::InputHandler * *,Ogre::InputHandler * *>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::InputHandler * *,Ogre::InputHandler * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::InputHandler * *,Ogre::InputHandler * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T126179 = -2						; size = 1
$T126178 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T126178[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVInputHandler@Ogre@@0@Z ; std::_Ptr_cat<Ogre::InputHandler * *,Ogre::InputHandler * *>
	add	esp, 8
	mov	BYTE PTR $T126179[ebp], al
	movzx	eax, BYTE PTR $T126178[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T126179[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::InputHandler * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::InputHandler * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z PROC ; std::_Checked_base<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Different_checked_iterator_base_type_tag>
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ENDP ; std::_Checked_base<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0@Z PROC ; std::_Iter_random<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0@Z ENDP ; std::_Iter_random<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0@Z PROC ; std::_Ptr_cat<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@0@Z ENDP ; std::_Ptr_cat<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::forward_iterator_tag>
PUBLIC	??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-
PUBLIC	??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@1@@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator-
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_backward_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T126192 = -28						; size = 8
$T126191 = -20						; size = 8
$T126190 = -11						; size = 1
$T126189 = -10						; size = 1
$T126188 = -9						; size = 1
__Result$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_backward_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@1@@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator-
	push	eax
	lea	ecx, DWORD PTR __Result$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T126188[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T126189[ebp], al
	movzx	ecx, BYTE PTR $T126188[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T126189[ebp]
	push	edx
	movzx	eax, BYTE PTR $T126190[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T126191[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T126192[ebp]
	push	ecx
	call	??$_Copy_backward_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::forward_iterator_tag>
	add	esp, 40					; 00000028H

; 2690 : 	return _Result;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Result$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T126199 = -28						; size = 8
$T126198 = -20						; size = 8
$T126197 = -11						; size = 1
$T126196 = -10						; size = 1
$T126195 = -9						; size = 1
__Result$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@1@@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator-
	push	eax
	lea	ecx, DWORD PTR __Result$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??H?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T126195[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T126196[ebp], al
	movzx	ecx, BYTE PTR $T126195[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T126196[ebp]
	push	edx
	movzx	eax, BYTE PTR $T126197[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T126198[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T126199[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::forward_iterator_tag>
	add	esp, 40					; 00000028H

; 2486 : 	return _Result;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Result$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::InputEvent * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@PAPAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@AAPAPAU12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@AAPAPAU12@@Z PROC ; std::_Checked_base<Ogre::InputEvent * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::InputEvent * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@AAPAPAU12@@Z ENDP ; std::_Checked_base<Ogre::InputEvent * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAUInputEvent@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUInputEvent@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAUInputEvent@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUInputEvent@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::InputEvent * *,Ogre::InputEvent * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAUInputEvent@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUInputEvent@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::InputEvent * *,Ogre::InputEvent * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAUInputEvent@Ogre@@PAPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAPAPAUInputEvent@Ogre@@PAPAU12@00AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAUInputEvent@Ogre@@PAPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAPAPAUInputEvent@Ogre@@PAPAU12@00AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::InputEvent * *,Ogre::InputEvent * *,std::allocator<Ogre::InputEvent *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAUInputEvent@Ogre@@PAPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAPAPAUInputEvent@Ogre@@PAPAU12@00AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::InputEvent * *,Ogre::InputEvent * *,std::allocator<Ogre::InputEvent *> >
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAUInputEvent@Ogre@@IPAU12@@stdext@@YAXPAPAUInputEvent@Ogre@@IABQAU12@@Z ; stdext::unchecked_fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *>
; Function compile flags: /Odtp
;	COMDAT ??$_Uninit_fill_n@PAPAUInputEvent@Ogre@@IPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAUInputEvent@Ogre@@IPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *,std::allocator<Ogre::InputEvent *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAUInputEvent@Ogre@@IPAU12@@stdext@@YAXPAPAUInputEvent@Ogre@@IABQAU12@@Z ; stdext::unchecked_fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAUInputEvent@Ogre@@IPAU12@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *,std::allocator<Ogre::InputEvent *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@0AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@0AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::InputEvent *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAUInputEvent@Ogre@@@std@@@std@@YAXPAPAUInputEvent@Ogre@@0AAV?$allocator@PAUInputEvent@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::InputEvent *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@0AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@0AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::InputHandler *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@0AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::InputHandler *> >
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVInputHandler@Ogre@@IPAV12@@stdext@@YAXPAPAVInputHandler@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAVInputHandler@Ogre@@IPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVInputHandler@Ogre@@IPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAVInputHandler@Ogre@@IPAV12@@stdext@@YAXPAPAVInputHandler@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAVInputHandler@Ogre@@IPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T126217 = -2						; size = 1
$T126216 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T126216[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVInputHandler@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVInputHandler@Ogre@@@Z ; std::_Move_cat<Ogre::InputHandler * *>
	add	esp, 4
	mov	BYTE PTR $T126217[ebp], al
	movzx	edx, BYTE PTR $T126216[ebp]
	push	edx
	movzx	eax, BYTE PTR $T126217[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::InputHandler * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::InputHandler * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAVInputHandler@Ogre@@PAV12@@std@@YAXPAPAVInputHandler@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVInputHandler@Ogre@@PAV12@@std@@YAXPAPAVInputHandler@Ogre@@0ABQAV12@@Z PROC ; std::_Fill<Ogre::InputHandler * *,Ogre::InputHandler *>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill
$LN2@Fill:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill
$LN4@Fill:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAPAVInputHandler@Ogre@@PAV12@@std@@YAXPAPAVInputHandler@Ogre@@0ABQAV12@@Z ENDP ; std::_Fill<Ogre::InputHandler * *,Ogre::InputHandler *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAVInputHandler@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVInputHandler@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVInputHandler@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVInputHandler@Ogre@@@Z PROC ; std::_Move_cat<Ogre::InputHandler * *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAPAVInputHandler@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVInputHandler@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::InputHandler * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::InputHandler * *,Ogre::InputHandler * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T126225 = -2						; size = 1
$T126224 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::InputHandler * *,Ogre::InputHandler * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T126224[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVInputHandler@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVInputHandler@Ogre@@0@Z ; std::_Ptr_cat<Ogre::InputHandler * *,Ogre::InputHandler * *>
	add	esp, 8
	mov	BYTE PTR $T126225[ebp], al
	movzx	eax, BYTE PTR $T126224[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T126225[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::InputHandler * *,Ogre::InputHandler * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::InputHandler * *,Ogre::InputHandler * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?push_front@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXABUInputEvent@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -16						; size = 4
_this$ = -12						; size = 4
__Block$ = -8						; size = 4
__Newoff$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_front@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXABUInputEvent@Ogre@@@Z PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::push_front, COMDAT
; _this$ = ecx

; 799  : 		{	// insert element at beginning

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 800  : 
; 801  :  #if _HAS_ITERATOR_DEBUGGING
; 802  : 		this->_Orphan_all();
; 803  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 804  : 
; 805  : 		if (_Myoff % _DEQUESIZ == 0
; 806  : 			&& _Mapsize <= (_Mysize + _DEQUESIZ) / _DEQUESIZ)

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	xor	edx, edx
	mov	ecx, 1
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@push_front
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN2@push_front

; 807  : 			_Growmap(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@IAEXI@Z ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Growmap
$LN2@push_front:

; 808  : 		size_type _Newoff = _Myoff != 0 ? _Myoff
; 809  : 			: _Mapsize * _DEQUESIZ;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN5@push_front
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR tv77[ebp], ecx
	jmp	SHORT $LN6@push_front
$LN5@push_front:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv77[ebp], eax
$LN6@push_front:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Newoff$[ebp], ecx

; 810  : 		size_type _Block = --_Newoff / _DEQUESIZ;

	mov	edx, DWORD PTR __Newoff$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Newoff$[ebp], edx
	mov	eax, DWORD PTR __Newoff$[ebp]
	mov	DWORD PTR __Block$[ebp], eax

; 811  : 		if (_Map[_Block] == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	SHORT $LN1@push_front

; 812  : 			_Map[_Block] = this->_Alval.allocate(_DEQUESIZ);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@UInputEvent@Ogre@@@std@@QAEPAUInputEvent@Ogre@@I@Z ; std::allocator<Ogre::InputEvent>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@push_front:

; 813  : 		this->_Alval.construct(_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 1
	div	esi
	shl	edx, 4
	mov	eax, DWORD PTR __Block$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?construct@?$allocator@UInputEvent@Ogre@@@std@@QAEXPAUInputEvent@Ogre@@ABU34@@Z ; std::allocator<Ogre::InputEvent>::construct

; 814  : 		_Myoff = _Newoff;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Newoff$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 815  : 		++_Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 816  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_front@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXABUInputEvent@Ogre@@@Z ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::push_front
_TEXT	ENDS
PUBLIC	??$_Swap_adl@UInputEvent@Ogre@@@std@@YAXAAUInputEvent@Ogre@@0@Z ; std::_Swap_adl<Ogre::InputEvent>
PUBLIC	??A?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEAAUInputEvent@Ogre@@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator[]
; Function compile flags: /Odtp
;	COMDAT ?_Reverse@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Start$ = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Reverse@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXII@Z PROC ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Reverse, COMDAT
; _this$ = ecx

; 1031 : 		{	// reverse a subrange

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1032 : 		iterator _Start = begin();

	lea	eax, DWORD PTR __Start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@2@XZ ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::begin

; 1033 : 		for (; _First != _Last && _First != --_Last; ++_First)

	jmp	SHORT $LN3@Reverse
$LN2@Reverse:
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 1
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Reverse:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Reverse
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Last$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Reverse

; 1034 : 			_STD _Swap_adl(_Start[_First], _Start[_Last]);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Start$[ebp]
	call	??A?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEAAUInputEvent@Ogre@@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator[]
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Start$[ebp]
	call	??A?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEAAUInputEvent@Ogre@@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator[]
	push	eax
	call	??$_Swap_adl@UInputEvent@Ogre@@@std@@YAXAAUInputEvent@Ogre@@0@Z ; std::_Swap_adl<Ogre::InputEvent>
	add	esp, 8
	jmp	SHORT $LN2@Reverse
$LN4@Reverse:

; 1035 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Reverse@?$deque@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@@std@@QAEXII@Z ENDP ; std::deque<Ogre::InputEvent,std::allocator<Ogre::InputEvent> >::_Reverse
_TEXT	ENDS
PUBLIC	??Z?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-=
; Function compile flags: /Odtp
;	COMDAT ??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-, COMDAT
; _this$ = ecx

; 438  : 		{	// return this - integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 439  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 440  : 		return (_Tmp -= _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Z?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 441  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEABUInputEvent@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Off$ = -8						; size = 4
__Block$ = -4						; size = 4
??D?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEABUInputEvent@Ogre@@XZ PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator*, COMDAT
; _this$ = ecx

; 136  : 			{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 			size_type _Block = _Myoff / _DEQUESIZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Block$[ebp], ecx

; 138  : 			size_type _Off = _Myoff & (_DEQUESIZ - 1);	// assume power of 2

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 0
	mov	DWORD PTR __Off$[ebp], eax

; 139  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@operator@9
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@operator@9:
	xor	edx, edx
	jne	SHORT $LN7@operator@9

; 140  : 			_SCL_SECURE_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [esi+24]
	add	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], ecx
	jb	SHORT $LN3@operator@9
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@9:
	xor	eax, eax
	jne	SHORT $LN3@operator@9

; 141  : 			if (static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize <= _Block)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Block$[ebp]
	ja	SHORT $LN1@operator@9

; 142  : 				_Block -= static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	edx, DWORD PTR __Block$[ebp]
	sub	edx, DWORD PTR [eax+20]
	mov	DWORD PTR __Block$[ebp], edx
$LN1@operator@9:

; 143  : 			return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR __Block$[ebp]
	add	ecx, DWORD PTR [eax+edx*4]
	mov	eax, ecx

; 144  : 			}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEABUInputEvent@Ogre@@XZ ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??E?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator++, COMDAT
; _this$ = ecx

; 153  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN10@operator@10
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@operator@10
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@operator@10:
	xor	edx, edx
	jne	SHORT $LN7@operator@10
$LN10@operator@10:

; 155  : 		_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@operator@10
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [esi+24]
	add	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], ecx
	jb	SHORT $LN2@operator@10
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@10:
	xor	eax, eax
	jne	SHORT $LN2@operator@10
$LN5@operator@10:

; 156  : 
; 157  :  #if _HAS_ITERATOR_DEBUGGING
; 158  : 		if (this->_Mycont == 0
; 159  : 			|| ((_Mydeque *)this->_Mycont)->_Myoff
; 160  : 				+ ((_Mydeque *)this->_Mycont)->_Mysize == _Myoff)
; 161  : 			_DEBUG_ERROR("deque iterator not incrementable");
; 162  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 163  : 
; 164  : 		++_Myoff;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator==, COMDAT
; _this$ = ecx

; 243  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 
; 245  :  #if _HAS_ITERATOR_DEBUGGING
; 246  : 		_Compat(_Right);
; 247  : 		return (_Myoff == _Right._Myoff);
; 248  : 		}
; 249  : 
; 250  :  #elif _SECURE_SCL
; 251  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN6@operator@11
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@operator@11
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@11
$LN4@operator@11:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@11:
	xor	ecx, ecx
	jne	SHORT $LN2@operator@11
$LN6@operator@11:

; 252  : 		return (_Myoff == _Right._Myoff);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	sete	dl
	mov	al, dl

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??9?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator!=, COMDAT
; _this$ = ecx

; 261  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 262  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 263  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEHABV01@@Z PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator-, COMDAT
; _this$ = ecx

; 225  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 
; 227  :  #if _HAS_ITERATOR_DEBUGGING
; 228  : 		_Compat(_Right);
; 229  :  #else
; 230  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	xor	eax, eax
	je	SHORT $LN6@operator@12
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@operator@12
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@12
$LN4@operator@12:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@12:
	xor	ecx, ecx
	jne	SHORT $LN2@operator@12
$LN6@operator@12:

; 231  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 232  : 
; 233  : 		return (_Right._Myoff <= _Myoff ? _Myoff - _Right._Myoff
; 234  : 			: -(difference_type)(_Right._Myoff - _Myoff));

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	ja	SHORT $LN9@operator@12
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	sub	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv129[ebp], ecx
	jmp	SHORT $LN10@operator@12
$LN9@operator@12:
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	sub	ecx, DWORD PTR [eax+4]
	neg	ecx
	mov	DWORD PTR tv129[ebp], ecx
$LN10@operator@12:
	mov	eax, DWORD PTR tv129[ebp]

; 235  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEHABV01@@Z ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@1@@Z PROC ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator-, COMDAT
; _this$ = ecx

; 444  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 445  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator-

; 446  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@1@@Z ENDP ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Z?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Z?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-=, COMDAT
; _this$ = ecx

; 433  : 		{	// decrement by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 434  : 		return (*this += -_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+=

; 435  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Z?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator-=
_TEXT	ENDS
PUBLIC	??D?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEAAUInputEvent@Ogre@@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator*
; Function compile flags: /Odtp
;	COMDAT ??A?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEAAUInputEvent@Ogre@@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T126252 = -8						; size = 8
__Off$ = 8						; size = 4
??A?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEAAUInputEvent@Ogre@@H@Z PROC ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator[], COMDAT
; _this$ = ecx

; 449  : 		{	// subscript

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 450  : 		return (*(*this + _Off));

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T126252[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??H?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator+
	mov	ecx, eax
	call	??D?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEAAUInputEvent@Ogre@@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator*

; 451  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEAAUInputEvent@Ogre@@H@Z ENDP ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator[]
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEAAUInputEvent@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEAAUInputEvent@Ogre@@XZ PROC ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator*, COMDAT
; _this$ = ecx

; 385  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 386  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEABUInputEvent@Ogre@@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator*

; 387  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBEAAUInputEvent@Ogre@@XZ ENDP ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::operator*
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<int *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<int *>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Checked_base@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Checked_iterator_base
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	??D?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEAAUInputEvent@Ogre@@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator*
PUBLIC	??D?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEABUInputEvent@Ogre@@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator*
PUBLIC	??9?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator!=
PUBLIC	??E?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator++
PUBLIC	??E?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator++
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	esi

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@2
$LN2@Copy_opt@2:
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator++
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator++
$LN3@Copy_opt@2:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_opt@2

; 2472 : 		*_Dest = *_First;

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEABUInputEvent@Ogre@@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator*
	mov	esi, eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEAAUInputEvent@Ogre@@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator*
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], ecx
	jmp	SHORT $LN2@Copy_opt@2
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	pop	esi
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVInputHandler@Ogre@@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@@std@@YAPBQAVInputHandler@Ogre@@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@@std@@YAPBQAVInputHandler@Ogre@@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVInputHandler@Ogre@@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@@std@@YAPBQAVInputHandler@Ogre@@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@PAPAVInputHandler@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@AAPAPAVInputHandler@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@PAPAVInputHandler@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@AAPAPAVInputHandler@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >,Ogre::InputHandler * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@PAPAVInputHandler@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@AAPAPAVInputHandler@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >,Ogre::InputHandler * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAPAPAVInputHandler@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAPAPAVInputHandler@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::InputHandler * const *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@2:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAPAPAVInputHandler@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::InputHandler * const *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::InputHandler * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::InputHandler * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@3

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@3:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Checked_iterator_base
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Checked_iterator_base
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@AAV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	??F?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator--
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_backward_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_backward_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	esi
$LN2@Copy_backw:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_backw

; 2676 : 		*--_Dest = *--_Last;

	lea	ecx, DWORD PTR __Last$[ebp]
	call	??F?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator--
	mov	ecx, eax
	call	??D?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEAAUInputEvent@Ogre@@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator*
	mov	esi, eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??F?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator--
	mov	ecx, eax
	call	??D?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEAAUInputEvent@Ogre@@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator*
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], ecx
	jmp	SHORT $LN2@Copy_backw
$LN1@Copy_backw:

; 2677 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2678 : 	}

	pop	esi
	pop	ebp
	ret	0
??$_Copy_backward_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	esi

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@3
$LN2@Copy_opt@3:
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator++
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator++
$LN3@Copy_opt@3:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_opt@3

; 2472 : 		*_Dest = *_First;

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEAAUInputEvent@Ogre@@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator*
	mov	esi, eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEAAUInputEvent@Ogre@@XZ ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator*
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], ecx
	jmp	SHORT $LN2@Copy_opt@3
$LN1@Copy_opt@3:

; 2473 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	pop	esi
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::InputEvent * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::InputEvent * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAUInputEvent@Ogre@@IPAU12@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *>
PUBLIC	??$_Iter_cat@PAPAUInputEvent@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUInputEvent@Ogre@@@Z ; std::_Iter_cat<Ogre::InputEvent * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_fill_n@PAPAUInputEvent@Ogre@@IPAU12@@stdext@@YAXPAPAUInputEvent@Ogre@@IABQAU12@@Z
_TEXT	SEGMENT
$T126282 = -2						; size = 1
$T126281 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAUInputEvent@Ogre@@IPAU12@@stdext@@YAXPAPAUInputEvent@Ogre@@IABQAU12@@Z PROC ; stdext::unchecked_fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T126281[ebp], al
	movzx	ecx, BYTE PTR $T126281[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T126282[ebp]
	push	eax
	call	??$_Iter_cat@PAPAUInputEvent@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUInputEvent@Ogre@@@Z ; std::_Iter_cat<Ogre::InputEvent * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAUInputEvent@Ogre@@IPAU12@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAUInputEvent@Ogre@@IPAU12@@stdext@@YAXPAPAUInputEvent@Ogre@@IABQAU12@@Z ENDP ; stdext::unchecked_fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVInputHandler@Ogre@@IPAV12@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *>
PUBLIC	??$_Iter_cat@PAPAVInputHandler@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVInputHandler@Ogre@@@Z ; std::_Iter_cat<Ogre::InputHandler * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_fill_n@PAPAVInputHandler@Ogre@@IPAV12@@stdext@@YAXPAPAVInputHandler@Ogre@@IABQAV12@@Z
_TEXT	SEGMENT
$T126286 = -2						; size = 1
$T126285 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVInputHandler@Ogre@@IPAV12@@stdext@@YAXPAPAVInputHandler@Ogre@@IABQAV12@@Z PROC ; stdext::unchecked_fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T126285[ebp], al
	movzx	ecx, BYTE PTR $T126285[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T126286[ebp]
	push	eax
	call	??$_Iter_cat@PAPAVInputHandler@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVInputHandler@Ogre@@@Z ; std::_Iter_cat<Ogre::InputHandler * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAVInputHandler@Ogre@@IPAV12@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAVInputHandler@Ogre@@IPAV12@@stdext@@YAXPAPAVInputHandler@Ogre@@IABQAV12@@Z ENDP ; stdext::unchecked_fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@@stdext@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAPAVInputHandler@Ogre@@PAPAV12@V?$allocator@PAVInputHandler@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00AAV?$allocator@PAVInputHandler@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::InputHandler * *,Ogre::InputHandler * *,std::allocator<Ogre::InputHandler *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::InputHandler * *,Ogre::InputHandler * *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Result$[ebp], edx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw@2

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR __Result$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw@2:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPAVInputHandler@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVInputHandler@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::InputHandler * *,Ogre::InputHandler * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$swap@UInputEvent@Ogre@@@std@@YAXAAUInputEvent@Ogre@@0@Z ; std::swap<Ogre::InputEvent>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$_Swap_adl@UInputEvent@Ogre@@@std@@YAXAAUInputEvent@Ogre@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@UInputEvent@Ogre@@@std@@YAXAAUInputEvent@Ogre@@0@Z PROC ; std::_Swap_adl<Ogre::InputEvent>, COMDAT

; 30   : 	{	// exchange values stored at _Left and _Right, using ADL

	push	ebp
	mov	ebp, esp

; 31   : 	swap(_Left, _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$swap@UInputEvent@Ogre@@@std@@YAXAAUInputEvent@Ogre@@0@Z ; std::swap<Ogre::InputEvent>
	add	esp, 8

; 32   : 	}

	pop	ebp
	ret	0
??$_Swap_adl@UInputEvent@Ogre@@@std@@YAXAAUInputEvent@Ogre@@0@Z ENDP ; std::_Swap_adl<Ogre::InputEvent>
_TEXT	ENDS
PUBLIC	??0?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
;	COMDAT ?_Checked_iterator_base@?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Base$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?_Checked_iterator_base@?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@XZ PROC ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 363  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 364  : 		_Deque_iterator<_Ty, _Alloc, false> _Base(this->_Myoff, this->_Getmycont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	ecx, DWORD PTR __Base$[ebp]
	call	??0?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>

; 365  : 		return _Base;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Base$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Base$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 366  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Checked_iterator_base@?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@XZ ENDP ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Checked_iterator_base
_TEXT	ENDS
PUBLIC	??0?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>
; Function compile flags: /Odtp
;	COMDAT ?_Checked_iterator_base@?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Base$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?_Checked_iterator_base@?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@XZ PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 		_Deque_const_iterator<_Ty, _Alloc, false> _Base(this->_Myoff, this->_Getmycont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	ecx, DWORD PTR __Base$[ebp]
	call	??0?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>

; 70   : 		return _Base;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Base$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Base$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Checked_iterator_base@?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@2@XZ ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,1>::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEABUInputEvent@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Off$ = -8						; size = 4
__Block$ = -4						; size = 4
??D?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEABUInputEvent@Ogre@@XZ PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator*, COMDAT
; _this$ = ecx

; 136  : 			{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 			size_type _Block = _Myoff / _DEQUESIZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Block$[ebp], ecx

; 138  : 			size_type _Off = _Myoff & (_DEQUESIZ - 1);	// assume power of 2

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 0
	mov	DWORD PTR __Off$[ebp], eax

; 139  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@operator@13
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@operator@13:
	xor	edx, edx
	jne	SHORT $LN7@operator@13

; 140  : 			_SCL_SECURE_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [esi+24]
	add	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], ecx
	jb	SHORT $LN3@operator@13
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@13:
	xor	eax, eax
	jne	SHORT $LN3@operator@13

; 141  : 			if (static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize <= _Block)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Block$[ebp]
	ja	SHORT $LN1@operator@13

; 142  : 				_Block -= static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	edx, DWORD PTR __Block$[ebp]
	sub	edx, DWORD PTR [eax+20]
	mov	DWORD PTR __Block$[ebp], edx
$LN1@operator@13:

; 143  : 			return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR __Block$[ebp]
	add	ecx, DWORD PTR [eax+edx*4]
	mov	eax, ecx

; 144  : 			}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEABUInputEvent@Ogre@@XZ ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??E?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator++, COMDAT
; _this$ = ecx

; 153  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	xor	eax, eax
	je	SHORT $LN10@operator@14
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@operator@14
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@operator@14:
	xor	edx, edx
	jne	SHORT $LN7@operator@14
$LN10@operator@14:

; 155  : 		_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	xor	eax, eax
	je	SHORT $LN5@operator@14
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [esi+24]
	add	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], ecx
	jb	SHORT $LN2@operator@14
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@14:
	xor	eax, eax
	jne	SHORT $LN2@operator@14
$LN5@operator@14:

; 156  : 
; 157  :  #if _HAS_ITERATOR_DEBUGGING
; 158  : 		if (this->_Mycont == 0
; 159  : 			|| ((_Mydeque *)this->_Mycont)->_Myoff
; 160  : 				+ ((_Mydeque *)this->_Mycont)->_Mysize == _Myoff)
; 161  : 			_DEBUG_ERROR("deque iterator not incrementable");
; 162  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 163  : 
; 164  : 		++_Myoff;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator++
_TEXT	ENDS
PUBLIC	??8?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator!=, COMDAT
; _this$ = ecx

; 261  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 262  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 263  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEAAUInputEvent@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEAAUInputEvent@Ogre@@XZ PROC ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator*, COMDAT
; _this$ = ecx

; 385  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 386  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEABUInputEvent@Ogre@@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator*

; 387  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBEAAUInputEvent@Ogre@@XZ ENDP ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??E?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ PROC ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator++, COMDAT
; _this$ = ecx

; 395  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 396  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator++

; 397  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 398  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ENDP ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator++
_TEXT	ENDS
PUBLIC	??F?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator--
; Function compile flags: /Odtp
;	COMDAT ??F?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ PROC ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator--, COMDAT
; _this$ = ecx

; 408  : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 		--*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??F?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator--

; 410  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 411  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ENDP ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator--
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>, COMDAT
; _this$ = ecx

; 125  : 		_Deque_const_iterator(size_type _Off, const _Mydequebase *_Pdeque)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UInputEvent@Ogre@@HPBU12@ABU12@@std@@QAE@XZ

; 126  : 			{	// construct with offset _Off in *_Pdeque
; 127  : 			_SCL_SECURE_TRAITS_VALIDATE(
; 128  : 				_Pdeque != NULL &&
; 129  : 				((_Mydeque *)_Pdeque)->_Myoff <= _Off && _Off <= (((_Mydeque *)_Pdeque)->_Myoff + ((_Mydeque *)_Pdeque)->_Mysize));

	xor	eax, eax
	je	SHORT $LN6@Deque_cons@2
	cmp	DWORD PTR __Pdeque$[ebp], 0
	je	SHORT $LN4@Deque_cons@2
	mov	ecx, DWORD PTR __Pdeque$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR __Off$[ebp]
	ja	SHORT $LN4@Deque_cons@2
	mov	eax, DWORD PTR __Pdeque$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Pdeque$[ebp]
	add	ecx, DWORD PTR [edx+28]
	cmp	DWORD PTR __Off$[ebp], ecx
	jbe	SHORT $LN2@Deque_cons@2
$LN4@Deque_cons@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Deque_cons@2:
	xor	eax, eax
	jne	SHORT $LN2@Deque_cons@2
$LN6@Deque_cons@2:

; 130  : 				
; 131  : 			this->_Set_container(_Pdeque);

	mov	ecx, DWORD PTR __Pdeque$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 132  : 			_Myoff = _Off;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [edx+4], eax

; 133  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??F?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator--, COMDAT
; _this$ = ecx

; 176  : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	xor	eax, eax
	je	SHORT $LN10@operator@15
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@operator@15
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@operator@15:
	xor	edx, edx
	jne	SHORT $LN7@operator@15
$LN10@operator@15:

; 178  : 		_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Myoff > ((_Mydeque *)(this->_Getmycont()))->_Myoff);

	xor	eax, eax
	je	SHORT $LN5@operator@15
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+24]
	ja	SHORT $LN2@operator@15
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@15:
	xor	eax, eax
	jne	SHORT $LN2@operator@15
$LN5@operator@15:

; 179  : 
; 180  :  #if _HAS_ITERATOR_DEBUGGING
; 181  : 		if (this->_Mycont == 0
; 182  : 			|| _Myoff == ((_Mydeque *)this->_Mycont)->_Myoff)
; 183  : 			_DEBUG_ERROR("deque iterator not decrementable");
; 184  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 185  : 
; 186  : 		--_Myoff;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 187  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator--
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator==, COMDAT
; _this$ = ecx

; 243  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 
; 245  :  #if _HAS_ITERATOR_DEBUGGING
; 246  : 		_Compat(_Right);
; 247  : 		return (_Myoff == _Right._Myoff);
; 248  : 		}
; 249  : 
; 250  :  #elif _SECURE_SCL
; 251  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	xor	eax, eax
	je	SHORT $LN6@operator@16
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@operator@16
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@16
$LN4@operator@16:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@16:
	xor	ecx, ecx
	jne	SHORT $LN2@operator@16
$LN6@operator@16:

; 252  : 		return (_Myoff == _Right._Myoff);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	sete	dl
	mov	al, dl

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>, COMDAT
; _this$ = ecx

; 381  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_const_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::_Deque_const_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>

; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_iterator@UInputEvent@Ogre@@V?$allocator@UInputEvent@Ogre@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>::_Deque_iterator<Ogre::InputEvent,std::allocator<Ogre::InputEvent>,0>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEPBQAVInputHandler@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Checked_iterator_base
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVInputHandler@Ogre@@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVInputHandler@Ogre@@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEPBQAVInputHandler@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVInputHandler@Ogre@@AAV?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAUInputEvent@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUInputEvent@Ogre@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAUInputEvent@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUInputEvent@Ogre@@@Z PROC ; std::_Iter_cat<Ogre::InputEvent * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAUInputEvent@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUInputEvent@Ogre@@@Z ENDP ; std::_Iter_cat<Ogre::InputEvent * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAUInputEvent@Ogre@@IPAU12@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAPAUInputEvent@Ogre@@IPAU12@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T126323 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAUInputEvent@Ogre@@IPAU12@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T126323[ebp], al
	movzx	ecx, BYTE PTR $T126323[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUInputEvent@Ogre@@@std@@YAPAPAUInputEvent@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::InputEvent * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAUInputEvent@Ogre@@IPAU12@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAUInputEvent@Ogre@@IPAU12@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAVInputHandler@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVInputHandler@Ogre@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVInputHandler@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVInputHandler@Ogre@@@Z PROC ; std::_Iter_cat<Ogre::InputHandler * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAVInputHandler@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVInputHandler@Ogre@@@Z ENDP ; std::_Iter_cat<Ogre::InputHandler * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVInputHandler@Ogre@@IPAV12@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAPAVInputHandler@Ogre@@IPAV12@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T126328 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVInputHandler@Ogre@@IPAV12@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T126328[ebp], al
	movzx	ecx, BYTE PTR $T126328[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVInputHandler@Ogre@@@std@@YAPAPAVInputHandler@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::InputHandler * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAVInputHandler@Ogre@@IPAV12@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAVInputHandler@Ogre@@IPAV12@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@UInputEvent@Ogre@@@std@@YAXAAUInputEvent@Ogre@@0@Z
_TEXT	SEGMENT
__Tmp$124170 = -16					; size = 16
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UInputEvent@Ogre@@@std@@YAXAAUInputEvent@Ogre@@0@Z PROC ; std::swap<Ogre::InputEvent>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$124170[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$124170[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$124170[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$124170[ebp+12], eax

; 21   : 
; 22   : 		_Left = _Right;

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Left$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 23   : 		_Right = _Tmp;

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Tmp$124170[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$124170[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Tmp$124170[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Tmp$124170[ebp+12]
	mov	DWORD PTR [edx+12], ecx
$LN2@swap:

; 24   : 		}
; 25   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@UInputEvent@Ogre@@@std@@YAXAAUInputEvent@Ogre@@0@Z ENDP ; std::swap<Ogre::InputEvent>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEPBQAVInputHandler@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEPBQAVInputHandler@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVInputHandler@Ogre@@V?$allocator@PAVInputHandler@Ogre@@@std@@@std@@QBEPBQAVInputHandler@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::InputHandler *,std::allocator<Ogre::InputHandler *> >::_Checked_iterator_base
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAUInputEvent@Ogre@@IPAU12@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAUInputEvent@Ogre@@IPAU12@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n
$LN2@Fill_n:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n
$LN4@Fill_n:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAUInputEvent@Ogre@@IPAU12@@std@@YAXPAPAUInputEvent@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::InputEvent * *,unsigned int,Ogre::InputEvent *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVInputHandler@Ogre@@IPAV12@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVInputHandler@Ogre@@IPAV12@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n@2
$LN2@Fill_n@2:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n@2

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n@2
$LN4@Fill_n@2:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAVInputHandler@Ogre@@IPAV12@@std@@YAXPAPAVInputHandler@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::InputHandler * *,unsigned int,Ogre::InputHandler *>
_TEXT	ENDS
END

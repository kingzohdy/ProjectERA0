; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\OgreFontBase.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?m_nInstanceCount@RFontBase@Ogre@@1IA		; Ogre::RFontBase::m_nInstanceCount
PUBLIC	?ms_Singleton@?$Singleton@VUIRenderer@Ogre@@@Ogre@@1PAVUIRenderer@2@A ; Ogre::Singleton<Ogre::UIRenderer>::ms_Singleton
_BSS	SEGMENT
?m_nInstanceCount@RFontBase@Ogre@@1IA DD 01H DUP (?)	; Ogre::RFontBase::m_nInstanceCount
_BSS	ENDS
;	COMDAT ?ms_Singleton@?$Singleton@VUIRenderer@Ogre@@@Ogre@@1PAVUIRenderer@2@A
_BSS	SEGMENT
?ms_Singleton@?$Singleton@VUIRenderer@Ogre@@@Ogre@@1PAVUIRenderer@2@A DD 01H DUP (?) ; Ogre::Singleton<Ogre::UIRenderer>::ms_Singleton
_BSS	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5715
_DATA	ENDS
CONST	SEGMENT
$SG5715	DB	'bad allocation', 00H
	ORG $+1
_MAX_FLOAT DD	07f7fffffr			; 3.40282e+038
_ONE_PI	DD	040490fd0r			; 3.14159
_EPSILON DD	03727c5acr			; 1e-005
_RADS_PER_DEG DD 03c8efa35r			; 0.0174533
_DEGS_PER_RAD DD 042652ee1r			; 57.2958
CONST	ENDS
PUBLIC	??_7DataStream@Ogre@@6B@			; Ogre::DataStream::`vftable'
PUBLIC	??0DataStream@Ogre@@QAE@XZ			; Ogre::DataStream::DataStream
PUBLIC	??_R4DataStream@Ogre@@6B@			; Ogre::DataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDataStream@Ogre@@@8			; Ogre::DataStream `RTTI Type Descriptor'
PUBLIC	??_R3DataStream@Ogre@@8				; Ogre::DataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DataStream@Ogre@@8				; Ogre::DataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DataStream@Ogre@@8		; Ogre::DataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDataStream@Ogre@@UAEPAXI@Z			; Ogre::DataStream::`vector deleting destructor'
PUBLIC	?size@DataStream@Ogre@@UBEIXZ			; Ogre::DataStream::size
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__purecall:PROC
EXTRN	?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::DataStream::readLine
EXTRN	?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:PROC ; Ogre::DataStream::getLine
EXTRN	?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:PROC ; Ogre::DataStream::getAsString
EXTRN	?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::DataStream::skipLine
;	COMDAT ??_R1A@?0A@EA@DataStream@Ogre@@8
; File i:\svnroot\client\ogremain\ogredatastream.h
rdata$r	SEGMENT
??_R1A@?0A@EA@DataStream@Ogre@@8 DD FLAT:??_R0?AVDataStream@Ogre@@@8 ; Ogre::DataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DataStream@Ogre@@8
rdata$r	SEGMENT
??_R2DataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8 ; Ogre::DataStream::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DataStream@Ogre@@8
rdata$r	SEGMENT
??_R3DataStream@Ogre@@8 DD 00H				; Ogre::DataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::DataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4DataStream@Ogre@@6B@ DD 00H			; Ogre::DataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDataStream@Ogre@@@8
	DD	FLAT:??_R3DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DataStream@Ogre@@6B@
CONST	SEGMENT
??_7DataStream@Ogre@@6B@ DD FLAT:??_R4DataStream@Ogre@@6B@ ; Ogre::DataStream::`vftable'
	DD	FLAT:??_EDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@XZ$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0DataStream@Ogre@@QAE@XZ PROC				; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx

; 68   : 		DataStream() : mSize(0) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@XZ ENDP				; Ogre::DataStream::DataStream
PUBLIC	??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ogre::DataStream::DataStream
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx

; 70   : 		DataStream(const String& name) : mName(name), mSize(0) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Ogre::DataStream::DataStream
PUBLIC	?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Ogre::DataStream::getName
; Function compile flags: /Odtp
;	COMDAT ?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Ogre::DataStream::getName, COMDAT
; _this$ = ecx

; 72   : 		const String& getName(void) { return mName; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Ogre::DataStream::getName
_TEXT	ENDS
PUBLIC	??1DataStream@Ogre@@UAE@XZ			; Ogre::DataStream::~DataStream
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1DataStream@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DataStream@Ogre@@UAE@XZ$0
__ehfuncinfo$??1DataStream@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1DataStream@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1DataStream@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1DataStream@Ogre@@UAE@XZ PROC				; Ogre::DataStream::~DataStream, COMDAT
; _this$ = ecx

; 73   : 		virtual ~DataStream() {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DataStream@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DataStream@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1DataStream@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1DataStream@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1DataStream@Ogre@@UAE@XZ ENDP				; Ogre::DataStream::~DataStream
; Function compile flags: /Odtp
;	COMDAT ?size@DataStream@Ogre@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@DataStream@Ogre@@UBEIXZ PROC			; Ogre::DataStream::size, COMDAT
; _this$ = ecx

; 157  : 		virtual size_t size(void) const { return mSize; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?size@DataStream@Ogre@@UBEIXZ ENDP			; Ogre::DataStream::size
_TEXT	ENDS
PUBLIC	??0DataStream@Ogre@@QAE@ABV01@@Z		; Ogre::DataStream::DataStream
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0DataStream@Ogre@@QAE@ABV01@@Z PROC			; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::DataStream::DataStream
PUBLIC	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::DataStream::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DataStream@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::DataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::DataStream::operator=
_TEXT	ENDS
PUBLIC	??_GDataStream@Ogre@@UAEPAXI@Z			; Ogre::DataStream::`scalar deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDataStream@Ogre@@UAEPAXI@Z PROC			; Ogre::DataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDataStream@Ogre@@UAEPAXI@Z ENDP			; Ogre::DataStream::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_EDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDataStream@Ogre@@UAEPAXI@Z PROC			; Ogre::DataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1DataStream@Ogre@@UAE@XZ	; Ogre::DataStream::~DataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDataStream@Ogre@@UAEPAXI@Z ENDP			; Ogre::DataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ		; Ogre::MemoryDataStream::getPtr
; Function compile flags: /Odtp
;	COMDAT ?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ PROC		; Ogre::MemoryDataStream::getPtr, COMDAT
; _this$ = ecx

; 267  : 		uchar* getPtr(void) { return mData; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ ENDP		; Ogre::MemoryDataStream::getPtr
_TEXT	ENDS
PUBLIC	?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ	; Ogre::MemoryDataStream::getCurrentPtr
; Function compile flags: /Odtp
;	COMDAT ?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ PROC	; Ogre::MemoryDataStream::getCurrentPtr, COMDAT
; _this$ = ecx

; 270  : 		uchar* getCurrentPtr(void) { return mPos; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ ENDP	; Ogre::MemoryDataStream::getCurrentPtr
_TEXT	ENDS
PUBLIC	?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ	; Ogre::MemoryDataStream::getMemoryImage
; Function compile flags: /Odtp
;	COMDAT ?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ PROC	; Ogre::MemoryDataStream::getMemoryImage, COMDAT
; _this$ = ecx

; 307  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 308  : 			return mData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 309  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ ENDP	; Ogre::MemoryDataStream::getMemoryImage
_TEXT	ENDS
PUBLIC	?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z ; Ogre::MemoryDataStream::setFreeOnClose
; Function compile flags: /Odtp
;	COMDAT ?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_freeOnClose$ = 8					; size = 4
?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z PROC ; Ogre::MemoryDataStream::setFreeOnClose, COMDAT
; _this$ = ecx

; 313  : 		void setFreeOnClose(void (*freeOnClose)(void *)) { mFreeOnClose = freeOnClose; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _freeOnClose$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z ENDP ; Ogre::MemoryDataStream::setFreeOnClose
_TEXT	ENDS
PUBLIC	??_7MemoryDataStream@Ogre@@6B@			; Ogre::MemoryDataStream::`vftable'
PUBLIC	??0MemoryDataStream@Ogre@@QAE@ABV01@@Z		; Ogre::MemoryDataStream::MemoryDataStream
PUBLIC	??_R4MemoryDataStream@Ogre@@6B@			; Ogre::MemoryDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMemoryDataStream@Ogre@@@8		; Ogre::MemoryDataStream `RTTI Type Descriptor'
PUBLIC	??_R3MemoryDataStream@Ogre@@8			; Ogre::MemoryDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MemoryDataStream@Ogre@@8			; Ogre::MemoryDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MemoryDataStream@Ogre@@8		; Ogre::MemoryDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EMemoryDataStream@Ogre@@UAEPAXI@Z		; Ogre::MemoryDataStream::`vector deleting destructor'
EXTRN	?read@MemoryDataStream@Ogre@@UAEIPAXI@Z:PROC	; Ogre::MemoryDataStream::read
EXTRN	?write@MemoryDataStream@Ogre@@UAEIPBXI@Z:PROC	; Ogre::MemoryDataStream::write
EXTRN	?readLine@MemoryDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::MemoryDataStream::readLine
EXTRN	?skipLine@MemoryDataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::MemoryDataStream::skipLine
EXTRN	?skip@MemoryDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::MemoryDataStream::skip
EXTRN	?seek@MemoryDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::MemoryDataStream::seek
EXTRN	?tell@MemoryDataStream@Ogre@@UBEIXZ:PROC	; Ogre::MemoryDataStream::tell
EXTRN	?eof@MemoryDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::MemoryDataStream::eof
EXTRN	?close@MemoryDataStream@Ogre@@UAEXXZ:PROC	; Ogre::MemoryDataStream::close
;	COMDAT ??_R1A@?0A@EA@MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MemoryDataStream@Ogre@@8 DD FLAT:??_R0?AVMemoryDataStream@Ogre@@@8 ; Ogre::MemoryDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2MemoryDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MemoryDataStream@Ogre@@8 ; Ogre::MemoryDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3MemoryDataStream@Ogre@@8 DD 00H			; Ogre::MemoryDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMemoryDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMemoryDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MemoryDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMemoryDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MemoryDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4MemoryDataStream@Ogre@@6B@ DD 00H			; Ogre::MemoryDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMemoryDataStream@Ogre@@@8
	DD	FLAT:??_R3MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7MemoryDataStream@Ogre@@6B@
CONST	SEGMENT
??_7MemoryDataStream@Ogre@@6B@ DD FLAT:??_R4MemoryDataStream@Ogre@@6B@ ; Ogre::MemoryDataStream::`vftable'
	DD	FLAT:??_EMemoryDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@MemoryDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@MemoryDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@MemoryDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@MemoryDataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@MemoryDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@MemoryDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@MemoryDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@MemoryDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@MemoryDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0MemoryDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::MemoryDataStream::MemoryDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7MemoryDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+44], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MemoryDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::MemoryDataStream::MemoryDataStream
PUBLIC	??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MemoryDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::MemoryDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+48], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::MemoryDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GMemoryDataStream@Ogre@@UAEPAXI@Z		; Ogre::MemoryDataStream::`scalar deleting destructor'
EXTRN	??1MemoryDataStream@Ogre@@UAE@XZ:PROC		; Ogre::MemoryDataStream::~MemoryDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GMemoryDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMemoryDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::MemoryDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GMemoryDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::MemoryDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EMemoryDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EMemoryDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::MemoryDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@2
	push	OFFSET ??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@2
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@2
$LN3@vector@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EMemoryDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::MemoryDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7FileStreamDataStream@Ogre@@6B@		; Ogre::FileStreamDataStream::`vftable'
PUBLIC	??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z	; Ogre::FileStreamDataStream::FileStreamDataStream
PUBLIC	??_R4FileStreamDataStream@Ogre@@6B@		; Ogre::FileStreamDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFileStreamDataStream@Ogre@@@8		; Ogre::FileStreamDataStream `RTTI Type Descriptor'
PUBLIC	??_R3FileStreamDataStream@Ogre@@8		; Ogre::FileStreamDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileStreamDataStream@Ogre@@8		; Ogre::FileStreamDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8	; Ogre::FileStreamDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EFileStreamDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileStreamDataStream::`vector deleting destructor'
EXTRN	?read@FileStreamDataStream@Ogre@@UAEIPAXI@Z:PROC ; Ogre::FileStreamDataStream::read
EXTRN	?write@FileStreamDataStream@Ogre@@UAEIPBXI@Z:PROC ; Ogre::FileStreamDataStream::write
EXTRN	?readLine@FileStreamDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::FileStreamDataStream::readLine
EXTRN	?skip@FileStreamDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::FileStreamDataStream::skip
EXTRN	?seek@FileStreamDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::FileStreamDataStream::seek
EXTRN	?tell@FileStreamDataStream@Ogre@@UBEIXZ:PROC	; Ogre::FileStreamDataStream::tell
EXTRN	?eof@FileStreamDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::FileStreamDataStream::eof
EXTRN	?close@FileStreamDataStream@Ogre@@UAEXXZ:PROC	; Ogre::FileStreamDataStream::close
EXTRN	?getMemoryImage@FileStreamDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::FileStreamDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8 DD FLAT:??_R0?AVFileStreamDataStream@Ogre@@@8 ; Ogre::FileStreamDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2FileStreamDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8 ; Ogre::FileStreamDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3FileStreamDataStream@Ogre@@8 DD 00H		; Ogre::FileStreamDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileStreamDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVFileStreamDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::FileStreamDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileStreamDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FileStreamDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4FileStreamDataStream@Ogre@@6B@ DD 00H		; Ogre::FileStreamDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFileStreamDataStream@Ogre@@@8
	DD	FLAT:??_R3FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7FileStreamDataStream@Ogre@@6B@
CONST	SEGMENT
??_7FileStreamDataStream@Ogre@@6B@ DD FLAT:??_R4FileStreamDataStream@Ogre@@6B@ ; Ogre::FileStreamDataStream::`vftable'
	DD	FLAT:??_EFileStreamDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@FileStreamDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@FileStreamDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@FileStreamDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@FileStreamDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@FileStreamDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@FileStreamDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@FileStreamDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@FileStreamDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@FileStreamDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::FileStreamDataStream::FileStreamDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7FileStreamDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+40]
	mov	BYTE PTR [edx+40], cl
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::FileStreamDataStream::FileStreamDataStream
PUBLIC	??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FileStreamDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::FileStreamDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+40]
	mov	BYTE PTR [ecx+40], al
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::FileStreamDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GFileStreamDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileStreamDataStream::`scalar deleting destructor'
EXTRN	??1FileStreamDataStream@Ogre@@UAE@XZ:PROC	; Ogre::FileStreamDataStream::~FileStreamDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GFileStreamDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFileStreamDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileStreamDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileStreamDataStream@Ogre@@UAE@XZ	; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFileStreamDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileStreamDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EFileStreamDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EFileStreamDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileStreamDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@3
	push	OFFSET ??1FileStreamDataStream@Ogre@@UAE@XZ ; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@3
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@3
$LN3@vector@3:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileStreamDataStream@Ogre@@UAE@XZ	; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@3:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EFileStreamDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileStreamDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7FileHandleDataStream@Ogre@@6B@		; Ogre::FileHandleDataStream::`vftable'
PUBLIC	??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z	; Ogre::FileHandleDataStream::FileHandleDataStream
PUBLIC	??_R4FileHandleDataStream@Ogre@@6B@		; Ogre::FileHandleDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFileHandleDataStream@Ogre@@@8		; Ogre::FileHandleDataStream `RTTI Type Descriptor'
PUBLIC	??_R3FileHandleDataStream@Ogre@@8		; Ogre::FileHandleDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileHandleDataStream@Ogre@@8		; Ogre::FileHandleDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8	; Ogre::FileHandleDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EFileHandleDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileHandleDataStream::`vector deleting destructor'
EXTRN	?read@FileHandleDataStream@Ogre@@UAEIPAXI@Z:PROC ; Ogre::FileHandleDataStream::read
EXTRN	?write@FileHandleDataStream@Ogre@@UAEIPBXI@Z:PROC ; Ogre::FileHandleDataStream::write
EXTRN	?skip@FileHandleDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::FileHandleDataStream::skip
EXTRN	?seek@FileHandleDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::FileHandleDataStream::seek
EXTRN	?tell@FileHandleDataStream@Ogre@@UBEIXZ:PROC	; Ogre::FileHandleDataStream::tell
EXTRN	?eof@FileHandleDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::FileHandleDataStream::eof
EXTRN	?close@FileHandleDataStream@Ogre@@UAEXXZ:PROC	; Ogre::FileHandleDataStream::close
EXTRN	?getMemoryImage@FileHandleDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::FileHandleDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8 DD FLAT:??_R0?AVFileHandleDataStream@Ogre@@@8 ; Ogre::FileHandleDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2FileHandleDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8 ; Ogre::FileHandleDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3FileHandleDataStream@Ogre@@8 DD 00H		; Ogre::FileHandleDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileHandleDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVFileHandleDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::FileHandleDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileHandleDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FileHandleDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4FileHandleDataStream@Ogre@@6B@ DD 00H		; Ogre::FileHandleDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFileHandleDataStream@Ogre@@@8
	DD	FLAT:??_R3FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7FileHandleDataStream@Ogre@@6B@
CONST	SEGMENT
??_7FileHandleDataStream@Ogre@@6B@ DD FLAT:??_R4FileHandleDataStream@Ogre@@6B@ ; Ogre::FileHandleDataStream::`vftable'
	DD	FLAT:??_EFileHandleDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@FileHandleDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@FileHandleDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@FileHandleDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@FileHandleDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@FileHandleDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@FileHandleDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@FileHandleDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@FileHandleDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::FileHandleDataStream::FileHandleDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7FileHandleDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::FileHandleDataStream::FileHandleDataStream
PUBLIC	??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FileHandleDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::FileHandleDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::FileHandleDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GFileHandleDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileHandleDataStream::`scalar deleting destructor'
EXTRN	??1FileHandleDataStream@Ogre@@UAE@XZ:PROC	; Ogre::FileHandleDataStream::~FileHandleDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GFileHandleDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFileHandleDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileHandleDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileHandleDataStream@Ogre@@UAE@XZ	; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFileHandleDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileHandleDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EFileHandleDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EFileHandleDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileHandleDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@4
	push	OFFSET ??1FileHandleDataStream@Ogre@@UAE@XZ ; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@4
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@4
$LN3@vector@4:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileHandleDataStream@Ogre@@UAE@XZ	; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@4:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EFileHandleDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileHandleDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7DataStreamObject@Ogre@@6B@			; Ogre::DataStreamObject::`vftable'
PUBLIC	??1DataStreamObject@Ogre@@MAE@XZ		; Ogre::DataStreamObject::~DataStreamObject
PUBLIC	??_R4DataStreamObject@Ogre@@6B@			; Ogre::DataStreamObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDataStreamObject@Ogre@@@8		; Ogre::DataStreamObject `RTTI Type Descriptor'
PUBLIC	??_R3DataStreamObject@Ogre@@8			; Ogre::DataStreamObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DataStreamObject@Ogre@@8			; Ogre::DataStreamObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DataStreamObject@Ogre@@8		; Ogre::DataStreamObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDataStreamObject@Ogre@@MAEPAXI@Z		; Ogre::DataStreamObject::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DataStreamObject@Ogre@@8 DD FLAT:??_R0?AVDataStreamObject@Ogre@@@8 ; Ogre::DataStreamObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R2DataStreamObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DataStreamObject@Ogre@@8 ; Ogre::DataStreamObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R3DataStreamObject@Ogre@@8 DD 00H			; Ogre::DataStreamObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDataStreamObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDataStreamObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::DataStreamObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDataStreamObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DataStreamObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4DataStreamObject@Ogre@@6B@ DD 00H			; Ogre::DataStreamObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDataStreamObject@Ogre@@@8
	DD	FLAT:??_R3DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DataStreamObject@Ogre@@6B@
CONST	SEGMENT
??_7DataStreamObject@Ogre@@6B@ DD FLAT:??_R4DataStreamObject@Ogre@@6B@ ; Ogre::DataStreamObject::`vftable'
	DD	FLAT:??_EDataStreamObject@Ogre@@MAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??1DataStreamObject@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DataStreamObject@Ogre@@MAE@XZ PROC			; Ogre::DataStreamObject::~DataStreamObject, COMDAT
; _this$ = ecx

; 445  : 		virtual ~DataStreamObject(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1DataStreamObject@Ogre@@MAE@XZ ENDP			; Ogre::DataStreamObject::~DataStreamObject
_TEXT	ENDS
PUBLIC	??0DataStreamObject@Ogre@@QAE@XZ		; Ogre::DataStreamObject::DataStreamObject
; Function compile flags: /Odtp
;	COMDAT ??0DataStreamObject@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DataStreamObject@Ogre@@QAE@XZ PROC			; Ogre::DataStreamObject::DataStreamObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DataStreamObject@Ogre@@QAE@XZ ENDP			; Ogre::DataStreamObject::DataStreamObject
_TEXT	ENDS
PUBLIC	??0DataStreamObject@Ogre@@QAE@ABV01@@Z		; Ogre::DataStreamObject::DataStreamObject
; Function compile flags: /Odtp
;	COMDAT ??0DataStreamObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0DataStreamObject@Ogre@@QAE@ABV01@@Z PROC		; Ogre::DataStreamObject::DataStreamObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0DataStreamObject@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::DataStreamObject::DataStreamObject
_TEXT	ENDS
PUBLIC	??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::DataStreamObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::DataStreamObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::DataStreamObject::operator=
_TEXT	ENDS
PUBLIC	??_GDataStreamObject@Ogre@@MAEPAXI@Z		; Ogre::DataStreamObject::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GDataStreamObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDataStreamObject@Ogre@@MAEPAXI@Z PROC		; Ogre::DataStreamObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDataStreamObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::DataStreamObject::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EDataStreamObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDataStreamObject@Ogre@@MAEPAXI@Z PROC		; Ogre::DataStreamObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@5
	push	OFFSET ??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@5
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@5:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@5
$LN3@vector@5:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@5:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@5:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDataStreamObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::DataStreamObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7ObjectDataStream@Ogre@@6B@			; Ogre::ObjectDataStream::`vftable'
PUBLIC	??0ObjectDataStream@Ogre@@QAE@ABV01@@Z		; Ogre::ObjectDataStream::ObjectDataStream
PUBLIC	??_R4ObjectDataStream@Ogre@@6B@			; Ogre::ObjectDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVObjectDataStream@Ogre@@@8		; Ogre::ObjectDataStream `RTTI Type Descriptor'
PUBLIC	??_R3ObjectDataStream@Ogre@@8			; Ogre::ObjectDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ObjectDataStream@Ogre@@8			; Ogre::ObjectDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ObjectDataStream@Ogre@@8		; Ogre::ObjectDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EObjectDataStream@Ogre@@UAEPAXI@Z		; Ogre::ObjectDataStream::`vector deleting destructor'
EXTRN	?read@ObjectDataStream@Ogre@@UAEIPAXI@Z:PROC	; Ogre::ObjectDataStream::read
EXTRN	?write@ObjectDataStream@Ogre@@UAEIPBXI@Z:PROC	; Ogre::ObjectDataStream::write
EXTRN	?skip@ObjectDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::ObjectDataStream::skip
EXTRN	?seek@ObjectDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::ObjectDataStream::seek
EXTRN	?tell@ObjectDataStream@Ogre@@UBEIXZ:PROC	; Ogre::ObjectDataStream::tell
EXTRN	?eof@ObjectDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::ObjectDataStream::eof
EXTRN	?size@ObjectDataStream@Ogre@@UBEIXZ:PROC	; Ogre::ObjectDataStream::size
EXTRN	?close@ObjectDataStream@Ogre@@UAEXXZ:PROC	; Ogre::ObjectDataStream::close
EXTRN	?getMemoryImage@ObjectDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::ObjectDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ObjectDataStream@Ogre@@8 DD FLAT:??_R0?AVObjectDataStream@Ogre@@@8 ; Ogre::ObjectDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2ObjectDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@ObjectDataStream@Ogre@@8 ; Ogre::ObjectDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3ObjectDataStream@Ogre@@8 DD 00H			; Ogre::ObjectDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVObjectDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVObjectDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::ObjectDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVObjectDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ObjectDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4ObjectDataStream@Ogre@@6B@ DD 00H			; Ogre::ObjectDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVObjectDataStream@Ogre@@@8
	DD	FLAT:??_R3ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7ObjectDataStream@Ogre@@6B@
CONST	SEGMENT
??_7ObjectDataStream@Ogre@@6B@ DD FLAT:??_R4ObjectDataStream@Ogre@@6B@ ; Ogre::ObjectDataStream::`vftable'
	DD	FLAT:??_EObjectDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@ObjectDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@ObjectDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@ObjectDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@ObjectDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@ObjectDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@ObjectDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@ObjectDataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@ObjectDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@ObjectDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0ObjectDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::ObjectDataStream::ObjectDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ObjectDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ObjectDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::ObjectDataStream::ObjectDataStream
PUBLIC	??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::ObjectDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::ObjectDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::ObjectDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GObjectDataStream@Ogre@@UAEPAXI@Z		; Ogre::ObjectDataStream::`scalar deleting destructor'
EXTRN	??1ObjectDataStream@Ogre@@UAE@XZ:PROC		; Ogre::ObjectDataStream::~ObjectDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GObjectDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GObjectDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::ObjectDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GObjectDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::ObjectDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EObjectDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EObjectDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::ObjectDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@6
	push	OFFSET ??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@6
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@6:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@6
$LN3@vector@6:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@6:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@6:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EObjectDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::ObjectDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MemoryDelegation::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::MemoryDelegation::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::MemoryDelegation::operator=
_TEXT	ENDS
PUBLIC	?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ	; Ogre::RuntimeClass::getBaseClass
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebaseobject.h
;	COMDAT ?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ PROC	; Ogre::RuntimeClass::getBaseClass, COMDAT
; _this$ = ecx

; 20   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 21   : 			return m_pBaseClass;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 22   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ ENDP	; Ogre::RuntimeClass::getBaseClass
_TEXT	ENDS
PUBLIC	?getClassName@RuntimeClass@Ogre@@QBEPBDXZ	; Ogre::RuntimeClass::getClassName
; Function compile flags: /Odtp
;	COMDAT ?getClassName@RuntimeClass@Ogre@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getClassName@RuntimeClass@Ogre@@QBEPBDXZ PROC		; Ogre::RuntimeClass::getClassName, COMDAT
; _this$ = ecx

; 25   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 26   : 			return m_pClassName; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 27   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getClassName@RuntimeClass@Ogre@@QBEPBDXZ ENDP		; Ogre::RuntimeClass::getClassName
_TEXT	ENDS
PUBLIC	?getVersion@RuntimeClass@Ogre@@QBEHXZ		; Ogre::RuntimeClass::getVersion
; Function compile flags: /Odtp
;	COMDAT ?getVersion@RuntimeClass@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getVersion@RuntimeClass@Ogre@@QBEHXZ PROC		; Ogre::RuntimeClass::getVersion, COMDAT
; _this$ = ecx

; 30   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 			return m_Version;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 32   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getVersion@RuntimeClass@Ogre@@QBEHXZ ENDP		; Ogre::RuntimeClass::getVersion
_TEXT	ENDS
PUBLIC	?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ ; Ogre::RuntimeClass::newObject
; Function compile flags: /Odtp
;	COMDAT ?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ PROC ; Ogre::RuntimeClass::newObject, COMDAT
; _this$ = ecx

; 35   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 36   : 			return (*m_pNewFunc)();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	ecx

; 37   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ ENDP ; Ogre::RuntimeClass::newObject
_TEXT	ENDS
PUBLIC	??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::RuntimeClass::operator=
; Function compile flags: /Odtp
;	COMDAT ??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::RuntimeClass::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::RuntimeClass::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::BaseObject::getRTTI
EXTRN	?m_RTTI@BaseObject@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::BaseObject::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::BaseObject::getRTTI, COMDAT
; _this$ = ecx

; 56   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 			return &m_RTTI;

	mov	eax, OFFSET ?m_RTTI@BaseObject@Ogre@@2VRuntimeClass@2@B ; Ogre::BaseObject::m_RTTI

; 58   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::BaseObject::getRTTI
_TEXT	ENDS
PUBLIC	?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z ; Ogre::BaseObject::isExactKindOf
; Function compile flags: /Odtp
;	COMDAT ?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_prtti$ = 8						; size = 4
?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z PROC ; Ogre::BaseObject::isExactKindOf, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			return (getRTTI() == prtti);

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	xor	ecx, ecx
	cmp	eax, DWORD PTR _prtti$[ebp]
	sete	cl
	mov	al, cl

; 63   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z ENDP ; Ogre::BaseObject::isExactKindOf
_TEXT	ENDS
PUBLIC	?release@BaseObject@Ogre@@UAEXXZ		; Ogre::BaseObject::release
; Function compile flags: /Odtp
;	COMDAT ?release@BaseObject@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?release@BaseObject@Ogre@@UAEXXZ PROC			; Ogre::BaseObject::release, COMDAT
; _this$ = ecx

; 68   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 			m_RefCount--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 70   : 			if(m_RefCount <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jg	SHORT $LN2@release

; 71   : 			{
; 72   : 				deleteThis();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
$LN2@release:

; 73   : 			}
; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@BaseObject@Ogre@@UAEXXZ ENDP			; Ogre::BaseObject::release
_TEXT	ENDS
PUBLIC	?addRef@BaseObject@Ogre@@UAEXXZ			; Ogre::BaseObject::addRef
; Function compile flags: /Odtp
;	COMDAT ?addRef@BaseObject@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?addRef@BaseObject@Ogre@@UAEXXZ PROC			; Ogre::BaseObject::addRef, COMDAT
; _this$ = ecx

; 77   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 			m_RefCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 79   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?addRef@BaseObject@Ogre@@UAEXXZ ENDP			; Ogre::BaseObject::addRef
_TEXT	ENDS
PUBLIC	?getRefCount@BaseObject@Ogre@@UAEHXZ		; Ogre::BaseObject::getRefCount
; Function compile flags: /Odtp
;	COMDAT ?getRefCount@BaseObject@Ogre@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRefCount@BaseObject@Ogre@@UAEHXZ PROC		; Ogre::BaseObject::getRefCount, COMDAT
; _this$ = ecx

; 82   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 			return m_RefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 84   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRefCount@BaseObject@Ogre@@UAEHXZ ENDP		; Ogre::BaseObject::getRefCount
_TEXT	ENDS
PUBLIC	?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::BaseObject::_serialize
; Function compile flags: /Odtp
;	COMDAT ?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
_version$ = 12						; size = 4
?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z PROC	; Ogre::BaseObject::_serialize, COMDAT
; _this$ = ecx

; 87   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z ENDP	; Ogre::BaseObject::_serialize
_TEXT	ENDS
PUBLIC	??_7BaseObject@Ogre@@6B@			; Ogre::BaseObject::`vftable'
PUBLIC	??0BaseObject@Ogre@@IAE@XZ			; Ogre::BaseObject::BaseObject
PUBLIC	??_R4BaseObject@Ogre@@6B@			; Ogre::BaseObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVBaseObject@Ogre@@@8			; Ogre::BaseObject `RTTI Type Descriptor'
PUBLIC	??_R3BaseObject@Ogre@@8				; Ogre::BaseObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2BaseObject@Ogre@@8				; Ogre::BaseObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@BaseObject@Ogre@@8		; Ogre::BaseObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@MemoryDelegation@Ogre@@8		; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AVMemoryDelegation@Ogre@@@8		; Ogre::MemoryDelegation `RTTI Type Descriptor'
PUBLIC	??_R3MemoryDelegation@Ogre@@8			; Ogre::MemoryDelegation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MemoryDelegation@Ogre@@8			; Ogre::MemoryDelegation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MemoryDelegation@Ogre@@8		; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EBaseObject@Ogre@@MAEPAXI@Z			; Ogre::BaseObject::`vector deleting destructor'
PUBLIC	?deleteThis@BaseObject@Ogre@@MAEXXZ		; Ogre::BaseObject::deleteThis
;	COMDAT ??_R1A@?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MemoryDelegation@Ogre@@8 DD FLAT:??_R0?AVMemoryDelegation@Ogre@@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R2MemoryDelegation@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MemoryDelegation@Ogre@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R3MemoryDelegation@Ogre@@8 DD 00H			; Ogre::MemoryDelegation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMemoryDelegation@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMemoryDelegation@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MemoryDelegation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMemoryDelegation@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R13?0A@EA@MemoryDelegation@Ogre@@8 DD FLAT:??_R0?AVMemoryDelegation@Ogre@@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@BaseObject@Ogre@@8 DD FLAT:??_R0?AVBaseObject@Ogre@@@8 ; Ogre::BaseObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R2BaseObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8 ; Ogre::BaseObject::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R3BaseObject@Ogre@@8 DD 00H				; Ogre::BaseObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBaseObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVBaseObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::BaseObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBaseObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4BaseObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4BaseObject@Ogre@@6B@ DD 00H			; Ogre::BaseObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBaseObject@Ogre@@@8
	DD	FLAT:??_R3BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7BaseObject@Ogre@@6B@
CONST	SEGMENT
??_7BaseObject@Ogre@@6B@ DD FLAT:??_R4BaseObject@Ogre@@6B@ ; Ogre::BaseObject::`vftable'
	DD	FLAT:?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EBaseObject@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0BaseObject@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BaseObject@Ogre@@IAE@XZ PROC				; Ogre::BaseObject::BaseObject, COMDAT
; _this$ = ecx

; 92   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseObject@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 1

; 93   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BaseObject@Ogre@@IAE@XZ ENDP				; Ogre::BaseObject::BaseObject
_TEXT	ENDS
PUBLIC	??1BaseObject@Ogre@@MAE@XZ			; Ogre::BaseObject::~BaseObject
; Function compile flags: /Odtp
;	COMDAT ??1BaseObject@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1BaseObject@Ogre@@MAE@XZ PROC				; Ogre::BaseObject::~BaseObject, COMDAT
; _this$ = ecx

; 96   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseObject@Ogre@@6B@

; 97   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1BaseObject@Ogre@@MAE@XZ ENDP				; Ogre::BaseObject::~BaseObject
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deleteThis@BaseObject@Ogre@@MAEXXZ
_TEXT	SEGMENT
tv70 = -16						; size = 4
_this$ = -12						; size = 4
$T129459 = -8						; size = 4
$T129458 = -4						; size = 4
?deleteThis@BaseObject@Ogre@@MAEXXZ PROC		; Ogre::BaseObject::deleteThis, COMDAT
; _this$ = ecx

; 100  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 			delete this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T129459[ebp], eax
	mov	ecx, DWORD PTR $T129459[ebp]
	mov	DWORD PTR $T129458[ebp], ecx
	cmp	DWORD PTR $T129458[ebp], 0
	je	SHORT $LN3@deleteThis
	push	1
	mov	edx, DWORD PTR $T129458[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T129458[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN1@deleteThis
$LN3@deleteThis:
	mov	DWORD PTR tv70[ebp], 0
$LN1@deleteThis:

; 102  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?deleteThis@BaseObject@Ogre@@MAEXXZ ENDP		; Ogre::BaseObject::deleteThis
_TEXT	ENDS
PUBLIC	??0BaseObject@Ogre@@QAE@ABV01@@Z		; Ogre::BaseObject::BaseObject
; Function compile flags: /Odtp
;	COMDAT ??0BaseObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0BaseObject@Ogre@@QAE@ABV01@@Z PROC			; Ogre::BaseObject::BaseObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR ___that$[ebp], 0
	je	SHORT $LN3@BaseObject
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@BaseObject
$LN3@BaseObject:
	mov	DWORD PTR tv68[ebp], 0
$LN4@BaseObject:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7BaseObject@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BaseObject@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::BaseObject::BaseObject
_TEXT	ENDS
PUBLIC	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::BaseObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BaseObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BaseObject::operator=
_TEXT	ENDS
PUBLIC	??_GBaseObject@Ogre@@MAEPAXI@Z			; Ogre::BaseObject::`scalar deleting destructor'
EXTRN	??3MemoryDelegation@Ogre@@SAXPAXI@Z:PROC	; Ogre::MemoryDelegation::operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GBaseObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GBaseObject@Ogre@@MAEPAXI@Z PROC			; Ogre::BaseObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@7
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBaseObject@Ogre@@MAEPAXI@Z ENDP			; Ogre::BaseObject::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_VMemoryDelegation@Ogre@@SAXPAXI@Z:PROC	; Ogre::MemoryDelegation::operator delete[]
; Function compile flags: /Odtp
;	COMDAT ??_EBaseObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EBaseObject@Ogre@@MAEPAXI@Z PROC			; Ogre::BaseObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@7
	push	OFFSET ??1BaseObject@Ogre@@MAE@XZ	; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@7
	push	8
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@7:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@7
$LN3@vector@7:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@7
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@7:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@7:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EBaseObject@Ogre@@MAEPAXI@Z ENDP			; Ogre::BaseObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7Archive@Ogre@@6B@				; Ogre::Archive::`vftable'
PUBLIC	??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z	; Ogre::Archive::Archive
PUBLIC	??_R4Archive@Ogre@@6B@				; Ogre::Archive::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVArchive@Ogre@@@8			; Ogre::Archive `RTTI Type Descriptor'
PUBLIC	??_R3Archive@Ogre@@8				; Ogre::Archive::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Archive@Ogre@@8				; Ogre::Archive::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Archive@Ogre@@8			; Ogre::Archive::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EArchive@Ogre@@UAEPAXI@Z			; Ogre::Archive::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@Archive@Ogre@@8
; File i:\svnroot\client\ogremain\ogrearchive.h
rdata$r	SEGMENT
??_R1A@?0A@EA@Archive@Ogre@@8 DD FLAT:??_R0?AVArchive@Ogre@@@8 ; Ogre::Archive::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Archive@Ogre@@8
rdata$r	SEGMENT
??_R2Archive@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Archive@Ogre@@8 ; Ogre::Archive::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Archive@Ogre@@8
rdata$r	SEGMENT
??_R3Archive@Ogre@@8 DD 00H				; Ogre::Archive::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVArchive@Ogre@@@8
_DATA	SEGMENT
??_R0?AVArchive@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Archive `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVArchive@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Archive@Ogre@@6B@
rdata$r	SEGMENT
??_R4Archive@Ogre@@6B@ DD 00H				; Ogre::Archive::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVArchive@Ogre@@@8
	DD	FLAT:??_R3Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Archive@Ogre@@6B@
CONST	SEGMENT
??_7Archive@Ogre@@6B@ DD FLAT:??_R4Archive@Ogre@@6B@	; Ogre::Archive::`vftable'
	DD	FLAT:??_EArchive@Ogre@@UAEPAXI@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstream$ = 8						; size = 4
_mode$ = 12						; size = 4
??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z PROC		; Ogre::Archive::Archive, COMDAT
; _this$ = ecx

; 22   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pstream$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 23   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z ENDP		; Ogre::Archive::Archive
_TEXT	ENDS
PUBLIC	??1Archive@Ogre@@UAE@XZ				; Ogre::Archive::~Archive
; Function compile flags: /Odtp
;	COMDAT ??1Archive@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Archive@Ogre@@UAE@XZ PROC				; Ogre::Archive::~Archive, COMDAT
; _this$ = ecx

; 26   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@

; 27   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1Archive@Ogre@@UAE@XZ ENDP				; Ogre::Archive::~Archive
_TEXT	ENDS
PUBLIC	?isLoading@Archive@Ogre@@QAE_NXZ		; Ogre::Archive::isLoading
; Function compile flags: /Odtp
;	COMDAT ?isLoading@Archive@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isLoading@Archive@Ogre@@QAE_NXZ PROC			; Ogre::Archive::isLoading, COMDAT
; _this$ = ecx

; 30   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 			return m_Mode==MODE_LOAD;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 1
	sete	cl
	mov	al, cl

; 32   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?isLoading@Archive@Ogre@@QAE_NXZ ENDP			; Ogre::Archive::isLoading
_TEXT	ENDS
PUBLIC	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z	; Ogre::Archive::serialize
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAD@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAD@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 108  : 		SERIALIZE_PRIMITIVE_FUNC(char)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAD@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAF@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAF@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 109  : 		SERIALIZE_PRIMITIVE_FUNC(short)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	2
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAF@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAH@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAH@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 110  : 		SERIALIZE_PRIMITIVE_FUNC(int)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAH@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_J@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_J@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 111  : 		SERIALIZE_PRIMITIVE_FUNC(int64)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	8
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_J@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAE@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAE@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 112  : 		SERIALIZE_PRIMITIVE_FUNC(uchar)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAE@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAG@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAG@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 113  : 		SERIALIZE_PRIMITIVE_FUNC(ushort)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	2
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAG@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAI@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAI@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 114  : 		SERIALIZE_PRIMITIVE_FUNC(uint)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAI@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_K@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_K@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 115  : 		SERIALIZE_PRIMITIVE_FUNC(uint64)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	8
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_K@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_N@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_N@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 116  : 		SERIALIZE_PRIMITIVE_FUNC(bool)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_N@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAM@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAM@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 117  : 		SERIALIZE_PRIMITIVE_FUNC(float)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAM@Z ENDP			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z PROC		; Ogre::Archive::serialize, COMDAT
; _this$ = ecx

; 155  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 			if(isLoading()) m_pStream->read(pbuf, len);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@serialize
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
	jmp	SHORT $LN1@serialize
$LN2@serialize:

; 157  : 			else m_pStream->write(pbuf, len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN1@serialize:

; 158  : 
; 159  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 160  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ENDP		; Ogre::Archive::serialize
_TEXT	ENDS
PUBLIC	?read@Archive@Ogre@@QAEXPAXI@Z			; Ogre::Archive::read
; Function compile flags: /Odtp
;	COMDAT ?read@Archive@Ogre@@QAEXPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?read@Archive@Ogre@@QAEXPAXI@Z PROC			; Ogre::Archive::read, COMDAT
; _this$ = ecx

; 163  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 			m_pStream->read(pbuf, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 165  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?read@Archive@Ogre@@QAEXPAXI@Z ENDP			; Ogre::Archive::read
_TEXT	ENDS
PUBLIC	?write@Archive@Ogre@@QAEXPBXI@Z			; Ogre::Archive::write
; Function compile flags: /Odtp
;	COMDAT ?write@Archive@Ogre@@QAEXPBXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?write@Archive@Ogre@@QAEXPBXI@Z PROC			; Ogre::Archive::write, COMDAT
; _this$ = ecx

; 168  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 			m_pStream->write(pbuf, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 170  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?write@Archive@Ogre@@QAEXPBXI@Z ENDP			; Ogre::Archive::write
_TEXT	ENDS
PUBLIC	??0Archive@Ogre@@QAE@ABV01@@Z			; Ogre::Archive::Archive
; Function compile flags: /Odtp
;	COMDAT ??0Archive@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Archive@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Archive::Archive, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Archive@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Archive::Archive
_TEXT	ENDS
PUBLIC	??4Archive@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Archive::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Archive@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Archive@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Archive::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Archive@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Archive::operator=
_TEXT	ENDS
PUBLIC	??_GArchive@Ogre@@UAEPAXI@Z			; Ogre::Archive::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GArchive@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GArchive@Ogre@@UAEPAXI@Z PROC			; Ogre::Archive::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Archive@Ogre@@UAE@XZ			; Ogre::Archive::~Archive
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GArchive@Ogre@@UAEPAXI@Z ENDP			; Ogre::Archive::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EArchive@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EArchive@Ogre@@UAEPAXI@Z PROC			; Ogre::Archive::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@8
	push	OFFSET ??1Archive@Ogre@@UAE@XZ		; Ogre::Archive::~Archive
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@8
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@8:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@8
$LN3@vector@8:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Archive@Ogre@@UAE@XZ			; Ogre::Archive::~Archive
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@8:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@8:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EArchive@Ogre@@UAEPAXI@Z ENDP			; Ogre::Archive::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??0ColourValue@Ogre@@QAE@MMMM@Z			; Ogre::ColourValue::ColourValue
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrecolourvalue.h
;	COMDAT ??0ColourValue@Ogre@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_red$ = 8						; size = 4
_green$ = 12						; size = 4
_blue$ = 16						; size = 4
_alpha$ = 20						; size = 4
??0ColourValue@Ogre@@QAE@MMMM@Z PROC			; Ogre::ColourValue::ColourValue, COMDAT
; _this$ = ecx

; 68   : 		{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _red$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _green$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _blue$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _alpha$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0ColourValue@Ogre@@QAE@MMMM@Z ENDP			; Ogre::ColourValue::ColourValue
_TEXT	ENDS
PUBLIC	?set@ColourValue@Ogre@@QAEXMMMM@Z		; Ogre::ColourValue::set
; Function compile flags: /Odtp
;	COMDAT ?set@ColourValue@Ogre@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_red$ = 8						; size = 4
_green$ = 12						; size = 4
_blue$ = 16						; size = 4
_alpha$ = 20						; size = 4
?set@ColourValue@Ogre@@QAEXMMMM@Z PROC			; Ogre::ColourValue::set, COMDAT
; _this$ = ecx

; 76   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   : 			r	= red;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _red$[ebp]
	fstp	DWORD PTR [eax]

; 78   : 			g	= green;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _green$[ebp]
	fstp	DWORD PTR [ecx+4]

; 79   : 			b	= blue;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _blue$[ebp]
	fstp	DWORD PTR [edx+8]

; 80   : 			a	= alpha;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _alpha$[ebp]
	fstp	DWORD PTR [eax+12]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?set@ColourValue@Ogre@@QAEXMMMM@Z ENDP			; Ogre::ColourValue::set
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	?saturate@ColourValue@Ogre@@QAEXXZ		; Ogre::ColourValue::saturate
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?saturate@ColourValue@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?saturate@ColourValue@Ogre@@QAEXXZ PROC			; Ogre::ColourValue::saturate, COMDAT
; _this$ = ecx

; 117  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 			if (r < 0)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN12@saturate

; 119  : 				r = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx]
	jmp	SHORT $LN10@saturate
$LN12@saturate:

; 120  : 			else if (r > 1)

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN10@saturate

; 121  : 				r = 1;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax]
$LN10@saturate:

; 122  : 
; 123  : 			if (g < 0)

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@saturate

; 124  : 				g = 0;

	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+4]
	jmp	SHORT $LN7@saturate
$LN9@saturate:

; 125  : 			else if (g > 1)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN7@saturate

; 126  : 				g = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [ecx+4]
$LN7@saturate:

; 127  : 
; 128  : 			if (b < 0)

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@saturate

; 129  : 				b = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+8]
	jmp	SHORT $LN4@saturate
$LN6@saturate:

; 130  : 			else if (b > 1)

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@saturate

; 131  : 				b = 1;

	mov	edx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [edx+8]
$LN4@saturate:

; 132  : 
; 133  : 			if (a < 0)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@saturate

; 134  : 				a = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+12]
	jmp	SHORT $LN1@saturate
$LN3@saturate:

; 135  : 			else if (a > 1)

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+12]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@saturate

; 136  : 				a = 1;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax+12]
$LN1@saturate:

; 137  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?saturate@ColourValue@Ogre@@QAEXXZ ENDP			; Ogre::ColourValue::saturate
_TEXT	ENDS
PUBLIC	?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ	; Ogre::ColourValue::saturateCopy
; Function compile flags: /Odtp
;	COMDAT ?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_ret$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ PROC	; Ogre::ColourValue::saturateCopy, COMDAT
; _this$ = ecx

; 142  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 			ColourValue ret = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ret$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _ret$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _ret$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _ret$[ebp+12], edx

; 144  : 			ret.saturate();

	lea	ecx, DWORD PTR _ret$[ebp]
	call	?saturate@ColourValue@Ogre@@QAEXXZ	; Ogre::ColourValue::saturate

; 145  : 			return ret;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _ret$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _ret$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _ret$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ ENDP	; Ogre::ColourValue::saturateCopy
_TEXT	ENDS
PUBLIC	??AColourValue@Ogre@@QBEMI@Z			; Ogre::ColourValue::operator[]
; Function compile flags: /Odtp
;	COMDAT ??AColourValue@Ogre@@QBEMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??AColourValue@Ogre@@QBEMI@Z PROC			; Ogre::ColourValue::operator[], COMDAT
; _this$ = ecx

; 150  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 151  : 			assert( i < 4 );
; 152  : 
; 153  : 			return *(&r+i);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+eax*4]

; 154  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??AColourValue@Ogre@@QBEMI@Z ENDP			; Ogre::ColourValue::operator[]
_TEXT	ENDS
PUBLIC	??AColourValue@Ogre@@QAEAAMI@Z			; Ogre::ColourValue::operator[]
; Function compile flags: /Odtp
;	COMDAT ??AColourValue@Ogre@@QAEAAMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??AColourValue@Ogre@@QAEAAMI@Z PROC			; Ogre::ColourValue::operator[], COMDAT
; _this$ = ecx

; 158  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 159  : 			assert( i < 4 );
; 160  : 
; 161  : 			return *(&r+i);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 162  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??AColourValue@Ogre@@QAEAAMI@Z ENDP			; Ogre::ColourValue::operator[]
_TEXT	ENDS
PUBLIC	?ptr@ColourValue@Ogre@@QAEPAMXZ			; Ogre::ColourValue::ptr
; Function compile flags: /Odtp
;	COMDAT ?ptr@ColourValue@Ogre@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ptr@ColourValue@Ogre@@QAEPAMXZ PROC			; Ogre::ColourValue::ptr, COMDAT
; _this$ = ecx

; 166  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 			return &r;

	mov	eax, DWORD PTR _this$[ebp]

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?ptr@ColourValue@Ogre@@QAEPAMXZ ENDP			; Ogre::ColourValue::ptr
_TEXT	ENDS
PUBLIC	?ptr@ColourValue@Ogre@@QBEPBMXZ			; Ogre::ColourValue::ptr
; Function compile flags: /Odtp
;	COMDAT ?ptr@ColourValue@Ogre@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ptr@ColourValue@Ogre@@QBEPBMXZ PROC			; Ogre::ColourValue::ptr, COMDAT
; _this$ = ecx

; 171  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 			return &r;

	mov	eax, DWORD PTR _this$[ebp]

; 173  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?ptr@ColourValue@Ogre@@QBEPBMXZ ENDP			; Ogre::ColourValue::ptr
_TEXT	ENDS
PUBLIC	??HColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator+
; Function compile flags: /Odtp
;	COMDAT ??HColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kSum$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rkVector$ = 12						; size = 4
??HColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator+, COMDAT
; _this$ = ecx

; 178  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 			ColourValue kSum;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kSum$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 180  : 
; 181  : 			kSum.r = r + rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR _kSum$[ebp]

; 182  : 			kSum.g = g + rkVector.g;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _kSum$[ebp+4]

; 183  : 			kSum.b = b + rkVector.b;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [edx+8]
	fstp	DWORD PTR _kSum$[ebp+8]

; 184  : 			kSum.a = a + rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kSum$[ebp+12]

; 185  : 
; 186  : 			return kSum;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kSum$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kSum$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kSum$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kSum$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 187  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??HColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator+
_TEXT	ENDS
PUBLIC	??GColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator-
; Function compile flags: /Odtp
;	COMDAT ??GColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kDiff$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rkVector$ = 12						; size = 4
??GColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator-, COMDAT
; _this$ = ecx

; 190  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 191  : 			ColourValue kDiff;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kDiff$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 192  : 
; 193  : 			kDiff.r = r - rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _kDiff$[ebp]

; 194  : 			kDiff.g = g - rkVector.g;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR _kDiff$[ebp+4]

; 195  : 			kDiff.b = b - rkVector.b;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [edx+8]
	fstp	DWORD PTR _kDiff$[ebp+8]

; 196  : 			kDiff.a = a - rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kDiff$[ebp+12]

; 197  : 
; 198  : 			return kDiff;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kDiff$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kDiff$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kDiff$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kDiff$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 199  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??GColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator-
_TEXT	ENDS
PUBLIC	??DColourValue@Ogre@@QBE?AV01@M@Z		; Ogre::ColourValue::operator*
; Function compile flags: /Odtp
;	COMDAT ??DColourValue@Ogre@@QBE?AV01@M@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kProd$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_fScalar$ = 12						; size = 4
??DColourValue@Ogre@@QBE?AV01@M@Z PROC			; Ogre::ColourValue::operator*, COMDAT
; _this$ = ecx

; 202  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 			ColourValue kProd;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kProd$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 204  : 
; 205  : 			kProd.r = fScalar*r;

	fld	DWORD PTR _fScalar$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR _kProd$[ebp]

; 206  : 			kProd.g = fScalar*g;

	fld	DWORD PTR _fScalar$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+4]
	fstp	DWORD PTR _kProd$[ebp+4]

; 207  : 			kProd.b = fScalar*b;

	fld	DWORD PTR _fScalar$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR _kProd$[ebp+8]

; 208  : 			kProd.a = fScalar*a;

	fld	DWORD PTR _fScalar$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+12]
	fstp	DWORD PTR _kProd$[ebp+12]

; 209  : 
; 210  : 			return kProd;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _kProd$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _kProd$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _kProd$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _kProd$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??DColourValue@Ogre@@QBE?AV01@M@Z ENDP			; Ogre::ColourValue::operator*
_TEXT	ENDS
PUBLIC	??DColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator*
; Function compile flags: /Odtp
;	COMDAT ??DColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kProd$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??DColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator*, COMDAT
; _this$ = ecx

; 214  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 215  : 			ColourValue kProd;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kProd$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 216  : 
; 217  : 			kProd.r = rhs.r * r;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR _kProd$[ebp]

; 218  : 			kProd.g = rhs.g * g;

	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR _kProd$[ebp+4]

; 219  : 			kProd.b = rhs.b * b;

	mov	ecx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR _kProd$[ebp+8]

; 220  : 			kProd.a = rhs.a * a;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kProd$[ebp+12]

; 221  : 
; 222  : 			return kProd;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kProd$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kProd$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kProd$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kProd$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 223  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??DColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator*
_TEXT	ENDS
PUBLIC	??KColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator/
; Function compile flags: /Odtp
;	COMDAT ??KColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kProd$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??KColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator/, COMDAT
; _this$ = ecx

; 226  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 227  : 			ColourValue kProd;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kProd$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 228  : 
; 229  : 			kProd.r = rhs.r / r;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx]
	fstp	DWORD PTR _kProd$[ebp]

; 230  : 			kProd.g = rhs.g / g;

	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [eax+4]
	fstp	DWORD PTR _kProd$[ebp+4]

; 231  : 			kProd.b = rhs.b / b;

	mov	ecx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [edx+8]
	fstp	DWORD PTR _kProd$[ebp+8]

; 232  : 			kProd.a = rhs.a / a;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kProd$[ebp+12]

; 233  : 
; 234  : 			return kProd;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kProd$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kProd$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kProd$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kProd$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 235  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??KColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator/
_TEXT	ENDS
PUBLIC	??KColourValue@Ogre@@QBE?AV01@M@Z		; Ogre::ColourValue::operator/
; Function compile flags: /Odtp
;	COMDAT ??KColourValue@Ogre@@QBE?AV01@M@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_kDiv$ = -20						; size = 16
_fInv$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_fScalar$ = 12						; size = 4
??KColourValue@Ogre@@QBE?AV01@M@Z PROC			; Ogre::ColourValue::operator/, COMDAT
; _this$ = ecx

; 238  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 			assert( fScalar != 0.0f );
; 240  : 
; 241  : 			ColourValue kDiv;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kDiv$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 242  : 
; 243  : 			float fInv = 1.0f / fScalar;

	fld	DWORD PTR _fScalar$[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _fInv$[ebp]

; 244  : 			kDiv.r = r * fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp]

; 245  : 			kDiv.g = g * fInv;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp+4]

; 246  : 			kDiv.b = b * fInv;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp+8]

; 247  : 			kDiv.a = a * fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp+12]

; 248  : 
; 249  : 			return kDiv;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _kDiv$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _kDiv$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _kDiv$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _kDiv$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 250  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??KColourValue@Ogre@@QBE?AV01@M@Z ENDP			; Ogre::ColourValue::operator/
_TEXT	ENDS
PUBLIC	??YColourValue@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::ColourValue::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YColourValue@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rkVector$ = 8						; size = 4
??YColourValue@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ColourValue::operator+=, COMDAT
; _this$ = ecx

; 266  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 267  : 			r += rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 268  : 			g += rkVector.g;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 269  : 			b += rkVector.b;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 270  : 			a += rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+12]

; 271  : 
; 272  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 273  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YColourValue@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator+=
_TEXT	ENDS
PUBLIC	??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::ColourValue::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rkVector$ = 8						; size = 4
??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ColourValue::operator-=, COMDAT
; _this$ = ecx

; 276  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 			r -= rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 278  : 			g -= rkVector.g;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 279  : 			b -= rkVector.b;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 280  : 			a -= rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+12]

; 281  : 
; 282  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 283  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator-=
_TEXT	ENDS
PUBLIC	??XColourValue@Ogre@@QAEAAV01@M@Z		; Ogre::ColourValue::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XColourValue@Ogre@@QAEAAV01@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fScalar$ = 8						; size = 4
??XColourValue@Ogre@@QAEAAV01@M@Z PROC			; Ogre::ColourValue::operator*=, COMDAT
; _this$ = ecx

; 286  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 287  : 			r *= fScalar;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 288  : 			g *= fScalar;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 289  : 			b *= fScalar;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 290  : 			a *= fScalar;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 291  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 292  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XColourValue@Ogre@@QAEAAV01@M@Z ENDP			; Ogre::ColourValue::operator*=
_TEXT	ENDS
PUBLIC	??_0ColourValue@Ogre@@QAEAAV01@M@Z		; Ogre::ColourValue::operator/=
; Function compile flags: /Odtp
;	COMDAT ??_0ColourValue@Ogre@@QAEAAV01@M@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fInv$ = -4						; size = 4
_fScalar$ = 8						; size = 4
??_0ColourValue@Ogre@@QAEAAV01@M@Z PROC			; Ogre::ColourValue::operator/=, COMDAT
; _this$ = ecx

; 295  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 296  : 			assert( fScalar != 0.0 );
; 297  : 
; 298  : 			float fInv = 1.0f / fScalar;

	fld	DWORD PTR _fScalar$[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _fInv$[ebp]

; 299  : 
; 300  : 			r *= fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _fInv$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 301  : 			g *= fInv;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _fInv$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 302  : 			b *= fInv;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _fInv$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 303  : 			a *= fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _fInv$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 304  : 
; 305  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 306  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??_0ColourValue@Ogre@@QAEAAV01@M@Z ENDP			; Ogre::ColourValue::operator/=
_TEXT	ENDS
PUBLIC	??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::ColourValue::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ColourValue::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator=
_TEXT	ENDS
PUBLIC	??_FColourValue@Ogre@@QAEXXZ			; Ogre::ColourValue::`default constructor closure'
; Function compile flags: /Odtp
;	COMDAT ??_FColourValue@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??_FColourValue@Ogre@@QAEXXZ PROC			; Ogre::ColourValue::`default constructor closure', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue
	mov	esp, ebp
	pop	ebp
	ret	0
??_FColourValue@Ogre@@QAEXXZ ENDP			; Ogre::ColourValue::`default constructor closure'
_TEXT	ENDS
PUBLIC	?size@?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::size
PUBLIC	?getNumElements@VertexFormat@Ogre@@QBEIXZ	; Ogre::VertexFormat::getNumElements
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevertexformat.h
;	COMDAT ?getNumElements@VertexFormat@Ogre@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumElements@VertexFormat@Ogre@@QBEIXZ PROC		; Ogre::VertexFormat::getNumElements, COMDAT
; _this$ = ecx

; 82   : 		uint getNumElements() const{ return (uint)m_Elements.size(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::size
	mov	esp, ebp
	pop	ebp
	ret	0
?getNumElements@VertexFormat@Ogre@@QBEIXZ ENDP		; Ogre::VertexFormat::getNumElements
_TEXT	ENDS
PUBLIC	??A?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEABVVertexElement@Ogre@@I@Z ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::operator[]
PUBLIC	?getElement@VertexFormat@Ogre@@QBEABVVertexElement@2@I@Z ; Ogre::VertexFormat::getElement
; Function compile flags: /Odtp
;	COMDAT ?getElement@VertexFormat@Ogre@@QBEABVVertexElement@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?getElement@VertexFormat@Ogre@@QBEABVVertexElement@2@I@Z PROC ; Ogre::VertexFormat::getElement, COMDAT
; _this$ = ecx

; 83   : 		const VertexElement &getElement(uint i) const{ return m_Elements[i]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEABVVertexElement@Ogre@@I@Z ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::operator[]
	mov	esp, ebp
	pop	ebp
	ret	4
?getElement@VertexFormat@Ogre@@QBEABVVertexElement@2@I@Z ENDP ; Ogre::VertexFormat::getElement
_TEXT	ENDS
PUBLIC	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z	; Ogre::FixedString::handle2Ptr
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefixedstring.h
;	COMDAT ?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z
_TEXT	SEGMENT
_h$ = 8							; size = 4
?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z PROC		; Ogre::FixedString::handle2Ptr, COMDAT

; 22   : 		{

	push	ebp
	mov	ebp, esp

; 23   : 			return (const char *)h;

	mov	eax, DWORD PTR _h$[ebp]

; 24   : 		}

	pop	ebp
	ret	0
?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ENDP		; Ogre::FixedString::handle2Ptr
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@XZ			; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0FixedString@Ogre@@QAE@XZ PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 27   : 		FixedString() : m_StrHandle(NULL){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0FixedString@Ogre@@QAE@XZ ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PAX@Z			; Ogre::FixedString::FixedString
EXTRN	?addRef@FixedString@Ogre@@SAXPAX@Z:PROC		; Ogre::FixedString::addRef
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h$ = 8							; size = 4
??0FixedString@Ogre@@QAE@PAX@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 29   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [eax], ecx

; 30   : 			addRef(h);

	mov	edx, DWORD PTR _h$[ebp]
	push	edx
	call	?addRef@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::addRef
	add	esp, 4

; 31   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@PAX@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@ABV01@@Z		; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??0FixedString@Ogre@@QAE@ABV01@@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 34   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 35   : 			addRef(m_StrHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?addRef@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::addRef
	add	esp, 4

; 36   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PBD@Z			; Ogre::FixedString::FixedString
EXTRN	?insert@FixedString@Ogre@@SAPAXPBDH@Z:PROC	; Ogre::FixedString::insert
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstr$ = 8						; size = 4
??0FixedString@Ogre@@QAE@PBD@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 38   : 		FixedString(const char *pstr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 		{
; 40   : 			m_StrHandle = insert(pstr); 

	push	-1
	mov	eax, DWORD PTR _pstr$[ebp]
	push	eax
	call	?insert@FixedString@Ogre@@SAPAXPBDH@Z	; Ogre::FixedString::insert
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 41   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@PBD@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PBDI@Z			; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstr$ = 8						; size = 4
_len$ = 12						; size = 4
??0FixedString@Ogre@@QAE@PBDI@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 43   : 		FixedString(const char *pstr, size_t len)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 		{
; 45   : 			m_StrHandle = insert(pstr, (int)len); 

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pstr$[ebp]
	push	ecx
	call	?insert@FixedString@Ogre@@SAPAXPBDH@Z	; Ogre::FixedString::insert
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 46   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0FixedString@Ogre@@QAE@PBDI@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??1FixedString@Ogre@@QAE@XZ			; Ogre::FixedString::~FixedString
EXTRN	?release@FixedString@Ogre@@SAXPAX@Z:PROC	; Ogre::FixedString::release
; Function compile flags: /Odtp
;	COMDAT ??1FixedString@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1FixedString@Ogre@@QAE@XZ PROC			; Ogre::FixedString::~FixedString, COMDAT
; _this$ = ecx

; 49   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 			release(m_StrHandle); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?release@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::release
	add	esp, 4

; 51   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1FixedString@Ogre@@QAE@XZ ENDP			; Ogre::FixedString::~FixedString
_TEXT	ENDS
PUBLIC	??BFixedString@Ogre@@QBEPBDXZ			; Ogre::FixedString::operator char const *
; Function compile flags: /Odtp
;	COMDAT ??BFixedString@Ogre@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BFixedString@Ogre@@QBEPBDXZ PROC			; Ogre::FixedString::operator char const *, COMDAT
; _this$ = ecx

; 54   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 			return handle2Ptr(m_StrHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ; Ogre::FixedString::handle2Ptr
	add	esp, 4

; 56   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??BFixedString@Ogre@@QBEPBDXZ ENDP			; Ogre::FixedString::operator char const *
_TEXT	ENDS
PUBLIC	?getHandle@FixedString@Ogre@@QBEPAXXZ		; Ogre::FixedString::getHandle
; Function compile flags: /Odtp
;	COMDAT ?getHandle@FixedString@Ogre@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHandle@FixedString@Ogre@@QBEPAXXZ PROC		; Ogre::FixedString::getHandle, COMDAT
; _this$ = ecx

; 59   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 			return m_StrHandle;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 61   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getHandle@FixedString@Ogre@@QBEPAXXZ ENDP		; Ogre::FixedString::getHandle
_TEXT	ENDS
PUBLIC	?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ	; Ogre::Resource::getRTTI
EXTRN	?m_RTTI@Resource@Ogre@@2VRuntimeClass@2@B:BYTE	; Ogre::Resource::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreresource.h
;	COMDAT ?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::Resource::getRTTI, COMDAT
; _this$ = ecx

; 39   : 		DECLARE_RTTI_VIRTUAL(Resource)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@Resource@Ogre@@2VRuntimeClass@2@B ; Ogre::Resource::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::Resource::getRTTI
_TEXT	ENDS
PUBLIC	?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ ; Ogre::Resource::getResPath
; Function compile flags: /Odtp
;	COMDAT ?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ PROC	; Ogre::Resource::getResPath, COMDAT
; _this$ = ecx

; 44   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 			return m_ResPath;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8

; 46   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ ENDP	; Ogre::Resource::getResPath
_TEXT	ENDS
PUBLIC	?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z ; Ogre::Resource::setResPath
EXTRN	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z:PROC	; Ogre::FixedString::operator=
; Function compile flags: /Odtp
;	COMDAT ?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_path$ = 8						; size = 4
?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z PROC	; Ogre::Resource::setResPath, COMDAT
; _this$ = ecx

; 48   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 			m_ResPath = path;

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FixedString::operator=

; 50   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z ENDP	; Ogre::Resource::setResPath
_TEXT	ENDS
PUBLIC	??_7Resource@Ogre@@6B@				; Ogre::Resource::`vftable'
PUBLIC	??0Resource@Ogre@@IAE@XZ			; Ogre::Resource::Resource
PUBLIC	??_R4Resource@Ogre@@6B@				; Ogre::Resource::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVResource@Ogre@@@8			; Ogre::Resource `RTTI Type Descriptor'
PUBLIC	??_R3Resource@Ogre@@8				; Ogre::Resource::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Resource@Ogre@@8				; Ogre::Resource::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Resource@Ogre@@8			; Ogre::Resource::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EResource@Ogre@@MAEPAXI@Z			; Ogre::Resource::`vector deleting destructor'
EXTRN	?release@Resource@Ogre@@UAEXXZ:PROC		; Ogre::Resource::release
EXTRN	?addRef@Resource@Ogre@@UAEXXZ:PROC		; Ogre::Resource::addRef
EXTRN	?getRefCount@Resource@Ogre@@UAEHXZ:PROC		; Ogre::Resource::getRefCount
;	COMDAT ??_R1A@?0A@EA@Resource@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Resource@Ogre@@8 DD FLAT:??_R0?AVResource@Ogre@@@8 ; Ogre::Resource::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Resource@Ogre@@8
rdata$r	SEGMENT
??_R2Resource@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Resource@Ogre@@8 ; Ogre::Resource::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3Resource@Ogre@@8
rdata$r	SEGMENT
??_R3Resource@Ogre@@8 DD 00H				; Ogre::Resource::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVResource@Ogre@@@8
_DATA	SEGMENT
??_R0?AVResource@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Resource `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVResource@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Resource@Ogre@@6B@
rdata$r	SEGMENT
??_R4Resource@Ogre@@6B@ DD 00H				; Ogre::Resource::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVResource@Ogre@@@8
	DD	FLAT:??_R3Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Resource@Ogre@@6B@
CONST	SEGMENT
??_7Resource@Ogre@@6B@ DD FLAT:??_R4Resource@Ogre@@6B@	; Ogre::Resource::`vftable'
	DD	FLAT:?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EResource@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Resource@Ogre@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@IAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@IAE@XZ$1
__ehfuncinfo$??0Resource@Ogre@@IAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Resource@Ogre@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Resource@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Resource@Ogre@@IAE@XZ PROC				; Ogre::Resource::Resource, COMDAT
; _this$ = ecx

; 72   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Resource@Ogre@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@IAE@XZ		; Ogre::BaseObject::BaseObject
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Resource@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::FixedString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 73   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Resource@Ogre@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0Resource@Ogre@@IAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??0Resource@Ogre@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Resource@Ogre@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Resource@Ogre@@IAE@XZ ENDP				; Ogre::Resource::Resource
PUBLIC	??1Resource@Ogre@@MAE@XZ			; Ogre::Resource::~Resource
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Resource@Ogre@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Resource@Ogre@@MAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Resource@Ogre@@MAE@XZ$1
__ehfuncinfo$??1Resource@Ogre@@MAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1Resource@Ogre@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1Resource@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Resource@Ogre@@MAE@XZ PROC				; Ogre::Resource::~Resource, COMDAT
; _this$ = ecx

; 76   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Resource@Ogre@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Resource@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 77   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Resource@Ogre@@MAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??1Resource@Ogre@@MAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??1Resource@Ogre@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Resource@Ogre@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Resource@Ogre@@MAE@XZ ENDP				; Ogre::Resource::~Resource
PUBLIC	??0Resource@Ogre@@QAE@ABV01@@Z			; Ogre::Resource::Resource
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Resource@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0Resource@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Resource@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Resource@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Resource@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Resource::Resource, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Resource@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7Resource@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0FixedString@Ogre@@QAE@ABV01@@Z	; Ogre::FixedString::FixedString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??0Resource@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Resource@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Resource@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Resource::Resource
PUBLIC	??4Resource@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Resource::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Resource@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Resource@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::Resource::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FixedString::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Resource@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::Resource::operator=
_TEXT	ENDS
PUBLIC	??_GResource@Ogre@@MAEPAXI@Z			; Ogre::Resource::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GResource@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GResource@Ogre@@MAEPAXI@Z PROC			; Ogre::Resource::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@9
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@9:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GResource@Ogre@@MAEPAXI@Z ENDP			; Ogre::Resource::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EResource@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EResource@Ogre@@MAEPAXI@Z PROC			; Ogre::Resource::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@9
	push	OFFSET ??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@9
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@9:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@9
$LN3@vector@9:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@9
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@9:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@9:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EResource@Ogre@@MAEPAXI@Z ENDP			; Ogre::Resource::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::VertexBuffer::getRTTI
EXTRN	?m_RTTI@VertexBuffer@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::VertexBuffer::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrerendertypes.h
;	COMDAT ?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::VertexBuffer::getRTTI, COMDAT
; _this$ = ecx

; 223  : 		DECLARE_RTTI_VIRTUAL(VertexBuffer)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@VertexBuffer@Ogre@@2VRuntimeClass@2@B ; Ogre::VertexBuffer::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::VertexBuffer::getRTTI
_TEXT	ENDS
PUBLIC	??_7VertexBuffer@Ogre@@6B@			; Ogre::VertexBuffer::`vftable'
PUBLIC	??0VertexBuffer@Ogre@@QAE@XZ			; Ogre::VertexBuffer::VertexBuffer
PUBLIC	??_R4VertexBuffer@Ogre@@6B@			; Ogre::VertexBuffer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVertexBuffer@Ogre@@@8			; Ogre::VertexBuffer `RTTI Type Descriptor'
PUBLIC	??_R3VertexBuffer@Ogre@@8			; Ogre::VertexBuffer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VertexBuffer@Ogre@@8			; Ogre::VertexBuffer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VertexBuffer@Ogre@@8		; Ogre::VertexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EVertexBuffer@Ogre@@UAEPAXI@Z		; Ogre::VertexBuffer::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@VertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VertexBuffer@Ogre@@8 DD FLAT:??_R0?AVVertexBuffer@Ogre@@@8 ; Ogre::VertexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2VertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R2VertexBuffer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@VertexBuffer@Ogre@@8 ; Ogre::VertexBuffer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3VertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R3VertexBuffer@Ogre@@8 DD 00H			; Ogre::VertexBuffer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2VertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVertexBuffer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVVertexBuffer@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::VertexBuffer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVertexBuffer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VertexBuffer@Ogre@@6B@
rdata$r	SEGMENT
??_R4VertexBuffer@Ogre@@6B@ DD 00H			; Ogre::VertexBuffer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVertexBuffer@Ogre@@@8
	DD	FLAT:??_R3VertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7VertexBuffer@Ogre@@6B@
CONST	SEGMENT
??_7VertexBuffer@Ogre@@6B@ DD FLAT:??_R4VertexBuffer@Ogre@@6B@ ; Ogre::VertexBuffer::`vftable'
	DD	FLAT:?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EVertexBuffer@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0VertexBuffer@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0VertexBuffer@Ogre@@QAE@XZ$0
__ehfuncinfo$??0VertexBuffer@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0VertexBuffer@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0VertexBuffer@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0VertexBuffer@Ogre@@QAE@XZ PROC			; Ogre::VertexBuffer::VertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0VertexBuffer@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VertexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0VertexBuffer@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0VertexBuffer@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0VertexBuffer@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0VertexBuffer@Ogre@@QAE@XZ ENDP			; Ogre::VertexBuffer::VertexBuffer
PUBLIC	??1VertexBuffer@Ogre@@UAE@XZ			; Ogre::VertexBuffer::~VertexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1VertexBuffer@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1VertexBuffer@Ogre@@UAE@XZ$0
__ehfuncinfo$??1VertexBuffer@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1VertexBuffer@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1VertexBuffer@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1VertexBuffer@Ogre@@UAE@XZ PROC			; Ogre::VertexBuffer::~VertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1VertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1VertexBuffer@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??1VertexBuffer@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1VertexBuffer@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1VertexBuffer@Ogre@@UAE@XZ ENDP			; Ogre::VertexBuffer::~VertexBuffer
PUBLIC	??0VertexBuffer@Ogre@@QAE@ABV01@@Z		; Ogre::VertexBuffer::VertexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0VertexBuffer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0VertexBuffer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0VertexBuffer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0VertexBuffer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0VertexBuffer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0VertexBuffer@Ogre@@QAE@ABV01@@Z PROC			; Ogre::VertexBuffer::VertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0VertexBuffer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7VertexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0VertexBuffer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0VertexBuffer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0VertexBuffer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0VertexBuffer@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::VertexBuffer::VertexBuffer
PUBLIC	??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::VertexBuffer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::VertexBuffer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::VertexBuffer::operator=
_TEXT	ENDS
PUBLIC	??_GVertexBuffer@Ogre@@UAEPAXI@Z		; Ogre::VertexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GVertexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVertexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::VertexBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@10
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@10:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVertexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::VertexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EVertexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EVertexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::VertexBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@10
	push	OFFSET ??1VertexBuffer@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@10
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@10:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@10
$LN3@vector@10:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@10
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@10:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@10:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EVertexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::VertexBuffer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::IndexBuffer::getRTTI
EXTRN	?m_RTTI@IndexBuffer@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::IndexBuffer::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::IndexBuffer::getRTTI, COMDAT
; _this$ = ecx

; 230  : 		DECLARE_RTTI_VIRTUAL(IndexBuffer)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@IndexBuffer@Ogre@@2VRuntimeClass@2@B ; Ogre::IndexBuffer::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::IndexBuffer::getRTTI
_TEXT	ENDS
PUBLIC	?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z	; Ogre::IndexBuffer::setVertexRange
; Function compile flags: /Odtp
;	COMDAT ?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_start$ = 8						; size = 4
_num$ = 12						; size = 4
?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z PROC		; Ogre::IndexBuffer::setVertexRange, COMDAT
; _this$ = ecx

; 235  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 236  : 			m_RefVertStart = start;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 237  : 			m_RefVertNum = num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _num$[ebp]
	mov	DWORD PTR [edx+20], eax

; 238  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z ENDP		; Ogre::IndexBuffer::setVertexRange
_TEXT	ENDS
PUBLIC	??_7IndexBuffer@Ogre@@6B@			; Ogre::IndexBuffer::`vftable'
PUBLIC	??0IndexBuffer@Ogre@@QAE@XZ			; Ogre::IndexBuffer::IndexBuffer
PUBLIC	??_R4IndexBuffer@Ogre@@6B@			; Ogre::IndexBuffer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVIndexBuffer@Ogre@@@8			; Ogre::IndexBuffer `RTTI Type Descriptor'
PUBLIC	??_R3IndexBuffer@Ogre@@8			; Ogre::IndexBuffer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IndexBuffer@Ogre@@8			; Ogre::IndexBuffer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IndexBuffer@Ogre@@8		; Ogre::IndexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EIndexBuffer@Ogre@@UAEPAXI@Z			; Ogre::IndexBuffer::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@IndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IndexBuffer@Ogre@@8 DD FLAT:??_R0?AVIndexBuffer@Ogre@@@8 ; Ogre::IndexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2IndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R2IndexBuffer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@IndexBuffer@Ogre@@8 ; Ogre::IndexBuffer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3IndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R3IndexBuffer@Ogre@@8 DD 00H				; Ogre::IndexBuffer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2IndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIndexBuffer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVIndexBuffer@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::IndexBuffer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIndexBuffer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4IndexBuffer@Ogre@@6B@
rdata$r	SEGMENT
??_R4IndexBuffer@Ogre@@6B@ DD 00H			; Ogre::IndexBuffer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIndexBuffer@Ogre@@@8
	DD	FLAT:??_R3IndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7IndexBuffer@Ogre@@6B@
CONST	SEGMENT
??_7IndexBuffer@Ogre@@6B@ DD FLAT:??_R4IndexBuffer@Ogre@@6B@ ; Ogre::IndexBuffer::`vftable'
	DD	FLAT:?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EIndexBuffer@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0IndexBuffer@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0IndexBuffer@Ogre@@QAE@XZ$0
__ehfuncinfo$??0IndexBuffer@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0IndexBuffer@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0IndexBuffer@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0IndexBuffer@Ogre@@QAE@XZ PROC			; Ogre::IndexBuffer::IndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0IndexBuffer@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7IndexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0IndexBuffer@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0IndexBuffer@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0IndexBuffer@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0IndexBuffer@Ogre@@QAE@XZ ENDP			; Ogre::IndexBuffer::IndexBuffer
PUBLIC	??1IndexBuffer@Ogre@@UAE@XZ			; Ogre::IndexBuffer::~IndexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1IndexBuffer@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1IndexBuffer@Ogre@@UAE@XZ$0
__ehfuncinfo$??1IndexBuffer@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1IndexBuffer@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1IndexBuffer@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1IndexBuffer@Ogre@@UAE@XZ PROC			; Ogre::IndexBuffer::~IndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1IndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1IndexBuffer@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??1IndexBuffer@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1IndexBuffer@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1IndexBuffer@Ogre@@UAE@XZ ENDP			; Ogre::IndexBuffer::~IndexBuffer
PUBLIC	??0IndexBuffer@Ogre@@QAE@ABV01@@Z		; Ogre::IndexBuffer::IndexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0IndexBuffer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0IndexBuffer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0IndexBuffer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0IndexBuffer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0IndexBuffer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0IndexBuffer@Ogre@@QAE@ABV01@@Z PROC			; Ogre::IndexBuffer::IndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0IndexBuffer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7IndexBuffer@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0IndexBuffer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0IndexBuffer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0IndexBuffer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0IndexBuffer@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::IndexBuffer::IndexBuffer
PUBLIC	??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::IndexBuffer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::IndexBuffer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::IndexBuffer::operator=
_TEXT	ENDS
PUBLIC	??_GIndexBuffer@Ogre@@UAEPAXI@Z			; Ogre::IndexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GIndexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIndexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::IndexBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1IndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@11
	push	24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@11:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GIndexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::IndexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EIndexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EIndexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::IndexBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@11
	push	OFFSET ??1IndexBuffer@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@11
	push	24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@11:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@11
$LN3@vector@11:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1IndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@11
	push	24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@11:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@11:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EIndexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::IndexBuffer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ	; Ogre::Texture::getRTTI
EXTRN	?m_RTTI@Texture@Ogre@@2VRuntimeClass@2@B:BYTE	; Ogre::Texture::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::Texture::getRTTI, COMDAT
; _this$ = ecx

; 248  : 		DECLARE_RTTI_VIRTUAL(Texture)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@Texture@Ogre@@2VRuntimeClass@2@B ; Ogre::Texture::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::Texture::getRTTI
_TEXT	ENDS
PUBLIC	??_7Texture@Ogre@@6B@				; Ogre::Texture::`vftable'
PUBLIC	??1Texture@Ogre@@MAE@XZ				; Ogre::Texture::~Texture
PUBLIC	??_R4Texture@Ogre@@6B@				; Ogre::Texture::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTexture@Ogre@@@8			; Ogre::Texture `RTTI Type Descriptor'
PUBLIC	??_R3Texture@Ogre@@8				; Ogre::Texture::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Texture@Ogre@@8				; Ogre::Texture::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Texture@Ogre@@8			; Ogre::Texture::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ETexture@Ogre@@MAEPAXI@Z			; Ogre::Texture::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@Texture@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Texture@Ogre@@8 DD FLAT:??_R0?AVTexture@Ogre@@@8 ; Ogre::Texture::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Texture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Texture@Ogre@@8
rdata$r	SEGMENT
??_R2Texture@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Texture@Ogre@@8 ; Ogre::Texture::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3Texture@Ogre@@8
rdata$r	SEGMENT
??_R3Texture@Ogre@@8 DD 00H				; Ogre::Texture::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2Texture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTexture@Ogre@@@8
_DATA	SEGMENT
??_R0?AVTexture@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Texture `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTexture@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Texture@Ogre@@6B@
rdata$r	SEGMENT
??_R4Texture@Ogre@@6B@ DD 00H				; Ogre::Texture::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTexture@Ogre@@@8
	DD	FLAT:??_R3Texture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Texture@Ogre@@6B@
CONST	SEGMENT
??_7Texture@Ogre@@6B@ DD FLAT:??_R4Texture@Ogre@@6B@	; Ogre::Texture::`vftable'
	DD	FLAT:?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_ETexture@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Texture@Ogre@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Texture@Ogre@@MAE@XZ$0
__ehfuncinfo$??1Texture@Ogre@@MAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1Texture@Ogre@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1Texture@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Texture@Ogre@@MAE@XZ PROC				; Ogre::Texture::~Texture, COMDAT
; _this$ = ecx

; 257  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Texture@Ogre@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Texture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 258  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Texture@Ogre@@MAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??1Texture@Ogre@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Texture@Ogre@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Texture@Ogre@@MAE@XZ ENDP				; Ogre::Texture::~Texture
PUBLIC	??0Texture@Ogre@@QAE@XZ				; Ogre::Texture::Texture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Texture@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Texture@Ogre@@QAE@XZ$0
__ehfuncinfo$??0Texture@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Texture@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Texture@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Texture@Ogre@@QAE@XZ PROC				; Ogre::Texture::Texture, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Texture@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Texture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Texture@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0Texture@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Texture@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Texture@Ogre@@QAE@XZ ENDP				; Ogre::Texture::Texture
PUBLIC	??0Texture@Ogre@@QAE@ABV01@@Z			; Ogre::Texture::Texture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Texture@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Texture@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0Texture@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Texture@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Texture@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Texture@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Texture::Texture, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Texture@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7Texture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Texture@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0Texture@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Texture@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Texture@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Texture::Texture
PUBLIC	??4Texture@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Texture::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Texture@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Texture@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Texture::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Texture@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Texture::operator=
_TEXT	ENDS
PUBLIC	??_GTexture@Ogre@@MAEPAXI@Z			; Ogre::Texture::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GTexture@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTexture@Ogre@@MAEPAXI@Z PROC			; Ogre::Texture::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@12
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@12:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTexture@Ogre@@MAEPAXI@Z ENDP			; Ogre::Texture::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ETexture@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ETexture@Ogre@@MAEPAXI@Z PROC			; Ogre::Texture::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@12
	push	OFFSET ??1Texture@Ogre@@MAE@XZ		; Ogre::Texture::~Texture
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@12
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@12:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@12
$LN3@vector@12:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@12
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@12:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@12:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ETexture@Ogre@@MAEPAXI@Z ENDP			; Ogre::Texture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@XZ				; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
;	COMDAT ??0Vector3@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector3@Ogre@@QAE@XZ PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 49   : 		Vector3(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector3@Ogre@@QAE@XZ ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@ABV01@@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??0Vector3@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 50   : 		Vector3(const Vector3 &rhs)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		{
; 52   : 			x = rhs.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 53   : 			y = rhs.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 54   : 			z = rhs.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 55   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector3@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@MMM@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
??0Vector3@Ogre@@QAE@MMM@Z PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 56   : 		Vector3( float x1, float y1, float z1 ) : x(x1), y(y1), z(z1){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector3@Ogre@@QAE@MMM@Z ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@M@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector3@Ogre@@QAE@M@Z PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 57   : 		Vector3(float v) : x(v), y(v), z(v){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector3@Ogre@@QAE@M@Z ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@PAM@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@PAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector3@Ogre@@QAE@PAM@Z PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 58   : 		Vector3(float* v) : x(v[0]), y(v[1]), z(v[2]){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector3@Ogre@@QAE@PAM@Z ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??4Vector3@Ogre@@QAEABV01@ABV01@@Z		; Ogre::Vector3::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Vector3@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??4Vector3@Ogre@@QAEABV01@ABV01@@Z PROC			; Ogre::Vector3::operator=, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			x = vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 63   : 			y = vec.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 64   : 			z = vec.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 65   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 66   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4Vector3@Ogre@@QAEABV01@ABV01@@Z ENDP			; Ogre::Vector3::operator=
_TEXT	ENDS
PUBLIC	??YVector3@Ogre@@QAEXABV01@@Z			; Ogre::Vector3::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YVector3@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??YVector3@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector3::operator+=, COMDAT
; _this$ = ecx

; 68   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 			x += vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 70   : 			y += vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 71   : 			z += vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 72   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YVector3@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector3::operator+=
_TEXT	ENDS
PUBLIC	??ZVector3@Ogre@@QAEXABV01@@Z			; Ogre::Vector3::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZVector3@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??ZVector3@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector3::operator-=, COMDAT
; _this$ = ecx

; 74   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 			x -= vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 76   : 			y -= vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 77   : 			z -= vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 78   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZVector3@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector3::operator-=
_TEXT	ENDS
PUBLIC	??XVector3@Ogre@@QAEXM@Z			; Ogre::Vector3::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XVector3@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??XVector3@Ogre@@QAEXM@Z PROC				; Ogre::Vector3::operator*=, COMDAT
; _this$ = ecx

; 81   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 			x *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 83   : 			y *= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 84   : 			z *= s;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 85   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XVector3@Ogre@@QAEXM@Z ENDP				; Ogre::Vector3::operator*=
_TEXT	ENDS
PUBLIC	??XVector3@Ogre@@QAEXABV01@@Z			; Ogre::Vector3::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XVector3@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??XVector3@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector3::operator*=, COMDAT
; _this$ = ecx

; 88   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 89   : 			x *= vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 90   : 			y *= vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 91   : 			z *= vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vec$[ebp]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 92   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XVector3@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector3::operator*=
_TEXT	ENDS
PUBLIC	??_0Vector3@Ogre@@QAEXM@Z			; Ogre::Vector3::operator/=
; Function compile flags: /Odtp
;	COMDAT ??_0Vector3@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??_0Vector3@Ogre@@QAEXM@Z PROC				; Ogre::Vector3::operator/=, COMDAT
; _this$ = ecx

; 95   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 			x /= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fdiv	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 97   : 			y /= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fdiv	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 98   : 			z /= s;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fdiv	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 99   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??_0Vector3@Ogre@@QAEXM@Z ENDP				; Ogre::Vector3::operator/=
_TEXT	ENDS
PUBLIC	??BVector3@Ogre@@QAEPAMXZ			; Ogre::Vector3::operator float *
; Function compile flags: /Odtp
;	COMDAT ??BVector3@Ogre@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector3@Ogre@@QAEPAMXZ PROC				; Ogre::Vector3::operator float *, COMDAT
; _this$ = ecx

; 101  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 			return &x;

	mov	eax, DWORD PTR _this$[ebp]

; 103  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??BVector3@Ogre@@QAEPAMXZ ENDP				; Ogre::Vector3::operator float *
_TEXT	ENDS
PUBLIC	??BVector3@Ogre@@QBEPBMXZ			; Ogre::Vector3::operator float const *
; Function compile flags: /Odtp
;	COMDAT ??BVector3@Ogre@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector3@Ogre@@QBEPBMXZ PROC				; Ogre::Vector3::operator float const *, COMDAT
; _this$ = ecx

; 105  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 106  : 			return &x;

	mov	eax, DWORD PTR _this$[ebp]

; 107  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??BVector3@Ogre@@QBEPBMXZ ENDP				; Ogre::Vector3::operator float const *
_TEXT	ENDS
PUBLIC	??HVector3@Ogre@@QBE?AV01@XZ			; Ogre::Vector3::operator+
; Function compile flags: /Odtp
;	COMDAT ??HVector3@Ogre@@QBE?AV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??HVector3@Ogre@@QBE?AV01@XZ PROC			; Ogre::Vector3::operator+, COMDAT
; _this$ = ecx

; 109  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 111  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??HVector3@Ogre@@QBE?AV01@XZ ENDP			; Ogre::Vector3::operator+
_TEXT	ENDS
PUBLIC	??GVector3@Ogre@@QBE?AV01@XZ			; Ogre::Vector3::operator-
; Function compile flags: /Odtp
;	COMDAT ??GVector3@Ogre@@QBE?AV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??GVector3@Ogre@@QBE?AV01@XZ PROC			; Ogre::Vector3::operator-, COMDAT
; _this$ = ecx

; 113  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 			return Vector3(-x, -y, -z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 115  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??GVector3@Ogre@@QBE?AV01@XZ ENDP			; Ogre::Vector3::operator-
_TEXT	ENDS
PUBLIC	??8Vector3@Ogre@@QBE_NABV01@@Z			; Ogre::Vector3::operator==
; Function compile flags: /Odtp
;	COMDAT ??8Vector3@Ogre@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv77 = -8						; size = 4
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??8Vector3@Ogre@@QBE_NABV01@@Z PROC			; Ogre::Vector3::operator==, COMDAT
; _this$ = ecx

; 117  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 			return (x==vec.x && y==vec.y && z==vec.z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv77[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv77[ebp]

; 119  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector3@Ogre@@QBE_NABV01@@Z ENDP			; Ogre::Vector3::operator==
_TEXT	ENDS
PUBLIC	?setElement@Vector3@Ogre@@QAEXMMM@Z		; Ogre::Vector3::setElement
; Function compile flags: /Odtp
;	COMDAT ?setElement@Vector3@Ogre@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
?setElement@Vector3@Ogre@@QAEXMMM@Z PROC		; Ogre::Vector3::setElement, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 			x = x1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]

; 123  : 			y = y1;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]

; 124  : 			z = z1;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]

; 125  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setElement@Vector3@Ogre@@QAEXMMM@Z ENDP		; Ogre::Vector3::setElement
_TEXT	ENDS
PUBLIC	?setElement@Vector3@Ogre@@QAEXPAM@Z		; Ogre::Vector3::setElement
; Function compile flags: /Odtp
;	COMDAT ?setElement@Vector3@Ogre@@QAEXPAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?setElement@Vector3@Ogre@@QAEXPAM@Z PROC		; Ogre::Vector3::setElement, COMDAT
; _this$ = ecx

; 127  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 			x = p[0];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 129  : 			y = p[1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 130  : 			z = p[2];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 131  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setElement@Vector3@Ogre@@QAEXPAM@Z ENDP		; Ogre::Vector3::setElement
_TEXT	ENDS
PUBLIC	?Sqrt@Ogre@@YAMM@Z				; Ogre::Sqrt
PUBLIC	?length@Vector3@Ogre@@QBEMXZ			; Ogre::Vector3::length
; Function compile flags: /Odtp
;	COMDAT ?length@Vector3@Ogre@@QBEMXZ
_TEXT	SEGMENT
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?length@Vector3@Ogre@@QBEMXZ PROC			; Ogre::Vector3::length, COMDAT
; _this$ = ecx

; 133  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 			return (float)Sqrt(x*x+y*y+z*z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv88[ebp]
	fld	DWORD PTR tv88[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?Sqrt@Ogre@@YAMM@Z			; Ogre::Sqrt
	add	esp, 4

; 135  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@Vector3@Ogre@@QBEMXZ ENDP			; Ogre::Vector3::length
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
;	COMDAT ?Sqrt@Ogre@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?Sqrt@Ogre@@YAMM@Z PROC					; Ogre::Sqrt, COMDAT

; 59   : 	{

	push	ebp
	mov	ebp, esp

; 60   : 		return (float)sqrt(x);

	push	ecx
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4

; 61   : 	}

	pop	ebp
	ret	0
?Sqrt@Ogre@@YAMM@Z ENDP					; Ogre::Sqrt
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 534  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	fstp	DWORD PTR [esp]
	call	_sqrtf
	add	esp, 4
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 423  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?lengthSqr@Vector3@Ogre@@QBEMXZ			; Ogre::Vector3::lengthSqr
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
;	COMDAT ?lengthSqr@Vector3@Ogre@@QBEMXZ
_TEXT	SEGMENT
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?lengthSqr@Vector3@Ogre@@QBEMXZ PROC			; Ogre::Vector3::lengthSqr, COMDAT
; _this$ = ecx

; 137  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 			return (x*x+y*y+z*z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv88[ebp]
	fld	DWORD PTR tv88[ebp]

; 139  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?lengthSqr@Vector3@Ogre@@QBEMXZ ENDP			; Ogre::Vector3::lengthSqr
_TEXT	ENDS
PUBLIC	??0WorldPos@Ogre@@QAE@XZ			; Ogre::WorldPos::WorldPos
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreworldpos.h
;	COMDAT ??0WorldPos@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0WorldPos@Ogre@@QAE@XZ PROC				; Ogre::WorldPos::WorldPos, COMDAT
; _this$ = ecx

; 18   : 		WorldPos()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 19   : 		{
; 20   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0WorldPos@Ogre@@QAE@XZ ENDP				; Ogre::WorldPos::WorldPos
_TEXT	ENDS
PUBLIC	??0WorldPos@Ogre@@QAE@HHH@Z			; Ogre::WorldPos::WorldPos
; Function compile flags: /Odtp
;	COMDAT ??0WorldPos@Ogre@@QAE@HHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
??0WorldPos@Ogre@@QAE@HHH@Z PROC			; Ogre::WorldPos::WorldPos, COMDAT
; _this$ = ecx

; 23   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __x$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __z$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 24   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0WorldPos@Ogre@@QAE@HHH@Z ENDP			; Ogre::WorldPos::WorldPos
_TEXT	ENDS
PUBLIC	__real@4024000000000000
PUBLIC	??0WorldPos@Ogre@@QAE@ABVVector3@1@@Z		; Ogre::WorldPos::WorldPos
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0WorldPos@Ogre@@QAE@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??0WorldPos@Ogre@@QAE@ABVVector3@1@@Z PROC		; Ogre::WorldPos::WorldPos, COMDAT
; _this$ = ecx

; 26   : 		WorldPos( const Vector3 &vec )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 27   : 		{
; 28   : 			x = (WPOS_T)(vec.x * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 29   : 			y = (WPOS_T)(vec.y * UNIT);

	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 30   : 			z = (WPOS_T)(vec.z * UNIT);

	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 31   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0WorldPos@Ogre@@QAE@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::WorldPos
_TEXT	ENDS
PUBLIC	??4WorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator=
; Function compile flags: /Odtp
;	COMDAT ??4WorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??4WorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator=, COMDAT
; _this$ = ecx

; 34   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 			x = (WPOS_T)(vec.x * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 36   : 			y = (WPOS_T)(vec.y * UNIT);

	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 37   : 			z = (WPOS_T)(vec.z * UNIT);

	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 38   : 
; 39   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 40   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4WorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator=
_TEXT	ENDS
PUBLIC	??YWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??YWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator+=, COMDAT
; _this$ = ecx

; 43   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 			x += (WPOS_T)(vec.x * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 45   : 			y += (WPOS_T)(vec.y * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 46   : 			z += (WPOS_T)(vec.z * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 47   : 
; 48   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 49   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator+=
_TEXT	ENDS
PUBLIC	??YWorldPos@Ogre@@QAEABV01@ABV01@@Z		; Ogre::WorldPos::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YWorldPos@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
??YWorldPos@Ogre@@QAEABV01@ABV01@@Z PROC		; Ogre::WorldPos::operator+=, COMDAT
; _this$ = ecx

; 52   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 53   : 			x += pos.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx

; 54   : 			y += pos.y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _pos$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 55   : 			z += pos.z;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _pos$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 56   : 
; 57   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 58   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YWorldPos@Ogre@@QAEABV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator+=
_TEXT	ENDS
PUBLIC	??ZWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??ZWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator-=, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			x -= (WPOS_T)(vec.x * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 63   : 			y -= (WPOS_T)(vec.y * UNIT);

	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	sub	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 64   : 			z -= (WPOS_T)(vec.z * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 65   : 
; 66   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 67   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator-=
_TEXT	ENDS
PUBLIC	??ZWorldPos@Ogre@@QAEABV01@ABV01@@Z		; Ogre::WorldPos::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZWorldPos@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
??ZWorldPos@Ogre@@QAEABV01@ABV01@@Z PROC		; Ogre::WorldPos::operator-=, COMDAT
; _this$ = ecx

; 70   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 			x -= pos.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 72   : 			y -= pos.y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 73   : 			z -= pos.z;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 74   : 
; 75   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 76   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZWorldPos@Ogre@@QAEABV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator-=
_TEXT	ENDS
PUBLIC	??HWorldPos@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::WorldPos::operator+
; Function compile flags: /Odtp
;	COMDAT ??HWorldPos@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
??HWorldPos@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::WorldPos::operator+, COMDAT
; _this$ = ecx

; 79   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 			return WorldPos(x+pos.x, y+pos.y, z+pos.z);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _pos$[ebp]
	add	ecx, DWORD PTR [edx+8]
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pos$[ebp]
	add	ecx, DWORD PTR [edx+4]
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??HWorldPos@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator+
_TEXT	ENDS
PUBLIC	??GWorldPos@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::WorldPos::operator-
; Function compile flags: /Odtp
;	COMDAT ??GWorldPos@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
??GWorldPos@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::WorldPos::operator-, COMDAT
; _this$ = ecx

; 84   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 			return WorldPos(x-pos.x, y-pos.y, z-pos.z);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 86   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??GWorldPos@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator-
_TEXT	ENDS
PUBLIC	??HWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator+
; Function compile flags: /Odtp
;	COMDAT ??HWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
??HWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator+, COMDAT
; _this$ = ecx

; 89   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 			return WorldPos(x+(WPOS_T)(pos.x*UNIT), y+(WPOS_T)(pos.y*UNIT), z+(WPOS_T)(pos.z*UNIT));

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	push	eax
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	push	eax
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 91   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??HWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator+
_TEXT	ENDS
PUBLIC	??GWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator-
; Function compile flags: /Odtp
;	COMDAT ??GWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
??GWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator-, COMDAT
; _this$ = ecx

; 94   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 			return WorldPos(x-(WPOS_T)(pos.x*UNIT), y-(WPOS_T)(pos.y*UNIT), z-(WPOS_T)(pos.z*UNIT));

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, eax
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 96   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??GWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator-
_TEXT	ENDS
PUBLIC	??DWorldPos@Ogre@@QBE?AV01@H@Z			; Ogre::WorldPos::operator*
; Function compile flags: /Odtp
;	COMDAT ??DWorldPos@Ogre@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
??DWorldPos@Ogre@@QBE?AV01@H@Z PROC			; Ogre::WorldPos::operator*, COMDAT
; _this$ = ecx

; 99   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 			return WorldPos((WPOS_T)(x*s), (WPOS_T)(y*s), (WPOS_T)(z*s));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	imul	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	imul	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 101  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??DWorldPos@Ogre@@QBE?AV01@H@Z ENDP			; Ogre::WorldPos::operator*
_TEXT	ENDS
PUBLIC	??DWorldPos@Ogre@@QBE?AV01@M@Z			; Ogre::WorldPos::operator*
; Function compile flags: /Odtp
;	COMDAT ??DWorldPos@Ogre@@QBE?AV01@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
??DWorldPos@Ogre@@QBE?AV01@M@Z PROC			; Ogre::WorldPos::operator*, COMDAT
; _this$ = ecx

; 104  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 			return WorldPos((WPOS_T)(x*s), (WPOS_T)(y*s), (WPOS_T)(z*s));

	mov	eax, DWORD PTR _this$[ebp]
	fild	DWORD PTR [eax+8]
	fmul	DWORD PTR _s$[ebp]
	call	__ftol2_sse
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [ecx+4]
	fmul	DWORD PTR _s$[ebp]
	call	__ftol2_sse
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [edx]
	fmul	DWORD PTR _s$[ebp]
	call	__ftol2_sse
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 106  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??DWorldPos@Ogre@@QBE?AV01@M@Z ENDP			; Ogre::WorldPos::operator*
_TEXT	ENDS
PUBLIC	??KWorldPos@Ogre@@QBE?AV01@H@Z			; Ogre::WorldPos::operator/
; Function compile flags: /Odtp
;	COMDAT ??KWorldPos@Ogre@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
??KWorldPos@Ogre@@QBE?AV01@H@Z PROC			; Ogre::WorldPos::operator/, COMDAT
; _this$ = ecx

; 109  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 			return WorldPos((WPOS_T)(x/s), (WPOS_T)(y/s), (WPOS_T)(z/s));

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	cdq
	idiv	DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cdq
	idiv	DWORD PTR _s$[ebp]
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	idiv	DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 111  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??KWorldPos@Ogre@@QBE?AV01@H@Z ENDP			; Ogre::WorldPos::operator/
_TEXT	ENDS
PUBLIC	??8WorldPos@Ogre@@QBE_NABV01@@Z			; Ogre::WorldPos::operator==
; Function compile flags: /Odtp
;	COMDAT ??8WorldPos@Ogre@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??8WorldPos@Ogre@@QBE_NABV01@@Z PROC			; Ogre::WorldPos::operator==, COMDAT
; _this$ = ecx

; 114  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 			return x==rhs.x && y==rhs.y && z==rhs.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN3@operator@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator@2
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@operator@2
$LN3@operator@2:
	mov	DWORD PTR tv71[ebp], 0
$LN4@operator@2:
	mov	al, BYTE PTR tv71[ebp]

; 116  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8WorldPos@Ogre@@QBE_NABV01@@Z ENDP			; Ogre::WorldPos::operator==
_TEXT	ENDS
PUBLIC	??9WorldPos@Ogre@@QBE_NABV01@@Z			; Ogre::WorldPos::operator!=
; Function compile flags: /Odtp
;	COMDAT ??9WorldPos@Ogre@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??9WorldPos@Ogre@@QBE_NABV01@@Z PROC			; Ogre::WorldPos::operator!=, COMDAT
; _this$ = ecx

; 119  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 			return x!=rhs.x || y!=rhs.y || z!=rhs.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator@3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN3@operator@3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator@3
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN4@operator@3
$LN3@operator@3:
	mov	DWORD PTR tv71[ebp], 1
$LN4@operator@3:
	mov	al, BYTE PTR tv71[ebp]

; 121  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9WorldPos@Ogre@@QBE_NABV01@@Z ENDP			; Ogre::WorldPos::operator!=
_TEXT	ENDS
PUBLIC	?inverse@WorldPos@Ogre@@QAEXXZ			; Ogre::WorldPos::inverse
; Function compile flags: /Odtp
;	COMDAT ?inverse@WorldPos@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?inverse@WorldPos@Ogre@@QAEXXZ PROC			; Ogre::WorldPos::inverse, COMDAT
; _this$ = ecx

; 124  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 			x = -x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	neg	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 126  : 			y = -y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	neg	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 127  : 			z = -z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	neg	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 128  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?inverse@WorldPos@Ogre@@QAEXXZ ENDP			; Ogre::WorldPos::inverse
_TEXT	ENDS
PUBLIC	?normalize@WorldPos@Ogre@@QBE?AVVector3@2@XZ	; Ogre::WorldPos::normalize
; Function compile flags: /Odtp
;	COMDAT ?normalize@WorldPos@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
tv133 = -48						; size = 4
tv131 = -44						; size = 4
tv129 = -40						; size = 4
_this$ = -36						; size = 4
_fy$ = -32						; size = 8
_fz$ = -24						; size = 8
_len$ = -16						; size = 8
_fx$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?normalize@WorldPos@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::WorldPos::normalize, COMDAT
; _this$ = ecx

; 131  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 			double fx = double(x);

	mov	eax, DWORD PTR _this$[ebp]
	fild	DWORD PTR [eax]
	fstp	QWORD PTR _fx$[ebp]

; 133  : 			double fy = double(y);

	mov	ecx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [ecx+4]
	fstp	QWORD PTR _fy$[ebp]

; 134  : 			double fz = double(z);

	mov	edx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [edx+8]
	fstp	QWORD PTR _fz$[ebp]

; 135  : 			double len = sqrt( fx*fx + fy*fy + fz*fz );

	fld	QWORD PTR _fx$[ebp]
	fmul	QWORD PTR _fx$[ebp]
	fld	QWORD PTR _fy$[ebp]
	fmul	QWORD PTR _fy$[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _fz$[ebp]
	fmul	QWORD PTR _fz$[ebp]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR _len$[ebp]

; 136  : 
; 137  : 			return Vector3( float(fx/len), float(fy/len), float(fz/len) );

	fld	QWORD PTR _fz$[ebp]
	fdiv	QWORD PTR _len$[ebp]
	fstp	DWORD PTR tv129[ebp]
	fld	DWORD PTR tv129[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	QWORD PTR _fy$[ebp]
	fdiv	QWORD PTR _len$[ebp]
	fstp	DWORD PTR tv131[ebp]
	fld	DWORD PTR tv131[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	QWORD PTR _fx$[ebp]
	fdiv	QWORD PTR _len$[ebp]
	fstp	DWORD PTR tv133[ebp]
	fld	DWORD PTR tv133[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 138  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?normalize@WorldPos@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::WorldPos::normalize
_TEXT	ENDS
PUBLIC	?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z ; Ogre::WorldPos::subtract
PUBLIC	?toVector3@WorldPos@Ogre@@QBE?AVVector3@2@XZ	; Ogre::WorldPos::toVector3
EXTRN	?m_Origin@WorldPos@Ogre@@2V12@A:BYTE		; Ogre::WorldPos::m_Origin
; Function compile flags: /Odtp
;	COMDAT ?toVector3@WorldPos@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?toVector3@WorldPos@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::WorldPos::toVector3, COMDAT
; _this$ = ecx

; 141  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 			return subtract(m_Origin);

	push	OFFSET ?m_Origin@WorldPos@Ogre@@2V12@A	; Ogre::WorldPos::m_Origin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z ; Ogre::WorldPos::subtract
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 143  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?toVector3@WorldPos@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::WorldPos::toVector3
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z
_TEXT	SEGMENT
tv130 = -28						; size = 4
tv129 = -24						; size = 4
tv93 = -20						; size = 4
tv92 = -16						; size = 4
tv88 = -12						; size = 4
tv87 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z PROC	; Ogre::WorldPos::subtract, COMDAT
; _this$ = ecx

; 146  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 			return Vector3( float(double(x-pos.x)/UNIT), float(double(y-pos.y)/UNIT), float(double(z-pos.z)/UNIT) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv87[ebp], edx
	fild	DWORD PTR tv87[ebp]
	fdiv	QWORD PTR __real@4024000000000000
	fstp	DWORD PTR tv88[ebp]
	fld	DWORD PTR tv88[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv92[ebp], edx
	fild	DWORD PTR tv92[ebp]
	fdiv	QWORD PTR __real@4024000000000000
	fstp	DWORD PTR tv93[ebp]
	fld	DWORD PTR tv93[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv129[ebp], edx
	fild	DWORD PTR tv129[ebp]
	fdiv	QWORD PTR __real@4024000000000000
	fstp	DWORD PTR tv130[ebp]
	fld	DWORD PTR tv130[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 148  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z ENDP	; Ogre::WorldPos::subtract
_TEXT	ENDS
PUBLIC	?Flt2Fix@WorldPos@Ogre@@SAHM@Z			; Ogre::WorldPos::Flt2Fix
; Function compile flags: /Odtp
;	COMDAT ?Flt2Fix@WorldPos@Ogre@@SAHM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?Flt2Fix@WorldPos@Ogre@@SAHM@Z PROC			; Ogre::WorldPos::Flt2Fix, COMDAT

; 151  : 		{

	push	ebp
	mov	ebp, esp

; 152  : 			return (WPOS_T)(x*UNIT);

	fld	DWORD PTR _x$[ebp]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse

; 153  : 		}

	pop	ebp
	ret	0
?Flt2Fix@WorldPos@Ogre@@SAHM@Z ENDP			; Ogre::WorldPos::Flt2Fix
_TEXT	ENDS
PUBLIC	?Fix2Flt@WorldPos@Ogre@@SAMH@Z			; Ogre::WorldPos::Fix2Flt
; Function compile flags: /Odtp
;	COMDAT ?Fix2Flt@WorldPos@Ogre@@SAMH@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
_x$ = 8							; size = 4
?Fix2Flt@WorldPos@Ogre@@SAMH@Z PROC			; Ogre::WorldPos::Fix2Flt, COMDAT

; 156  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx

; 157  : 			return float(double(x)/UNIT);

	fild	DWORD PTR _x$[ebp]
	fdiv	QWORD PTR __real@4024000000000000
	fstp	DWORD PTR tv67[ebp]
	fld	DWORD PTR tv67[ebp]

; 158  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?Fix2Flt@WorldPos@Ogre@@SAMH@Z ENDP			; Ogre::WorldPos::Fix2Flt
_TEXT	ENDS
PUBLIC	??4WorldPos@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::WorldPos::operator=
; Function compile flags: /Odtp
;	COMDAT ??4WorldPos@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4WorldPos@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::WorldPos::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4WorldPos@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator=
_TEXT	ENDS
PUBLIC	??0Plane@Ogre@@QAE@XZ				; Ogre::Plane::Plane
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreplane.h
;	COMDAT ??0Plane@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Plane@Ogre@@QAE@XZ PROC				; Ogre::Plane::Plane, COMDAT
; _this$ = ecx

; 71   : 		Plane()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3

; 72   : 		{
; 73   : 			//assert(0);
; 74   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Plane@Ogre@@QAE@XZ ENDP				; Ogre::Plane::Plane
_TEXT	ENDS
PUBLIC	?setFromNormalAndPoint@Plane@Ogre@@QAEXABVVector3@2@0@Z ; Ogre::Plane::setFromNormalAndPoint
PUBLIC	??0Plane@Ogre@@QAE@ABVVector3@1@0@Z		; Ogre::Plane::Plane
; Function compile flags: /Odtp
;	COMDAT ??0Plane@Ogre@@QAE@ABVVector3@1@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_normal$ = 8						; size = 4
_point$ = 12						; size = 4
??0Plane@Ogre@@QAE@ABVVector3@1@0@Z PROC		; Ogre::Plane::Plane, COMDAT
; _this$ = ecx

; 76   : 		Plane( const Vector3 &normal, const Vector3 &point )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3

; 77   : 		{
; 78   : 			setFromNormalAndPoint(normal,point);

	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _normal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setFromNormalAndPoint@Plane@Ogre@@QAEXABVVector3@2@0@Z ; Ogre::Plane::setFromNormalAndPoint

; 79   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Plane@Ogre@@QAE@ABVVector3@1@0@Z ENDP		; Ogre::Plane::Plane
_TEXT	ENDS
PUBLIC	??0Plane@Ogre@@QAE@ABVVector3@1@M@Z		; Ogre::Plane::Plane
; Function compile flags: /Odtp
;	COMDAT ??0Plane@Ogre@@QAE@ABVVector3@1@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_normal$ = 8						; size = 4
_offset$ = 12						; size = 4
??0Plane@Ogre@@QAE@ABVVector3@1@M@Z PROC		; Ogre::Plane::Plane, COMDAT
; _this$ = ecx

; 82   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _normal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _offset$[ebp]
	fstp	DWORD PTR [ecx+12]

; 83   : 			assert( isValid() );
; 84   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Plane@Ogre@@QAE@ABVVector3@1@M@Z ENDP		; Ogre::Plane::Plane
_TEXT	ENDS
PUBLIC	?isValid@Plane@Ogre@@QBE_NXZ			; Ogre::Plane::isValid
; Function compile flags: /Odtp
;	COMDAT ?isValid@Plane@Ogre@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isValid@Plane@Ogre@@QBE_NXZ PROC			; Ogre::Plane::isValid, COMDAT
; _this$ = ecx

; 92   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 			assert( IsFloatValid(m_offset) );
; 94   : 			return true;

	mov	al, 1

; 95   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?isValid@Plane@Ogre@@QBE_NXZ ENDP			; Ogre::Plane::isValid
_TEXT	ENDS
PUBLIC	?setFromPlaneParam@Plane@Ogre@@QAEXQBM@Z	; Ogre::Plane::setFromPlaneParam
; Function compile flags: /Odtp
;	COMDAT ?setFromPlaneParam@Plane@Ogre@@QAEXQBM@Z
_TEXT	SEGMENT
tv142 = -12						; size = 4
_this$ = -8						; size = 4
_len$ = -4						; size = 4
_plane$ = 8						; size = 4
?setFromPlaneParam@Plane@Ogre@@QAEXQBM@Z PROC		; Ogre::Plane::setFromPlaneParam, COMDAT
; _this$ = ecx

; 100  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 			float len = (float)Sqrt( plane[0]*plane[0] + plane[1]*plane[1] + plane[2]*plane[2] );

	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv142[ebp]
	fld	DWORD PTR tv142[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?Sqrt@Ogre@@YAMM@Z			; Ogre::Sqrt
	add	esp, 4
	fstp	DWORD PTR _len$[ebp]

; 102  : 			m_normal.x = plane[0] / len;

	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax]
	fdiv	DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 103  : 			m_normal.y = plane[1] / len;

	mov	edx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [edx+4]
	fdiv	DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 104  : 			m_normal.z = plane[2] / len;

	mov	ecx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [ecx+8]
	fdiv	DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 105  : 			m_offset   = plane[3] / len;

	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax+12]
	fdiv	DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 106  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setFromPlaneParam@Plane@Ogre@@QAEXQBM@Z ENDP		; Ogre::Plane::setFromPlaneParam
_TEXT	ENDS
PUBLIC	?DotProduct@Ogre@@YAMABVVector3@1@0@Z		; Ogre::DotProduct
; Function compile flags: /Odtp
;	COMDAT ?setFromNormalAndPoint@Plane@Ogre@@QAEXABVVector3@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_normal$ = 8						; size = 4
_point$ = 12						; size = 4
?setFromNormalAndPoint@Plane@Ogre@@QAEXABVVector3@2@0@Z PROC ; Ogre::Plane::setFromNormalAndPoint, COMDAT
; _this$ = ecx

; 109  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 			m_normal = normal;

	mov	eax, DWORD PTR _normal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 111  : 			m_offset = - DotProduct( m_normal, point );

	mov	ecx, DWORD PTR _point$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?DotProduct@Ogre@@YAMABVVector3@1@0@Z	; Ogre::DotProduct
	add	esp, 8
	fchs
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+12]

; 112  : 
; 113  : 			assert(isValid());
; 114  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setFromNormalAndPoint@Plane@Ogre@@QAEXABVVector3@2@0@Z ENDP ; Ogre::Plane::setFromNormalAndPoint
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
_TEXT	ENDS
;	COMDAT ?DotProduct@Ogre@@YAMABVVector3@1@0@Z
_TEXT	SEGMENT
tv86 = -4						; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
?DotProduct@Ogre@@YAMABVVector3@1@0@Z PROC		; Ogre::DotProduct, COMDAT

; 263  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 264  : 		return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _v2$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _v2$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _v2$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]

; 265  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@Ogre@@YAMABVVector3@1@0@Z ENDP		; Ogre::DotProduct
_TEXT	ENDS
PUBLIC	?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ; Ogre::Plane::distanceToPoint
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreplane.h
;	COMDAT ?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
_point$ = 8						; size = 4
?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z PROC	; Ogre::Plane::distanceToPoint, COMDAT
; _this$ = ecx

; 122  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 			assert(isValid());
; 124  : 			return DotProduct(m_normal, point) + m_offset;

	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?DotProduct@Ogre@@YAMABVVector3@1@0@Z	; Ogre::DotProduct
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+12]
	fstp	DWORD PTR tv78[ebp]
	fld	DWORD PTR tv78[ebp]

; 125  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ENDP	; Ogre::Plane::distanceToPoint
_TEXT	ENDS
PUBLIC	?pointSideGE@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@@Z ; Ogre::Plane::pointSideGE
; Function compile flags: /Odtp
;	COMDAT ?pointSideGE@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
_this$ = -8						; size = 4
_d$ = -4						; size = 4
_point$ = 8						; size = 4
?pointSideGE@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@@Z PROC ; Ogre::Plane::pointSideGE, COMDAT
; _this$ = ecx

; 128  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 			assert(isValid());
; 130  : 			const float d = distanceToPoint(point);

	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ; Ogre::Plane::distanceToPoint
	fstp	DWORD PTR _d$[ebp]

; 131  : 			return ( d >= 0.f ) ? FRONT : BACK;

	fld	DWORD PTR _d$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN3@pointSideG
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN4@pointSideG
$LN3@pointSideG:
	mov	DWORD PTR tv69[ebp], 1
$LN4@pointSideG:
	mov	eax, DWORD PTR tv69[ebp]

; 132  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?pointSideGE@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@@Z ENDP ; Ogre::Plane::pointSideGE
_TEXT	ENDS
PUBLIC	?pointSideOrOn@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@M@Z ; Ogre::Plane::pointSideOrOn
; Function compile flags: /Odtp
;	COMDAT ?pointSideOrOn@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@M@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_d$ = -4						; size = 4
_point$ = 8						; size = 4
_rOnTolerance$ = 12					; size = 4
?pointSideOrOn@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@M@Z PROC ; Ogre::Plane::pointSideOrOn, COMDAT
; _this$ = ecx

; 135  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 136  : 			assert(isValid());
; 137  : 			const float d = distanceToPoint(point);

	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ; Ogre::Plane::distanceToPoint
	fstp	DWORD PTR _d$[ebp]

; 138  : 			if ( d > rOnTolerance )

	fld	DWORD PTR _d$[ebp]
	fld	DWORD PTR _rOnTolerance$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@pointSideO

; 139  : 				return FRONT;

	xor	eax, eax
	jmp	SHORT $LN3@pointSideO
$LN2@pointSideO:

; 140  : 			if ( d <-rOnTolerance )

	fld	DWORD PTR _rOnTolerance$[ebp]
	fchs
	fld	DWORD PTR _d$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@pointSideO

; 141  : 				return BACK;

	mov	eax, 1
	jmp	SHORT $LN3@pointSideO
$LN1@pointSideO:

; 142  : 			return INTERSECT;

	mov	eax, 2
$LN3@pointSideO:

; 143  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?pointSideOrOn@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@M@Z ENDP ; Ogre::Plane::pointSideOrOn
_TEXT	ENDS
PUBLIC	?translate@Plane@Ogre@@QAEXABVVector3@2@@Z	; Ogre::Plane::translate
; Function compile flags: /Odtp
;	COMDAT ?translate@Plane@Ogre@@QAEXABVVector3@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
?translate@Plane@Ogre@@QAEXABVVector3@2@@Z PROC		; Ogre::Plane::translate, COMDAT
; _this$ = ecx

; 160  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 			assert(isValid());
; 162  : 			// slide the offset
; 163  : 			m_offset -= DotProduct( v, m_normal );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	call	?DotProduct@Ogre@@YAMABVVector3@1@0@Z	; Ogre::DotProduct
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	fsubr	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+12]

; 164  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?translate@Plane@Ogre@@QAEXABVVector3@2@@Z ENDP		; Ogre::Plane::translate
_TEXT	ENDS
PUBLIC	?moveForwards@Plane@Ogre@@QAEXM@Z		; Ogre::Plane::moveForwards
; Function compile flags: /Odtp
;	COMDAT ?moveForwards@Plane@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rDelta$ = 8						; size = 4
?moveForwards@Plane@Ogre@@QAEXM@Z PROC			; Ogre::Plane::moveForwards, COMDAT
; _this$ = ecx

; 170  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 171  : 			assert(isValid());
; 172  : 			m_offset -= rDelta;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR _rDelta$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 173  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?moveForwards@Plane@Ogre@@QAEXM@Z ENDP			; Ogre::Plane::moveForwards
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	__real@bf800000
PUBLIC	?flipNormal@Plane@Ogre@@QAEXXZ			; Ogre::Plane::flipNormal
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?flipNormal@Plane@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?flipNormal@Plane@Ogre@@QAEXXZ PROC			; Ogre::Plane::flipNormal, COMDAT
; _this$ = ecx

; 176  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 			assert(isValid());
; 178  : 			m_normal *= -1.0f;

	push	ecx
	fld	DWORD PTR __real@bf800000
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??XVector3@Ogre@@QAEXM@Z		; Ogre::Vector3::operator*=

; 179  : 			m_offset *= -1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	QWORD PTR __real@bff0000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 180  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?flipNormal@Plane@Ogre@@QAEXXZ ENDP			; Ogre::Plane::flipNormal
_TEXT	ENDS
PUBLIC	?solveForX@Plane@Ogre@@QBEMMM@Z			; Ogre::Plane::solveForX
; Function compile flags: /Odtp
;	COMDAT ?solveForX@Plane@Ogre@@QBEMMM@Z
_TEXT	SEGMENT
tv92 = -8						; size = 4
_this$ = -4						; size = 4
_y$ = 8							; size = 4
_z$ = 12						; size = 4
?solveForX@Plane@Ogre@@QBEMMM@Z PROC			; Ogre::Plane::solveForX, COMDAT
; _this$ = ecx

; 183  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 184  : 			if( m_normal.x ) return -(m_normal.y*y + m_normal.z*z + m_offset)/m_normal.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@solveForX
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR _z$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	jmp	SHORT $LN1@solveForX

; 185  : 			else

	jmp	SHORT $LN1@solveForX
$LN2@solveForX:

; 186  : 			{
; 187  : 				assert(0);
; 188  : 				return 0;

	fldz
$LN1@solveForX:

; 189  : 			}
; 190  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?solveForX@Plane@Ogre@@QBEMMM@Z ENDP			; Ogre::Plane::solveForX
_TEXT	ENDS
PUBLIC	?solveForY@Plane@Ogre@@QBEMMM@Z			; Ogre::Plane::solveForY
; Function compile flags: /Odtp
;	COMDAT ?solveForY@Plane@Ogre@@QBEMMM@Z
_TEXT	SEGMENT
tv93 = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_z$ = 12						; size = 4
?solveForY@Plane@Ogre@@QBEMMM@Z PROC			; Ogre::Plane::solveForY, COMDAT
; _this$ = ecx

; 192  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 193  : 			if( m_normal.y ) return -(m_normal.x*x + m_normal.z*z + m_offset)/m_normal.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@solveForY
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR _z$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx+4]
	fstp	DWORD PTR tv93[ebp]
	fld	DWORD PTR tv93[ebp]
	jmp	SHORT $LN1@solveForY

; 194  : 			else

	jmp	SHORT $LN1@solveForY
$LN2@solveForY:

; 195  : 			{
; 196  : 				assert(0);
; 197  : 				return 0;

	fldz
$LN1@solveForY:

; 198  : 			}
; 199  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?solveForY@Plane@Ogre@@QBEMMM@Z ENDP			; Ogre::Plane::solveForY
_TEXT	ENDS
PUBLIC	?solveForZ@Plane@Ogre@@QBEMMM@Z			; Ogre::Plane::solveForZ
; Function compile flags: /Odtp
;	COMDAT ?solveForZ@Plane@Ogre@@QBEMMM@Z
_TEXT	SEGMENT
tv93 = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?solveForZ@Plane@Ogre@@QBEMMM@Z PROC			; Ogre::Plane::solveForZ, COMDAT
; _this$ = ecx

; 201  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 			if( m_normal.z ) return -(m_normal.x*x + m_normal.y*y + m_offset)/m_normal.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@solveForZ
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _y$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv93[ebp]
	fld	DWORD PTR tv93[ebp]
	jmp	SHORT $LN1@solveForZ

; 203  : 			else

	jmp	SHORT $LN1@solveForZ
$LN2@solveForZ:

; 204  : 			{
; 205  : 				assert(0);
; 206  : 				return 0;

	fldz
$LN1@solveForZ:

; 207  : 			}
; 208  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?solveForZ@Plane@Ogre@@QBEMMM@Z ENDP			; Ogre::Plane::solveForZ
_TEXT	ENDS
PUBLIC	??HOgre@@YA?AVVector3@0@ABV10@0@Z		; Ogre::operator+
PUBLIC	??KOgre@@YA?AVVector3@0@ABV10@M@Z		; Ogre::operator/
PUBLIC	??DOgre@@YA?AVVector3@0@ABV10@M@Z		; Ogre::operator*
PUBLIC	??GOgre@@YA?AVVector3@0@ABV10@0@Z		; Ogre::operator-
PUBLIC	?segmentIntersec@Plane@Ogre@@QBE_NAAVVector3@2@ABV32@1@Z ; Ogre::Plane::segmentIntersec
; Function compile flags: /Odtp
;	COMDAT ?segmentIntersec@Plane@Ogre@@QBE_NAAVVector3@2@ABV32@1@Z
_TEXT	SEGMENT
tv140 = -64						; size = 4
_this$ = -60						; size = 4
$T129878 = -56						; size = 12
$T129877 = -44						; size = 12
$T129876 = -32						; size = 12
$T129875 = -20						; size = 12
_fDis0$ = -8						; size = 4
_fDis1$ = -4						; size = 4
_vOut$ = 8						; size = 4
_vP0$ = 12						; size = 4
_vP1$ = 16						; size = 4
?segmentIntersec@Plane@Ogre@@QBE_NAAVVector3@2@ABV32@1@Z PROC ; Ogre::Plane::segmentIntersec, COMDAT
; _this$ = ecx

; 212  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 			float fDis0 = distanceToPoint(vP0);

	mov	eax, DWORD PTR _vP0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ; Ogre::Plane::distanceToPoint
	fstp	DWORD PTR _fDis0$[ebp]

; 214  : 			float fDis1 = distanceToPoint(vP1);

	mov	ecx, DWORD PTR _vP1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ; Ogre::Plane::distanceToPoint
	fstp	DWORD PTR _fDis1$[ebp]

; 215  : 			if( fDis0 * fDis1 >= 0 )

	fld	DWORD PTR _fDis0$[ebp]
	fmul	DWORD PTR _fDis1$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN1@segmentInt

; 216  : 				return false;

	xor	al, al
	jmp	SHORT $LN2@segmentInt
$LN1@segmentInt:

; 217  : 
; 218  : 			vOut = vP0 + (vP1 - vP0) * fDis0 / (fDis0 - fDis1);

	fld	DWORD PTR _fDis0$[ebp]
	fsub	DWORD PTR _fDis1$[ebp]
	fstp	DWORD PTR tv140[ebp]
	fld	DWORD PTR tv140[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fDis0$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _vP0$[ebp]
	push	edx
	mov	eax, DWORD PTR _vP1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T129875[ebp]
	push	ecx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T129876[ebp]
	push	edx
	call	??DOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T129877[ebp]
	push	eax
	call	??KOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator/
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _vP0$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T129878[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _vOut$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 219  : 			return true;

	mov	al, 1
$LN2@segmentInt:

; 220  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?segmentIntersec@Plane@Ogre@@QBE_NAAVVector3@2@ABV32@1@Z ENDP ; Ogre::Plane::segmentIntersec
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
_TEXT	ENDS
;	COMDAT ??HOgre@@YA?AVVector3@0@ABV10@0@Z
_TEXT	SEGMENT
tv92 = -12						; size = 4
tv89 = -8						; size = 4
tv86 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
??HOgre@@YA?AVVector3@0@ABV10@0@Z PROC			; Ogre::operator+, COMDAT

; 164  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 165  : 		return Vector3(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [edx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 166  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??HOgre@@YA?AVVector3@0@ABV10@0@Z ENDP			; Ogre::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??GOgre@@YA?AVVector3@0@ABV10@0@Z
_TEXT	SEGMENT
tv92 = -12						; size = 4
tv89 = -8						; size = 4
tv86 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
??GOgre@@YA?AVVector3@0@ABV10@0@Z PROC			; Ogre::operator-, COMDAT

; 174  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 175  : 		return Vector3(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _v2$[ebp]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _v2$[ebp]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _v2$[ebp]
	fsub	DWORD PTR [edx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 176  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??GOgre@@YA?AVVector3@0@ABV10@0@Z ENDP			; Ogre::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??DOgre@@YA?AVVector3@0@ABV10@M@Z
_TEXT	SEGMENT
tv87 = -12						; size = 4
tv85 = -8						; size = 4
tv83 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_s$ = 16						; size = 4
??DOgre@@YA?AVVector3@0@ABV10@M@Z PROC			; Ogre::operator*, COMDAT

; 189  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 190  : 		return Vector3(v1.x*s, v1.y*s, v1.z*s);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv83[ebp]
	fld	DWORD PTR tv83[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv85[ebp]
	fld	DWORD PTR tv85[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv87[ebp]
	fld	DWORD PTR tv87[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 191  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??DOgre@@YA?AVVector3@0@ABV10@M@Z ENDP			; Ogre::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??KOgre@@YA?AVVector3@0@ABV10@M@Z
_TEXT	SEGMENT
tv87 = -12						; size = 4
tv85 = -8						; size = 4
tv83 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_s$ = 16						; size = 4
??KOgre@@YA?AVVector3@0@ABV10@M@Z PROC			; Ogre::operator/, COMDAT

; 199  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 200  : 		return Vector3(v1.x/s, v1.y/s, v1.z/s);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	fdiv	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv83[ebp]
	fld	DWORD PTR tv83[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx+4]
	fdiv	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv85[ebp]
	fld	DWORD PTR tv85[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx]
	fdiv	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv87[ebp]
	fld	DWORD PTR tv87[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 201  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??KOgre@@YA?AVVector3@0@ABV10@M@Z ENDP			; Ogre::operator/
_TEXT	ENDS
PUBLIC	_fabsf
PUBLIC	?segmentSide@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@0M@Z ; Ogre::Plane::segmentSide
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreplane.h
;	COMDAT ?segmentSide@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@0M@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_dFm$ = -8						; size = 4
_dTo$ = -4						; size = 4
_fm$ = 8						; size = 4
_to$ = 12						; size = 4
_radius$ = 16						; size = 4
?segmentSide@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@0M@Z PROC ; Ogre::Plane::segmentSide, COMDAT
; _this$ = ecx

; 223  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 			assert(isValid());
; 225  : 
; 226  : 			const float dFm = distanceToPoint(fm);

	mov	eax, DWORD PTR _fm$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ; Ogre::Plane::distanceToPoint
	fstp	DWORD PTR _dFm$[ebp]

; 227  : 			const float dTo = distanceToPoint(to);

	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ; Ogre::Plane::distanceToPoint
	fstp	DWORD PTR _dTo$[ebp]

; 228  : 
; 229  : 			if ( fabsf(dFm) <= EPSILON && fabsf(dTo) <= EPSILON )

	push	ecx
	fld	DWORD PTR _dFm$[ebp]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fld	DWORD PTR _EPSILON
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN6@segmentSid
	push	ecx
	fld	DWORD PTR _dTo$[ebp]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fld	DWORD PTR _EPSILON
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN6@segmentSid

; 230  : 			{
; 231  : 				return ON;

	mov	eax, 3
	jmp	SHORT $LN1@segmentSid
	jmp	SHORT $LN1@segmentSid
$LN6@segmentSid:

; 232  : 			}
; 233  : 			else if ( dFm < -radius && dTo < -radius )

	fld	DWORD PTR _radius$[ebp]
	fchs
	fld	DWORD PTR _dFm$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@segmentSid
	fld	DWORD PTR _radius$[ebp]
	fchs
	fld	DWORD PTR _dTo$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@segmentSid

; 234  : 			{
; 235  : 				return BACK;

	mov	eax, 1
	jmp	SHORT $LN1@segmentSid
	jmp	SHORT $LN1@segmentSid
$LN4@segmentSid:

; 236  : 			}
; 237  : 			else if ( dFm >  radius && dTo >  radius )

	fld	DWORD PTR _dFm$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@segmentSid
	fld	DWORD PTR _dTo$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@segmentSid

; 238  : 			{
; 239  : 				return FRONT;

	xor	eax, eax
	jmp	SHORT $LN1@segmentSid

; 240  : 			}
; 241  : 			else

	jmp	SHORT $LN1@segmentSid
$LN2@segmentSid:

; 242  : 			{
; 243  : 				return INTERSECT;

	mov	eax, 2
$LN1@segmentSid:

; 244  : 			}
; 245  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?segmentSide@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@0M@Z ENDP ; Ogre::Plane::segmentSide
_TEXT	ENDS
EXTRN	_fabs:PROC
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 384  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
PUBLIC	?getVec4@Plane@Ogre@@QBEABVVector4@2@XZ		; Ogre::Plane::getVec4
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreplane.h
;	COMDAT ?getVec4@Plane@Ogre@@QBEABVVector4@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getVec4@Plane@Ogre@@QBEABVVector4@2@XZ PROC		; Ogre::Plane::getVec4, COMDAT
; _this$ = ecx

; 251  : 		{ return *((Vector4 *)&m_normal); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?getVec4@Plane@Ogre@@QBEABVVector4@2@XZ ENDP		; Ogre::Plane::getVec4
_TEXT	ENDS
PUBLIC	?getNormal@Plane@Ogre@@QBEABVVector3@2@XZ	; Ogre::Plane::getNormal
; Function compile flags: /Odtp
;	COMDAT ?getNormal@Plane@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNormal@Plane@Ogre@@QBEABVVector3@2@XZ PROC		; Ogre::Plane::getNormal, COMDAT
; _this$ = ecx

; 254  : 		{ return m_normal; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?getNormal@Plane@Ogre@@QBEABVVector3@2@XZ ENDP		; Ogre::Plane::getNormal
_TEXT	ENDS
PUBLIC	?getOffset@Plane@Ogre@@QBE?BMXZ			; Ogre::Plane::getOffset
; Function compile flags: /Odtp
;	COMDAT ?getOffset@Plane@Ogre@@QBE?BMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getOffset@Plane@Ogre@@QBE?BMXZ PROC			; Ogre::Plane::getOffset, COMDAT
; _this$ = ecx

; 257  : 		{ return(m_offset); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?getOffset@Plane@Ogre@@QBE?BMXZ ENDP			; Ogre::Plane::getOffset
_TEXT	ENDS
PUBLIC	??0Plane@Ogre@@QAE@ABV01@@Z			; Ogre::Plane::Plane
; Function compile flags: /Odtp
;	COMDAT ??0Plane@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Plane@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Plane::Plane, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Plane@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Plane::Plane
_TEXT	ENDS
PUBLIC	??4Plane@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Plane::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Plane@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Plane@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Plane::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Plane@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Plane::operator=
_TEXT	ENDS
PUBLIC	??0WorldPlane@Ogre@@QAE@XZ			; Ogre::WorldPlane::WorldPlane
; Function compile flags: /Odtp
;	COMDAT ??0WorldPlane@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0WorldPlane@Ogre@@QAE@XZ PROC				; Ogre::WorldPlane::WorldPlane, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0WorldPos@Ogre@@QAE@XZ		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0WorldPlane@Ogre@@QAE@XZ ENDP				; Ogre::WorldPlane::WorldPlane
_TEXT	ENDS
PUBLIC	??0WorldPlane@Ogre@@QAE@ABV01@@Z		; Ogre::WorldPlane::WorldPlane
; Function compile flags: /Odtp
;	COMDAT ??0WorldPlane@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0WorldPlane@Ogre@@QAE@ABV01@@Z PROC			; Ogre::WorldPlane::WorldPlane, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0WorldPlane@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::WorldPlane::WorldPlane
_TEXT	ENDS
PUBLIC	??4WorldPlane@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::WorldPlane::operator=
; Function compile flags: /Odtp
;	COMDAT ??4WorldPlane@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4WorldPlane@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::WorldPlane::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4WorldPlane@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::WorldPlane::operator=
_TEXT	ENDS
PUBLIC	??0BoxBound@Ogre@@QAE@XZ			; Ogre::BoxBound::BoxBound
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebounding.h
;	COMDAT ??0BoxBound@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BoxBound@Ogre@@QAE@XZ PROC				; Ogre::BoxBound::BoxBound, COMDAT
; _this$ = ecx

; 14   : 		BoxBound() : m_isValid(false){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BoxBound@Ogre@@QAE@XZ ENDP				; Ogre::BoxBound::BoxBound
_TEXT	ENDS
PUBLIC	??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z		; Ogre::BoxBound::BoxBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_minpos$ = 8						; size = 4
_maxpos$ = 12						; size = 4
??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z PROC		; Ogre::BoxBound::BoxBound, COMDAT
; _this$ = ecx

; 15   : 		BoxBound(const Vector3 &minpos, const Vector3 &maxpos) : m_MinPos(minpos), m_MaxPos(maxpos), m_isValid(true){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _minpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _maxpos$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+24], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z ENDP		; Ogre::BoxBound::BoxBound
_TEXT	ENDS
PUBLIC	??0BoxBound@Ogre@@QAE@ABV01@@Z			; Ogre::BoxBound::BoxBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxBound@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??0BoxBound@Ogre@@QAE@ABV01@@Z PROC			; Ogre::BoxBound::BoxBound, COMDAT
; _this$ = ecx

; 16   : 		BoxBound(const BoxBound &rhs) : m_MinPos(rhs.m_MinPos), m_MaxPos(rhs.m_MaxPos), m_isValid(rhs.m_isValid){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _rhs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _rhs$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rhs$[ebp]
	mov	cl, BYTE PTR [eax+24]
	mov	BYTE PTR [edx+24], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BoxBound@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::BoxBound::BoxBound
_TEXT	ENDS
PUBLIC	??$Max@M@Ogre@@YAMABM0@Z			; Ogre::Max<float>
PUBLIC	??$Min@M@Ogre@@YAMABM0@Z			; Ogre::Min<float>
PUBLIC	??YBoxBound@Ogre@@QAEAAV01@ABVVector3@1@@Z	; Ogre::BoxBound::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YBoxBound@Ogre@@QAEAAV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Other$ = 8						; size = 4
??YBoxBound@Ogre@@QAEAAV01@ABVVector3@1@@Z PROC		; Ogre::BoxBound::operator+=, COMDAT
; _this$ = ecx

; 19   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 			if( m_isValid )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	test	ecx, ecx
	je	$LN2@operator@4

; 21   : 			{
; 22   : #if ASM_x86
; 23   : 				__asm
; 24   : 				{
; 25   : 						mov		eax,[Other]
; 26   : 						mov		ecx,[this]
; 27   : 
; 28   : 						movss	xmm3,[eax]Vector3.x
; 29   : 						movss	xmm4,[eax]Vector3.y
; 30   : 						movss	xmm5,[eax]Vector3.z
; 31   : 
; 32   : 						movss	xmm0,[ecx]BoxBound.m_MinPos.x
; 33   : 						movss	xmm1,[ecx]BoxBound.m_MinPos.y
; 34   : 						movss	xmm2,[ecx]BoxBound.m_MinPos.z
; 35   : 						minss	xmm0,xmm3
; 36   : 						minss	xmm1,xmm4
; 37   : 						minss	xmm2,xmm5
; 38   : 						movss	[ecx]BoxBound.m_MinPos.x,xmm0
; 39   : 						movss	[ecx]BoxBound.m_MinPos.y,xmm1
; 40   : 						movss	[ecx]BoxBound.m_MinPos.z,xmm2
; 41   : 
; 42   : 						movss	xmm0,[ecx]BoxBound.m_MaxPos.x
; 43   : 						movss	xmm1,[ecx]BoxBound.m_MaxPos.y
; 44   : 						movss	xmm2,[ecx]BoxBound.m_MaxPos.z
; 45   : 						maxss	xmm0,xmm3
; 46   : 						maxss	xmm1,xmm4
; 47   : 						maxss	xmm2,xmm5
; 48   : 						movss	[ecx]BoxBound.m_MaxPos.x,xmm0
; 49   : 						movss	[ecx]BoxBound.m_MaxPos.y,xmm1
; 50   : 						movss	[ecx]BoxBound.m_MaxPos.z,xmm2
; 51   : 				}
; 52   : #else
; 53   : 				m_MinPos.x = Min( m_MinPos.x, Other.x );

	mov	edx, DWORD PTR _Other$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 54   : 				m_MinPos.y = Min( m_MinPos.y, Other.y );

	mov	edx, DWORD PTR _Other$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+4]

; 55   : 				m_MinPos.z = Min( m_MinPos.z, Other.z );

	mov	edx, DWORD PTR _Other$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+8]

; 56   : 
; 57   : 				m_MaxPos.x = Max( m_MaxPos.x, Other.x );

	mov	edx, DWORD PTR _Other$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 58   : 				m_MaxPos.y = Max( m_MaxPos.y, Other.y );

	mov	edx, DWORD PTR _Other$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+16]

; 59   : 				m_MaxPos.z = Max( m_MaxPos.z, Other.z );

	mov	edx, DWORD PTR _Other$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+20]

; 60   : #endif
; 61   : 			}
; 62   : 			else

	jmp	SHORT $LN1@operator@4
$LN2@operator@4:

; 63   : 			{
; 64   : 				m_MinPos = m_MaxPos = Other;

	mov	edx, DWORD PTR _Other$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 65   : 				m_isValid = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 1
$LN1@operator@4:

; 66   : 			}
; 67   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 68   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YBoxBound@Ogre@@QAEAAV01@ABVVector3@1@@Z ENDP		; Ogre::BoxBound::operator+=
_TEXT	ENDS
PUBLIC	??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::BoxBound::operator=
PUBLIC	??YBoxBound@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::BoxBound::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YBoxBound@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Other$ = 8						; size = 4
??YBoxBound@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BoxBound::operator+=, COMDAT
; _this$ = ecx

; 71   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 			if( m_isValid && Other.m_isValid )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	test	ecx, ecx
	je	$LN3@operator@5
	mov	edx, DWORD PTR _Other$[ebp]
	movzx	eax, BYTE PTR [edx+24]
	test	eax, eax
	je	$LN3@operator@5

; 73   : 			{
; 74   : #if ASM_X86
; 75   : 				__asm
; 76   : 				{
; 77   : 						mov		eax,[Other]
; 78   : 						mov		ecx,[this]
; 79   : 
; 80   : 						movss	xmm0,[ecx]BoxBound.m_MinPos.x
; 81   : 						movss	xmm1,[ecx]BoxBound.m_MinPos.y
; 82   : 						movss	xmm2,[ecx]BoxBound.m_MinPos.z
; 83   : 						minss	xmm0,[eax]BoxBound.m_MinPos.x
; 84   : 						minss	xmm1,[eax]BoxBound.m_MinPos.y
; 85   : 						minss	xmm2,[eax]BoxBound.m_MinPos.z
; 86   : 						movss	[ecx]BoxBound.m_MinPos.x,xmm0
; 87   : 						movss	[ecx]BoxBound.m_MinPos.y,xmm1
; 88   : 						movss	[ecx]BoxBound.m_MinPos.z,xmm2
; 89   : 
; 90   : 						movss	xmm0,[ecx]BoxBound.m_MaxPos.x
; 91   : 						movss	xmm1,[ecx]BoxBound.m_MaxPos.y
; 92   : 						movss	xmm2,[ecx]BoxBound.m_MaxPos.z
; 93   : 						maxss	xmm0,[eax]BoxBound.m_MaxPos.x
; 94   : 						maxss	xmm1,[eax]BoxBound.m_MaxPos.y
; 95   : 						maxss	xmm2,[eax]BoxBound.m_MaxPos.z
; 96   : 						movss	[ecx]BoxBound.m_MaxPos.x,xmm0
; 97   : 						movss	[ecx]BoxBound.m_MaxPos.y,xmm1
; 98   : 						movss	[ecx]BoxBound.m_MaxPos.z,xmm2
; 99   : 				}
; 100  : #else
; 101  : 				m_MinPos.x = Min( m_MinPos.x, Other.m_MinPos.x );

	mov	ecx, DWORD PTR _Other$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax]

; 102  : 				m_MinPos.y = Min( m_MinPos.y, Other.m_MinPos.y );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 103  : 				m_MinPos.z = Min( m_MinPos.z, Other.m_MinPos.z );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+8]

; 104  : 
; 105  : 				m_MaxPos.x = Max( m_MaxPos.x, Other.m_MaxPos.x );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+12]

; 106  : 				m_MaxPos.y = Max( m_MaxPos.y, Other.m_MaxPos.y );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+16]

; 107  : 				m_MaxPos.z = Max( m_MaxPos.z, Other.m_MaxPos.z );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+20]
	jmp	SHORT $LN1@operator@5
$LN3@operator@5:

; 108  : #endif
; 109  : 			}
; 110  : 			else if( Other.m_isValid )

	mov	ecx, DWORD PTR _Other$[ebp]
	movzx	edx, BYTE PTR [ecx+24]
	test	edx, edx
	je	SHORT $LN1@operator@5

; 111  : 			{
; 112  : 				*this = Other;

	mov	eax, DWORD PTR _Other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z
$LN1@operator@5:

; 113  : 			}
; 114  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 115  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YBoxBound@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BoxBound::operator+=
_TEXT	ENDS
PUBLIC	?setRange@BoxBound@Ogre@@QAEXABVVector3@2@0@Z	; Ogre::BoxBound::setRange
; Function compile flags: /Odtp
;	COMDAT ?setRange@BoxBound@Ogre@@QAEXABVVector3@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_minpt$ = 8						; size = 4
_maxpt$ = 12						; size = 4
?setRange@BoxBound@Ogre@@QAEXABVVector3@2@0@Z PROC	; Ogre::BoxBound::setRange, COMDAT
; _this$ = ecx

; 118  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 119  : 			m_MinPos = minpt;

	mov	eax, DWORD PTR _minpt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 120  : 			m_MaxPos = maxpt;

	mov	ecx, DWORD PTR _maxpt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 121  : 			m_isValid = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+24], 1

; 122  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setRange@BoxBound@Ogre@@QAEXABVVector3@2@0@Z ENDP	; Ogre::BoxBound::setRange
_TEXT	ENDS
PUBLIC	?setCenterExtension@BoxBound@Ogre@@QAEXABVVector3@2@0@Z ; Ogre::BoxBound::setCenterExtension
; Function compile flags: /Odtp
;	COMDAT ?setCenterExtension@BoxBound@Ogre@@QAEXABVVector3@2@0@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T129922 = -24						; size = 12
$T129921 = -12						; size = 12
_center$ = 8						; size = 4
_exten$ = 12						; size = 4
?setCenterExtension@BoxBound@Ogre@@QAEXABVVector3@2@0@Z PROC ; Ogre::BoxBound::setCenterExtension, COMDAT
; _this$ = ecx

; 125  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 126  : 			m_MinPos = center-exten;

	mov	eax, DWORD PTR _exten$[ebp]
	push	eax
	mov	ecx, DWORD PTR _center$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T129921[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 127  : 			m_MaxPos = center+exten;

	mov	eax, DWORD PTR _exten$[ebp]
	push	eax
	mov	ecx, DWORD PTR _center$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T129922[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 128  : 			m_isValid = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 1

; 129  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setCenterExtension@BoxBound@Ogre@@QAEXABVVector3@2@0@Z ENDP ; Ogre::BoxBound::setCenterExtension
_TEXT	ENDS
PUBLIC	?expandBy@BoxBound@Ogre@@QBE?AV12@M@Z		; Ogre::BoxBound::expandBy
; Function compile flags: /Odtp
;	COMDAT ?expandBy@BoxBound@Ogre@@QBE?AV12@M@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T129928 = -48						; size = 12
$T129927 = -36						; size = 12
$T129926 = -24						; size = 12
$T129925 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_w$ = 12						; size = 4
?expandBy@BoxBound@Ogre@@QBE?AV12@M@Z PROC		; Ogre::BoxBound::expandBy, COMDAT
; _this$ = ecx

; 134  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 135  : 			return BoxBound( m_MinPos - Vector3(w,w,w), m_MaxPos + Vector3(w,w,w) );

	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T129925[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T129926[ebp]
	push	ecx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T129927[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR $T129928[ebp]
	push	eax
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z	; Ogre::BoxBound::BoxBound
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 136  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?expandBy@BoxBound@Ogre@@QBE?AV12@M@Z ENDP		; Ogre::BoxBound::expandBy
_TEXT	ENDS
PUBLIC	__real@3f000000
PUBLIC	?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ	; Ogre::BoxBound::getCenter
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T129931 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::BoxBound::getCenter, COMDAT
; _this$ = ecx

; 144  : 		Vector3 getCenter() const{ return (m_MinPos + m_MaxPos)*0.5f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fld	DWORD PTR __real@3f000000
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T129931[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??DOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::BoxBound::getCenter
_TEXT	ENDS
PUBLIC	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ	; Ogre::BoxBound::getExtension
; Function compile flags: /Odtp
;	COMDAT ?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T129936 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::BoxBound::getExtension, COMDAT
; _this$ = ecx

; 145  : 		Vector3 getExtension() const{ return (m_MaxPos - m_MinPos)*0.5f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fld	DWORD PTR __real@3f000000
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	lea	edx, DWORD PTR $T129936[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??DOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::BoxBound::getExtension
_TEXT	ENDS
PUBLIC	?getMinPos@BoxBound@Ogre@@QBEABVVector3@2@XZ	; Ogre::BoxBound::getMinPos
; Function compile flags: /Odtp
;	COMDAT ?getMinPos@BoxBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMinPos@BoxBound@Ogre@@QBEABVVector3@2@XZ PROC	; Ogre::BoxBound::getMinPos, COMDAT
; _this$ = ecx

; 146  : 		const Vector3 &getMinPos() const{ return m_MinPos; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?getMinPos@BoxBound@Ogre@@QBEABVVector3@2@XZ ENDP	; Ogre::BoxBound::getMinPos
_TEXT	ENDS
PUBLIC	?getMaxPos@BoxBound@Ogre@@QBEABVVector3@2@XZ	; Ogre::BoxBound::getMaxPos
; Function compile flags: /Odtp
;	COMDAT ?getMaxPos@BoxBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMaxPos@BoxBound@Ogre@@QBEABVVector3@2@XZ PROC	; Ogre::BoxBound::getMaxPos, COMDAT
; _this$ = ecx

; 147  : 		const Vector3 &getMaxPos() const{ return m_MaxPos; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	0
?getMaxPos@BoxBound@Ogre@@QBEABVVector3@2@XZ ENDP	; Ogre::BoxBound::getMaxPos
_TEXT	ENDS
PUBLIC	??$Abs@M@Ogre@@YAMABM@Z				; Ogre::Abs<float>
PUBLIC	?getRadiusInDirection@BoxBound@Ogre@@QBEMABVVector3@2@@Z ; Ogre::BoxBound::getRadiusInDirection
; Function compile flags: /Odtp
;	COMDAT ?getRadiusInDirection@BoxBound@Ogre@@QBEMABVVector3@2@@Z
_TEXT	SEGMENT
tv143 = -48						; size = 4
tv148 = -44						; size = 8
tv146 = -36						; size = 8
_this$ = -28						; size = 4
$T129945 = -24						; size = 4
$T129944 = -20						; size = 4
$T129943 = -16						; size = 4
_extent$ = -12						; size = 12
_dir$ = 8						; size = 4
?getRadiusInDirection@BoxBound@Ogre@@QBEMABVVector3@2@@Z PROC ; Ogre::BoxBound::getRadiusInDirection, COMDAT
; _this$ = ecx

; 150  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 151  : 			Vector3 extent = getExtension();

	lea	eax, DWORD PTR _extent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getExtension

; 152  : 			return Abs(dir.x*extent.x) + Abs(dir.y*extent.y) + Abs(dir.z*extent.z);

	mov	ecx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR _extent$[ebp]
	fstp	DWORD PTR $T129943[ebp]
	mov	edx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _extent$[ebp+4]
	fstp	DWORD PTR $T129944[ebp]
	mov	eax, DWORD PTR _dir$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR _extent$[ebp+8]
	fstp	DWORD PTR $T129945[ebp]
	lea	ecx, DWORD PTR $T129943[ebp]
	push	ecx
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	add	esp, 4
	lea	edx, DWORD PTR $T129944[ebp]
	push	edx
	fstp	QWORD PTR tv146[ebp]
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	add	esp, 4
	fadd	QWORD PTR tv146[ebp]
	lea	eax, DWORD PTR $T129945[ebp]
	push	eax
	fstp	QWORD PTR tv148[ebp]
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	add	esp, 4
	fadd	QWORD PTR tv148[ebp]
	fstp	DWORD PTR tv143[ebp]
	fld	DWORD PTR tv143[ebp]

; 153  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getRadiusInDirection@BoxBound@Ogre@@QBEMABVVector3@2@@Z ENDP ; Ogre::BoxBound::getRadiusInDirection
_TEXT	ENDS
PUBLIC	?isPointIn@BoxBound@Ogre@@QBE_NABVVector3@2@@Z	; Ogre::BoxBound::isPointIn
; Function compile flags: /Odtp
;	COMDAT ?isPointIn@BoxBound@Ogre@@QBE_NABVVector3@2@@Z
_TEXT	SEGMENT
tv94 = -8						; size = 4
_this$ = -4						; size = 4
_vPos$ = 8						; size = 4
?isPointIn@BoxBound@Ogre@@QBE_NABVVector3@2@@Z PROC	; Ogre::BoxBound::isPointIn, COMDAT
; _this$ = ecx

; 156  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 			return (vPos.x>m_MinPos.x && vPos.x<m_MaxPos.x 
; 158  : 				    &&vPos.y>m_MinPos.y && vPos.y<m_MaxPos.y
; 159  : 					&&vPos.z>m_MinPos.z && vPos.z<m_MaxPos.z );

	mov	eax, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointIn
	mov	edx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointIn
	mov	ecx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointIn
	mov	eax, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+16]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointIn
	mov	edx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointIn
	mov	ecx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointIn
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN4@isPointIn
$LN3@isPointIn:
	mov	DWORD PTR tv94[ebp], 0
$LN4@isPointIn:
	mov	al, BYTE PTR tv94[ebp]

; 160  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isPointIn@BoxBound@Ogre@@QBE_NABVVector3@2@@Z ENDP	; Ogre::BoxBound::isPointIn
_TEXT	ENDS
PUBLIC	?isPointInXZ@BoxBound@Ogre@@QBE_NABVVector3@2@@Z ; Ogre::BoxBound::isPointInXZ
; Function compile flags: /Odtp
;	COMDAT ?isPointInXZ@BoxBound@Ogre@@QBE_NABVVector3@2@@Z
_TEXT	SEGMENT
tv83 = -8						; size = 4
_this$ = -4						; size = 4
_vPos$ = 8						; size = 4
?isPointInXZ@BoxBound@Ogre@@QBE_NABVVector3@2@@Z PROC	; Ogre::BoxBound::isPointInXZ, COMDAT
; _this$ = ecx

; 163  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 			return (vPos.x>m_MinPos.x && vPos.x<m_MaxPos.x 
; 165  : 				&&vPos.z>m_MinPos.z && vPos.z<m_MaxPos.z );

	mov	eax, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointInX
	mov	edx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointInX
	mov	ecx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointInX
	mov	eax, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointInX
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN4@isPointInX
$LN3@isPointInX:
	mov	DWORD PTR tv83[ebp], 0
$LN4@isPointInX:
	mov	al, BYTE PTR tv83[ebp]

; 166  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isPointInXZ@BoxBound@Ogre@@QBE_NABVVector3@2@@Z ENDP	; Ogre::BoxBound::isPointInXZ
_TEXT	ENDS
PUBLIC	?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z	; Ogre::BoxBound::intersectBoxBound
; Function compile flags: /Odtp
;	COMDAT ?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z PROC	; Ogre::BoxBound::intersectBoxBound, COMDAT
; _this$ = ecx

; 169  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 			if( m_MinPos.x > other.m_MaxPos.x || other.m_MinPos.x > m_MaxPos.x )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _other$[ebp]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN5@intersectB
	mov	edx, DWORD PTR _other$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@intersectB
$LN5@intersectB:

; 171  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@intersectB
$LN6@intersectB:

; 172  : 			if( m_MinPos.y > other.m_MaxPos.y || other.m_MinPos.y > m_MaxPos.y )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _other$[ebp]
	fld	DWORD PTR [edx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN3@intersectB
	mov	eax, DWORD PTR _other$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@intersectB
$LN3@intersectB:

; 173  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@intersectB
$LN4@intersectB:

; 174  : 			if( m_MinPos.z > other.m_MaxPos.z || other.m_MinPos.z > m_MaxPos.z )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _other$[ebp]
	fld	DWORD PTR [eax+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@intersectB
	mov	ecx, DWORD PTR _other$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@intersectB
$LN1@intersectB:

; 175  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@intersectB
$LN2@intersectB:

; 176  : 			return true;

	mov	al, 1
$LN7@intersectB:

; 177  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z ENDP	; Ogre::BoxBound::intersectBoxBound
_TEXT	ENDS
PUBLIC	?isBoxBoundIn@BoxBound@Ogre@@QAE_NABV12@@Z	; Ogre::BoxBound::isBoxBoundIn
; Function compile flags: /Odtp
;	COMDAT ?isBoxBoundIn@BoxBound@Ogre@@QAE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_box$ = 8						; size = 4
?isBoxBoundIn@BoxBound@Ogre@@QAE_NABV12@@Z PROC		; Ogre::BoxBound::isBoxBoundIn, COMDAT
; _this$ = ecx

; 181  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 182  : 			if( box.m_MaxPos.x > m_MaxPos.x ||
; 183  : 				box.m_MinPos.x < m_MinPos.x )

	mov	eax, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN5@isBoxBound
	mov	edx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN6@isBoxBound
$LN5@isBoxBound:

; 184  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@isBoxBound
$LN6@isBoxBound:

; 185  : 			if( box.m_MaxPos.y > m_MaxPos.y ||
; 186  : 				box.m_MinPos.y < m_MinPos.y )

	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN3@isBoxBound
	mov	eax, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@isBoxBound
$LN3@isBoxBound:

; 187  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@isBoxBound
$LN4@isBoxBound:

; 188  : 			if( box.m_MaxPos.z > m_MaxPos.z ||
; 189  : 				box.m_MinPos.z < m_MinPos.z )

	mov	edx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@isBoxBound
	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@isBoxBound
$LN1@isBoxBound:

; 190  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@isBoxBound
$LN2@isBoxBound:

; 191  : 
; 192  : 			return true;

	mov	al, 1
$LN7@isBoxBound:

; 193  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isBoxBoundIn@BoxBound@Ogre@@QAE_NABV12@@Z ENDP		; Ogre::BoxBound::isBoxBoundIn
_TEXT	ENDS
PUBLIC	?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z		; Ogre::Abs
PUBLIC	?isBoxBoundOut@BoxBound@Ogre@@QBE_NABV12@@Z	; Ogre::BoxBound::isBoxBoundOut
; Function compile flags: /Odtp
;	COMDAT ?isBoxBoundOut@BoxBound@Ogre@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T129964 = -84						; size = 12
$T129963 = -72						; size = 12
$T129962 = -60						; size = 12
$T129961 = -48						; size = 12
$T129960 = -36						; size = 12
_vRadius$ = -24						; size = 12
_vDis$ = -12						; size = 12
_box$ = 8						; size = 4
?isBoxBoundOut@BoxBound@Ogre@@QBE_NABV12@@Z PROC	; Ogre::BoxBound::isBoxBoundOut, COMDAT
; _this$ = ecx

; 197  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 			Vector3 vDis = Abs(box.getCenter() - getCenter());

	lea	eax, DWORD PTR $T129960[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getCenter
	push	eax
	lea	ecx, DWORD PTR $T129961[ebp]
	push	ecx
	mov	ecx, DWORD PTR _box$[ebp]
	call	?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getCenter
	push	eax
	lea	edx, DWORD PTR $T129962[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR _vDis$[ebp]
	push	eax
	call	?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z	; Ogre::Abs
	add	esp, 8

; 199  : 			Vector3 vRadius = box.getExtension() + getExtension();

	lea	ecx, DWORD PTR $T129963[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getExtension
	push	eax
	lea	edx, DWORD PTR $T129964[ebp]
	push	edx
	mov	ecx, DWORD PTR _box$[ebp]
	call	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getExtension
	push	eax
	lea	eax, DWORD PTR _vRadius$[ebp]
	push	eax
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH

; 200  : 
; 201  : 			if( vDis.x > vRadius.x || vDis.y > vRadius.y || vDis.z > vRadius.z )

	fld	DWORD PTR _vDis$[ebp]
	fld	DWORD PTR _vRadius$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@isBoxBound@2
	fld	DWORD PTR _vDis$[ebp+4]
	fld	DWORD PTR _vRadius$[ebp+4]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@isBoxBound@2
	fld	DWORD PTR _vDis$[ebp+8]
	fld	DWORD PTR _vRadius$[ebp+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@isBoxBound@2
$LN1@isBoxBound@2:

; 202  : 				return true;

	mov	al, 1
	jmp	SHORT $LN3@isBoxBound@2
$LN2@isBoxBound@2:

; 203  : 
; 204  : 			return false;

	xor	al, al
$LN3@isBoxBound@2:

; 205  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isBoxBoundOut@BoxBound@Ogre@@QBE_NABV12@@Z ENDP	; Ogre::BoxBound::isBoxBoundOut
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
_TEXT	ENDS
;	COMDAT ?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z PROC			; Ogre::Abs, COMDAT

; 204  : 	{

	push	ebp
	mov	ebp, esp

; 205  : 		return Vector3( Abs(v.x), Abs(v.y), Abs(v.z) );

	mov	eax, DWORD PTR _v$[ebp]
	add	eax, 8
	push	eax
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 4
	push	ecx
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v$[ebp]
	push	edx
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 206  : 	}

	pop	ebp
	ret	0
?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z ENDP			; Ogre::Abs
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BoxBound::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+24]
	mov	BYTE PTR [edx+24], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BoxBound::operator=
_TEXT	ENDS
PUBLIC	??0SphereBound@Ogre@@QAE@XZ			; Ogre::SphereBound::SphereBound
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebounding.h
;	COMDAT ??0SphereBound@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SphereBound@Ogre@@QAE@XZ PROC			; Ogre::SphereBound::SphereBound, COMDAT
; _this$ = ecx

; 221  : 		SphereBound(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0SphereBound@Ogre@@QAE@XZ ENDP			; Ogre::SphereBound::SphereBound
_TEXT	ENDS
PUBLIC	?getCenter@SphereBound@Ogre@@QBEABVVector3@2@XZ	; Ogre::SphereBound::getCenter
; Function compile flags: /Odtp
;	COMDAT ?getCenter@SphereBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCenter@SphereBound@Ogre@@QBEABVVector3@2@XZ PROC	; Ogre::SphereBound::getCenter, COMDAT
; _this$ = ecx

; 229  : 		const Vector3 &getCenter() const{ return m_Center; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?getCenter@SphereBound@Ogre@@QBEABVVector3@2@XZ ENDP	; Ogre::SphereBound::getCenter
_TEXT	ENDS
PUBLIC	?getRadius@SphereBound@Ogre@@QBEMXZ		; Ogre::SphereBound::getRadius
; Function compile flags: /Odtp
;	COMDAT ?getRadius@SphereBound@Ogre@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRadius@SphereBound@Ogre@@QBEMXZ PROC		; Ogre::SphereBound::getRadius, COMDAT
; _this$ = ecx

; 230  : 		float   getRadius() const{ return m_Radius; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?getRadius@SphereBound@Ogre@@QBEMXZ ENDP		; Ogre::SphereBound::getRadius
_TEXT	ENDS
PUBLIC	?isPointIn@SphereBound@Ogre@@QBE_NABVVector3@2@@Z ; Ogre::SphereBound::isPointIn
; Function compile flags: /Odtp
;	COMDAT ?isPointIn@SphereBound@Ogre@@QBE_NABVVector3@2@@Z
_TEXT	SEGMENT
tv79 = -24						; size = 4
tv89 = -20						; size = 4
_this$ = -16						; size = 4
$T129977 = -12						; size = 12
_vPos$ = 8						; size = 4
?isPointIn@SphereBound@Ogre@@QBE_NABVVector3@2@@Z PROC	; Ogre::SphereBound::isPointIn, COMDAT
; _this$ = ecx

; 233  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 			return ( (vPos - m_Center).lengthSqr() < m_Radius * m_Radius );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vPos$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T129977[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	?lengthSqr@Vector3@Ogre@@QBEMXZ		; Ogre::Vector3::lengthSqr
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+12]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointIn@2
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN4@isPointIn@2
$LN3@isPointIn@2:
	mov	DWORD PTR tv79[ebp], 0
$LN4@isPointIn@2:
	mov	al, BYTE PTR tv79[ebp]

; 235  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isPointIn@SphereBound@Ogre@@QBE_NABVVector3@2@@Z ENDP	; Ogre::SphereBound::isPointIn
_TEXT	ENDS
PUBLIC	??0SphereBound@Ogre@@QAE@ABV01@@Z		; Ogre::SphereBound::SphereBound
; Function compile flags: /Odtp
;	COMDAT ??0SphereBound@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0SphereBound@Ogre@@QAE@ABV01@@Z PROC			; Ogre::SphereBound::SphereBound, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0SphereBound@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::SphereBound::SphereBound
_TEXT	ENDS
PUBLIC	??4SphereBound@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::SphereBound::operator=
; Function compile flags: /Odtp
;	COMDAT ??4SphereBound@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4SphereBound@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::SphereBound::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4SphereBound@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::SphereBound::operator=
_TEXT	ENDS
PUBLIC	??0BoxSphereBound@Ogre@@QAE@XZ			; Ogre::BoxSphereBound::BoxSphereBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxSphereBound@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BoxSphereBound@Ogre@@QAE@XZ PROC			; Ogre::BoxSphereBound::BoxSphereBound, COMDAT
; _this$ = ecx

; 252  : 		BoxSphereBound()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3

; 253  : 		{
; 254  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BoxSphereBound@Ogre@@QAE@XZ ENDP			; Ogre::BoxSphereBound::BoxSphereBound
_TEXT	ENDS
PUBLIC	?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z ; Ogre::BoxSphereBound::fromBoxBound
PUBLIC	??0BoxSphereBound@Ogre@@QAE@ABVBoxBound@1@@Z	; Ogre::BoxSphereBound::BoxSphereBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxSphereBound@Ogre@@QAE@ABVBoxBound@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_box$ = 8						; size = 4
??0BoxSphereBound@Ogre@@QAE@ABVBoxBound@1@@Z PROC	; Ogre::BoxSphereBound::BoxSphereBound, COMDAT
; _this$ = ecx

; 256  : 		BoxSphereBound(const BoxBound &box)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3

; 257  : 		{
; 258  : 			fromBoxBound(box);

	mov	eax, DWORD PTR _box$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z ; Ogre::BoxSphereBound::fromBoxBound

; 259  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BoxSphereBound@Ogre@@QAE@ABVBoxBound@1@@Z ENDP	; Ogre::BoxSphereBound::BoxSphereBound
_TEXT	ENDS
PUBLIC	?reset@BoxSphereBound@Ogre@@QAEXXZ		; Ogre::BoxSphereBound::reset
; Function compile flags: /Odtp
;	COMDAT ?reset@BoxSphereBound@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T129990 = -12						; size = 12
?reset@BoxSphereBound@Ogre@@QAEXXZ PROC			; Ogre::BoxSphereBound::reset, COMDAT
; _this$ = ecx

; 262  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 263  : 			m_Center = m_Extent = Vector3(0,0,0);

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T129990[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 264  : 			m_Radius = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+24]

; 265  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?reset@BoxSphereBound@Ogre@@QAEXXZ ENDP			; Ogre::BoxSphereBound::reset
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T129994 = -24						; size = 12
$T129993 = -12						; size = 12
_box$ = 8						; size = 4
?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z PROC ; Ogre::BoxSphereBound::fromBoxBound, COMDAT
; _this$ = ecx

; 268  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 269  : 			m_Center = box.getCenter();

	lea	eax, DWORD PTR $T129993[ebp]
	push	eax
	mov	ecx, DWORD PTR _box$[ebp]
	call	?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getCenter
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 270  : 			m_Extent = box.getExtension();

	lea	ecx, DWORD PTR $T129994[ebp]
	push	ecx
	mov	ecx, DWORD PTR _box$[ebp]
	call	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getExtension
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 271  : 
; 272  : 			m_Radius = m_Extent.length();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?length@Vector3@Ogre@@QBEMXZ		; Ogre::Vector3::length
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+24]

; 273  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z ENDP ; Ogre::BoxSphereBound::fromBoxBound
_TEXT	ENDS
PUBLIC	?getSphere@BoxSphereBound@Ogre@@QBE?AVSphereBound@2@XZ ; Ogre::BoxSphereBound::getSphere
; Function compile flags: /Odtp
;	COMDAT ?getSphere@BoxSphereBound@Ogre@@QBE?AVSphereBound@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_sphere$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?getSphere@BoxSphereBound@Ogre@@QBE?AVSphereBound@2@XZ PROC ; Ogre::BoxSphereBound::getSphere, COMDAT
; _this$ = ecx

; 276  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 			SphereBound sphere;

	lea	ecx, DWORD PTR _sphere$[ebp]
	call	??0SphereBound@Ogre@@QAE@XZ		; Ogre::SphereBound::SphereBound

; 278  : 			sphere.m_Center = m_Center;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sphere$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 279  : 			sphere.m_Radius = m_Radius;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+24]
	fstp	DWORD PTR _sphere$[ebp+12]

; 280  : 			return sphere;

	lea	edx, DWORD PTR _sphere$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0SphereBound@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 281  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getSphere@BoxSphereBound@Ogre@@QBE?AVSphereBound@2@XZ ENDP ; Ogre::BoxSphereBound::getSphere
_TEXT	ENDS
PUBLIC	?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ ; Ogre::BoxSphereBound::getBox
; Function compile flags: /Odtp
;	COMDAT ?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T130000 = -52						; size = 12
$T129999 = -40						; size = 12
_box$ = -28						; size = 28
___$ReturnUdt$ = 8					; size = 4
?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ PROC	; Ogre::BoxSphereBound::getBox, COMDAT
; _this$ = ecx

; 284  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 285  : 			BoxBound box;

	lea	ecx, DWORD PTR _box$[ebp]
	call	??0BoxBound@Ogre@@QAE@XZ		; Ogre::BoxBound::BoxBound

; 286  : 			box.m_MinPos = m_Center - m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T129999[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _box$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 287  : 			box.m_MaxPos = m_Center + m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T130000[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _box$[ebp+12]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 288  : 			box.m_isValid = true;

	mov	BYTE PTR _box$[ebp+24], 1

; 289  : 			return box;

	lea	eax, DWORD PTR _box$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxBound@Ogre@@QAE@ABV01@@Z		; Ogre::BoxBound::BoxBound
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 290  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ ENDP	; Ogre::BoxSphereBound::getBox
_TEXT	ENDS
PUBLIC	?getMin@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ	; Ogre::BoxSphereBound::getMin
; Function compile flags: /Odtp
;	COMDAT ?getMin@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getMin@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::BoxSphereBound::getMin, COMDAT
; _this$ = ecx

; 310  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 311  : 			return m_Center-m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 312  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getMin@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::BoxSphereBound::getMin
_TEXT	ENDS
PUBLIC	?getMax@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ	; Ogre::BoxSphereBound::getMax
; Function compile flags: /Odtp
;	COMDAT ?getMax@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getMax@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::BoxSphereBound::getMax, COMDAT
; _this$ = ecx

; 315  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 			return m_Center+m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 317  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getMax@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::BoxSphereBound::getMax
_TEXT	ENDS
PUBLIC	?getCenter@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ ; Ogre::BoxSphereBound::getCenter
; Function compile flags: /Odtp
;	COMDAT ?getCenter@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCenter@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ PROC	; Ogre::BoxSphereBound::getCenter, COMDAT
; _this$ = ecx

; 320  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 			return m_Center;

	mov	eax, DWORD PTR _this$[ebp]

; 322  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getCenter@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ ENDP	; Ogre::BoxSphereBound::getCenter
_TEXT	ENDS
PUBLIC	?getExtension@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ ; Ogre::BoxSphereBound::getExtension
; Function compile flags: /Odtp
;	COMDAT ?getExtension@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getExtension@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ PROC ; Ogre::BoxSphereBound::getExtension, COMDAT
; _this$ = ecx

; 325  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 326  : 			return m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH

; 327  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getExtension@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ ENDP ; Ogre::BoxSphereBound::getExtension
_TEXT	ENDS
PUBLIC	__real@40000000
PUBLIC	?fromBox@BoxSphereBound@Ogre@@QAEXABVVector3@2@0@Z ; Ogre::BoxSphereBound::fromBox
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?fromBox@BoxSphereBound@Ogre@@QAEXABVVector3@2@0@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T130014 = -48						; size = 12
$T130013 = -36						; size = 12
$T130012 = -24						; size = 12
$T130011 = -12						; size = 12
_minpt$ = 8						; size = 4
_maxpt$ = 12						; size = 4
?fromBox@BoxSphereBound@Ogre@@QAEXABVVector3@2@0@Z PROC	; Ogre::BoxSphereBound::fromBox, COMDAT
; _this$ = ecx

; 330  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 			m_Center = (minpt + maxpt)/2.0f;

	push	ecx
	fld	DWORD PTR __real@40000000
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _maxpt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _minpt$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T130011[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T130012[ebp]
	push	eax
	call	??KOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator/
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 332  : 			m_Extent = (maxpt - minpt)/2.0f;

	push	ecx
	fld	DWORD PTR __real@40000000
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _minpt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxpt$[ebp]
	push	edx
	lea	eax, DWORD PTR $T130013[ebp]
	push	eax
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T130014[ebp]
	push	ecx
	call	??KOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator/
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 333  : 			m_Radius = m_Extent.length();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?length@Vector3@Ogre@@QBEMXZ		; Ogre::Vector3::length
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+24]

; 334  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?fromBox@BoxSphereBound@Ogre@@QAEXABVVector3@2@0@Z ENDP	; Ogre::BoxSphereBound::fromBox
_TEXT	ENDS
PUBLIC	?intersect@BoxSphereBound@Ogre@@QBE_NABV12@@Z	; Ogre::BoxSphereBound::intersect
; Function compile flags: /Odtp
;	COMDAT ?intersect@BoxSphereBound@Ogre@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
_box1$ = -56						; size = 28
_box2$ = -28						; size = 28
_other$ = 8						; size = 4
?intersect@BoxSphereBound@Ogre@@QBE_NABV12@@Z PROC	; Ogre::BoxSphereBound::intersect, COMDAT
; _this$ = ecx

; 337  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 338  : 			BoxBound box1 = getBox();

	lea	eax, DWORD PTR _box1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ ; Ogre::BoxSphereBound::getBox

; 339  : 			BoxBound box2 = other.getBox();

	lea	ecx, DWORD PTR _box2$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _other$[ebp]
	call	?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ ; Ogre::BoxSphereBound::getBox

; 340  : 			return box1.intersectBoxBound(box2);

	lea	edx, DWORD PTR _box2$[ebp]
	push	edx
	lea	ecx, DWORD PTR _box1$[ebp]
	call	?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z ; Ogre::BoxBound::intersectBoxBound

; 341  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?intersect@BoxSphereBound@Ogre@@QBE_NABV12@@Z ENDP	; Ogre::BoxSphereBound::intersect
_TEXT	ENDS
PUBLIC	??0BoxSphereBound@Ogre@@QAE@ABV01@@Z		; Ogre::BoxSphereBound::BoxSphereBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxSphereBound@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0BoxSphereBound@Ogre@@QAE@ABV01@@Z PROC		; Ogre::BoxSphereBound::BoxSphereBound, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [eax+24]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BoxSphereBound@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::BoxSphereBound::BoxSphereBound
_TEXT	ENDS
PUBLIC	??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::BoxSphereBound::operator=
; Function compile flags: /Odtp
;	COMDAT ??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BoxSphereBound::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [eax+24]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BoxSphereBound::operator=
_TEXT	ENDS
PUBLIC	?getBounding@CullFrustum@Ogre@@QAEABVBoxSphereBound@2@XZ ; Ogre::CullFrustum::getBounding
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrecullfrustum.h
;	COMDAT ?getBounding@CullFrustum@Ogre@@QAEABVBoxSphereBound@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBounding@CullFrustum@Ogre@@QAEABVBoxSphereBound@2@XZ PROC ; Ogre::CullFrustum::getBounding, COMDAT
; _this$ = ecx

; 34   : 		const BoxSphereBound &getBounding(){ return m_Bounding; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 516				; 00000204H
	mov	esp, ebp
	pop	ebp
	ret	0
?getBounding@CullFrustum@Ogre@@QAEABVBoxSphereBound@2@XZ ENDP ; Ogre::CullFrustum::getBounding
_TEXT	ENDS
PUBLIC	??__G@YGXPAX0IHP6EPAX00@Z@Z			; `vector copy constructor iterator'
PUBLIC	??0CullFrustum@Ogre@@QAE@ABV01@@Z		; Ogre::CullFrustum::CullFrustum
; Function compile flags: /Odtp
;	COMDAT ??0CullFrustum@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0CullFrustum@Ogre@@QAE@ABV01@@Z PROC			; Ogre::CullFrustum::CullFrustum, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0Plane@Ogre@@QAE@ABV01@@Z
	push	32					; 00000020H
	push	16					; 00000010H
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??__G@YGXPAX0IHP6EPAX00@Z@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	mov	DWORD PTR [edx+512], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 516				; 00000204H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	??0BoxSphereBound@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CullFrustum@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::CullFrustum::CullFrustum
_TEXT	ENDS
PUBLIC	??4CullFrustum@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::CullFrustum::operator=
; Function compile flags: /Odtp
;	COMDAT ??4CullFrustum@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_$S1$60556 = -4						; size = 4
___that$ = 8						; size = 4
??4CullFrustum@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::CullFrustum::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S1$60556[ebp], 0
	jmp	SHORT $LN3@operator@6
$LN2@operator@6:
	mov	eax, DWORD PTR _$S1$60556[ebp]
	add	eax, 1
	mov	DWORD PTR _$S1$60556[ebp], eax
$LN3@operator@6:
	cmp	DWORD PTR _$S1$60556[ebp], 32		; 00000020H
	jae	SHORT $LN1@operator@6
	mov	ecx, DWORD PTR _$S1$60556[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR ___that$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _$S1$60556[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _this$[ebp]
	call	??4Plane@Ogre@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN2@operator@6
$LN1@operator@6:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	mov	DWORD PTR [edx+512], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 516				; 00000204H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4CullFrustum@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::CullFrustum::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??__G@YGXPAX0IHP6EPAX00@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___u$ = 12						; size = 4
___s$ = 16						; size = 4
___n$ = 20						; size = 4
___f$ = 24						; size = 4
??__G@YGXPAX0IHP6EPAX00@Z@Z PROC			; `vector copy constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
$LN2@vector@13:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector@13
	mov	ecx, DWORD PTR ___u$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	edx, DWORD PTR ___t$[ebp]
	add	edx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], edx
	mov	eax, DWORD PTR ___u$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___u$[ebp], eax
	jmp	SHORT $LN2@vector@13
$LN3@vector@13:
	pop	ebp
	ret	20					; 00000014H
??__G@YGXPAX0IHP6EPAX00@Z@Z ENDP			; `vector copy constructor iterator'
_TEXT	ENDS
PUBLIC	?setShaderLevel@SceneRenderer@Ogre@@QAEXH@Z	; Ogre::SceneRenderer::setShaderLevel
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrescenerenderer.h
;	COMDAT ?setShaderLevel@SceneRenderer@Ogre@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nShaderLevel$ = 8					; size = 4
?setShaderLevel@SceneRenderer@Ogre@@QAEXH@Z PROC	; Ogre::SceneRenderer::setShaderLevel, COMDAT
; _this$ = ecx

; 23   : 		void setShaderLevel(int nShaderLevel){m_nShaderLevel = nShaderLevel;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nShaderLevel$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?setShaderLevel@SceneRenderer@Ogre@@QAEXH@Z ENDP	; Ogre::SceneRenderer::setShaderLevel
_TEXT	ENDS
PUBLIC	?setSceneDebugger@SceneRenderer@Ogre@@QAEXPAVSceneDebugger@2@@Z ; Ogre::SceneRenderer::setSceneDebugger
; Function compile flags: /Odtp
;	COMDAT ?setSceneDebugger@SceneRenderer@Ogre@@QAEXPAVSceneDebugger@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSceneDebugger$ = 8					; size = 4
?setSceneDebugger@SceneRenderer@Ogre@@QAEXPAVSceneDebugger@2@@Z PROC ; Ogre::SceneRenderer::setSceneDebugger, COMDAT
; _this$ = ecx

; 24   : 		void setSceneDebugger(SceneDebugger* pSceneDebugger){ m_pSceneDebugger = pSceneDebugger; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pSceneDebugger$[ebp]
	mov	DWORD PTR [eax+576], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?setSceneDebugger@SceneRenderer@Ogre@@QAEXPAVSceneDebugger@2@@Z ENDP ; Ogre::SceneRenderer::setSceneDebugger
_TEXT	ENDS
PUBLIC	?setCamera@SceneRenderer@Ogre@@QAEXPAVCamera@2@@Z ; Ogre::SceneRenderer::setCamera
; Function compile flags: /Odtp
;	COMDAT ?setCamera@SceneRenderer@Ogre@@QAEXPAVCamera@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pcamera$ = 8						; size = 4
?setCamera@SceneRenderer@Ogre@@QAEXPAVCamera@2@@Z PROC	; Ogre::SceneRenderer::setCamera, COMDAT
; _this$ = ecx

; 32   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 			m_pCamera = pcamera;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pcamera$[ebp]
	mov	DWORD PTR [eax+580], ecx

; 34   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setCamera@SceneRenderer@Ogre@@QAEXPAVCamera@2@@Z ENDP	; Ogre::SceneRenderer::setCamera
_TEXT	ENDS
PUBLIC	?getCamera@SceneRenderer@Ogre@@QAEPAVCamera@2@XZ ; Ogre::SceneRenderer::getCamera
; Function compile flags: /Odtp
;	COMDAT ?getCamera@SceneRenderer@Ogre@@QAEPAVCamera@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCamera@SceneRenderer@Ogre@@QAEPAVCamera@2@XZ PROC	; Ogre::SceneRenderer::getCamera, COMDAT
; _this$ = ecx

; 37   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 			return m_pCamera;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+580]

; 39   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getCamera@SceneRenderer@Ogre@@QAEPAVCamera@2@XZ ENDP	; Ogre::SceneRenderer::getCamera
_TEXT	ENDS
PUBLIC	?setRenderTarget@SceneRenderer@Ogre@@QAEXPAVRenderTarget@2@@Z ; Ogre::SceneRenderer::setRenderTarget
; Function compile flags: /Odtp
;	COMDAT ?setRenderTarget@SceneRenderer@Ogre@@QAEXPAVRenderTarget@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ptarget$ = 8						; size = 4
?setRenderTarget@SceneRenderer@Ogre@@QAEXPAVRenderTarget@2@@Z PROC ; Ogre::SceneRenderer::setRenderTarget, COMDAT
; _this$ = ecx

; 42   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 			m_pTarget = ptarget;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ptarget$[ebp]
	mov	DWORD PTR [eax+608], ecx

; 44   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setRenderTarget@SceneRenderer@Ogre@@QAEXPAVRenderTarget@2@@Z ENDP ; Ogre::SceneRenderer::setRenderTarget
_TEXT	ENDS
PUBLIC	?setRenderScene@SceneRenderer@Ogre@@QAEXPAVGameScene@2@@Z ; Ogre::SceneRenderer::setRenderScene
; Function compile flags: /Odtp
;	COMDAT ?setRenderScene@SceneRenderer@Ogre@@QAEXPAVGameScene@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pscene$ = 8						; size = 4
?setRenderScene@SceneRenderer@Ogre@@QAEXPAVGameScene@2@@Z PROC ; Ogre::SceneRenderer::setRenderScene, COMDAT
; _this$ = ecx

; 47   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 			m_pScene = pscene;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pscene$[ebp]
	mov	DWORD PTR [eax+612], ecx

; 49   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setRenderScene@SceneRenderer@Ogre@@QAEXPAVGameScene@2@@Z ENDP ; Ogre::SceneRenderer::setRenderScene
_TEXT	ENDS
PUBLIC	?setClearParams@SceneRenderer@Ogre@@QAEXIIMI@Z	; Ogre::SceneRenderer::setClearParams
; Function compile flags: /Odtp
;	COMDAT ?setClearParams@SceneRenderer@Ogre@@QAEXIIMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flags$ = 8						; size = 4
_color$ = 12						; size = 4
_depth$ = 16						; size = 4
_stencil$ = 20						; size = 4
?setClearParams@SceneRenderer@Ogre@@QAEXIIMI@Z PROC	; Ogre::SceneRenderer::setClearParams, COMDAT
; _this$ = ecx

; 52   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 53   : 			m_ClearFlags = flags;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [eax+616], ecx

; 54   : 			m_ClearColor = color;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _color$[ebp]
	mov	DWORD PTR [edx+620], eax

; 55   : 			m_ClearDepth = depth;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _depth$[ebp]
	fstp	DWORD PTR [ecx+624]

; 56   : 			m_ClearStencil = stencil;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _stencil$[ebp]
	mov	DWORD PTR [edx+628], eax

; 57   : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?setClearParams@SceneRenderer@Ogre@@QAEXIIMI@Z ENDP	; Ogre::SceneRenderer::setClearParams
_TEXT	ENDS
PUBLIC	?setRenderPool@SceneRenderer@Ogre@@QAEXPAVShaderContextPool@2@PAVDynamicBufferPool@2@@Z ; Ogre::SceneRenderer::setRenderPool
; Function compile flags: /Odtp
;	COMDAT ?setRenderPool@SceneRenderer@Ogre@@QAEXPAVShaderContextPool@2@PAVDynamicBufferPool@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pcontextpool$ = 8					; size = 4
_pbufferpool$ = 12					; size = 4
?setRenderPool@SceneRenderer@Ogre@@QAEXPAVShaderContextPool@2@PAVDynamicBufferPool@2@@Z PROC ; Ogre::SceneRenderer::setRenderPool, COMDAT
; _this$ = ecx

; 60   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 			m_pContextPool = pcontextpool;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pcontextpool$[ebp]
	mov	DWORD PTR [eax+568], ecx

; 62   : 			m_pDynBufferPool = pbufferpool;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pbufferpool$[ebp]
	mov	DWORD PTR [edx+572], eax

; 63   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setRenderPool@SceneRenderer@Ogre@@QAEXPAVShaderContextPool@2@PAVDynamicBufferPool@2@@Z ENDP ; Ogre::SceneRenderer::setRenderPool
_TEXT	ENDS
PUBLIC	?onLostDevice@SceneRenderer@Ogre@@UAEXXZ	; Ogre::SceneRenderer::onLostDevice
; Function compile flags: /Odtp
;	COMDAT ?onLostDevice@SceneRenderer@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?onLostDevice@SceneRenderer@Ogre@@UAEXXZ PROC		; Ogre::SceneRenderer::onLostDevice, COMDAT
; _this$ = ecx

; 66   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?onLostDevice@SceneRenderer@Ogre@@UAEXXZ ENDP		; Ogre::SceneRenderer::onLostDevice
_TEXT	ENDS
PUBLIC	?onRestoreDevice@SceneRenderer@Ogre@@UAEXXZ	; Ogre::SceneRenderer::onRestoreDevice
; Function compile flags: /Odtp
;	COMDAT ?onRestoreDevice@SceneRenderer@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?onRestoreDevice@SceneRenderer@Ogre@@UAEXXZ PROC	; Ogre::SceneRenderer::onRestoreDevice, COMDAT
; _this$ = ecx

; 70   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?onRestoreDevice@SceneRenderer@Ogre@@UAEXXZ ENDP	; Ogre::SceneRenderer::onRestoreDevice
_TEXT	ENDS
PUBLIC	?getGameScene@SceneRenderer@Ogre@@QAEPAVGameScene@2@XZ ; Ogre::SceneRenderer::getGameScene
; Function compile flags: /Odtp
;	COMDAT ?getGameScene@SceneRenderer@Ogre@@QAEPAVGameScene@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getGameScene@SceneRenderer@Ogre@@QAEPAVGameScene@2@XZ PROC ; Ogre::SceneRenderer::getGameScene, COMDAT
; _this$ = ecx

; 76   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   : 			return m_pScene;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+612]

; 78   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getGameScene@SceneRenderer@Ogre@@QAEPAVGameScene@2@XZ ENDP ; Ogre::SceneRenderer::getGameScene
_TEXT	ENDS
PUBLIC	??_7SceneRenderer@Ogre@@6B@			; Ogre::SceneRenderer::`vftable'
PUBLIC	??0SceneRenderer@Ogre@@QAE@ABV01@@Z		; Ogre::SceneRenderer::SceneRenderer
PUBLIC	??_R4SceneRenderer@Ogre@@6B@			; Ogre::SceneRenderer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSceneRenderer@Ogre@@@8			; Ogre::SceneRenderer `RTTI Type Descriptor'
PUBLIC	??_R3SceneRenderer@Ogre@@8			; Ogre::SceneRenderer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SceneRenderer@Ogre@@8			; Ogre::SceneRenderer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SceneRenderer@Ogre@@8		; Ogre::SceneRenderer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ESceneRenderer@Ogre@@UAEPAXI@Z		; Ogre::SceneRenderer::`vector deleting destructor'
EXTRN	??1CullFrustum@Ogre@@QAE@XZ:PROC		; Ogre::CullFrustum::~CullFrustum
;	COMDAT ??_R1A@?0A@EA@SceneRenderer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SceneRenderer@Ogre@@8 DD FLAT:??_R0?AVSceneRenderer@Ogre@@@8 ; Ogre::SceneRenderer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2SceneRenderer@Ogre@@8
rdata$r	SEGMENT
??_R2SceneRenderer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@SceneRenderer@Ogre@@8 ; Ogre::SceneRenderer::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3SceneRenderer@Ogre@@8
rdata$r	SEGMENT
??_R3SceneRenderer@Ogre@@8 DD 00H			; Ogre::SceneRenderer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSceneRenderer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVSceneRenderer@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::SceneRenderer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSceneRenderer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SceneRenderer@Ogre@@6B@
rdata$r	SEGMENT
??_R4SceneRenderer@Ogre@@6B@ DD 00H			; Ogre::SceneRenderer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSceneRenderer@Ogre@@@8
	DD	FLAT:??_R3SceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7SceneRenderer@Ogre@@6B@
CONST	SEGMENT
??_7SceneRenderer@Ogre@@6B@ DD FLAT:??_R4SceneRenderer@Ogre@@6B@ ; Ogre::SceneRenderer::`vftable'
	DD	FLAT:??_ESceneRenderer@Ogre@@UAEPAXI@Z
	DD	FLAT:?onLostDevice@SceneRenderer@Ogre@@UAEXXZ
	DD	FLAT:?onRestoreDevice@SceneRenderer@Ogre@@UAEXXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SceneRenderer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SceneRenderer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0SceneRenderer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SceneRenderer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0SceneRenderer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0SceneRenderer@Ogre@@QAE@ABV01@@Z PROC		; Ogre::SceneRenderer::SceneRenderer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SceneRenderer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SceneRenderer@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0CullFrustum@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+568]
	mov	DWORD PTR [edx+568], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+572]
	mov	DWORD PTR [edx+572], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	mov	DWORD PTR [edx+576], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+580]
	mov	DWORD PTR [edx+580], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	mov	DWORD PTR [edx+584], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [edx+588], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+592]
	mov	DWORD PTR [edx+592], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+596]
	mov	DWORD PTR [edx+596], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+600]
	mov	DWORD PTR [edx+600], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+604]
	mov	DWORD PTR [edx+604], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+608]
	mov	DWORD PTR [edx+608], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+612]
	mov	DWORD PTR [edx+612], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+616]
	mov	DWORD PTR [edx+616], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+620]
	mov	DWORD PTR [edx+620], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [eax+624]
	fstp	DWORD PTR [edx+624]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+628]
	mov	DWORD PTR [ecx+628], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+632]
	mov	BYTE PTR [ecx+632], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SceneRenderer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CullFrustum@Ogre@@QAE@XZ		; Ogre::CullFrustum::~CullFrustum
__ehhandler$??0SceneRenderer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SceneRenderer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SceneRenderer@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::SceneRenderer::SceneRenderer
PUBLIC	??4SceneRenderer@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::SceneRenderer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4SceneRenderer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4SceneRenderer@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::SceneRenderer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??4CullFrustum@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+568]
	mov	DWORD PTR [ecx+568], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+572]
	mov	DWORD PTR [ecx+572], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+576]
	mov	DWORD PTR [ecx+576], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+580]
	mov	DWORD PTR [ecx+580], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+584]
	mov	DWORD PTR [ecx+584], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+588]
	mov	DWORD PTR [ecx+588], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	DWORD PTR [ecx+592], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+596]
	mov	DWORD PTR [ecx+596], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+600]
	mov	DWORD PTR [ecx+600], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+604]
	mov	DWORD PTR [ecx+604], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+608]
	mov	DWORD PTR [ecx+608], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+612]
	mov	DWORD PTR [ecx+612], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+616]
	mov	DWORD PTR [ecx+616], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+620]
	mov	DWORD PTR [ecx+620], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+624]
	fstp	DWORD PTR [ecx+624]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+628]
	mov	DWORD PTR [eax+628], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+632]
	mov	BYTE PTR [eax+632], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4SceneRenderer@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::SceneRenderer::operator=
_TEXT	ENDS
PUBLIC	??_GSceneRenderer@Ogre@@UAEPAXI@Z		; Ogre::SceneRenderer::`scalar deleting destructor'
EXTRN	??1SceneRenderer@Ogre@@UAE@XZ:PROC		; Ogre::SceneRenderer::~SceneRenderer
; Function compile flags: /Odtp
;	COMDAT ??_GSceneRenderer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSceneRenderer@Ogre@@UAEPAXI@Z PROC			; Ogre::SceneRenderer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SceneRenderer@Ogre@@UAE@XZ		; Ogre::SceneRenderer::~SceneRenderer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@13
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@13:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSceneRenderer@Ogre@@UAEPAXI@Z ENDP			; Ogre::SceneRenderer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ESceneRenderer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ESceneRenderer@Ogre@@UAEPAXI@Z PROC			; Ogre::SceneRenderer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@14
	push	OFFSET ??1SceneRenderer@Ogre@@UAE@XZ	; Ogre::SceneRenderer::~SceneRenderer
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	636					; 0000027cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@14
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@14:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@14
$LN3@vector@14:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SceneRenderer@Ogre@@UAE@XZ		; Ogre::SceneRenderer::~SceneRenderer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@14
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@14:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@14:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ESceneRenderer@Ogre@@UAEPAXI@Z ENDP			; Ogre::SceneRenderer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??0CameraShakeSource@NormalSceneRenderer@Ogre@@QAE@ABU012@@Z ; Ogre::NormalSceneRenderer::CameraShakeSource::CameraShakeSource
PUBLIC	??_7NormalSceneRenderer@Ogre@@6B@		; Ogre::NormalSceneRenderer::`vftable'
PUBLIC	??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z	; Ogre::NormalSceneRenderer::NormalSceneRenderer
PUBLIC	??_R4NormalSceneRenderer@Ogre@@6B@		; Ogre::NormalSceneRenderer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVNormalSceneRenderer@Ogre@@@8		; Ogre::NormalSceneRenderer `RTTI Type Descriptor'
PUBLIC	??_R3NormalSceneRenderer@Ogre@@8		; Ogre::NormalSceneRenderer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2NormalSceneRenderer@Ogre@@8		; Ogre::NormalSceneRenderer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@NormalSceneRenderer@Ogre@@8	; Ogre::NormalSceneRenderer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ENormalSceneRenderer@Ogre@@UAEPAXI@Z		; Ogre::NormalSceneRenderer::`vector deleting destructor'
EXTRN	?onLostDevice@NormalSceneRenderer@Ogre@@UAEXXZ:PROC ; Ogre::NormalSceneRenderer::onLostDevice
EXTRN	?onRestoreDevice@NormalSceneRenderer@Ogre@@UAEXXZ:PROC ; Ogre::NormalSceneRenderer::onRestoreDevice
EXTRN	?doRender@NormalSceneRenderer@Ogre@@UAEXXZ:PROC	; Ogre::NormalSceneRenderer::doRender
;	COMDAT ??_R1A@?0A@EA@NormalSceneRenderer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@NormalSceneRenderer@Ogre@@8 DD FLAT:??_R0?AVNormalSceneRenderer@Ogre@@@8 ; Ogre::NormalSceneRenderer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3NormalSceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2NormalSceneRenderer@Ogre@@8
rdata$r	SEGMENT
??_R2NormalSceneRenderer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@NormalSceneRenderer@Ogre@@8 ; Ogre::NormalSceneRenderer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3NormalSceneRenderer@Ogre@@8
rdata$r	SEGMENT
??_R3NormalSceneRenderer@Ogre@@8 DD 00H			; Ogre::NormalSceneRenderer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2NormalSceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVNormalSceneRenderer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVNormalSceneRenderer@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::NormalSceneRenderer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVNormalSceneRenderer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4NormalSceneRenderer@Ogre@@6B@
rdata$r	SEGMENT
??_R4NormalSceneRenderer@Ogre@@6B@ DD 00H		; Ogre::NormalSceneRenderer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVNormalSceneRenderer@Ogre@@@8
	DD	FLAT:??_R3NormalSceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7NormalSceneRenderer@Ogre@@6B@
CONST	SEGMENT
??_7NormalSceneRenderer@Ogre@@6B@ DD FLAT:??_R4NormalSceneRenderer@Ogre@@6B@ ; Ogre::NormalSceneRenderer::`vftable'
	DD	FLAT:??_ENormalSceneRenderer@Ogre@@UAEPAXI@Z
	DD	FLAT:?onLostDevice@NormalSceneRenderer@Ogre@@UAEXXZ
	DD	FLAT:?onRestoreDevice@NormalSceneRenderer@Ogre@@UAEXXZ
	DD	FLAT:?doRender@NormalSceneRenderer@Ogre@@UAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z PROC		; Ogre::NormalSceneRenderer::NormalSceneRenderer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SceneRenderer@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7NormalSceneRenderer@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+636]
	mov	DWORD PTR [edx+636], ecx
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 640				; 00000280H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 640				; 00000280H
	mov	ecx, 24					; 00000018H
	rep movsd
	push	OFFSET ??0CameraShakeSource@NormalSceneRenderer@Ogre@@QAE@ABU012@@Z
	push	16					; 00000010H
	push	20					; 00000014H
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 736				; 000002e0H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 736				; 000002e0H
	push	eax
	call	??__G@YGXPAX0IHP6EPAX00@Z@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+1056]
	mov	DWORD PTR [ecx+1056], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+1060]
	mov	DWORD PTR [ecx+1060], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+1064]
	mov	DWORD PTR [ecx+1064], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SceneRenderer@Ogre@@UAE@XZ		; Ogre::SceneRenderer::~SceneRenderer
__ehhandler$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::NormalSceneRenderer::NormalSceneRenderer
PUBLIC	??4CameraShakeSource@NormalSceneRenderer@Ogre@@QAEAAU012@ABU012@@Z ; Ogre::NormalSceneRenderer::CameraShakeSource::operator=
PUBLIC	??4NormalSceneRenderer@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::NormalSceneRenderer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4NormalSceneRenderer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_$S3$60773 = -8						; size = 4
_$S2$60769 = -4						; size = 4
___that$ = 8						; size = 4
??4NormalSceneRenderer@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::NormalSceneRenderer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4SceneRenderer@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+636]
	mov	DWORD PTR [ecx+636], eax
	mov	DWORD PTR _$S2$60769[ebp], 0
	jmp	SHORT $LN6@operator@7
$LN5@operator@7:
	mov	ecx, DWORD PTR _$S2$60769[ebp]
	add	ecx, 1
	mov	DWORD PTR _$S2$60769[ebp], ecx
$LN6@operator@7:
	cmp	DWORD PTR _$S2$60769[ebp], 24		; 00000018H
	jae	SHORT $LN4@operator@7
	mov	edx, DWORD PTR _$S2$60769[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _$S2$60769[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [esi+ecx*4+640]
	fstp	DWORD PTR [eax+edx*4+640]
	jmp	SHORT $LN5@operator@7
$LN4@operator@7:
	mov	DWORD PTR _$S3$60773[ebp], 0
	jmp	SHORT $LN3@operator@7
$LN2@operator@7:
	mov	edx, DWORD PTR _$S3$60773[ebp]
	add	edx, 1
	mov	DWORD PTR _$S3$60773[ebp], edx
$LN3@operator@7:
	cmp	DWORD PTR _$S3$60773[ebp], 16		; 00000010H
	jae	SHORT $LN1@operator@7
	mov	eax, DWORD PTR _$S3$60773[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR ___that$[ebp]
	lea	edx, DWORD PTR [ecx+eax+736]
	push	edx
	mov	eax, DWORD PTR _$S3$60773[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+736]
	call	??4CameraShakeSource@NormalSceneRenderer@Ogre@@QAEAAU012@ABU012@@Z
	jmp	SHORT $LN2@operator@7
$LN1@operator@7:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+1056]
	mov	DWORD PTR [edx+1056], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+1060]
	mov	DWORD PTR [edx+1060], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+1064]
	mov	DWORD PTR [edx+1064], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4NormalSceneRenderer@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::NormalSceneRenderer::operator=
_TEXT	ENDS
PUBLIC	??_GNormalSceneRenderer@Ogre@@UAEPAXI@Z		; Ogre::NormalSceneRenderer::`scalar deleting destructor'
EXTRN	??1NormalSceneRenderer@Ogre@@UAE@XZ:PROC	; Ogre::NormalSceneRenderer::~NormalSceneRenderer
; Function compile flags: /Odtp
;	COMDAT ??_GNormalSceneRenderer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GNormalSceneRenderer@Ogre@@UAEPAXI@Z PROC		; Ogre::NormalSceneRenderer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NormalSceneRenderer@Ogre@@UAE@XZ	; Ogre::NormalSceneRenderer::~NormalSceneRenderer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@14
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@14:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GNormalSceneRenderer@Ogre@@UAEPAXI@Z ENDP		; Ogre::NormalSceneRenderer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ENormalSceneRenderer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ENormalSceneRenderer@Ogre@@UAEPAXI@Z PROC		; Ogre::NormalSceneRenderer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@15
	push	OFFSET ??1NormalSceneRenderer@Ogre@@UAE@XZ ; Ogre::NormalSceneRenderer::~NormalSceneRenderer
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	1068					; 0000042cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@15
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@15:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@15
$LN3@vector@15:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NormalSceneRenderer@Ogre@@UAE@XZ	; Ogre::NormalSceneRenderer::~NormalSceneRenderer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@15
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@15:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@15:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ENormalSceneRenderer@Ogre@@UAEPAXI@Z ENDP		; Ogre::NormalSceneRenderer::`vector deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0CameraShakeSource@NormalSceneRenderer@Ogre@@QAE@ABU012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0CameraShakeSource@NormalSceneRenderer@Ogre@@QAE@ABU012@@Z PROC ; Ogre::NormalSceneRenderer::CameraShakeSource::CameraShakeSource, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [eax+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CameraShakeSource@NormalSceneRenderer@Ogre@@QAE@ABU012@@Z ENDP ; Ogre::NormalSceneRenderer::CameraShakeSource::CameraShakeSource
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4CameraShakeSource@NormalSceneRenderer@Ogre@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4CameraShakeSource@NormalSceneRenderer@Ogre@@QAEAAU012@ABU012@@Z PROC ; Ogre::NormalSceneRenderer::CameraShakeSource::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [eax+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4CameraShakeSource@NormalSceneRenderer@Ogre@@QAEAAU012@ABU012@@Z ENDP ; Ogre::NormalSceneRenderer::CameraShakeSource::operator=
_TEXT	ENDS
PUBLIC	?setPreRenderCallback@UIRenderer@Ogre@@QAEXP6AXXZ@Z ; Ogre::UIRenderer::setPreRenderCallback
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreuirenderer.h
;	COMDAT ?setPreRenderCallback@UIRenderer@Ogre@@QAEXP6AXXZ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pcallback$ = 8						; size = 4
?setPreRenderCallback@UIRenderer@Ogre@@QAEXP6AXXZ@Z PROC ; Ogre::UIRenderer::setPreRenderCallback, COMDAT
; _this$ = ecx

; 42   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 			m_pPreRenderCallback = pcallback;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pcallback$[ebp]
	mov	DWORD PTR [eax+856], ecx

; 44   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setPreRenderCallback@UIRenderer@Ogre@@QAEXP6AXXZ@Z ENDP ; Ogre::UIRenderer::setPreRenderCallback
_TEXT	ENDS
PUBLIC	??4?$Singleton@VUIRenderer@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::Singleton<Ogre::UIRenderer>::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$Singleton@VUIRenderer@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Singleton@VUIRenderer@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z PROC ; Ogre::Singleton<Ogre::UIRenderer>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Singleton@VUIRenderer@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z ENDP ; Ogre::Singleton<Ogre::UIRenderer>::operator=
_TEXT	ENDS
PUBLIC	??1?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::~vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
PUBLIC	??1?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ ; Ogre::HashTable<Ogre::FixedString,Ogre::UIRenderer::UIResObject,Ogre::FixedStringHashCoder>::~HashTable<Ogre::FixedString,Ogre::UIRenderer::UIResObject,Ogre::FixedStringHashCoder>
PUBLIC	??1?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::~vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >
PUBLIC	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >
PUBLIC	??1?$Singleton@VUIRenderer@Ogre@@@Ogre@@QAE@XZ	; Ogre::Singleton<Ogre::UIRenderer>::~Singleton<Ogre::UIRenderer>
PUBLIC	??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
PUBLIC	??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >
PUBLIC	??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@ABV01@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >
PUBLIC	??_7UIRenderer@Ogre@@6B@			; Ogre::UIRenderer::`vftable'
PUBLIC	??0UIRenderer@Ogre@@QAE@ABV01@@Z		; Ogre::UIRenderer::UIRenderer
PUBLIC	??_R4UIRenderer@Ogre@@6B@			; Ogre::UIRenderer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVUIRenderer@Ogre@@@8			; Ogre::UIRenderer `RTTI Type Descriptor'
PUBLIC	??_R3UIRenderer@Ogre@@8				; Ogre::UIRenderer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2UIRenderer@Ogre@@8				; Ogre::UIRenderer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@UIRenderer@Ogre@@8		; Ogre::UIRenderer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1CHM@?0A@EA@?$Singleton@VUIRenderer@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::UIRenderer>::`RTTI Base Class Descriptor at (636,-1,0,64)'
PUBLIC	??_R0?AV?$Singleton@VUIRenderer@Ogre@@@Ogre@@@8	; Ogre::Singleton<Ogre::UIRenderer> `RTTI Type Descriptor'
PUBLIC	??_R3?$Singleton@VUIRenderer@Ogre@@@Ogre@@8	; Ogre::Singleton<Ogre::UIRenderer>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Singleton@VUIRenderer@Ogre@@@Ogre@@8	; Ogre::Singleton<Ogre::UIRenderer>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$Singleton@VUIRenderer@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::UIRenderer>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EUIRenderer@Ogre@@UAEPAXI@Z			; Ogre::UIRenderer::`vector deleting destructor'
EXTRN	??1VertexFormat@Ogre@@QAE@XZ:PROC		; Ogre::VertexFormat::~VertexFormat
EXTRN	??0VertexFormat@Ogre@@QAE@ABV01@@Z:PROC		; Ogre::VertexFormat::VertexFormat
EXTRN	?onLostDevice@UIRenderer@Ogre@@UAEXXZ:PROC	; Ogre::UIRenderer::onLostDevice
EXTRN	?onRestoreDevice@UIRenderer@Ogre@@UAEXXZ:PROC	; Ogre::UIRenderer::onRestoreDevice
EXTRN	?doRender@UIRenderer@Ogre@@UAEXXZ:PROC		; Ogre::UIRenderer::doRender
EXTRN	?CreateTrueTypeFont@UIRenderer@Ogre@@UAEPAXHHPBDW4ECharacterCoding@2@I@Z:PROC ; Ogre::UIRenderer::CreateTrueTypeFont
EXTRN	?CreateBitmapFont@UIRenderer@Ogre@@UAEPAXPBDW4ECharacterCoding@2@@Z:PROC ; Ogre::UIRenderer::CreateBitmapFont
EXTRN	?ReleaseTrueTypeFont@UIRenderer@Ogre@@UAEXPAX@Z:PROC ; Ogre::UIRenderer::ReleaseTrueTypeFont
EXTRN	?GetFontHeight@UIRenderer@Ogre@@UAEHPAX@Z:PROC	; Ogre::UIRenderer::GetFontHeight
EXTRN	?renderText@UIRenderer@Ogre@@UAEXPAXIPBDMMABVColorQuad@2@M_NM2@Z:PROC ; Ogre::UIRenderer::renderText
EXTRN	?renderTextRect@UIRenderer@Ogre@@UAEXPAXIIPBDAAV?$TRect@M@2@ABVColorQuad@2@M_N3@Z:PROC ; Ogre::UIRenderer::renderTextRect
EXTRN	?renderTextRect@UIRenderer@Ogre@@UAEXPAXIPBDAAV?$TRect@M@2@MM_NABVColorQuad@2@M34@Z:PROC ; Ogre::UIRenderer::renderTextRect
EXTRN	?GetCharExtent@UIRenderer@Ogre@@UAEXPAXPBDAAM2@Z:PROC ; Ogre::UIRenderer::GetCharExtent
EXTRN	?GetTextExtent@UIRenderer@Ogre@@UAEXPAXPBDAAM2@Z:PROC ; Ogre::UIRenderer::GetTextExtent
EXTRN	?GetTextExtentFitInWidth@UIRenderer@Ogre@@UAEXPAXPBDMAAMAAH@Z:PROC ; Ogre::UIRenderer::GetTextExtentFitInWidth
EXTRN	?GetLineInterval@UIRenderer@Ogre@@UAEMPAX@Z:PROC ; Ogre::UIRenderer::GetLineInterval
EXTRN	?SetLineInterval@UIRenderer@Ogre@@UAEXPAXM@Z:PROC ; Ogre::UIRenderer::SetLineInterval
EXTRN	?GetTexture@UIRenderer@Ogre@@UAEPAXPBD@Z:PROC	; Ogre::UIRenderer::GetTexture
EXTRN	?CreateTexture@UIRenderer@Ogre@@UAEPAXPAVResource@2@W4BlendMode@2@PAH2@Z:PROC ; Ogre::UIRenderer::CreateTexture
EXTRN	?CreateTexture@UIRenderer@Ogre@@UAEPAXPBDPAVTexture@2@W4BlendMode@2@@Z:PROC ; Ogre::UIRenderer::CreateTexture
EXTRN	?CreateTexture@UIRenderer@Ogre@@UAEPAXPBDW4BlendMode@2@PAH2@Z:PROC ; Ogre::UIRenderer::CreateTexture
EXTRN	?SetUiTextureBlendModel@UIRenderer@Ogre@@UAEXPAXW4BlendMode@2@@Z:PROC ; Ogre::UIRenderer::SetUiTextureBlendModel
EXTRN	?GetNullTexture@UIRenderer@Ogre@@UAEPAXXZ:PROC	; Ogre::UIRenderer::GetNullTexture
EXTRN	?AddRef@UIRenderer@Ogre@@UAEXPAX@Z:PROC		; Ogre::UIRenderer::AddRef
EXTRN	?ReleaseUIRes@UIRenderer@Ogre@@UAEXPAX@Z:PROC	; Ogre::UIRenderer::ReleaseUIRes
EXTRN	?BeginDraw@UIRenderer@Ogre@@UAEXPAX0M_N@Z:PROC	; Ogre::UIRenderer::BeginDraw
EXTRN	?DrawRect@UIRenderer@Ogre@@UAEXHHHHKHHM@Z:PROC	; Ogre::UIRenderer::DrawRect
EXTRN	?StretchRect@UIRenderer@Ogre@@UAEXMMMMK_NHHHHW4UiUvType@2@MMMAAV?$TRect@H@2@0@Z:PROC ; Ogre::UIRenderer::StretchRect
EXTRN	?DrawLine@UIRenderer@Ogre@@UAEXMMMMK@Z:PROC	; Ogre::UIRenderer::DrawLine
EXTRN	?DrawBar@UIRenderer@Ogre@@UAEXMMMMK@Z:PROC	; Ogre::UIRenderer::DrawBar
EXTRN	?DrawBox@UIRenderer@Ogre@@UAEXMMMMK@Z:PROC	; Ogre::UIRenderer::DrawBox
EXTRN	?EndDraw@UIRenderer@Ogre@@UAEXXZ:PROC		; Ogre::UIRenderer::EndDraw
EXTRN	?DrawTriangleList@UIRenderer@Ogre@@UAEXPAVVector2@2@IK@Z:PROC ; Ogre::UIRenderer::DrawTriangleList
EXTRN	?DrawTriangleFan@UIRenderer@Ogre@@UAEXPAVVector2@2@IPAVColorQuad@2@@Z:PROC ; Ogre::UIRenderer::DrawTriangleFan
EXTRN	?DrawTriangleFan@UIRenderer@Ogre@@UAEXPAVVector2@2@IK@Z:PROC ; Ogre::UIRenderer::DrawTriangleFan
EXTRN	?PushClipRect@UIRenderer@Ogre@@UAEXABV?$TRect@M@2@@Z:PROC ; Ogre::UIRenderer::PushClipRect
EXTRN	?GetClipRect@UIRenderer@Ogre@@UAEABV?$TRect@M@2@XZ:PROC ; Ogre::UIRenderer::GetClipRect
EXTRN	?PopClipRect@UIRenderer@Ogre@@UAEXXZ:PROC	; Ogre::UIRenderer::PopClipRect
EXTRN	?setCursor@UIRenderer@Ogre@@UAEXPAXHHHHHH@Z:PROC ; Ogre::UIRenderer::setCursor
;	COMDAT ??_R1A@?0A@EA@?$Singleton@VUIRenderer@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Singleton@VUIRenderer@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$Singleton@VUIRenderer@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::UIRenderer>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VUIRenderer@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2?$Singleton@VUIRenderer@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R2?$Singleton@VUIRenderer@Ogre@@@Ogre@@8 DD FLAT:??_R1A@?0A@EA@?$Singleton@VUIRenderer@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::UIRenderer>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$Singleton@VUIRenderer@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R3?$Singleton@VUIRenderer@Ogre@@@Ogre@@8 DD 00H	; Ogre::Singleton<Ogre::UIRenderer>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$Singleton@VUIRenderer@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$Singleton@VUIRenderer@Ogre@@@Ogre@@@8
_DATA	SEGMENT
??_R0?AV?$Singleton@VUIRenderer@Ogre@@@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::Singleton<Ogre::UIRenderer> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$Singleton@VUIRenderer@Ogre@@@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R1CHM@?0A@EA@?$Singleton@VUIRenderer@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R1CHM@?0A@EA@?$Singleton@VUIRenderer@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$Singleton@VUIRenderer@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::UIRenderer>::`RTTI Base Class Descriptor at (636,-1,0,64)'
	DD	00H
	DD	027cH
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VUIRenderer@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@UIRenderer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UIRenderer@Ogre@@8 DD FLAT:??_R0?AVUIRenderer@Ogre@@@8 ; Ogre::UIRenderer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3UIRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2UIRenderer@Ogre@@8
rdata$r	SEGMENT
??_R2UIRenderer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@UIRenderer@Ogre@@8 ; Ogre::UIRenderer::`RTTI Base Class Array'
	DD	FLAT:??_R1CHM@?0A@EA@?$Singleton@VUIRenderer@Ogre@@@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@SceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3UIRenderer@Ogre@@8
rdata$r	SEGMENT
??_R3UIRenderer@Ogre@@8 DD 00H				; Ogre::UIRenderer::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2UIRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVUIRenderer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVUIRenderer@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::UIRenderer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVUIRenderer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4UIRenderer@Ogre@@6B@
rdata$r	SEGMENT
??_R4UIRenderer@Ogre@@6B@ DD 00H			; Ogre::UIRenderer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVUIRenderer@Ogre@@@8
	DD	FLAT:??_R3UIRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7UIRenderer@Ogre@@6B@
CONST	SEGMENT
??_7UIRenderer@Ogre@@6B@ DD FLAT:??_R4UIRenderer@Ogre@@6B@ ; Ogre::UIRenderer::`vftable'
	DD	FLAT:??_EUIRenderer@Ogre@@UAEPAXI@Z
	DD	FLAT:?onLostDevice@UIRenderer@Ogre@@UAEXXZ
	DD	FLAT:?onRestoreDevice@UIRenderer@Ogre@@UAEXXZ
	DD	FLAT:?doRender@UIRenderer@Ogre@@UAEXXZ
	DD	FLAT:?CreateTrueTypeFont@UIRenderer@Ogre@@UAEPAXHHPBDW4ECharacterCoding@2@I@Z
	DD	FLAT:?CreateBitmapFont@UIRenderer@Ogre@@UAEPAXPBDW4ECharacterCoding@2@@Z
	DD	FLAT:?ReleaseTrueTypeFont@UIRenderer@Ogre@@UAEXPAX@Z
	DD	FLAT:?GetFontHeight@UIRenderer@Ogre@@UAEHPAX@Z
	DD	FLAT:?renderText@UIRenderer@Ogre@@UAEXPAXIPBDMMABVColorQuad@2@M_NM2@Z
	DD	FLAT:?renderTextRect@UIRenderer@Ogre@@UAEXPAXIIPBDAAV?$TRect@M@2@ABVColorQuad@2@M_N3@Z
	DD	FLAT:?renderTextRect@UIRenderer@Ogre@@UAEXPAXIPBDAAV?$TRect@M@2@MM_NABVColorQuad@2@M34@Z
	DD	FLAT:?GetCharExtent@UIRenderer@Ogre@@UAEXPAXPBDAAM2@Z
	DD	FLAT:?GetTextExtent@UIRenderer@Ogre@@UAEXPAXPBDAAM2@Z
	DD	FLAT:?GetTextExtentFitInWidth@UIRenderer@Ogre@@UAEXPAXPBDMAAMAAH@Z
	DD	FLAT:?GetLineInterval@UIRenderer@Ogre@@UAEMPAX@Z
	DD	FLAT:?SetLineInterval@UIRenderer@Ogre@@UAEXPAXM@Z
	DD	FLAT:?GetTexture@UIRenderer@Ogre@@UAEPAXPBD@Z
	DD	FLAT:?CreateTexture@UIRenderer@Ogre@@UAEPAXPAVResource@2@W4BlendMode@2@PAH2@Z
	DD	FLAT:?CreateTexture@UIRenderer@Ogre@@UAEPAXPBDPAVTexture@2@W4BlendMode@2@@Z
	DD	FLAT:?CreateTexture@UIRenderer@Ogre@@UAEPAXPBDW4BlendMode@2@PAH2@Z
	DD	FLAT:?SetUiTextureBlendModel@UIRenderer@Ogre@@UAEXPAXW4BlendMode@2@@Z
	DD	FLAT:?GetNullTexture@UIRenderer@Ogre@@UAEPAXXZ
	DD	FLAT:?AddRef@UIRenderer@Ogre@@UAEXPAX@Z
	DD	FLAT:?ReleaseUIRes@UIRenderer@Ogre@@UAEXPAX@Z
	DD	FLAT:?BeginDraw@UIRenderer@Ogre@@UAEXPAX0M_N@Z
	DD	FLAT:?DrawRect@UIRenderer@Ogre@@UAEXHHHHKHHM@Z
	DD	FLAT:?StretchRect@UIRenderer@Ogre@@UAEXMMMMK_NHHHHW4UiUvType@2@MMMAAV?$TRect@H@2@0@Z
	DD	FLAT:?DrawLine@UIRenderer@Ogre@@UAEXMMMMK@Z
	DD	FLAT:?DrawBar@UIRenderer@Ogre@@UAEXMMMMK@Z
	DD	FLAT:?DrawBox@UIRenderer@Ogre@@UAEXMMMMK@Z
	DD	FLAT:?EndDraw@UIRenderer@Ogre@@UAEXXZ
	DD	FLAT:?DrawTriangleList@UIRenderer@Ogre@@UAEXPAVVector2@2@IK@Z
	DD	FLAT:?DrawTriangleFan@UIRenderer@Ogre@@UAEXPAVVector2@2@IPAVColorQuad@2@@Z
	DD	FLAT:?DrawTriangleFan@UIRenderer@Ogre@@UAEXPAVVector2@2@IK@Z
	DD	FLAT:?PushClipRect@UIRenderer@Ogre@@UAEXABV?$TRect@M@2@@Z
	DD	FLAT:?GetClipRect@UIRenderer@Ogre@@UAEABV?$TRect@M@2@XZ
	DD	FLAT:?PopClipRect@UIRenderer@Ogre@@UAEXXZ
	DD	FLAT:?setCursor@UIRenderer@Ogre@@UAEXPAXHHHHHH@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0UIRenderer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0UIRenderer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0UIRenderer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0UIRenderer@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0UIRenderer@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0UIRenderer@Ogre@@QAE@ABV01@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0UIRenderer@Ogre@@QAE@ABV01@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0UIRenderer@Ogre@@QAE@ABV01@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0UIRenderer@Ogre@@QAE@ABV01@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0UIRenderer@Ogre@@QAE@ABV01@@Z$6
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0UIRenderer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv68 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0UIRenderer@Ogre@@QAE@ABV01@@Z PROC			; Ogre::UIRenderer::UIRenderer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0UIRenderer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR ___that$[ebp], 0
	je	SHORT $LN3@UIRenderer
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 636				; 0000027cH
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@UIRenderer
$LN3@UIRenderer:
	mov	DWORD PTR tv68[ebp], 0
$LN4@UIRenderer:
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR ___that$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SceneRenderer@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7UIRenderer@Ogre@@6B@
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 636				; 0000027cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 636				; 0000027cH
	call	??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+668]
	mov	DWORD PTR [ecx+668], eax
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 672				; 000002a0H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 672				; 000002a0H
	mov	ecx, 14					; 0000000eH
	rep movsd
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+728]
	mov	DWORD PTR [ecx+728], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 732				; 000002dcH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 732				; 000002dcH
	call	??0VertexFormat@Ogre@@QAE@ABV01@@Z	; Ogre::VertexFormat::VertexFormat
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+756]
	mov	DWORD PTR [edx+756], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 760				; 000002f8H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 760				; 000002f8H
	call	??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+784]
	mov	BYTE PTR [eax+784], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [ecx+788]
	fstp	DWORD PTR [eax+788]
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 792				; 00000318H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 792				; 00000318H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+804]
	mov	DWORD PTR [eax+804], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	DWORD PTR [eax+808], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 812				; 0000032cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+828]
	mov	BYTE PTR [ecx+828], al
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 832				; 00000340H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 832				; 00000340H
	call	??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [edx+856], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0UIRenderer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 636				; 0000027cH
	jmp	??1?$Singleton@VUIRenderer@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::UIRenderer>::~Singleton<Ogre::UIRenderer>
__unwindfunclet$??0UIRenderer@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SceneRenderer@Ogre@@UAE@XZ		; Ogre::SceneRenderer::~SceneRenderer
__unwindfunclet$??0UIRenderer@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 636				; 0000027cH
	jmp	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0UIRenderer@Ogre@@QAE@ABV01@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 732				; 000002dcH
	jmp	??1VertexFormat@Ogre@@QAE@XZ		; Ogre::VertexFormat::~VertexFormat
__unwindfunclet$??0UIRenderer@Ogre@@QAE@ABV01@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 760				; 000002f8H
	jmp	??1?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::~vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >
__unwindfunclet$??0UIRenderer@Ogre@@QAE@ABV01@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 792				; 00000318H
	jmp	??1?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ ; Ogre::HashTable<Ogre::FixedString,Ogre::UIRenderer::UIResObject,Ogre::FixedStringHashCoder>::~HashTable<Ogre::FixedString,Ogre::UIRenderer::UIResObject,Ogre::FixedStringHashCoder>
__unwindfunclet$??0UIRenderer@Ogre@@QAE@ABV01@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 832				; 00000340H
	jmp	??1?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::~vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
__ehhandler$??0UIRenderer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0UIRenderer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0UIRenderer@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::UIRenderer::UIRenderer
PUBLIC	??4?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::operator=
PUBLIC	??4?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::operator=
PUBLIC	??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::operator=
PUBLIC	??4UIRenderer@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::UIRenderer::operator=
EXTRN	??4VertexFormat@Ogre@@QAEAAV01@ABV01@@Z:PROC	; Ogre::VertexFormat::operator=
; Function compile flags: /Odtp
;	COMDAT ??4UIRenderer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_$S4$62460 = -4						; size = 4
___that$ = 8						; size = 4
??4UIRenderer@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::UIRenderer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4SceneRenderer@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 636				; 0000027cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 636				; 0000027cH
	call	??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAEAAV01@ABV01@@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+668]
	mov	DWORD PTR [edx+668], ecx
	mov	DWORD PTR _$S4$62460[ebp], 0
	jmp	SHORT $LN3@operator@8
$LN2@operator@8:
	mov	edx, DWORD PTR _$S4$62460[ebp]
	add	edx, 1
	mov	DWORD PTR _$S4$62460[ebp], edx
$LN3@operator@8:
	cmp	DWORD PTR _$S4$62460[ebp], 14		; 0000000eH
	jae	SHORT $LN1@operator@8
	mov	eax, DWORD PTR _$S4$62460[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S4$62460[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+672]
	mov	DWORD PTR [ecx+eax*4+672], edx
	jmp	SHORT $LN2@operator@8
$LN1@operator@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+728]
	mov	DWORD PTR [eax+728], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 732				; 000002dcH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 732				; 000002dcH
	call	??4VertexFormat@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::VertexFormat::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+756]
	mov	DWORD PTR [ecx+756], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 760				; 000002f8H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 760				; 000002f8H
	call	??4?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+784]
	mov	BYTE PTR [edx+784], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [eax+788]
	fstp	DWORD PTR [edx+788]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 792				; 00000318H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 792				; 00000318H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+804]
	mov	DWORD PTR [edx+804], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+808]
	mov	DWORD PTR [edx+808], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 812				; 0000032cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+828]
	mov	BYTE PTR [eax+828], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 832				; 00000340H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 832				; 00000340H
	call	??4?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	DWORD PTR [ecx+856], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4UIRenderer@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::UIRenderer::operator=
_TEXT	ENDS
PUBLIC	??_GUIRenderer@Ogre@@UAEPAXI@Z			; Ogre::UIRenderer::`scalar deleting destructor'
EXTRN	??1UIRenderer@Ogre@@UAE@XZ:PROC			; Ogre::UIRenderer::~UIRenderer
; Function compile flags: /Odtp
;	COMDAT ??_GUIRenderer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GUIRenderer@Ogre@@UAEPAXI@Z PROC			; Ogre::UIRenderer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1UIRenderer@Ogre@@UAE@XZ		; Ogre::UIRenderer::~UIRenderer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@15
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@15:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GUIRenderer@Ogre@@UAEPAXI@Z ENDP			; Ogre::UIRenderer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EUIRenderer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EUIRenderer@Ogre@@UAEPAXI@Z PROC			; Ogre::UIRenderer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@16
	push	OFFSET ??1UIRenderer@Ogre@@UAE@XZ	; Ogre::UIRenderer::~UIRenderer
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	860					; 0000035cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@16
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@16:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@16
$LN3@vector@16:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1UIRenderer@Ogre@@UAE@XZ		; Ogre::UIRenderer::~UIRenderer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@16
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@16:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@16:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EUIRenderer@Ogre@@UAEPAXI@Z ENDP			; Ogre::UIRenderer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
__ehhandler$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
__ehhandler$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >
PUBLIC	??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::operator=
_TEXT	ENDS
PUBLIC	?GetTextExtent@RFontBase@Ogre@@UAEXPBDAAM1_N@Z	; Ogre::RFontBase::GetTextExtent
EXTRN	_memset:PROC
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefontbase.cpp
_TEXT	SEGMENT
_this$ = -40						; size = 4
_fCW$120603 = -36					; size = 4
_fCH$120604 = -32					; size = 4
_n$120606 = -28						; size = 4
_cc$120605 = -24					; size = 4
_bFirstCharFind$ = -17					; size = 1
_fW$ = -16						; size = 4
_p$ = -12						; size = 4
_nRetNum$ = -8						; size = 4
_eCtrlCode$ = -4					; size = 4
_pText$ = 8						; size = 4
_fWidth$ = 12						; size = 4
_fHeight$ = 16						; size = 4
_bDoTransfer$ = 20					; size = 1
?GetTextExtent@RFontBase@Ogre@@UAEXPBDAAM1_N@Z PROC	; Ogre::RFontBase::GetTextExtent
; _this$ = ecx

; 23   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 24   : 		if(!pText)

	cmp	DWORD PTR _pText$[ebp], 0
	jne	SHORT $LN10@GetTextExt

; 25   : 			return;

	jmp	$LN11@GetTextExt
$LN10@GetTextExt:

; 26   : 
; 27   : 		const char *p = pText;

	mov	eax, DWORD PTR _pText$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 28   : 		float fW;
; 29   : 		int nRetNum;
; 30   : 		bool bFirstCharFind;
; 31   : 		EControlCode eCtrlCode;
; 32   : 
; 33   : 		bFirstCharFind = false;

	mov	BYTE PTR _bFirstCharFind$[ebp], 0

; 34   : 		fWidth = fHeight = 0;

	mov	ecx, DWORD PTR _fHeight$[ebp]
	fldz
	fstp	DWORD PTR [ecx]
	mov	edx, DWORD PTR _fWidth$[ebp]
	fldz
	fstp	DWORD PTR [edx]

; 35   : 		fW = 0;

	fldz
	fstp	DWORD PTR _fW$[ebp]
$LN9@GetTextExt:

; 36   : 		while(1)

	mov	eax, 1
	test	eax, eax
	je	$LN8@GetTextExt

; 37   : 		{
; 38   : 			nRetNum = m_pCharacterCoding->GetControlCode(p, eCtrlCode, bDoTransfer);

	movzx	ecx, BYTE PTR _bDoTransfer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _eCtrlCode$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _nRetNum$[ebp], eax

; 39   : 			p += nRetNum;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _nRetNum$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 40   : 
; 41   : 			if( eCtrlCode == CTRLCODE_ENDOFSTRING )

	cmp	DWORD PTR _eCtrlCode$[ebp], 3
	jne	SHORT $LN7@GetTextExt

; 42   : 			{
; 43   : 				if(fW > fWidth)

	fld	DWORD PTR _fW$[ebp]
	mov	edx, DWORD PTR _fWidth$[ebp]
	fld	DWORD PTR [edx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@GetTextExt

; 44   : 				{
; 45   : 					fWidth = fW;

	mov	eax, DWORD PTR _fWidth$[ebp]
	fld	DWORD PTR _fW$[ebp]
	fstp	DWORD PTR [eax]
$LN6@GetTextExt:

; 46   : 				}
; 47   : 				break;

	jmp	$LN8@GetTextExt
$LN7@GetTextExt:

; 48   : 			}
; 49   : 
; 50   : 			if(CTRLCODE_NEWLINE == eCtrlCode)

	cmp	DWORD PTR _eCtrlCode$[ebp], 2
	jne	SHORT $LN5@GetTextExt

; 51   : 			{
; 52   : 				//
; 53   : 				if(fW > fWidth)

	fld	DWORD PTR _fW$[ebp]
	mov	ecx, DWORD PTR _fWidth$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@GetTextExt

; 54   : 					fWidth = fW;

	mov	edx, DWORD PTR _fWidth$[ebp]
	fld	DWORD PTR _fW$[ebp]
	fstp	DWORD PTR [edx]
$LN4@GetTextExt:

; 55   : 				//
; 56   : 				fW = 0;

	fldz
	fstp	DWORD PTR _fW$[ebp]

; 57   : 				//
; 58   : 				bFirstCharFind = false;

	mov	BYTE PTR _bFirstCharFind$[ebp], 0
	jmp	$LN1@GetTextExt
$LN5@GetTextExt:

; 59   : 			}
; 60   : 			else if(CTRLCODE_CHARACTER == eCtrlCode)

	cmp	DWORD PTR _eCtrlCode$[ebp], 0
	jne	SHORT $LN1@GetTextExt

; 61   : 			{
; 62   : 				float fCW,fCH;
; 63   : 				unsigned char cc[4];
; 64   : 				memset( cc, 0, sizeof( cc ) );

	push	4
	push	0
	lea	eax, DWORD PTR _cc$120605[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 65   : 				int n = m_pCharacterCoding->GetAChar(p, cc);

	lea	ecx, DWORD PTR _cc$120605[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR _n$120606[ebp], eax

; 66   : 
; 67   : 				GetCharExtent(cc, fCW, fCH);

	lea	ecx, DWORD PTR _fCH$120604[ebp]
	push	ecx
	lea	edx, DWORD PTR _fCW$120603[ebp]
	push	edx
	lea	eax, DWORD PTR _cc$120605[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 68   : 				p += n;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _n$120606[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 69   : 				fW += fCW;

	fld	DWORD PTR _fW$[ebp]
	fadd	DWORD PTR _fCW$120603[ebp]
	fstp	DWORD PTR _fW$[ebp]

; 70   : 				//
; 71   : 				if(!bFirstCharFind)

	movzx	edx, BYTE PTR _bFirstCharFind$[ebp]
	test	edx, edx
	jne	SHORT $LN1@GetTextExt

; 72   : 				{
; 73   : 					fHeight += m_fCharHeight + m_fLineInterval;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _fHeight$[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _fHeight$[ebp]
	fstp	DWORD PTR [eax]

; 74   : 					bFirstCharFind = true;

	mov	BYTE PTR _bFirstCharFind$[ebp], 1
$LN1@GetTextExt:

; 75   : 				}
; 76   : 			}
; 77   : 		}

	jmp	$LN9@GetTextExt
$LN8@GetTextExt:
$LN11@GetTextExt:

; 78   : 	}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetTextExtent@RFontBase@Ogre@@UAEXPBDAAM1_N@Z ENDP	; Ogre::RFontBase::GetTextExtent
_TEXT	ENDS
PUBLIC	?GetTextExtentFitInWidth@RFontBase@Ogre@@UAEXPBDMAAMAAH_N@Z ; Ogre::RFontBase::GetTextExtentFitInWidth
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -32						; size = 4
_fCW$120625 = -28					; size = 4
_fCH$120626 = -24					; size = 4
_n$120628 = -20						; size = 4
_cc$120627 = -16					; size = 4
_p$ = -12						; size = 4
_nRetNum$ = -8						; size = 4
_eCtrlCode$ = -4					; size = 4
_pText$ = 8						; size = 4
_fFixedWidth$ = 12					; size = 4
_fWidth$ = 16						; size = 4
_nCount$ = 20						; size = 4
_bDoTransfer$ = 24					; size = 1
?GetTextExtentFitInWidth@RFontBase@Ogre@@UAEXPBDMAAMAAH_N@Z PROC ; Ogre::RFontBase::GetTextExtentFitInWidth
; _this$ = ecx

; 82   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 		if(!pText)

	cmp	DWORD PTR _pText$[ebp], 0
	jne	SHORT $LN6@GetTextExt@2

; 84   : 			return;

	jmp	$LN7@GetTextExt@2
$LN6@GetTextExt@2:

; 85   : 
; 86   : 		const char *p = pText;

	mov	eax, DWORD PTR _pText$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 87   : 		int nRetNum;
; 88   : 		EControlCode eCtrlCode;
; 89   : 
; 90   : 		fWidth = 0;

	mov	ecx, DWORD PTR _fWidth$[ebp]
	fldz
	fstp	DWORD PTR [ecx]

; 91   : 		nCount = 0;

	mov	edx, DWORD PTR _nCount$[ebp]
	mov	DWORD PTR [edx], 0
$LN5@GetTextExt@2:

; 92   : 
; 93   : 		while(1)

	mov	eax, 1
	test	eax, eax
	je	$LN4@GetTextExt@2

; 94   : 		{
; 95   : 			nRetNum = m_pCharacterCoding->GetControlCode(p, eCtrlCode, bDoTransfer);

	movzx	ecx, BYTE PTR _bDoTransfer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _eCtrlCode$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _nRetNum$[ebp], eax

; 96   : 			p += nRetNum;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _nRetNum$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 97   : 
; 98   : 			if( eCtrlCode == CTRLCODE_ENDOFSTRING )

	cmp	DWORD PTR _eCtrlCode$[ebp], 3
	jne	SHORT $LN3@GetTextExt@2

; 99   : 				break;

	jmp	$LN4@GetTextExt@2
$LN3@GetTextExt@2:

; 100  : 
; 101  : 			if( CTRLCODE_CHARACTER == eCtrlCode )

	cmp	DWORD PTR _eCtrlCode$[ebp], 0
	jne	$LN2@GetTextExt@2

; 102  : 			{
; 103  : 				float fCW,fCH;
; 104  : 				unsigned char cc[4];
; 105  : 				memset( cc, 0, sizeof( cc ) );

	push	4
	push	0
	lea	edx, DWORD PTR _cc$120627[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 106  : 				int n = m_pCharacterCoding->GetAChar(p, cc);

	lea	eax, DWORD PTR _cc$120627[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+76]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR _n$120628[ebp], eax

; 107  : 
; 108  : 				GetCharExtent(cc, fCW, fCH);

	lea	ecx, DWORD PTR _fCH$120626[ebp]
	push	ecx
	lea	edx, DWORD PTR _fCW$120625[ebp]
	push	edx
	lea	eax, DWORD PTR _cc$120627[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 109  : 				p += n;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _n$120628[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 110  : 
; 111  : 				if( fWidth + fCW > fFixedWidth )

	mov	edx, DWORD PTR _fWidth$[ebp]
	fld	DWORD PTR [edx]
	fadd	DWORD PTR _fCW$120625[ebp]
	fld	DWORD PTR _fFixedWidth$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@GetTextExt@2

; 112  : 					break;

	jmp	SHORT $LN4@GetTextExt@2
$LN1@GetTextExt@2:

; 113  : 
; 114  : 				fWidth += fCW;

	mov	eax, DWORD PTR _fWidth$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR _fCW$120625[ebp]
	mov	ecx, DWORD PTR _fWidth$[ebp]
	fstp	DWORD PTR [ecx]

; 115  : 				nCount += n;

	mov	edx, DWORD PTR _nCount$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _n$120628[ebp]
	mov	ecx, DWORD PTR _nCount$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@GetTextExt@2:

; 116  : 			}
; 117  : 		}

	jmp	$LN5@GetTextExt@2
$LN4@GetTextExt@2:
$LN7@GetTextExt@2:

; 118  : 	}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?GetTextExtentFitInWidth@RFontBase@Ogre@@UAEXPBDMAAMAAH_N@Z ENDP ; Ogre::RFontBase::GetTextExtentFitInWidth
_TEXT	ENDS
PUBLIC	?MinDisToNewLine@RFontBase@Ogre@@IAEMPBD_N@Z	; Ogre::RFontBase::MinDisToNewLine
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -32						; size = 4
_fRet$ = -28						; size = 4
_fWidth$ = -24						; size = 4
_fHeight$ = -20						; size = 4
_nLen$ = -16						; size = 4
_cc$ = -12						; size = 4
_eCtrlCode$ = -8					; size = 4
_p$ = -4						; size = 4
_pText$ = 8						; size = 4
_bDoTransfer$ = 12					; size = 1
?MinDisToNewLine@RFontBase@Ogre@@IAEMPBD_N@Z PROC	; Ogre::RFontBase::MinDisToNewLine
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if( !pText )

	cmp	DWORD PTR _pText$[ebp], 0
	jne	SHORT $LN9@MinDisToNe

; 123  : 			return 0.0f;

	fldz
	jmp	$LN10@MinDisToNe
$LN9@MinDisToNe:

; 124  : 
; 125  : 		EControlCode eCtrlCode;
; 126  : 		m_pCharacterCoding->GetControlCode(pText, eCtrlCode, bDoTransfer);

	movzx	eax, BYTE PTR _bDoTransfer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _eCtrlCode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pText$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 127  : 		if(CTRLCODE_CHARACTER != eCtrlCode)

	cmp	DWORD PTR _eCtrlCode$[ebp], 0
	je	SHORT $LN8@MinDisToNe

; 128  : 			return 0.0f;

	fldz
	jmp	$LN10@MinDisToNe
$LN8@MinDisToNe:

; 129  : 
; 130  : 		const unsigned char *p = (unsigned char *)pText;

	mov	ecx, DWORD PTR _pText$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 131  : 		float fRet = 0.0f;

	fldz
	fstp	DWORD PTR _fRet$[ebp]

; 132  : 		float fWidth, fHeight;
; 133  : 		unsigned char cc[4];
; 134  : 		memset( cc, 0 ,sizeof( cc ) );

	push	4
	push	0
	lea	edx, DWORD PTR _cc$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 135  : 		int nLen;
; 136  : 		nLen = m_pCharacterCoding->GetAChar((const char*)p, cc);

	lea	eax, DWORD PTR _cc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+76]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR _nLen$[ebp], eax

; 137  : 
; 138  : 		if( m_pCharacterCoding->IsEnglish(cc) )			//

	lea	ecx, DWORD PTR _cc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+76]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@MinDisToNe
$LN6@MinDisToNe:

; 139  : 		{
; 140  : 			while(1)

	mov	edx, 1
	test	edx, edx
	je	$LN5@MinDisToNe

; 141  : 			{
; 142  : 				nLen = m_pCharacterCoding->GetAChar((const char*)p, cc);

	lea	eax, DWORD PTR _cc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+76]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR _nLen$[ebp], eax

; 143  : 				if( m_pCharacterCoding->IsEnglish(cc) )

	lea	ecx, DWORD PTR _cc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+76]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@MinDisToNe

; 144  : 				{
; 145  : 					GetCharExtent(cc, fWidth, fHeight);

	lea	edx, DWORD PTR _fHeight$[ebp]
	push	edx
	lea	eax, DWORD PTR _fWidth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 146  : 					fRet += fWidth;

	fld	DWORD PTR _fRet$[ebp]
	fadd	DWORD PTR _fWidth$[ebp]
	fstp	DWORD PTR _fRet$[ebp]

; 147  : 					p += nLen;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _nLen$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 148  : 
; 149  : 					if( m_pCharacterCoding->IsPunctuation(cc) )

	lea	ecx, DWORD PTR _cc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+76]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@MinDisToNe

; 150  : 						return fRet;

	fld	DWORD PTR _fRet$[ebp]
	jmp	SHORT $LN10@MinDisToNe
$LN3@MinDisToNe:

; 151  : 				}
; 152  : 				else

	jmp	SHORT $LN2@MinDisToNe
$LN4@MinDisToNe:

; 153  : 					return fRet;

	fld	DWORD PTR _fRet$[ebp]
	jmp	SHORT $LN10@MinDisToNe
$LN2@MinDisToNe:

; 154  : 			}

	jmp	$LN6@MinDisToNe
$LN5@MinDisToNe:

; 155  : 		}
; 156  : 		else									//

	jmp	SHORT $LN1@MinDisToNe
$LN7@MinDisToNe:

; 157  : 		{
; 158  : 			GetCharExtent(cc, fWidth, fHeight);

	lea	edx, DWORD PTR _fHeight$[ebp]
	push	edx
	lea	eax, DWORD PTR _fWidth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 159  : 			return fWidth;

	fld	DWORD PTR _fWidth$[ebp]
	jmp	SHORT $LN10@MinDisToNe
$LN1@MinDisToNe:

; 160  : 		}
; 161  : 
; 162  : 		return 0;

	fldz
$LN10@MinDisToNe:

; 163  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?MinDisToNewLine@RFontBase@Ogre@@IAEMPBD_N@Z ENDP	; Ogre::RFontBase::MinDisToNewLine
_TEXT	ENDS
PUBLIC	?GetCharSize@RFontBase@Ogre@@UAEXPBEAAM1@Z	; Ogre::RFontBase::GetCharSize
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_wChar$ = -4						; size = 2
_pChar$ = 8						; size = 4
_fWidth$ = 12						; size = 4
_fHeight$ = 16						; size = 4
?GetCharSize@RFontBase@Ogre@@UAEXPBEAAM1@Z PROC		; Ogre::RFontBase::GetCharSize
; _this$ = ecx

; 166  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 		wchar_t wChar = m_pCharacterCoding->ToUnicode(pChar);

	mov	eax, DWORD PTR _pChar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	mov	WORD PTR _wChar$[ebp], ax

; 168  : 		m_pGlyphMap->GetCharSize(wChar, fWidth, fHeight);

	mov	ecx, DWORD PTR _fHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fWidth$[ebp]
	push	edx
	movzx	eax, WORD PTR _wChar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 169  : 		fHeight = (float)m_nFontHeight;

	mov	ecx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _fHeight$[ebp]
	fstp	DWORD PTR [edx]

; 170  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetCharSize@RFontBase@Ogre@@UAEXPBEAAM1@Z ENDP		; Ogre::RFontBase::GetCharSize
_TEXT	ENDS
PUBLIC	?GetCharExtent@RFontBase@Ogre@@UAEXPBEAAM1@Z	; Ogre::RFontBase::GetCharExtent
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pChar$ = 8						; size = 4
_fWidth$ = 12						; size = 4
_fHeight$ = 16						; size = 4
?GetCharExtent@RFontBase@Ogre@@UAEXPBEAAM1@Z PROC	; Ogre::RFontBase::GetCharExtent
; _this$ = ecx

; 173  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 		GetCharSize(pChar, fWidth, fHeight);

	mov	eax, DWORD PTR _fHeight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pChar$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 175  : 		fWidth = (fWidth / m_nFontWidth) * m_fCharWidht;

	mov	ecx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _fWidth$[ebp]
	fdivr	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+52]
	mov	ecx, DWORD PTR _fWidth$[ebp]
	fstp	DWORD PTR [ecx]

; 176  : 		fHeight = (fHeight / m_nFontHeight) * m_fCharHeight;

	mov	edx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [edx+48]
	mov	eax, DWORD PTR _fHeight$[ebp]
	fdivr	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _fHeight$[ebp]
	fstp	DWORD PTR [edx]

; 177  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetCharExtent@RFontBase@Ogre@@UAEXPBEAAM1@Z ENDP	; Ogre::RFontBase::GetCharExtent
_TEXT	ENDS
PUBLIC	?SetupCharPoly@RFontBase@Ogre@@AAEXPAUDrawRect@2@MMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::SetupCharPoly
PUBLIC	??A?$vector@UDrawRect@Ogre@@V?$allocator@UDrawRect@Ogre@@@std@@@std@@QAEAAUDrawRect@Ogre@@I@Z ; std::vector<Ogre::DrawRect,std::allocator<Ogre::DrawRect> >::operator[]
PUBLIC	?DoRenderOneEmBoldenCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::DoRenderOneEmBoldenCharacter
PUBLIC	?DoRenderOneBorderCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::DoRenderOneBorderCharacter
PUBLIC	?DoRenderOneShadowCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::DoRenderOneShadowCharacter
PUBLIC	?ValidateMaxCharactersToRender@RFontBase@Ogre@@AAEXPAXM@Z ; Ogre::RFontBase::ValidateMaxCharactersToRender
PUBLIC	?DoRenderOneCharacter@RFontBase@Ogre@@AAEXAAPBDAAMMPAXIMMABV?$TRect@M@2@ABVColorQuad@2@4MH@Z ; Ogre::RFontBase::DoRenderOneCharacter
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_firstDrawRect$ = -4					; size = 4
_pszParseText$ = 8					; size = 4
_fCurX$ = 12						; size = 4
_fCurY$ = 16						; size = 4
_hUiResTp$ = 20						; size = 4
_dwStyle$ = 24						; size = 4
_fOneCharWidth$ = 28					; size = 4
_fOneCharHeight$ = 32					; size = 4
_rectUV$ = 36						; size = 4
_shadowColor$ = 40					; size = 4
_curColor$ = 44						; size = 4
_fZ$ = 48						; size = 4
_nPassBytes$ = 52					; size = 4
?DoRenderOneCharacter@RFontBase@Ogre@@AAEXAAPBDAAMMPAXIMMABV?$TRect@M@2@ABVColorQuad@2@4MH@Z PROC ; Ogre::RFontBase::DoRenderOneCharacter
; _this$ = ecx

; 183  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 184  : 		if ( m_hUiRes != hUiResTp )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	cmp	ecx, DWORD PTR _hUiResTp$[ebp]
	je	SHORT $LN6@DoRenderOn

; 185  : 		{
; 186  : 			ValidateMaxCharactersToRender( hUiResTp, fZ );

	push	ecx
	fld	DWORD PTR _fZ$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _hUiResTp$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateMaxCharactersToRender@RFontBase@Ogre@@AAEXPAXM@Z ; Ogre::RFontBase::ValidateMaxCharactersToRender

; 187  : 			return;

	jmp	$LN7@DoRenderOn
$LN6@DoRenderOn:

; 188  : 		}
; 189  : 
; 190  : 		//
; 191  : 		
; 192  : 		if ( dwStyle == FONTSYTLE_SHADOW )

	cmp	DWORD PTR _dwStyle$[ebp], 1
	jne	SHORT $LN5@DoRenderOn

; 193  : 		{
; 194  : 			DoRenderOneShadowCharacter( fCurX, fCurY, fOneCharWidth, fOneCharHeight, rectUV, shadowColor );

	mov	eax, DWORD PTR _shadowColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rectUV$[ebp]
	push	ecx
	push	ecx
	fld	DWORD PTR _fOneCharHeight$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fOneCharWidth$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fCurY$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _fCurX$[ebp]
	push	ecx
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRenderOneShadowCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::DoRenderOneShadowCharacter
	jmp	SHORT $LN1@DoRenderOn
$LN5@DoRenderOn:

; 195  : 		}
; 196  : 		else if ( dwStyle == FONTSYTLE_BORDER )

	cmp	DWORD PTR _dwStyle$[ebp], 2
	jne	SHORT $LN3@DoRenderOn

; 197  : 		{
; 198  : 			DoRenderOneBorderCharacter( fCurX, fCurY, fOneCharWidth, fOneCharHeight, rectUV, shadowColor );

	mov	eax, DWORD PTR _shadowColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rectUV$[ebp]
	push	ecx
	push	ecx
	fld	DWORD PTR _fOneCharHeight$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fOneCharWidth$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fCurY$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _fCurX$[ebp]
	push	ecx
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRenderOneBorderCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::DoRenderOneBorderCharacter
	jmp	SHORT $LN1@DoRenderOn
$LN3@DoRenderOn:

; 199  : 		}
; 200  : 		else if ( dwStyle == FONTSYTLE_EMBOLDEN )

	cmp	DWORD PTR _dwStyle$[ebp], 3
	jne	SHORT $LN1@DoRenderOn

; 201  : 		{
; 202  : 			DoRenderOneEmBoldenCharacter( fCurX, fCurY, fOneCharWidth, fOneCharHeight, rectUV, shadowColor );

	mov	eax, DWORD PTR _shadowColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rectUV$[ebp]
	push	ecx
	push	ecx
	fld	DWORD PTR _fOneCharHeight$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fOneCharWidth$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fCurY$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _fCurX$[ebp]
	push	ecx
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRenderOneEmBoldenCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::DoRenderOneEmBoldenCharacter
$LN1@DoRenderOn:

; 203  : 		}
; 204  : 
; 205  : 		DrawRect& firstDrawRect = m_vecDrawRect[0];

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??A?$vector@UDrawRect@Ogre@@V?$allocator@UDrawRect@Ogre@@@std@@@std@@QAEAAUDrawRect@Ogre@@I@Z ; std::vector<Ogre::DrawRect,std::allocator<Ogre::DrawRect> >::operator[]
	mov	DWORD PTR _firstDrawRect$[ebp], eax

; 206  : 		SetupCharPoly(&firstDrawRect + m_nShowPolyNum, fCurX, fCurY, fOneCharWidth, fOneCharHeight, rectUV, curColor);

	mov	eax, DWORD PTR _curColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rectUV$[ebp]
	push	ecx
	push	ecx
	fld	DWORD PTR _fOneCharHeight$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fOneCharWidth$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fCurY$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _fCurX$[ebp]
	push	ecx
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	imul	ecx, 36					; 00000024H
	add	ecx, DWORD PTR _firstDrawRect$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupCharPoly@RFontBase@Ogre@@AAEXPAUDrawRect@2@MMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::SetupCharPoly

; 207  : 		m_nShowPolyNum++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], eax

; 208  : 		m_nShowCharNum++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], eax

; 209  : 
; 210  : 		pszParseText	+= nPassBytes;

	mov	edx, DWORD PTR _pszParseText$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _nPassBytes$[ebp]
	mov	ecx, DWORD PTR _pszParseText$[ebp]
	mov	DWORD PTR [ecx], eax

; 211  : 		fCurX			+= fOneCharWidth;

	mov	edx, DWORD PTR _fCurX$[ebp]
	fld	DWORD PTR [edx]
	fadd	DWORD PTR _fOneCharWidth$[ebp]
	mov	eax, DWORD PTR _fCurX$[ebp]
	fstp	DWORD PTR [eax]

; 212  : 		ValidateMaxCharactersToRender( hUiResTp, fZ );

	push	ecx
	fld	DWORD PTR _fZ$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _hUiResTp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateMaxCharactersToRender@RFontBase@Ogre@@AAEXPAXM@Z ; Ogre::RFontBase::ValidateMaxCharactersToRender
$LN7@DoRenderOn:

; 213  : 	}

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
?DoRenderOneCharacter@RFontBase@Ogre@@AAEXAAPBDAAMMPAXIMMABV?$TRect@M@2@ABVColorQuad@2@4MH@Z ENDP ; Ogre::RFontBase::DoRenderOneCharacter
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefontbase.h
_TEXT	ENDS
;	COMDAT ?DoRenderOneShadowCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z
_TEXT	SEGMENT
tv93 = -16						; size = 4
tv92 = -12						; size = 4
_this$ = -8						; size = 4
_firstDrawRect$ = -4					; size = 4
_fCurX$ = 8						; size = 4
_fCurY$ = 12						; size = 4
_fOneCharWidth$ = 16					; size = 4
_fOneCharHeight$ = 20					; size = 4
_rectUV$ = 24						; size = 4
_shadowColor$ = 28					; size = 4
?DoRenderOneShadowCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z PROC ; Ogre::RFontBase::DoRenderOneShadowCharacter, COMDAT
; _this$ = ecx

; 337  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 338  : 		DrawRect& firstDrawRect = m_vecDrawRect[0];

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??A?$vector@UDrawRect@Ogre@@V?$allocator@UDrawRect@Ogre@@@std@@@std@@QAEAAUDrawRect@Ogre@@I@Z ; std::vector<Ogre::DrawRect,std::allocator<Ogre::DrawRect> >::operator[]
	mov	DWORD PTR _firstDrawRect$[ebp], eax

; 339  : 		SetupCharPoly( &firstDrawRect + m_nShowPolyNum, fCurX + 1.0f, fCurY + 1.0f, fOneCharWidth, fOneCharHeight, 
; 340  : 			rectUV, shadowColor);

	mov	eax, DWORD PTR _shadowColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rectUV$[ebp]
	push	ecx
	push	ecx
	fld	DWORD PTR _fOneCharHeight$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fOneCharWidth$[ebp]
	fstp	DWORD PTR [esp]
	fld	DWORD PTR _fCurY$[ebp]
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR _fCurX$[ebp]
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	DWORD PTR tv93[ebp]
	fld	DWORD PTR tv93[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	imul	eax, 36					; 00000024H
	add	eax, DWORD PTR _firstDrawRect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupCharPoly@RFontBase@Ogre@@AAEXPAUDrawRect@2@MMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::SetupCharPoly

; 341  : 		m_nShowPolyNum++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], edx

; 342  : 	}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?DoRenderOneShadowCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ENDP ; Ogre::RFontBase::DoRenderOneShadowCharacter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DoRenderOneBorderCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fCurX$ = 8						; size = 4
_fCurY$ = 12						; size = 4
_fOneCharWidth$ = 16					; size = 4
_fOneCharHeight$ = 20					; size = 4
_rectUV$ = 24						; size = 4
_shadowColor$ = 28					; size = 4
?DoRenderOneBorderCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z PROC ; Ogre::RFontBase::DoRenderOneBorderCharacter, COMDAT
; _this$ = ecx

; 346  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 347  : 		/*DrawRect& firstDrawRect = m_vecDrawRect[0];
; 348  : 		SetupCharPoly( &firstDrawRect + m_nShowPolyNum, fCurX - 1.0f, fCurY - 1.0f, fOneCharWidth + 2.0f, 
; 349  : 						fOneCharHeight + 2.0f, rectUV, shadowColor );
; 350  : 		m_nShowPolyNum++;*/
; 351  : 
; 352  : 		DoRenderOneShadowCharacter( fCurX, fCurY, fOneCharWidth, fOneCharHeight, rectUV, shadowColor );

	mov	eax, DWORD PTR _shadowColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rectUV$[ebp]
	push	ecx
	push	ecx
	fld	DWORD PTR _fOneCharHeight$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fOneCharWidth$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fCurY$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fCurX$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRenderOneShadowCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::DoRenderOneShadowCharacter

; 353  : 
; 354  : 		/*SetupCharPoly( &firstDrawRect + m_nShowPolyNum, fCurX - 1.0f, fCurY, fOneCharWidth, fOneCharHeight, 
; 355  : 			rectUV, shadowColor );
; 356  : 		m_nShowPolyNum++;
; 357  : 
; 358  : 		SetupCharPoly( &firstDrawRect + m_nShowPolyNum, fCurX + 1.0f, fCurY, fOneCharWidth, fOneCharHeight, 
; 359  : 			rectUV, shadowColor );
; 360  : 		m_nShowPolyNum++;
; 361  : 
; 362  : 		SetupCharPoly( &firstDrawRect + m_nShowPolyNum, fCurX, fCurY - 1.0f, fOneCharWidth, fOneCharHeight, 
; 363  : 			rectUV, shadowColor );
; 364  : 		m_nShowPolyNum++;
; 365  : 
; 366  : 		SetupCharPoly( &firstDrawRect + m_nShowPolyNum, fCurX, fCurY + 1.0f, fOneCharWidth, fOneCharHeight, 
; 367  : 			rectUV, shadowColor );
; 368  : 		m_nShowPolyNum++;*/
; 369  : 	}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?DoRenderOneBorderCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ENDP ; Ogre::RFontBase::DoRenderOneBorderCharacter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DoRenderOneEmBoldenCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fCurX$ = 8						; size = 4
_fCurY$ = 12						; size = 4
_fOneCharWidth$ = 16					; size = 4
_fOneCharHeight$ = 20					; size = 4
_rectUV$ = 24						; size = 4
_shadowColor$ = 28					; size = 4
?DoRenderOneEmBoldenCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z PROC ; Ogre::RFontBase::DoRenderOneEmBoldenCharacter, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		/*SetupCharPoly(&firstDrawRect + m_nShowPolyNum, fCurX - 0.2f, fCurY, fOneCharWidth, fOneCharHeight, rectUV, shadowColor);
; 375  : 		m_nShowPolyNum++;
; 376  : 		SetupCharPoly(&firstDrawRect + m_nShowPolyNum, fCurX + 0.2f, fCurY, fOneCharWidth, fOneCharHeight, rectUV, shadowColor);
; 377  : 		m_nShowPolyNum++;
; 378  : 		SetupCharPoly(&firstDrawRect + m_nShowPolyNum, fCurX, fCurY - 0.2f, fOneCharWidth, fOneCharHeight, rectUV, shadowColor);
; 379  : 		m_nShowPolyNum++;
; 380  : 		SetupCharPoly(&firstDrawRect + m_nShowPolyNum, fCurX, fCurY + 0.2f, fOneCharWidth, fOneCharHeight, rectUV, shadowColor);
; 381  : 		m_nShowPolyNum++;*/
; 382  : 	}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?DoRenderOneEmBoldenCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ENDP ; Ogre::RFontBase::DoRenderOneEmBoldenCharacter
_TEXT	ENDS
PUBLIC	?RenderText@RFontBase@Ogre@@QAEXM@Z		; Ogre::RFontBase::RenderText
; Function compile flags: /Odtp
;	COMDAT ?ValidateMaxCharactersToRender@RFontBase@Ogre@@AAEXPAXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hUiResTp$ = 8						; size = 4
_fZ$ = 12						; size = 4
?ValidateMaxCharactersToRender@RFontBase@Ogre@@AAEXPAXM@Z PROC ; Ogre::RFontBase::ValidateMaxCharactersToRender, COMDAT
; _this$ = ecx

; 385  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 386  : 		// 
; 387  : 		if( m_nShowCharNum >= m_nMaxCacheSize || m_nShowPolyNum+8>=RFONT_MAXPOLYNUM || m_hUiRes != hUiResTp)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+88]
	cmp	edx, DWORD PTR [ecx+64]
	jge	SHORT $LN1@ValidateMa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, 8
	cmp	ecx, 2048				; 00000800H
	jge	SHORT $LN1@ValidateMa
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	cmp	eax, DWORD PTR _hUiResTp$[ebp]
	je	SHORT $LN2@ValidateMa
$LN1@ValidateMa:

; 388  : 		{
; 389  : 			RenderText(fZ);

	push	ecx
	fld	DWORD PTR _fZ$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenderText@RFontBase@Ogre@@QAEXM@Z	; Ogre::RFontBase::RenderText

; 390  : 			m_nShowCharNum = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 0
$LN2@ValidateMa:

; 391  : 		}
; 392  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?ValidateMaxCharactersToRender@RFontBase@Ogre@@AAEXPAXM@Z ENDP ; Ogre::RFontBase::ValidateMaxCharactersToRender
_TEXT	ENDS
PUBLIC	?set@?$TRect@M@Ogre@@QAEXMMMM@Z			; Ogre::TRect<float>::set
; Function compile flags: /Odtp
;	COMDAT ?SetupCharPoly@RFontBase@Ogre@@AAEXPAUDrawRect@2@MMMMABV?$TRect@M@2@ABVColorQuad@2@@Z
_TEXT	SEGMENT
tv84 = -20						; size = 4
tv83 = -16						; size = 4
_this$ = -12						; size = 4
_oneDrawUVRect$ = -8					; size = 4
_oneDrawScreenRect$ = -4				; size = 4
_pPolys$ = 8						; size = 4
_fX$ = 12						; size = 4
_fY$ = 16						; size = 4
_fW$ = 20						; size = 4
_fH$ = 24						; size = 4
_rectUV$ = 28						; size = 4
_color$ = 32						; size = 4
?SetupCharPoly@RFontBase@Ogre@@AAEXPAUDrawRect@2@MMMMABV?$TRect@M@2@ABVColorQuad@2@@Z PROC ; Ogre::RFontBase::SetupCharPoly, COMDAT
; _this$ = ecx

; 396  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 397  : 		RectFloat&	oneDrawScreenRect	= pPolys->rect;

	mov	eax, DWORD PTR _pPolys$[ebp]
	mov	DWORD PTR _oneDrawScreenRect$[ebp], eax

; 398  : 		RectFloat&	oneDrawUVRect		= pPolys->rectUV;

	mov	ecx, DWORD PTR _pPolys$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _oneDrawUVRect$[ebp], ecx

; 399  : 		oneDrawScreenRect.set(fX, fY, fX+fW, fY+fH);

	fld	DWORD PTR _fY$[ebp]
	fadd	DWORD PTR _fH$[ebp]
	fstp	DWORD PTR tv83[ebp]
	fld	DWORD PTR tv83[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR _fX$[ebp]
	fadd	DWORD PTR _fW$[ebp]
	fstp	DWORD PTR tv84[ebp]
	fld	DWORD PTR tv84[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fY$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fX$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneDrawScreenRect$[ebp]
	call	?set@?$TRect@M@Ogre@@QAEXMMMM@Z		; Ogre::TRect<float>::set

; 400  : 		oneDrawUVRect = rectUV;

	mov	edx, DWORD PTR _rectUV$[ebp]
	mov	eax, DWORD PTR _oneDrawUVRect$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx

; 401  : 		pPolys->color = color;

	mov	eax, DWORD PTR _color$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pPolys$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 402  : 	}

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?SetupCharPoly@RFontBase@Ogre@@AAEXPAUDrawRect@2@MMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ENDP ; Ogre::RFontBase::SetupCharPoly
_TEXT	ENDS
PUBLIC	?PrepareRenderOneCharacter@RFontBase@Ogre@@AAEXPAEAAM1AAV?$TRect@M@2@AAPAXAAHAAVColorQuad@2@ABV42@MPBD@Z ; Ogre::RFontBase::PrepareRenderOneCharacter
PUBLIC	??0?$TRect@M@Ogre@@QAE@XZ			; Ogre::TRect<float>::TRect<float>
PUBLIC	?OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@2@MIABV32@M@Z ; Ogre::RFontBase::OnParseNormalCharacter
;	COMDAT ?rectUV@?1??OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@3@MIABV43@M@Z@4V?$TRect@M@3@A
; File i:\svnroot\client\ogremain\ogrefontbase.cpp
_BSS	SEGMENT
?rectUV@?1??OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@3@MIABV43@M@Z@4V?$TRect@M@3@A DB 010H DUP (?) ; `Ogre::RFontBase::OnParseNormalCharacter'::`2'::rectUV
_BSS	ENDS
;	COMDAT ?$S5@?1??OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@3@MIABV43@M@Z@4IA
_BSS	SEGMENT
?$S5@?1??OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@3@MIABV43@M@Z@4IA DD 01H DUP (?) ; `Ogre::RFontBase::OnParseNormalCharacter'::`2'::$S5
_BSS	ENDS
xdata$x	SEGMENT
__unwindtable$?OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@2@MIABV32@M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@2@MIABV32@M@Z$0
__ehfuncinfo$?OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@2@MIABV32@M@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@2@MIABV32@M@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -36						; size = 4
_fOneCharWidth$ = -32					; size = 4
_szCurRenderCharacter$ = -28				; size = 4
_fOneCharHeight$ = -24					; size = 4
_hUiResTp$ = -20					; size = 4
_nPassBytes$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_fCurX$ = 8						; size = 4
_fCurY$ = 12						; size = 4
_pszParseText$ = 16					; size = 4
_shadowColor$ = 20					; size = 4
_fScale$ = 24						; size = 4
_dwStyle$ = 28						; size = 4
_curColor$ = 32						; size = 4
_fZ$ = 36						; size = 4
?OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@2@MIABV32@M@Z PROC ; Ogre::RFontBase::OnParseNormalCharacter
; _this$ = ecx

; 218  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@2@MIABV32@M@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 219  : 		float fOneCharWidth		= 0.0f;

	fldz
	fstp	DWORD PTR _fOneCharWidth$[ebp]

; 220  : 		float fOneCharHeight	= 0.0f;

	fldz
	fstp	DWORD PTR _fOneCharHeight$[ebp]

; 221  : 		HUIRES hUiResTp			= NULL;

	mov	DWORD PTR _hUiResTp$[ebp], 0

; 222  : 
; 223  : 		static RectFloat rectUV;

	mov	eax, DWORD PTR ?$S5@?1??OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@3@MIABV43@M@Z@4IA
	and	eax, 1
	jne	SHORT $LN1@OnParseNor
	mov	ecx, DWORD PTR ?$S5@?1??OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@3@MIABV43@M@Z@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S5@?1??OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@3@MIABV43@M@Z@4IA, ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET ?rectUV@?1??OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@3@MIABV43@M@Z@4V?$TRect@M@3@A
	call	??0?$TRect@M@Ogre@@QAE@XZ		; Ogre::TRect<float>::TRect<float>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN1@OnParseNor:

; 224  : 
; 225  : 		//
; 226  : 		unsigned char szCurRenderCharacter[4] = { '\0' } ;

	mov	BYTE PTR _szCurRenderCharacter$[ebp], 0
	xor	edx, edx
	mov	WORD PTR _szCurRenderCharacter$[ebp+1], dx
	mov	BYTE PTR _szCurRenderCharacter$[ebp+3], dl

; 227  : 		int nPassBytes = 0;

	mov	DWORD PTR _nPassBytes$[ebp], 0

; 228  : 		PrepareRenderOneCharacter( szCurRenderCharacter, fOneCharWidth, fOneCharHeight, rectUV, hUiResTp,
; 229  : 									nPassBytes, shadowColor, curColor, fScale, pszParseText );

	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	ecx
	fld	DWORD PTR _fScale$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _curColor$[ebp]
	push	edx
	mov	eax, DWORD PTR _shadowColor$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nPassBytes$[ebp]
	push	ecx
	lea	edx, DWORD PTR _hUiResTp$[ebp]
	push	edx
	push	OFFSET ?rectUV@?1??OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@3@MIABV43@M@Z@4V?$TRect@M@3@A
	lea	eax, DWORD PTR _fOneCharHeight$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fOneCharWidth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szCurRenderCharacter$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrepareRenderOneCharacter@RFontBase@Ogre@@AAEXPAEAAM1AAV?$TRect@M@2@AAPAXAAHAAVColorQuad@2@ABV42@MPBD@Z ; Ogre::RFontBase::PrepareRenderOneCharacter

; 230  : 
; 231  : 		DoRenderOneCharacter( pszParseText, fCurX, fCurY, hUiResTp, dwStyle, fOneCharWidth, fOneCharHeight,
; 232  : 								rectUV, shadowColor, curColor, fZ, nPassBytes );

	mov	eax, DWORD PTR _nPassBytes$[ebp]
	push	eax
	push	ecx
	fld	DWORD PTR _fZ$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _curColor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _shadowColor$[ebp]
	push	edx
	push	OFFSET ?rectUV@?1??OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@3@MIABV43@M@Z@4V?$TRect@M@3@A
	push	ecx
	fld	DWORD PTR _fOneCharHeight$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fOneCharWidth$[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _dwStyle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hUiResTp$[ebp]
	push	ecx
	push	ecx
	fld	DWORD PTR _fCurY$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _fCurX$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszParseText$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRenderOneCharacter@RFontBase@Ogre@@AAEXAAPBDAAMMPAXIMMABV?$TRect@M@2@ABVColorQuad@2@4MH@Z ; Ogre::RFontBase::DoRenderOneCharacter

; 233  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@2@MIABV32@M@Z$0:
	mov	eax, DWORD PTR ?$S5@?1??OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@3@MIABV43@M@Z@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S5@?1??OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@3@MIABV43@M@Z@4IA, eax
	ret	0
__ehhandler$?OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@2@MIABV32@M@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@2@MIABV32@M@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@2@MIABV32@M@Z ENDP ; Ogre::RFontBase::OnParseNormalCharacter
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefontbase.h
;	COMDAT ?PrepareRenderOneCharacter@RFontBase@Ogre@@AAEXPAEAAM1AAV?$TRect@M@2@AAPAXAAHAAVColorQuad@2@ABV42@MPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_szCurRenderCharacter$ = 8				; size = 4
_fOneCharWidth$ = 12					; size = 4
_fOneCharHeight$ = 16					; size = 4
_rectUV$ = 20						; size = 4
_hUiResTp$ = 24						; size = 4
_nPassBytes$ = 28					; size = 4
_shadowColor$ = 32					; size = 4
_curColor$ = 36						; size = 4
_fScale$ = 40						; size = 4
_pszParseText$ = 44					; size = 4
?PrepareRenderOneCharacter@RFontBase@Ogre@@AAEXPAEAAM1AAV?$TRect@M@2@AAPAXAAHAAVColorQuad@2@ABV42@MPBD@Z PROC ; Ogre::RFontBase::PrepareRenderOneCharacter, COMDAT
; _this$ = ecx

; 318  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 319  : 		nPassBytes = m_pCharacterCoding->GetAChar( pszParseText, szCurRenderCharacter );

	mov	eax, DWORD PTR _szCurRenderCharacter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszParseText$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+76]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _nPassBytes$[ebp]
	mov	DWORD PTR [ecx], eax

; 320  : 		//
; 321  : 		GetCharExtent( szCurRenderCharacter, fOneCharWidth, fOneCharHeight );

	mov	edx, DWORD PTR _fOneCharHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _fOneCharWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szCurRenderCharacter$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 322  : 		//
; 323  : 		TextureMap( szCurRenderCharacter, hUiResTp, rectUV );

	mov	eax, DWORD PTR _rectUV$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hUiResTp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szCurRenderCharacter$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 324  : 
; 325  : 		if( NULL == m_hUiRes )	

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	jne	SHORT $LN1@PrepareRen

; 326  : 		{
; 327  : 			m_hUiRes = hUiResTp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _hUiResTp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+92], ecx
$LN1@PrepareRen:

; 328  : 		}
; 329  : 
; 330  : 		fOneCharWidth	*= fScale;

	mov	edx, DWORD PTR _fOneCharWidth$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR _fScale$[ebp]
	mov	eax, DWORD PTR _fOneCharWidth$[ebp]
	fstp	DWORD PTR [eax]

; 331  : 		fOneCharHeight	*= fScale;

	mov	ecx, DWORD PTR _fOneCharHeight$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR _fScale$[ebp]
	mov	edx, DWORD PTR _fOneCharHeight$[ebp]
	fstp	DWORD PTR [edx]

; 332  : 		shadowColor.a	= curColor.a;

	mov	eax, DWORD PTR _shadowColor$[ebp]
	mov	ecx, DWORD PTR _curColor$[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 333  : 	}

	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
?PrepareRenderOneCharacter@RFontBase@Ogre@@AAEXPAEAAM1AAV?$TRect@M@2@AAPAXAAHAAVColorQuad@2@ABV42@MPBD@Z ENDP ; Ogre::RFontBase::PrepareRenderOneCharacter
_TEXT	ENDS
PUBLIC	?set@ColorQuad@Ogre@@QAEXEEEE@Z			; Ogre::ColorQuad::set
PUBLIC	?OnParseTransferCharacter@RFontBase@Ogre@@AAEXAAPBDAAVColorQuad@2@AA_NAAHABV32@@Z ; Ogre::RFontBase::OnParseTransferCharacter
EXTRN	__imp__timeGetTime@0:PROC
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefontbase.cpp
_TEXT	SEGMENT
tv66 = -16						; size = 4
_this$ = -12						; size = 4
_n$120740 = -8						; size = 4
_chNextChar$120732 = -1					; size = 1
_pszParseText$ = 8					; size = 4
_curColor$ = 12						; size = 4
_bBlink$ = 16						; size = 4
_nBlinkModel$ = 20					; size = 4
_initColor$ = 24					; size = 4
?OnParseTransferCharacter@RFontBase@Ogre@@AAEXAAPBDAAVColorQuad@2@AA_NAAHABV32@@Z PROC ; Ogre::RFontBase::OnParseTransferCharacter
; _this$ = ecx

; 237  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 238  : 		switch ( *pszParseText )

	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv66[ebp], edx
	mov	eax, DWORD PTR tv66[ebp]
	sub	eax, 66					; 00000042H
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 44			; 0000002cH
	ja	$LN20@OnParseTra
	mov	ecx, DWORD PTR tv66[ebp]
	movzx	edx, BYTE PTR $LN24@OnParseTra[ecx]
	jmp	DWORD PTR $LN25@OnParseTra[edx*4]
$LN19@OnParseTra:

; 239  : 		{
; 240  : 		case 'R':
; 241  : 			curColor.set(255,100,0,255);

	push	255					; 000000ffH
	push	0
	push	100					; 00000064H
	push	255					; 000000ffH
	mov	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set

; 242  : 			pszParseText += 1;

	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _pszParseText$[ebp]
	mov	DWORD PTR [edx], ecx

; 243  : 			break;

	jmp	$LN20@OnParseTra
$LN18@OnParseTra:

; 244  : 		case 'G':
; 245  : 			curColor.set(0,255,0,255);

	push	255					; 000000ffH
	push	0
	push	255					; 000000ffH
	push	0
	mov	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set

; 246  : 			pszParseText += 1;

	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _pszParseText$[ebp]
	mov	DWORD PTR [edx], ecx

; 247  : 			break;

	jmp	$LN20@OnParseTra
$LN17@OnParseTra:

; 248  : 		case 'B':
; 249  : 			curColor.set(0,128,255,255);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	128					; 00000080H
	push	0
	mov	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set

; 250  : 			pszParseText += 1;

	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _pszParseText$[ebp]
	mov	DWORD PTR [edx], ecx

; 251  : 			break;

	jmp	$LN20@OnParseTra
$LN16@OnParseTra:

; 252  : 		case 'K':
; 253  : 			curColor.set(0,0,0,255);

	push	255					; 000000ffH
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set

; 254  : 			pszParseText += 1;

	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _pszParseText$[ebp]
	mov	DWORD PTR [edx], ecx

; 255  : 			break;

	jmp	$LN20@OnParseTra
$LN15@OnParseTra:

; 256  : 		case 'Y':
; 257  : 			curColor.set(255,255,0,255);

	push	255					; 000000ffH
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	mov	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set

; 258  : 			pszParseText += 1;

	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _pszParseText$[ebp]
	mov	DWORD PTR [edx], ecx

; 259  : 			break;	

	jmp	$LN20@OnParseTra
$LN14@OnParseTra:

; 260  : 		case 'W':
; 261  : 			curColor.set(255,255,255,255);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	mov	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set

; 262  : 			pszParseText += 1;

	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _pszParseText$[ebp]
	mov	DWORD PTR [edx], ecx

; 263  : 			break;

	jmp	$LN20@OnParseTra
$LN13@OnParseTra:

; 264  : 		case 'n':
; 265  : 			curColor		= initColor;

	mov	eax, DWORD PTR _initColor$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _curColor$[ebp]
	mov	DWORD PTR [edx], ecx

; 266  : 			pszParseText	+= 1;

	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _pszParseText$[ebp]
	mov	DWORD PTR [edx], ecx

; 267  : 			bBlink			= false;

	mov	eax, DWORD PTR _bBlink$[ebp]
	mov	BYTE PTR [eax], 0

; 268  : 			break;

	jmp	SHORT $LN20@OnParseTra
$LN12@OnParseTra:

; 269  : 		case 'b':
; 270  : 			{
; 271  : 				bBlink = true;

	mov	ecx, DWORD PTR _bBlink$[ebp]
	mov	BYTE PTR [ecx], 1

; 272  : 				char chNextChar = *( pszParseText + 1 );

	mov	edx, DWORD PTR _pszParseText$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _chNextChar$120732[ebp], cl

; 273  : 				if ( chNextChar == '1' )

	movsx	edx, BYTE PTR _chNextChar$120732[ebp]
	cmp	edx, 49					; 00000031H
	jne	SHORT $LN11@OnParseTra

; 274  : 				{
; 275  : 					nBlinkModel = BLINKMODEL_SMOOTH;

	mov	eax, DWORD PTR _nBlinkModel$[ebp]
	mov	DWORD PTR [eax], 1

; 276  : 					pszParseText += 2;

	mov	ecx, DWORD PTR _pszParseText$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 2
	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN20@OnParseTra
$LN11@OnParseTra:

; 277  : 				}
; 278  : 				else if ( chNextChar == '2' )

	movsx	ecx, BYTE PTR _chNextChar$120732[ebp]
	cmp	ecx, 50					; 00000032H
	jne	SHORT $LN9@OnParseTra

; 279  : 				{
; 280  : 					nBlinkModel = BLINKMODEL_SUDDEN;

	mov	edx, DWORD PTR _nBlinkModel$[ebp]
	mov	DWORD PTR [edx], 2

; 281  : 					pszParseText += 2;

	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _pszParseText$[ebp]
	mov	DWORD PTR [edx], ecx

; 282  : 				}
; 283  : 				else

	jmp	SHORT $LN20@OnParseTra
$LN9@OnParseTra:

; 284  : 				{
; 285  : 					nBlinkModel = BLINKMODEL_SMOOTH;

	mov	eax, DWORD PTR _nBlinkModel$[ebp]
	mov	DWORD PTR [eax], 1

; 286  : 					pszParseText += 1;

	mov	ecx, DWORD PTR _pszParseText$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	DWORD PTR [eax], edx
$LN20@OnParseTra:

; 287  : 				}
; 288  : 			}
; 289  : 			break;
; 290  : 
; 291  : 		default:
; 292  : 			break;
; 293  : 		}
; 294  : 		
; 295  : 		if ( !bBlink )

	mov	ecx, DWORD PTR _bBlink$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN6@OnParseTra

; 296  : 		{
; 297  : 			return;

	jmp	$LN22@OnParseTra
$LN6@OnParseTra:

; 298  : 		}
; 299  : 
; 300  : 		if( nBlinkModel == BLINKMODEL_SMOOTH )

	mov	eax, DWORD PTR _nBlinkModel$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN5@OnParseTra

; 301  : 		{
; 302  : 			int n = timeGetTime() % BLINK_CIRCLE;

	call	DWORD PTR __imp__timeGetTime@0
	xor	edx, edx
	mov	ecx, 1200				; 000004b0H
	div	ecx
	mov	DWORD PTR _n$120740[ebp], edx

; 303  : 			if(n >= BLINK_HALFCIRCLE)

	cmp	DWORD PTR _n$120740[ebp], 600		; 00000258H
	jl	SHORT $LN4@OnParseTra

; 304  : 				n = BLINK_CIRCLE - n - 1;

	mov	edx, 1200				; 000004b0H
	sub	edx, DWORD PTR _n$120740[ebp]
	sub	edx, 1
	mov	DWORD PTR _n$120740[ebp], edx
$LN4@OnParseTra:

; 305  : 			n = n * 320 / BLINK_HALFCIRCLE;

	mov	eax, DWORD PTR _n$120740[ebp]
	imul	eax, 320				; 00000140H
	cdq
	mov	ecx, 600				; 00000258H
	idiv	ecx
	mov	DWORD PTR _n$120740[ebp], eax

; 306  : 			if(n > 255)

	cmp	DWORD PTR _n$120740[ebp], 255		; 000000ffH
	jle	SHORT $LN3@OnParseTra

; 307  : 				n = 255;

	mov	DWORD PTR _n$120740[ebp], 255		; 000000ffH
$LN3@OnParseTra:

; 308  : 			curColor.set(curColor.r, curColor.g, curColor.b, (UINT8)n);

	movzx	edx, BYTE PTR _n$120740[ebp]
	push	edx
	mov	eax, DWORD PTR _curColor$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _curColor$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	mov	ecx, DWORD PTR _curColor$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	mov	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set

; 309  : 		}
; 310  : 		else

	jmp	SHORT $LN22@OnParseTra
$LN5@OnParseTra:

; 311  : 		{
; 312  : 			if( (timeGetTime() / BLINK_HALFCIRCLE) % 2 )

	call	DWORD PTR __imp__timeGetTime@0
	xor	edx, edx
	mov	ecx, 600				; 00000258H
	div	ecx
	xor	edx, edx
	mov	ecx, 2
	div	ecx
	test	edx, edx
	je	SHORT $LN22@OnParseTra

; 313  : 				curColor.set(0,0,0,0);

	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set
$LN22@OnParseTra:

; 314  : 		}
; 315  : 	}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	3
$LN25@OnParseTra:
	DD	$LN17@OnParseTra
	DD	$LN18@OnParseTra
	DD	$LN16@OnParseTra
	DD	$LN19@OnParseTra
	DD	$LN14@OnParseTra
	DD	$LN15@OnParseTra
	DD	$LN12@OnParseTra
	DD	$LN13@OnParseTra
	DD	$LN20@OnParseTra
$LN24@OnParseTra:
	DB	0
	DB	8
	DB	8
	DB	8
	DB	8
	DB	1
	DB	8
	DB	8
	DB	8
	DB	2
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	3
	DB	8
	DB	8
	DB	8
	DB	8
	DB	4
	DB	8
	DB	5
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	7
?OnParseTransferCharacter@RFontBase@Ogre@@AAEXAAPBDAAVColorQuad@2@AA_NAAHABV32@@Z ENDP ; Ogre::RFontBase::OnParseTransferCharacter
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrecolourvalue.h
_TEXT	ENDS
;	COMDAT ?set@ColorQuad@Ogre@@QAEXEEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r1$ = 8						; size = 1
_g1$ = 12						; size = 1
_b1$ = 16						; size = 1
_a1$ = 20						; size = 1
?set@ColorQuad@Ogre@@QAEXEEEE@Z PROC			; Ogre::ColorQuad::set, COMDAT
; _this$ = ecx

; 362  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 363  : 			r = r1, g = g1, b = b1, a = a1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _r1$[ebp]
	mov	BYTE PTR [eax+2], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _g1$[ebp]
	mov	BYTE PTR [edx+1], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _b1$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _a1$[ebp]
	mov	BYTE PTR [eax+3], cl

; 364  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?set@ColorQuad@Ogre@@QAEXEEEE@Z ENDP			; Ogre::ColorQuad::set
_TEXT	ENDS
PUBLIC	?OnParseNewlineCharacter@RFontBase@Ogre@@AAEXAAM0MM@Z ; Ogre::RFontBase::OnParseNewlineCharacter
PUBLIC	?IsEndParseText@RFontBase@Ogre@@AAE_NW4EControlCode@2@@Z ; Ogre::RFontBase::IsEndParseText
PUBLIC	?OnParseOneCharacter@RFontBase@Ogre@@AAE_NAAPBDAAM1AAVColorQuad@2@2AA_NAAHMW4EControlCode@2@MIMABV32@@Z ; Ogre::RFontBase::OnParseOneCharacter
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefontbase.cpp
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_pszParseText$ = 8					; size = 4
_fCurX$ = 12						; size = 4
_fCurY$ = 16						; size = 4
_shadowColor$ = 20					; size = 4
_curColor$ = 24						; size = 4
_bBlink$ = 28						; size = 4
_nBlinkModel$ = 32					; size = 4
_fX$ = 36						; size = 4
_eCtrlCode$ = 40					; size = 4
_fScale$ = 44						; size = 4
_dwStyle$ = 48						; size = 4
_fZ$ = 52						; size = 4
_initColor$ = 56					; size = 4
?OnParseOneCharacter@RFontBase@Ogre@@AAE_NAAPBDAAM1AAVColorQuad@2@2AA_NAAHMW4EControlCode@2@MIMABV32@@Z PROC ; Ogre::RFontBase::OnParseOneCharacter
; _this$ = ecx

; 321  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 322  : 		if ( IsEndParseText( eCtrlCode ) )

	mov	eax, DWORD PTR _eCtrlCode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsEndParseText@RFontBase@Ogre@@AAE_NW4EControlCode@2@@Z ; Ogre::RFontBase::IsEndParseText
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@OnParseOne

; 323  : 
; 324  : 		{
; 325  : 			return false;

	xor	al, al
	jmp	$LN8@OnParseOne
$LN7@OnParseOne:

; 326  : 		}
; 327  : 
; 328  : 		switch ( eCtrlCode )

	mov	edx, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN3@OnParseOne
	cmp	DWORD PTR tv69[ebp], 2
	je	SHORT $LN4@OnParseOne
	cmp	DWORD PTR tv69[ebp], 4
	je	SHORT $LN2@OnParseOne
	jmp	SHORT $LN1@OnParseOne
$LN4@OnParseOne:

; 329  : 		{
; 330  : 		case CTRLCODE_NEWLINE:
; 331  : 			{
; 332  : 				//X
; 333  : 				OnParseNewlineCharacter( fCurX, fCurY, fX, fScale );

	push	ecx
	fld	DWORD PTR _fScale$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fX$[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _fCurY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fCurX$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnParseNewlineCharacter@RFontBase@Ogre@@AAEXAAM0MM@Z ; Ogre::RFontBase::OnParseNewlineCharacter

; 334  : 			}
; 335  : 			break;

	jmp	SHORT $LN5@OnParseOne
$LN3@OnParseOne:

; 336  : 
; 337  : 		case CTRLCODE_CHARACTER:
; 338  : 			{
; 339  : 				OnParseNormalCharacter( fCurX, fCurY, pszParseText, shadowColor, 
; 340  : 										fScale, dwStyle, curColor, fZ );

	push	ecx
	fld	DWORD PTR _fZ$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _curColor$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwStyle$[ebp]
	push	eax
	push	ecx
	fld	DWORD PTR _fScale$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _shadowColor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszParseText$[ebp]
	push	edx
	mov	eax, DWORD PTR _fCurY$[ebp]
	push	ecx
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _fCurX$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnParseNormalCharacter@RFontBase@Ogre@@AAEXAAMMAAPBDAAVColorQuad@2@MIABV32@M@Z ; Ogre::RFontBase::OnParseNormalCharacter

; 341  : 			}
; 342  : 			break;

	jmp	SHORT $LN5@OnParseOne
$LN2@OnParseOne:

; 343  : 
; 344  : 		case CTRLCODE_TRANSFER:
; 345  : 			{
; 346  : 				OnParseTransferCharacter( pszParseText, curColor, bBlink, nBlinkModel, initColor );

	mov	edx, DWORD PTR _initColor$[ebp]
	push	edx
	mov	eax, DWORD PTR _nBlinkModel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bBlink$[ebp]
	push	ecx
	mov	edx, DWORD PTR _curColor$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszParseText$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnParseTransferCharacter@RFontBase@Ogre@@AAEXAAPBDAAVColorQuad@2@AA_NAAHABV32@@Z ; Ogre::RFontBase::OnParseTransferCharacter
$LN1@OnParseOne:
$LN5@OnParseOne:

; 347  : 			}
; 348  : 			break;
; 349  : 
; 350  : 		default:
; 351  : 			break;
; 352  : 		}
; 353  : 
; 354  : 		return true;

	mov	al, 1
$LN8@OnParseOne:

; 355  : 	}

	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
?OnParseOneCharacter@RFontBase@Ogre@@AAE_NAAPBDAAM1AAVColorQuad@2@2AA_NAAHMW4EControlCode@2@MIMABV32@@Z ENDP ; Ogre::RFontBase::OnParseOneCharacter
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefontbase.h
_TEXT	ENDS
;	COMDAT ?IsEndParseText@RFontBase@Ogre@@AAE_NW4EControlCode@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eCtrlCode$ = 8						; size = 4
?IsEndParseText@RFontBase@Ogre@@AAE_NW4EControlCode@2@@Z PROC ; Ogre::RFontBase::IsEndParseText, COMDAT
; _this$ = ecx

; 304  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 305  : 		return eCtrlCode == CTRLCODE_ENDOFSTRING;

	xor	eax, eax
	cmp	DWORD PTR _eCtrlCode$[ebp], 3
	sete	al

; 306  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?IsEndParseText@RFontBase@Ogre@@AAE_NW4EControlCode@2@@Z ENDP ; Ogre::RFontBase::IsEndParseText
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?OnParseNewlineCharacter@RFontBase@Ogre@@AAEXAAM0MM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fCurX$ = 8						; size = 4
_fCurY$ = 12						; size = 4
_fNewLineX$ = 16					; size = 4
_fScale$ = 20						; size = 4
?OnParseNewlineCharacter@RFontBase@Ogre@@AAEXAAM0MM@Z PROC ; Ogre::RFontBase::OnParseNewlineCharacter, COMDAT
; _this$ = ecx

; 309  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 310  : 		//X
; 311  : 		fCurX = fNewLineX;

	mov	eax, DWORD PTR _fCurX$[ebp]
	fld	DWORD PTR _fNewLineX$[ebp]
	fstp	DWORD PTR [eax]

; 312  : 		fCurY += ( m_fCharHeight + m_fLineInterval ) * fScale;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+60]
	fmul	DWORD PTR _fScale$[ebp]
	mov	eax, DWORD PTR _fCurY$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _fCurY$[ebp]
	fstp	DWORD PTR [ecx]

; 313  : 	}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?OnParseNewlineCharacter@RFontBase@Ogre@@AAEXAAM0MM@Z ENDP ; Ogre::RFontBase::OnParseNewlineCharacter
_TEXT	ENDS
PUBLIC	?TextOutM@RFontBase@Ogre@@UAEXPBDMMABVColorQuad@2@I_NMM1@Z ; Ogre::RFontBase::TextOutM
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefontbase.cpp
_TEXT	SEGMENT
_this$ = -44						; size = 4
_isContinueParseCharacter$120796 = -37			; size = 1
_nBlinkModel$ = -36					; size = 4
_shadowColor$ = -32					; size = 4
_fCurX$ = -28						; size = 4
_fCurY$ = -24						; size = 4
_curColor$ = -20					; size = 4
_pszParseText$ = -16					; size = 4
_nRetNum$ = -12						; size = 4
_eCtrlCode$ = -8					; size = 4
_bBlink$ = -1						; size = 1
_pSrcText$ = 8						; size = 4
_fX$ = 12						; size = 4
_fY$ = 16						; size = 4
_initColor$ = 20					; size = 4
_dwStyle$ = 24						; size = 4
_bDoTransfer$ = 28					; size = 1
_fScale$ = 32						; size = 4
_fZ$ = 36						; size = 4
_initShadowColor$ = 40					; size = 4
?TextOutM@RFontBase@Ogre@@UAEXPBDMMABVColorQuad@2@I_NMM1@Z PROC ; Ogre::RFontBase::TextOutM
; _this$ = ecx

; 359  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 360  : 		if ( pSrcText == NULL )

	cmp	DWORD PTR _pSrcText$[ebp], 0
	jne	SHORT $LN4@TextOutM

; 361  : 		{
; 362  : 			return;

	jmp	$LN5@TextOutM
$LN4@TextOutM:

; 363  : 		}
; 364  : 
; 365  : 		const char* pszParseText	= pSrcText;

	mov	eax, DWORD PTR _pSrcText$[ebp]
	mov	DWORD PTR _pszParseText$[ebp], eax

; 366  : 		int nRetNum					= 0;

	mov	DWORD PTR _nRetNum$[ebp], 0

; 367  : 		EControlCode eCtrlCode		= CTRLCODE_UNKNOWN;

	mov	DWORD PTR _eCtrlCode$[ebp], 5

; 368  : 		float fCurX					= fX;

	fld	DWORD PTR _fX$[ebp]
	fstp	DWORD PTR _fCurX$[ebp]

; 369  : 		float fCurY					= fY;

	fld	DWORD PTR _fY$[ebp]
	fstp	DWORD PTR _fCurY$[ebp]

; 370  : 		bool bBlink					= false;

	mov	BYTE PTR _bBlink$[ebp], 0

; 371  : 		int nBlinkModel				= BLINKMODEL_SMOOTH;

	mov	DWORD PTR _nBlinkModel$[ebp], 1

; 372  : 		m_nShowCharNum				= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 0

; 373  : 
; 374  : 		ColorQuad curColor( initColor );

	mov	edx, DWORD PTR _initColor$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _curColor$[ebp], eax

; 375  : 		ColorQuad shadowColor( initShadowColor );

	mov	ecx, DWORD PTR _initShadowColor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _shadowColor$[ebp], edx
$LN3@TextOutM:

; 376  : 
; 377  : 		while ( true )

	mov	eax, 1
	test	eax, eax
	je	$LN2@TextOutM

; 378  : 		{
; 379  : 			nRetNum			= m_pCharacterCoding->GetControlCode( pszParseText, eCtrlCode, bDoTransfer);

	movzx	ecx, BYTE PTR _bDoTransfer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _eCtrlCode$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszParseText$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _nRetNum$[ebp], eax

; 380  : 			pszParseText	+= nRetNum;

	mov	ecx, DWORD PTR _pszParseText$[ebp]
	add	ecx, DWORD PTR _nRetNum$[ebp]
	mov	DWORD PTR _pszParseText$[ebp], ecx

; 381  : 			
; 382  : 			bool isContinueParseCharacter = OnParseOneCharacter( pszParseText, fCurX, fCurY, shadowColor, 
; 383  : 																	curColor, bBlink, nBlinkModel, fX, eCtrlCode, fScale,
; 384  : 																	dwStyle, fZ, initColor );

	mov	edx, DWORD PTR _initColor$[ebp]
	push	edx
	push	ecx
	fld	DWORD PTR _fZ$[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _dwStyle$[ebp]
	push	eax
	push	ecx
	fld	DWORD PTR _fScale$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _eCtrlCode$[ebp]
	push	ecx
	push	ecx
	fld	DWORD PTR _fX$[ebp]
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR _nBlinkModel$[ebp]
	push	edx
	lea	eax, DWORD PTR _bBlink$[ebp]
	push	eax
	lea	ecx, DWORD PTR _curColor$[ebp]
	push	ecx
	lea	edx, DWORD PTR _shadowColor$[ebp]
	push	edx
	lea	eax, DWORD PTR _fCurY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fCurX$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pszParseText$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnParseOneCharacter@RFontBase@Ogre@@AAE_NAAPBDAAM1AAVColorQuad@2@2AA_NAAHMW4EControlCode@2@MIMABV32@@Z ; Ogre::RFontBase::OnParseOneCharacter
	mov	BYTE PTR _isContinueParseCharacter$120796[ebp], al

; 385  : 			if ( !isContinueParseCharacter )

	movzx	eax, BYTE PTR _isContinueParseCharacter$120796[ebp]
	test	eax, eax
	jne	SHORT $LN1@TextOutM

; 386  : 			{
; 387  : 				break;

	jmp	SHORT $LN2@TextOutM
$LN1@TextOutM:

; 388  : 			}
; 389  : 		}

	jmp	$LN3@TextOutM
$LN2@TextOutM:

; 390  : 
; 391  : 		RenderText( fZ );

	push	ecx
	fld	DWORD PTR _fZ$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenderText@RFontBase@Ogre@@QAEXM@Z	; Ogre::RFontBase::RenderText
$LN5@TextOutM:

; 392  : 	}

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?TextOutM@RFontBase@Ogre@@UAEXPBDMMABVColorQuad@2@I_NMM1@Z ENDP ; Ogre::RFontBase::TextOutM
_TEXT	ENDS
PUBLIC	?getHeight@?$TRect@M@Ogre@@QBEMXZ		; Ogre::TRect<float>::getHeight
PUBLIC	?getWidth@?$TRect@M@Ogre@@QBEMXZ		; Ogre::TRect<float>::getWidth
PUBLIC	__$ArrayPad$
PUBLIC	?TextOutRect@RFontBase@Ogre@@UAEXPBDAAV?$TRect@M@2@MM_NABVColorQuad@2@I2M3@Z ; Ogre::RFontBase::TextOutRect
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv461 = -208						; size = 4
tv770 = -204						; size = 4
tv769 = -200						; size = 4
tv758 = -196						; size = 4
tv757 = -192						; size = 4
tv746 = -188						; size = 4
tv745 = -184						; size = 4
tv734 = -180						; size = 4
tv733 = -176						; size = 4
tv86 = -172						; size = 4
tv602 = -168						; size = 4
tv596 = -164						; size = 4
_this$ = -160						; size = 4
_n$120905 = -156					; size = 4
_vWidth$120878 = -152					; size = 4
_uWidth$120877 = -148					; size = 4
_nSpace$120858 = -144					; size = 4
_fd$120855 = -140					; size = 4
_fCW$120842 = -136					; size = 4
_xx2$120849 = -132					; size = 4
_vOffset2$120853 = -128					; size = 4
_fCH$120843 = -124					; size = 4
_uOffset2$120851 = -120					; size = 4
_vOffset1$120852 = -116					; size = 4
_yy2$120847 = -112					; size = 4
_xx1$120848 = -108					; size = 4
_uOffset1$120850 = -104					; size = 4
_yy1$120846 = -100					; size = 4
_hUiResTp$120844 = -96					; size = 4
_rectUV$120845 = -92					; size = 16
_n$120861 = -76						; size = 4
_cc$120860 = -72					; size = 8
__$ArrayPad$ = -64					; size = 4
_ft$120867 = -60					; size = 4
_nBlinkModel$ = -56					; size = 4
_shadowColor$ = -52					; size = 4
_rec$ = -48						; size = 16
_fCurX$ = -32						; size = 4
_fCurY$ = -28						; size = 4
_nShowCharNum$ = -24					; size = 4
_curColor$ = -20					; size = 4
_p$ = -16						; size = 4
_nRetNum$ = -12						; size = 4
_eCtrlCode$ = -8					; size = 4
_bBlink$ = -1						; size = 1
_pText$ = 8						; size = 4
_rect$ = 12						; size = 4
_fOffsetX$ = 16						; size = 4
_fOffsetY$ = 20						; size = 4
_bAutoWrap$ = 24					; size = 1
_color$ = 28						; size = 4
_dwStyle$ = 32						; size = 4
_bDoTransfer$ = 36					; size = 1
_fScale$ = 40						; size = 4
_scolor$ = 44						; size = 4
?TextOutRect@RFontBase@Ogre@@UAEXPBDAAV?$TRect@M@2@MM_NABVColorQuad@2@I2M3@Z PROC ; Ogre::RFontBase::TextOutRect
; _this$ = ecx

; 397  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 398  : 		if(!pText)

	cmp	DWORD PTR _pText$[ebp], 0
	jne	SHORT $LN52@TextOutRec

; 399  : 			return;

	jmp	$LN53@TextOutRec
$LN52@TextOutRec:

; 400  : 
; 401  : 		const char *p = pText;

	mov	eax, DWORD PTR _pText$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 402  : 		int nRetNum;
; 403  : 		EControlCode eCtrlCode;
; 404  : 		RectFloat rec = rect;

	mov	ecx, DWORD PTR _rect$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _rec$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _rec$[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _rec$[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _rec$[ebp+12], eax

; 405  : 		rec.m_Left = (float)((int)rec.m_Left);

	fld	DWORD PTR _rec$[ebp]
	call	__ftol2_sse
	mov	DWORD PTR tv596[ebp], eax
	fild	DWORD PTR tv596[ebp]
	fstp	DWORD PTR _rec$[ebp]

; 406  : 		rec.m_Top = (float)((int)rec.m_Top);

	fld	DWORD PTR _rec$[ebp+4]
	call	__ftol2_sse
	mov	DWORD PTR tv602[ebp], eax
	fild	DWORD PTR tv602[ebp]
	fstp	DWORD PTR _rec$[ebp+4]

; 407  : 		float fCurX = rec.m_Left , fCurY = rec.m_Top;

	fld	DWORD PTR _rec$[ebp]
	fstp	DWORD PTR _fCurX$[ebp]
	fld	DWORD PTR _rec$[ebp+4]
	fstp	DWORD PTR _fCurY$[ebp]

; 408  : 
; 409  : 		ColorQuad curColor = color;

	mov	ecx, DWORD PTR _color$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _curColor$[ebp], edx

; 410  : 		ColorQuad shadowColor = scolor;

	mov	eax, DWORD PTR _scolor$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _shadowColor$[ebp], ecx

; 411  : 		bool bBlink = false;

	mov	BYTE PTR _bBlink$[ebp], 0

; 412  : 		int nBlinkModel = BLINKMODEL_SMOOTH;

	mov	DWORD PTR _nBlinkModel$[ebp], 1

; 413  : 		int nShowCharNum = 0;

	mov	DWORD PTR _nShowCharNum$[ebp], 0
$LN56@TextOutRec:

; 414  : 
; 415  : 		while(1)

	mov	edx, 1
	test	edx, edx
	je	$LN50@TextOutRec

; 416  : 		{
; 417  : 			nRetNum = m_pCharacterCoding->GetControlCode(p, eCtrlCode, bDoTransfer);

	movzx	eax, BYTE PTR _bDoTransfer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _eCtrlCode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _nRetNum$[ebp], eax

; 418  : 			p += nRetNum;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _nRetNum$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 419  : 
; 420  : 			if( eCtrlCode == CTRLCODE_ENDOFSTRING )

	cmp	DWORD PTR _eCtrlCode$[ebp], 3
	jne	SHORT $LN49@TextOutRec

; 421  : 				break;

	jmp	$LN50@TextOutRec
$LN49@TextOutRec:

; 422  : 
; 423  : 			switch(eCtrlCode)

	mov	edx, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR tv86[ebp], edx
	cmp	DWORD PTR tv86[ebp], 0
	je	SHORT $LN45@TextOutRec
	cmp	DWORD PTR tv86[ebp], 2
	je	SHORT $LN46@TextOutRec
	cmp	DWORD PTR tv86[ebp], 4
	je	$LN21@TextOutRec
	jmp	$LN47@TextOutRec
$LN46@TextOutRec:

; 424  : 			{
; 425  : 			case CTRLCODE_NEWLINE:
; 426  : 				{
; 427  : 					//X
; 428  : 					fCurX = rec.m_Left;

	fld	DWORD PTR _rec$[ebp]
	fstp	DWORD PTR _fCurX$[ebp]

; 429  : 					fCurY += (m_fCharHeight + m_fLineInterval) * fScale;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+60]
	fmul	DWORD PTR _fScale$[ebp]
	fadd	DWORD PTR _fCurY$[ebp]
	fstp	DWORD PTR _fCurY$[ebp]

; 430  : 				}
; 431  : 				break;

	jmp	$LN47@TextOutRec
$LN45@TextOutRec:

; 432  : 
; 433  : 			case CTRLCODE_CHARACTER:
; 434  : 				{
; 435  : 					float fCW,fCH;
; 436  : 					HUIRES hUiResTp;
; 437  : 					RectFloat rectUV;

	lea	ecx, DWORD PTR _rectUV$120845[ebp]
	call	??0?$TRect@M@Ogre@@QAE@XZ		; Ogre::TRect<float>::TRect<float>

; 438  : 					float yy1,yy2,xx1,xx2;
; 439  : 					float uOffset1,uOffset2,vOffset1,vOffset2;
; 440  : 
; 441  : 					if(bAutoWrap)

	movzx	edx, BYTE PTR _bAutoWrap$[ebp]
	test	edx, edx
	je	$LN41@TextOutRec

; 442  : 					{
; 443  : 						float fd = MinDisToNewLine(p, bDoTransfer);

	movzx	eax, BYTE PTR _bDoTransfer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MinDisToNewLine@RFontBase@Ogre@@IAEMPBD_N@Z ; Ogre::RFontBase::MinDisToNewLine
	fstp	DWORD PTR _fd$120855[ebp]

; 444  : 
; 445  : 						if(fd > rec.getWidth())

	lea	ecx, DWORD PTR _rec$[ebp]
	call	?getWidth@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getWidth
	fld	DWORD PTR _fd$120855[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN43@TextOutRec

; 446  : 							rec.m_Right = rec.m_Left + fd;

	fld	DWORD PTR _rec$[ebp]
	fadd	DWORD PTR _fd$120855[ebp]
	fstp	DWORD PTR _rec$[ebp+8]
$LN43@TextOutRec:

; 447  : 						if((fd + fCurX) > rec.m_Right)

	fld	DWORD PTR _fd$120855[ebp]
	fadd	DWORD PTR _fCurX$[ebp]
	fld	DWORD PTR _rec$[ebp+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN41@TextOutRec

; 448  : 						{
; 449  : 							//X
; 450  : 							fCurX = rec.m_Left;

	fld	DWORD PTR _rec$[ebp]
	fstp	DWORD PTR _fCurX$[ebp]

; 451  : 							fCurY += (m_fCharHeight + m_fLineInterval)  * fScale;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+56]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+60]
	fmul	DWORD PTR _fScale$[ebp]
	fadd	DWORD PTR _fCurY$[ebp]
	fstp	DWORD PTR _fCurY$[ebp]

; 452  : 							int nSpace = m_pCharacterCoding->JumpOverSpaces(p);

	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+76]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR _nSpace$120858[ebp], eax

; 453  : 							if(nSpace)

	cmp	DWORD PTR _nSpace$120858[ebp], 0
	je	SHORT $LN41@TextOutRec

; 454  : 							{
; 455  : 								p += nSpace;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _nSpace$120858[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 456  : 								continue;

	jmp	$LN56@TextOutRec
$LN41@TextOutRec:

; 457  : 							}
; 458  : 						}
; 459  : 					}
; 460  : 
; 461  : 					//
; 462  : 					unsigned char cc[8];
; 463  : 					memset(cc, 0 , sizeof( cc ) );

	push	8
	push	0
	lea	edx, DWORD PTR _cc$120860[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 464  : 					int n = m_pCharacterCoding->GetAChar(p, cc);

	lea	eax, DWORD PTR _cc$120860[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+76]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR _n$120861[ebp], eax

; 465  : 
; 466  : 					//
; 467  : 					GetCharExtent(cc, fCW, fCH);

	lea	ecx, DWORD PTR _fCH$120843[ebp]
	push	ecx
	lea	edx, DWORD PTR _fCW$120842[ebp]
	push	edx
	lea	eax, DWORD PTR _cc$120860[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 468  : 
; 469  : 					fCW *= fScale;

	fld	DWORD PTR _fCW$120842[ebp]
	fmul	DWORD PTR _fScale$[ebp]
	fstp	DWORD PTR _fCW$120842[ebp]

; 470  : 					fCH *= fScale;

	fld	DWORD PTR _fCH$120843[ebp]
	fmul	DWORD PTR _fScale$[ebp]
	fstp	DWORD PTR _fCH$120843[ebp]

; 471  : 
; 472  : 					if(bAutoWrap)

	movzx	ecx, BYTE PTR _bAutoWrap$[ebp]
	test	ecx, ecx
	je	SHORT $LN40@TextOutRec

; 473  : 						xx1 = fCurX , xx2 = fCurX + fCW;

	fld	DWORD PTR _fCurX$[ebp]
	fstp	DWORD PTR _xx1$120848[ebp]
	fld	DWORD PTR _fCurX$[ebp]
	fadd	DWORD PTR _fCW$120842[ebp]
	fstp	DWORD PTR _xx2$120849[ebp]

; 474  : 					else

	jmp	SHORT $LN39@TextOutRec
$LN40@TextOutRec:

; 475  : 						xx1 = fCurX + fOffsetX , xx2 = fCurX + fCW + fOffsetX;

	fld	DWORD PTR _fCurX$[ebp]
	fadd	DWORD PTR _fOffsetX$[ebp]
	fstp	DWORD PTR _xx1$120848[ebp]
	fld	DWORD PTR _fCurX$[ebp]
	fadd	DWORD PTR _fCW$120842[ebp]
	fadd	DWORD PTR _fOffsetX$[ebp]
	fstp	DWORD PTR _xx2$120849[ebp]
$LN39@TextOutRec:

; 476  : 					yy1 = fCurY + fOffsetY , yy2 = fCurY + fCH + fOffsetY;

	fld	DWORD PTR _fCurY$[ebp]
	fadd	DWORD PTR _fOffsetY$[ebp]
	fstp	DWORD PTR _yy1$120846[ebp]
	fld	DWORD PTR _fCurY$[ebp]
	fadd	DWORD PTR _fCH$120843[ebp]
	fadd	DWORD PTR _fOffsetY$[ebp]
	fstp	DWORD PTR _yy2$120847[ebp]

; 477  : 
; 478  : 					//
; 479  : 					if(yy1 >= rec.m_Bottom || yy2 <= rec.m_Top || (!bAutoWrap && (xx1 >= rec.m_Right || xx2 <= rec.m_Left)))

	fld	DWORD PTR _yy1$120846[ebp]
	fld	DWORD PTR _rec$[ebp+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN36@TextOutRec
	fld	DWORD PTR _yy2$120847[ebp]
	fld	DWORD PTR _rec$[ebp+4]
	fcompp
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN36@TextOutRec
	movzx	edx, BYTE PTR _bAutoWrap$[ebp]
	test	edx, edx
	jne	SHORT $LN38@TextOutRec
	fld	DWORD PTR _xx1$120848[ebp]
	fld	DWORD PTR _rec$[ebp+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN36@TextOutRec
	fld	DWORD PTR _xx2$120849[ebp]
	fld	DWORD PTR _rec$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN38@TextOutRec
$LN36@TextOutRec:

; 480  : 					{
; 481  : 						p += n;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _n$120861[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 482  : 						fCurX += fCW;

	fld	DWORD PTR _fCurX$[ebp]
	fadd	DWORD PTR _fCW$120842[ebp]
	fstp	DWORD PTR _fCurX$[ebp]

; 483  : 						continue;

	jmp	$LN56@TextOutRec
$LN38@TextOutRec:

; 484  : 					}
; 485  : 
; 486  : 					//
; 487  : 					uOffset1 = uOffset2 = 0.0f;

	fldz
	fstp	DWORD PTR _uOffset2$120851[ebp]
	fld	DWORD PTR _uOffset2$120851[ebp]
	fstp	DWORD PTR _uOffset1$120850[ebp]

; 488  : 					vOffset1 = vOffset2 = 0.0f;

	fldz
	fstp	DWORD PTR _vOffset2$120853[ebp]
	fld	DWORD PTR _vOffset2$120853[ebp]
	fstp	DWORD PTR _vOffset1$120852[ebp]

; 489  : 					float ft;
; 490  : 					ft = yy2 - yy1;

	fld	DWORD PTR _yy2$120847[ebp]
	fsub	DWORD PTR _yy1$120846[ebp]
	fstp	DWORD PTR _ft$120867[ebp]

; 491  : 					if(yy1 < rec.m_Top)

	fld	DWORD PTR _yy1$120846[ebp]
	fld	DWORD PTR _rec$[ebp+4]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN35@TextOutRec

; 492  : 					{
; 493  : 						vOffset1 = (rec.m_Top - yy1) / ft ;

	fld	DWORD PTR _rec$[ebp+4]
	fsub	DWORD PTR _yy1$120846[ebp]
	fdiv	DWORD PTR _ft$120867[ebp]
	fstp	DWORD PTR _vOffset1$120852[ebp]

; 494  : 						yy1 = rec.m_Top;

	fld	DWORD PTR _rec$[ebp+4]
	fstp	DWORD PTR _yy1$120846[ebp]
$LN35@TextOutRec:

; 495  : 					}
; 496  : 					if(yy2 > rec.m_Bottom)

	fld	DWORD PTR _yy2$120847[ebp]
	fld	DWORD PTR _rec$[ebp+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN34@TextOutRec

; 497  : 						vOffset2 = (yy2 - rec.m_Bottom) / ft, yy2 = rec.m_Bottom;

	fld	DWORD PTR _yy2$120847[ebp]
	fsub	DWORD PTR _rec$[ebp+12]
	fdiv	DWORD PTR _ft$120867[ebp]
	fstp	DWORD PTR _vOffset2$120853[ebp]
	fld	DWORD PTR _rec$[ebp+12]
	fstp	DWORD PTR _yy2$120847[ebp]
$LN34@TextOutRec:

; 498  : 
; 499  : 					if(!bAutoWrap)

	movzx	ecx, BYTE PTR _bAutoWrap$[ebp]
	test	ecx, ecx
	jne	SHORT $LN31@TextOutRec

; 500  : 					{
; 501  : 						ft = xx2 - xx1;

	fld	DWORD PTR _xx2$120849[ebp]
	fsub	DWORD PTR _xx1$120848[ebp]
	fstp	DWORD PTR _ft$120867[ebp]

; 502  : 						if(xx1 < rec.m_Left)

	fld	DWORD PTR _xx1$120848[ebp]
	fld	DWORD PTR _rec$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN32@TextOutRec

; 503  : 							uOffset1 = (rec.m_Left - xx1) / ft, xx1 = rec.m_Left;

	fld	DWORD PTR _rec$[ebp]
	fsub	DWORD PTR _xx1$120848[ebp]
	fdiv	DWORD PTR _ft$120867[ebp]
	fstp	DWORD PTR _uOffset1$120850[ebp]
	fld	DWORD PTR _rec$[ebp]
	fstp	DWORD PTR _xx1$120848[ebp]
$LN32@TextOutRec:

; 504  : 						if(xx2 > rec.m_Right)

	fld	DWORD PTR _xx2$120849[ebp]
	fld	DWORD PTR _rec$[ebp+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN31@TextOutRec

; 505  : 							uOffset2 = (xx2 - rec.m_Right) / ft, xx2 = rec.m_Right;

	fld	DWORD PTR _xx2$120849[ebp]
	fsub	DWORD PTR _rec$[ebp+8]
	fdiv	DWORD PTR _ft$120867[ebp]
	fstp	DWORD PTR _uOffset2$120851[ebp]
	fld	DWORD PTR _rec$[ebp+8]
	fstp	DWORD PTR _xx2$120849[ebp]
$LN31@TextOutRec:

; 506  : 					}
; 507  : 
; 508  : 					static bool bInThread = true;
; 509  : 					//
; 510  : 					TextureMap(cc, hUiResTp, rectUV);

	lea	edx, DWORD PTR _rectUV$120845[ebp]
	push	edx
	lea	eax, DWORD PTR _hUiResTp$120844[ebp]
	push	eax
	lea	ecx, DWORD PTR _cc$120860[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 511  : 
; 512  : 					if( NULL == m_hUiRes )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	jne	SHORT $LN30@TextOutRec

; 513  : 						m_hUiRes = hUiResTp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _hUiResTp$120844[ebp]
	mov	DWORD PTR [ecx+92], edx
$LN30@TextOutRec:

; 514  : 
; 515  : 					if( m_hUiRes == hUiResTp )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	cmp	ecx, DWORD PTR _hUiResTp$120844[ebp]
	jne	$LN29@TextOutRec

; 516  : 					{
; 517  : 						//
; 518  : 						float uWidth = rectUV.getWidth();

	lea	ecx, DWORD PTR _rectUV$120845[ebp]
	call	?getWidth@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getWidth
	fstp	DWORD PTR _uWidth$120877[ebp]

; 519  : 						float vWidth = rectUV.getHeight();

	lea	ecx, DWORD PTR _rectUV$120845[ebp]
	call	?getHeight@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getHeight
	fstp	DWORD PTR _vWidth$120878[ebp]

; 520  : 						rectUV.m_Top += vOffset1 * vWidth;

	fld	DWORD PTR _vOffset1$120852[ebp]
	fmul	DWORD PTR _vWidth$120878[ebp]
	fadd	DWORD PTR _rectUV$120845[ebp+4]
	fstp	DWORD PTR _rectUV$120845[ebp+4]

; 521  : 						rectUV.m_Bottom -= vOffset2 * vWidth;

	fld	DWORD PTR _vOffset2$120853[ebp]
	fmul	DWORD PTR _vWidth$120878[ebp]
	fsubr	DWORD PTR _rectUV$120845[ebp+12]
	fstp	DWORD PTR _rectUV$120845[ebp+12]

; 522  : 						rectUV.m_Left += uOffset1 * uWidth;

	fld	DWORD PTR _uOffset1$120850[ebp]
	fmul	DWORD PTR _uWidth$120877[ebp]
	fadd	DWORD PTR _rectUV$120845[ebp]
	fstp	DWORD PTR _rectUV$120845[ebp]

; 523  : 						rectUV.m_Right -= uOffset2 * uWidth;

	fld	DWORD PTR _uOffset2$120851[ebp]
	fmul	DWORD PTR _uWidth$120877[ebp]
	fsubr	DWORD PTR _rectUV$120845[ebp+8]
	fstp	DWORD PTR _rectUV$120845[ebp+8]

; 524  : 
; 525  : 						shadowColor.a = curColor.a;

	mov	dl, BYTE PTR _curColor$[ebp+3]
	mov	BYTE PTR _shadowColor$[ebp+3], dl

; 526  : 
; 527  : 						if ( dwStyle == FONTSYTLE_SHADOW )

	cmp	DWORD PTR _dwStyle$[ebp], 1
	jne	SHORT $LN28@TextOutRec

; 528  : 						{
; 529  : 							DoRenderOneShadowCharacter( 
; 530  : 								xx1, 
; 531  : 								yy1, 
; 532  : 								xx2 - xx1, 
; 533  : 								yy2 - yy1, 
; 534  : 								rectUV, shadowColor );

	lea	eax, DWORD PTR _shadowColor$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rectUV$120845[ebp]
	push	ecx
	fld	DWORD PTR _yy2$120847[ebp]
	fsub	DWORD PTR _yy1$120846[ebp]
	fstp	DWORD PTR tv733[ebp]
	fld	DWORD PTR tv733[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR _xx2$120849[ebp]
	fsub	DWORD PTR _xx1$120848[ebp]
	fstp	DWORD PTR tv734[ebp]
	fld	DWORD PTR tv734[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _yy1$120846[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _xx1$120848[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRenderOneShadowCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::DoRenderOneShadowCharacter
	jmp	$LN24@TextOutRec
$LN28@TextOutRec:

; 535  : 						}
; 536  : 						else if ( dwStyle == FONTSYTLE_BORDER )

	cmp	DWORD PTR _dwStyle$[ebp], 2
	jne	SHORT $LN26@TextOutRec

; 537  : 						{
; 538  : 							DoRenderOneBorderCharacter( 
; 539  : 								xx1, 
; 540  : 								yy1, 
; 541  : 								xx2 - xx1, 
; 542  : 								yy2 - yy1, 
; 543  : 								rectUV, shadowColor );

	lea	edx, DWORD PTR _shadowColor$[ebp]
	push	edx
	lea	eax, DWORD PTR _rectUV$120845[ebp]
	push	eax
	fld	DWORD PTR _yy2$120847[ebp]
	fsub	DWORD PTR _yy1$120846[ebp]
	fstp	DWORD PTR tv745[ebp]
	fld	DWORD PTR tv745[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR _xx2$120849[ebp]
	fsub	DWORD PTR _xx1$120848[ebp]
	fstp	DWORD PTR tv746[ebp]
	fld	DWORD PTR tv746[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _yy1$120846[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _xx1$120848[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRenderOneBorderCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::DoRenderOneBorderCharacter
	jmp	SHORT $LN24@TextOutRec
$LN26@TextOutRec:

; 544  : 						}
; 545  : 						else if ( dwStyle == FONTSYTLE_EMBOLDEN )

	cmp	DWORD PTR _dwStyle$[ebp], 3
	jne	SHORT $LN24@TextOutRec

; 546  : 						{
; 547  : 							DoRenderOneEmBoldenCharacter( 
; 548  : 								xx1, 
; 549  : 								yy1, 
; 550  : 								xx2 - xx1, 
; 551  : 								yy2 - yy1, 
; 552  : 								rectUV, shadowColor );

	lea	ecx, DWORD PTR _shadowColor$[ebp]
	push	ecx
	lea	edx, DWORD PTR _rectUV$120845[ebp]
	push	edx
	fld	DWORD PTR _yy2$120847[ebp]
	fsub	DWORD PTR _yy1$120846[ebp]
	fstp	DWORD PTR tv757[ebp]
	fld	DWORD PTR tv757[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR _xx2$120849[ebp]
	fsub	DWORD PTR _xx1$120848[ebp]
	fstp	DWORD PTR tv758[ebp]
	fld	DWORD PTR tv758[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _yy1$120846[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _xx1$120848[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRenderOneEmBoldenCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::DoRenderOneEmBoldenCharacter
$LN24@TextOutRec:

; 553  : 						}
; 554  : 
; 555  : 						SetupCharPoly(&m_vecDrawRect[0] + m_nShowPolyNum, xx1, yy1, xx2 - xx1, yy2 - yy1, rectUV, curColor);

	lea	eax, DWORD PTR _curColor$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rectUV$120845[ebp]
	push	ecx
	fld	DWORD PTR _yy2$120847[ebp]
	fsub	DWORD PTR _yy1$120846[ebp]
	fstp	DWORD PTR tv769[ebp]
	fld	DWORD PTR tv769[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR _xx2$120849[ebp]
	fsub	DWORD PTR _xx1$120848[ebp]
	fstp	DWORD PTR tv770[ebp]
	fld	DWORD PTR tv770[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _yy1$120846[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _xx1$120848[ebp]
	fstp	DWORD PTR [esp]
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??A?$vector@UDrawRect@Ogre@@V?$allocator@UDrawRect@Ogre@@@std@@@std@@QAEAAUDrawRect@Ogre@@I@Z ; std::vector<Ogre::DrawRect,std::allocator<Ogre::DrawRect> >::operator[]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+84]
	imul	ecx, 36					; 00000024H
	add	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupCharPoly@RFontBase@Ogre@@AAEXPAUDrawRect@2@MMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::SetupCharPoly

; 556  : 						m_nShowPolyNum++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], eax

; 557  : 						/*SetupCharPoly(&m_vecDrawRect[0] + m_nShowPolyNum, xx1, yy1, xx2 - xx1, yy2 - yy1, rectUV, curColor);
; 558  : 						m_nShowPolyNum++;*/
; 559  : 
; 560  : 						nShowCharNum++;

	mov	edx, DWORD PTR _nShowCharNum$[ebp]
	add	edx, 1
	mov	DWORD PTR _nShowCharNum$[ebp], edx

; 561  : 						p += n;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _n$120861[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 562  : 						fCurX += fCW;

	fld	DWORD PTR _fCurX$[ebp]
	fadd	DWORD PTR _fCW$120842[ebp]
	fstp	DWORD PTR _fCurX$[ebp]
$LN29@TextOutRec:

; 563  : 					}
; 564  : 
; 565  : 					//
; 566  : 					if( nShowCharNum >= m_nMaxCacheSize || m_nShowPolyNum >=RFONT_MAXPOLYNUM || m_hUiRes != hUiResTp)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nShowCharNum$[ebp]
	cmp	edx, DWORD PTR [ecx+64]
	jge	SHORT $LN22@TextOutRec
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 2048		; 00000800H
	jge	SHORT $LN22@TextOutRec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	cmp	edx, DWORD PTR _hUiResTp$120844[ebp]
	je	SHORT $LN23@TextOutRec
$LN22@TextOutRec:

; 567  : 					{
; 568  : 						RenderText();

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenderText@RFontBase@Ogre@@QAEXM@Z	; Ogre::RFontBase::RenderText
$LN23@TextOutRec:

; 569  : 					}
; 570  : 				}
; 571  : 				break;

	jmp	$LN47@TextOutRec
$LN21@TextOutRec:

; 572  : 
; 573  : 			case CTRLCODE_TRANSFER:
; 574  : 				{
; 575  : 					switch(*p)

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv461[ebp], ecx
	mov	edx, DWORD PTR tv461[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv461[ebp], edx
	cmp	DWORD PTR tv461[ebp], 44		; 0000002cH
	ja	$LN19@TextOutRec
	mov	eax, DWORD PTR tv461[ebp]
	movzx	ecx, BYTE PTR $LN57@TextOutRec[eax]
	jmp	DWORD PTR $LN58@TextOutRec[ecx*4]
$LN18@TextOutRec:

; 576  : 					{
; 577  : 					case 'R':
; 578  : 						curColor.set(255,0,0,255);

	push	255					; 000000ffH
	push	0
	push	0
	push	255					; 000000ffH
	lea	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set

; 579  : 						p += 1;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 580  : 						break;

	jmp	$LN19@TextOutRec
$LN17@TextOutRec:

; 581  : 					case 'G':
; 582  : 						curColor.set(0,255,0,255);

	push	255					; 000000ffH
	push	0
	push	255					; 000000ffH
	push	0
	lea	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set

; 583  : 						p += 1;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 584  : 						break;

	jmp	$LN19@TextOutRec
$LN16@TextOutRec:

; 585  : 					case 'B':
; 586  : 						curColor.set(0,128,255,255);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	128					; 00000080H
	push	0
	lea	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set

; 587  : 						p += 1;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 588  : 						break;

	jmp	$LN19@TextOutRec
$LN15@TextOutRec:

; 589  : 					case 'K':
; 590  : 						curColor.set(0,0,0,255);

	push	255					; 000000ffH
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set

; 591  : 						p += 1;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 592  : 						break;

	jmp	$LN19@TextOutRec
$LN14@TextOutRec:

; 593  : 					case 'Y':
; 594  : 						curColor.set(255,255,0,255);

	push	255					; 000000ffH
	push	0
	push	255					; 000000ffH
	push	255					; 000000ffH
	lea	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set

; 595  : 						p += 1;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 596  : 						break;	

	jmp	$LN19@TextOutRec
$LN13@TextOutRec:

; 597  : 					case 'W':
; 598  : 						curColor.set(255,255,255,255);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	lea	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set

; 599  : 						p += 1;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 600  : 						break;

	jmp	SHORT $LN19@TextOutRec
$LN12@TextOutRec:

; 601  : 					case 'n':
; 602  : 						curColor = color;

	mov	edx, DWORD PTR _color$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _curColor$[ebp], eax

; 603  : 						p += 1;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 604  : 						bBlink = false;

	mov	BYTE PTR _bBlink$[ebp], 0

; 605  : 						break;

	jmp	SHORT $LN19@TextOutRec
$LN11@TextOutRec:

; 606  : 					case 'b':
; 607  : 						bBlink = true;

	mov	BYTE PTR _bBlink$[ebp], 1

; 608  : 						if( *(p+1) == '1' )

	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 49					; 00000031H
	jne	SHORT $LN10@TextOutRec

; 609  : 						{
; 610  : 							nBlinkModel = BLINKMODEL_SMOOTH;

	mov	DWORD PTR _nBlinkModel$[ebp], 1

; 611  : 							p += 2;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 2
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN7@TextOutRec
$LN10@TextOutRec:

; 612  : 						}
; 613  : 						else if( *(p+1) == '2' )

	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 50					; 00000032H
	jne	SHORT $LN8@TextOutRec

; 614  : 						{
; 615  : 							nBlinkModel = BLINKMODEL_SUDDEN;

	mov	DWORD PTR _nBlinkModel$[ebp], 2

; 616  : 							p += 2;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 2
	mov	DWORD PTR _p$[ebp], ecx

; 617  : 						}
; 618  : 						else

	jmp	SHORT $LN7@TextOutRec
$LN8@TextOutRec:

; 619  : 						{
; 620  : 							nBlinkModel = BLINKMODEL_SMOOTH;

	mov	DWORD PTR _nBlinkModel$[ebp], 1

; 621  : 							p += 1;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx
$LN7@TextOutRec:
$LN19@TextOutRec:

; 622  : 						}
; 623  : 						break;
; 624  : 					}
; 625  : 
; 626  : 					if(bBlink)

	movzx	eax, BYTE PTR _bBlink$[ebp]
	test	eax, eax
	je	$LN1@TextOutRec

; 627  : 					{
; 628  : 						if( nBlinkModel == BLINKMODEL_SMOOTH )

	cmp	DWORD PTR _nBlinkModel$[ebp], 1
	jne	$LN5@TextOutRec

; 629  : 						{
; 630  : 							int n = timeGetTime() % BLINK_CIRCLE;

	call	DWORD PTR __imp__timeGetTime@0
	xor	edx, edx
	mov	ecx, 1200				; 000004b0H
	div	ecx
	mov	DWORD PTR _n$120905[ebp], edx

; 631  : 							if(n >= BLINK_HALFCIRCLE)

	cmp	DWORD PTR _n$120905[ebp], 600		; 00000258H
	jl	SHORT $LN4@TextOutRec

; 632  : 								n = BLINK_CIRCLE - n - 1;

	mov	edx, 1200				; 000004b0H
	sub	edx, DWORD PTR _n$120905[ebp]
	sub	edx, 1
	mov	DWORD PTR _n$120905[ebp], edx
$LN4@TextOutRec:

; 633  : 							n = n * 320 / BLINK_HALFCIRCLE;

	mov	eax, DWORD PTR _n$120905[ebp]
	imul	eax, 320				; 00000140H
	cdq
	mov	ecx, 600				; 00000258H
	idiv	ecx
	mov	DWORD PTR _n$120905[ebp], eax

; 634  : 							if(n > 255)

	cmp	DWORD PTR _n$120905[ebp], 255		; 000000ffH
	jle	SHORT $LN3@TextOutRec

; 635  : 								n = 255;

	mov	DWORD PTR _n$120905[ebp], 255		; 000000ffH
$LN3@TextOutRec:

; 636  : 							curColor.set(curColor.r, curColor.g, curColor.b, (UINT8)n);

	movzx	edx, BYTE PTR _n$120905[ebp]
	push	edx
	movzx	eax, BYTE PTR _curColor$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _curColor$[ebp+1]
	push	ecx
	movzx	edx, BYTE PTR _curColor$[ebp+2]
	push	edx
	lea	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set

; 637  : 						}
; 638  : 						else

	jmp	SHORT $LN1@TextOutRec
$LN5@TextOutRec:

; 639  : 						{
; 640  : 							if( (timeGetTime() / BLINK_HALFCIRCLE) % 2 )

	call	DWORD PTR __imp__timeGetTime@0
	xor	edx, edx
	mov	ecx, 600				; 00000258H
	div	ecx
	xor	edx, edx
	mov	ecx, 2
	div	ecx
	test	edx, edx
	je	SHORT $LN1@TextOutRec

; 641  : 								curColor.set(0,0,0,0);

	push	0
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _curColor$[ebp]
	call	?set@ColorQuad@Ogre@@QAEXEEEE@Z		; Ogre::ColorQuad::set
$LN1@TextOutRec:
$LN47@TextOutRec:

; 642  : 						}
; 643  : 					}
; 644  : 				}
; 645  : 				break;
; 646  : 			}
; 647  : 		}

	jmp	$LN56@TextOutRec
$LN50@TextOutRec:

; 648  : 
; 649  : 		RenderText();

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenderText@RFontBase@Ogre@@QAEXM@Z	; Ogre::RFontBase::RenderText
$LN53@TextOutRec:

; 650  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
	npad	1
$LN58@TextOutRec:
	DD	$LN16@TextOutRec
	DD	$LN17@TextOutRec
	DD	$LN15@TextOutRec
	DD	$LN18@TextOutRec
	DD	$LN13@TextOutRec
	DD	$LN14@TextOutRec
	DD	$LN11@TextOutRec
	DD	$LN12@TextOutRec
	DD	$LN19@TextOutRec
$LN57@TextOutRec:
	DB	0
	DB	8
	DB	8
	DB	8
	DB	8
	DB	1
	DB	8
	DB	8
	DB	8
	DB	2
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	3
	DB	8
	DB	8
	DB	8
	DB	8
	DB	4
	DB	8
	DB	5
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	7
?TextOutRect@RFontBase@Ogre@@UAEXPBDAAV?$TRect@M@2@MM_NABVColorQuad@2@I2M3@Z ENDP ; Ogre::RFontBase::TextOutRect
; Function compile flags: /Odtp
_this$ = -20						; size = 4
_oneDrawUVRect$120921 = -16				; size = 4
_oneDrawScreenRect$120920 = -12				; size = 4
_oneDrawRect$120919 = -8				; size = 4
_i$120915 = -4						; size = 4
_fZ$ = 8						; size = 4
?RenderText@RFontBase@Ogre@@QAEXM@Z PROC		; Ogre::RFontBase::RenderText
; _this$ = ecx

; 697  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 698  : 		JustBeforeRender();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax

; 699  : 
; 700  : 		m_pUiRenderer->BeginDraw(m_hUiRes,0, fZ);

	push	0
	push	ecx
	fld	DWORD PTR _fZ$[ebp]
	fstp	DWORD PTR [esp]
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+96]
	call	eax

; 701  : 
; 702  : 		for( int i=0; i<m_nShowPolyNum; i++ )

	mov	DWORD PTR _i$120915[ebp], 0
	jmp	SHORT $LN3@RenderText
$LN2@RenderText:
	mov	ecx, DWORD PTR _i$120915[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$120915[ebp], ecx
$LN3@RenderText:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$120915[ebp]
	cmp	eax, DWORD PTR [edx+84]
	jge	$LN1@RenderText

; 703  : 		{
; 704  : 			const DrawRect&		oneDrawRect			= m_vecDrawRect[i];

	mov	ecx, DWORD PTR _i$120915[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??A?$vector@UDrawRect@Ogre@@V?$allocator@UDrawRect@Ogre@@@std@@@std@@QAEAAUDrawRect@Ogre@@I@Z ; std::vector<Ogre::DrawRect,std::allocator<Ogre::DrawRect> >::operator[]
	mov	DWORD PTR _oneDrawRect$120919[ebp], eax

; 705  : 			const RectFloat&	oneDrawScreenRect	= oneDrawRect.rect;

	mov	edx, DWORD PTR _oneDrawRect$120919[ebp]
	mov	DWORD PTR _oneDrawScreenRect$120920[ebp], edx

; 706  : 			const RectFloat&	oneDrawUVRect		= oneDrawRect.rectUV;

	mov	eax, DWORD PTR _oneDrawRect$120919[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _oneDrawUVRect$120921[ebp], eax

; 707  : 			m_pUiRenderer->StretchRect(oneDrawScreenRect.m_Left, oneDrawScreenRect.m_Top, 
; 708  : 				oneDrawScreenRect.getWidth(), oneDrawScreenRect.getHeight(), 
; 709  : 				oneDrawRect.color.c, 
; 710  : 				false,
; 711  : 				(int)(oneDrawUVRect.m_Left * m_nTexWidth), 
; 712  : 				(int)(oneDrawUVRect.m_Top * m_nTexHeight), 
; 713  : 				(int)(oneDrawUVRect.getWidth() * m_nTexWidth), 
; 714  : 				(int)(oneDrawUVRect.getHeight() * m_nTexHeight), UI_UVT_NORMAL);

	push	0
	push	OFFSET _EMPTY_RECT_INT
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	0
	mov	ecx, DWORD PTR _oneDrawUVRect$120921[ebp]
	call	?getHeight@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getHeight
	mov	ecx, DWORD PTR _this$[ebp]
	fimul	DWORD PTR [ecx+72]
	call	__ftol2_sse
	push	eax
	mov	ecx, DWORD PTR _oneDrawUVRect$120921[ebp]
	call	?getWidth@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getWidth
	mov	edx, DWORD PTR _this$[ebp]
	fimul	DWORD PTR [edx+68]
	call	__ftol2_sse
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	fild	DWORD PTR [eax+72]
	mov	ecx, DWORD PTR _oneDrawUVRect$120921[ebp]
	fmul	DWORD PTR [ecx+4]
	call	__ftol2_sse
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [edx+68]
	mov	eax, DWORD PTR _oneDrawUVRect$120921[ebp]
	fmul	DWORD PTR [eax]
	call	__ftol2_sse
	push	eax
	push	0
	mov	ecx, DWORD PTR _oneDrawRect$120919[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	ecx, DWORD PTR _oneDrawScreenRect$120920[ebp]
	call	?getHeight@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getHeight
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneDrawScreenRect$120920[ebp]
	call	?getWidth@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getWidth
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _oneDrawScreenRect$120920[ebp]
	push	ecx
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneDrawScreenRect$120920[ebp]
	push	ecx
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+104]
	call	eax

; 715  : 		}

	jmp	$LN2@RenderText
$LN1@RenderText:

; 716  : 		m_pUiRenderer->EndDraw();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+120]
	call	eax

; 717  : 
; 718  : 		m_hUiRes = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0

; 719  : 		m_nShowPolyNum = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+84], 0

; 720  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?RenderText@RFontBase@Ogre@@QAEXM@Z ENDP		; Ogre::RFontBase::RenderText
_TEXT	ENDS
PUBLIC	?OnParseNormalCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAM0AAV?$TRect@M@2@AAPBDAAVColorQuad@2@3_N4MMMI@Z ; Ogre::RFontBase::OnParseNormalCharacterOnLimitRect
PUBLIC	?OnParseOneCharacterOnLimitRect@RFontBase@Ogre@@AAE_NAAV?$TRect@M@2@AAPBDAAM2AAVColorQuad@2@3AA_NAAHMMW4EControlCode@2@MIABV42@_N8@Z ; Ogre::RFontBase::OnParseOneCharacterOnLimitRect
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_limitRect$ = 8						; size = 4
_pszParseText$ = 12					; size = 4
_fCurX$ = 16						; size = 4
_fCurY$ = 20						; size = 4
_shadowColor$ = 24					; size = 4
_curColor$ = 28						; size = 4
_bBlink$ = 32						; size = 4
_nBlinkModel$ = 36					; size = 4
_fOffsetX$ = 40						; size = 4
_fOffsetY$ = 44						; size = 4
_eCtrlCode$ = 48					; size = 4
_fScale$ = 52						; size = 4
_dwStyle$ = 56						; size = 4
_initColor$ = 60					; size = 4
_bAutoWrap$ = 64					; size = 1
_bDoTransfer$ = 68					; size = 1
?OnParseOneCharacterOnLimitRect@RFontBase@Ogre@@AAE_NAAV?$TRect@M@2@AAPBDAAM2AAVColorQuad@2@3AA_NAAHMMW4EControlCode@2@MIABV42@_N8@Z PROC ; Ogre::RFontBase::OnParseOneCharacterOnLimitRect
; _this$ = ecx

; 727  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 728  : 		if ( IsEndParseText( eCtrlCode ) )

	mov	eax, DWORD PTR _eCtrlCode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsEndParseText@RFontBase@Ogre@@AAE_NW4EControlCode@2@@Z ; Ogre::RFontBase::IsEndParseText
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@OnParseOne@2

; 729  : 		{
; 730  : 			return false;

	xor	al, al
	jmp	$LN7@OnParseOne@2
$LN6@OnParseOne@2:

; 731  : 		}
; 732  : 
; 733  : 		switch(eCtrlCode)

	mov	edx, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN2@OnParseOne@2
	cmp	DWORD PTR tv69[ebp], 2
	je	SHORT $LN3@OnParseOne@2
	cmp	DWORD PTR tv69[ebp], 4
	je	SHORT $LN1@OnParseOne@2
	jmp	$LN4@OnParseOne@2
$LN3@OnParseOne@2:

; 734  : 		{
; 735  : 		case CTRLCODE_NEWLINE:
; 736  : 			{
; 737  : 				OnParseNewlineCharacter( fCurX, fCurY, limitRect.m_Left, fScale );

	push	ecx
	fld	DWORD PTR _fScale$[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _limitRect$[ebp]
	push	ecx
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _fCurY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fCurX$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnParseNewlineCharacter@RFontBase@Ogre@@AAEXAAM0MM@Z ; Ogre::RFontBase::OnParseNewlineCharacter

; 738  : 			}
; 739  : 			break;

	jmp	SHORT $LN4@OnParseOne@2
$LN2@OnParseOne@2:

; 740  : 
; 741  : 		case CTRLCODE_CHARACTER:
; 742  : 			{
; 743  : 				OnParseNormalCharacterOnLimitRect( fCurX, fCurY, limitRect, pszParseText, curColor, shadowColor,
; 744  : 					bAutoWrap, bDoTransfer, fScale, fOffsetX, fOffsetY, dwStyle );

	mov	eax, DWORD PTR _dwStyle$[ebp]
	push	eax
	push	ecx
	fld	DWORD PTR _fOffsetY$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fOffsetX$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fScale$[ebp]
	fstp	DWORD PTR [esp]
	movzx	ecx, BYTE PTR _bDoTransfer$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bAutoWrap$[ebp]
	push	edx
	mov	eax, DWORD PTR _shadowColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _curColor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszParseText$[ebp]
	push	edx
	mov	eax, DWORD PTR _limitRect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fCurY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fCurX$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnParseNormalCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAM0AAV?$TRect@M@2@AAPBDAAVColorQuad@2@3_N4MMMI@Z ; Ogre::RFontBase::OnParseNormalCharacterOnLimitRect

; 745  : 			}
; 746  : 			break;

	jmp	SHORT $LN4@OnParseOne@2
$LN1@OnParseOne@2:

; 747  : 
; 748  : 		case CTRLCODE_TRANSFER:
; 749  : 			{
; 750  : 				OnParseTransferCharacter( pszParseText, curColor, bBlink, nBlinkModel, initColor );

	mov	eax, DWORD PTR _initColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nBlinkModel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bBlink$[ebp]
	push	edx
	mov	eax, DWORD PTR _curColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszParseText$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnParseTransferCharacter@RFontBase@Ogre@@AAEXAAPBDAAVColorQuad@2@AA_NAAHABV32@@Z ; Ogre::RFontBase::OnParseTransferCharacter
$LN4@OnParseOne@2:

; 751  : 			}
; 752  : 			break;
; 753  : 		}
; 754  : 
; 755  : 		return true;

	mov	al, 1
$LN7@OnParseOne@2:

; 756  : 	}

	mov	esp, ebp
	pop	ebp
	ret	64					; 00000040H
?OnParseOneCharacterOnLimitRect@RFontBase@Ogre@@AAE_NAAV?$TRect@M@2@AAPBDAAM2AAVColorQuad@2@3AA_NAAHMMW4EControlCode@2@MIABV42@_N8@Z ENDP ; Ogre::RFontBase::OnParseOneCharacterOnLimitRect
_TEXT	ENDS
PUBLIC	?DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@2@ABV32@IPAEHM@Z ; Ogre::RFontBase::DoRenderOneCharacterOnLimitRect
PUBLIC	?PrepareRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAE_NAAMAAH00AAV?$TRect@M@2@AAPBDPAEM_N5MM@Z ; Ogre::RFontBase::PrepareRenderOneCharacterOnLimitRect
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefontbase.h
;	COMDAT ?OnParseNormalCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAM0AAV?$TRect@M@2@AAPBDAAVColorQuad@2@3_N4MMMI@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_canRenderText$ = -21					; size = 1
_fOneCharWidth$ = -20					; size = 4
_szCurRenderCharacter$ = -16				; size = 8
__$ArrayPad$ = -8					; size = 4
_nPassBytes$ = -4					; size = 4
_fCurX$ = 8						; size = 4
_fCurY$ = 12						; size = 4
_limitRect$ = 16					; size = 4
_pszParseText$ = 20					; size = 4
_curColor$ = 24						; size = 4
_shadowColor$ = 28					; size = 4
_bAutoWrap$ = 32					; size = 1
_bDoTransfer$ = 36					; size = 1
_fScale$ = 40						; size = 4
_fOffsetX$ = 44						; size = 4
_fOffsetY$ = 48						; size = 4
_dwStyle$ = 52						; size = 4
?OnParseNormalCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAM0AAV?$TRect@M@2@AAPBDAAVColorQuad@2@3_N4MMMI@Z PROC ; Ogre::RFontBase::OnParseNormalCharacterOnLimitRect, COMDAT
; _this$ = ecx

; 408  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 		float fOneCharWidth		= 0.0f;

	fldz
	fstp	DWORD PTR _fOneCharWidth$[ebp]

; 410  : 		int nPassBytes			= 0;

	mov	DWORD PTR _nPassBytes$[ebp], 0

; 411  : 		unsigned char szCurRenderCharacter[8] = { 0 };

	mov	BYTE PTR _szCurRenderCharacter$[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _szCurRenderCharacter$[ebp+1], eax
	mov	WORD PTR _szCurRenderCharacter$[ebp+5], ax
	mov	BYTE PTR _szCurRenderCharacter$[ebp+7], al

; 412  : 		bool canRenderText = PrepareRenderOneCharacterOnLimitRect( 
; 413  : 			fOneCharWidth, nPassBytes, fCurX, fCurY, limitRect, 
; 414  : 			pszParseText, szCurRenderCharacter, fScale, bAutoWrap, 
; 415  : 			bDoTransfer, fOffsetX, fOffsetY 
; 416  : 			);

	push	ecx
	fld	DWORD PTR _fOffsetY$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fOffsetX$[ebp]
	fstp	DWORD PTR [esp]
	movzx	ecx, BYTE PTR _bDoTransfer$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bAutoWrap$[ebp]
	push	edx
	push	ecx
	fld	DWORD PTR _fScale$[ebp]
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _szCurRenderCharacter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszParseText$[ebp]
	push	ecx
	mov	edx, DWORD PTR _limitRect$[ebp]
	push	edx
	mov	eax, DWORD PTR _fCurY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fCurX$[ebp]
	push	ecx
	lea	edx, DWORD PTR _nPassBytes$[ebp]
	push	edx
	lea	eax, DWORD PTR _fOneCharWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrepareRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAE_NAAMAAH00AAV?$TRect@M@2@AAPBDPAEM_N5MM@Z ; Ogre::RFontBase::PrepareRenderOneCharacterOnLimitRect
	mov	BYTE PTR _canRenderText$[ebp], al

; 417  : 		if ( !canRenderText )

	movzx	ecx, BYTE PTR _canRenderText$[ebp]
	test	ecx, ecx
	jne	SHORT $LN1@OnParseNor@2

; 418  : 		{
; 419  : 			return;

	jmp	SHORT $LN2@OnParseNor@2
$LN1@OnParseNor@2:

; 420  : 		}
; 421  : 
; 422  : 		DoRenderOneCharacterOnLimitRect( fCurX, pszParseText, shadowColor, curColor, dwStyle, 
; 423  : 			szCurRenderCharacter, nPassBytes, fOneCharWidth );

	push	ecx
	fld	DWORD PTR _fOneCharWidth$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _nPassBytes$[ebp]
	push	edx
	lea	eax, DWORD PTR _szCurRenderCharacter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwStyle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _curColor$[ebp]
	push	edx
	mov	eax, DWORD PTR _shadowColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszParseText$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fCurX$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@2@ABV32@IPAEHM@Z ; Ogre::RFontBase::DoRenderOneCharacterOnLimitRect
$LN2@OnParseNor@2:

; 424  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
?OnParseNormalCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAM0AAV?$TRect@M@2@AAPBDAAVColorQuad@2@3_N4MMMI@Z ENDP ; Ogre::RFontBase::OnParseNormalCharacterOnLimitRect
_TEXT	ENDS
PUBLIC	?CalculateNoClipAndOffsetScreenRect@RFontBase@Ogre@@AAEXABV?$TRect@M@2@_N@Z ; Ogre::RFontBase::CalculateNoClipAndOffsetScreenRect
PUBLIC	?IsWidthEnoughToPutOneNewText@RFontBase@Ogre@@AAE_NABV?$TRect@M@2@_N@Z ; Ogre::RFontBase::IsWidthEnoughToPutOneNewText
PUBLIC	?InitNoClipTextScreenRect@RFontBase@Ogre@@AAEX_NMMMMMM@Z ; Ogre::RFontBase::InitNoClipTextScreenRect
PUBLIC	?OnAutoWrapNewLine@RFontBase@Ogre@@AAE_NAAM0AAV?$TRect@M@2@AAPBDM_N@Z ; Ogre::RFontBase::OnAutoWrapNewLine
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefontbase.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_bContinueParseText$120969 = -5				; size = 1
_fOneCharHeight$ = -4					; size = 4
_fOneCharWidth$ = 8					; size = 4
_nPassBytes$ = 12					; size = 4
_fCurX$ = 16						; size = 4
_fCurY$ = 20						; size = 4
_limitRect$ = 24					; size = 4
_pszParseText$ = 28					; size = 4
_szCurRenderCharacter$ = 32				; size = 4
_fScale$ = 36						; size = 4
_bAutoWrap$ = 40					; size = 1
_bDoTransfer$ = 44					; size = 1
_fOffsetX$ = 48						; size = 4
_fOffsetY$ = 52						; size = 4
?PrepareRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAE_NAAMAAH00AAV?$TRect@M@2@AAPBDPAEM_N5MM@Z PROC ; Ogre::RFontBase::PrepareRenderOneCharacterOnLimitRect
; _this$ = ecx

; 762  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 763  : 		if ( bAutoWrap )

	movzx	eax, BYTE PTR _bAutoWrap$[ebp]
	test	eax, eax
	je	SHORT $LN2@PrepareRen@2

; 764  : 		{
; 765  : 			bool bContinueParseText = OnAutoWrapNewLine( fCurX, fCurY, limitRect, pszParseText, fScale,
; 766  : 				bDoTransfer );

	movzx	ecx, BYTE PTR _bDoTransfer$[ebp]
	push	ecx
	push	ecx
	fld	DWORD PTR _fScale$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _pszParseText$[ebp]
	push	edx
	mov	eax, DWORD PTR _limitRect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fCurY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fCurX$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnAutoWrapNewLine@RFontBase@Ogre@@AAE_NAAM0AAV?$TRect@M@2@AAPBDM_N@Z ; Ogre::RFontBase::OnAutoWrapNewLine
	mov	BYTE PTR _bContinueParseText$120969[ebp], al

; 767  : 			if ( !bContinueParseText )

	movzx	eax, BYTE PTR _bContinueParseText$120969[ebp]
	test	eax, eax
	jne	SHORT $LN2@PrepareRen@2

; 768  : 			{
; 769  : 				return false;

	xor	al, al
	jmp	$LN4@PrepareRen@2
$LN2@PrepareRen@2:

; 770  : 			}
; 771  : 		}
; 772  : 
; 773  : 		// 
; 774  : 		nPassBytes				= m_pCharacterCoding->GetAChar( pszParseText, szCurRenderCharacter );

	mov	ecx, DWORD PTR _szCurRenderCharacter$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszParseText$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _nPassBytes$[ebp]
	mov	DWORD PTR [ecx], eax

; 775  : 		float fOneCharHeight	= 0.0f;

	fldz
	fstp	DWORD PTR _fOneCharHeight$[ebp]

; 776  : 
; 777  : 		// 
; 778  : 		GetCharExtent( szCurRenderCharacter, fOneCharWidth, fOneCharHeight );

	lea	edx, DWORD PTR _fOneCharHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _fOneCharWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szCurRenderCharacter$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx

; 779  : 
; 780  : 		fOneCharWidth	*= fScale;

	mov	eax, DWORD PTR _fOneCharWidth$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _fScale$[ebp]
	mov	ecx, DWORD PTR _fOneCharWidth$[ebp]
	fstp	DWORD PTR [ecx]

; 781  : 		fOneCharHeight	*= fScale;

	fld	DWORD PTR _fOneCharHeight$[ebp]
	fmul	DWORD PTR _fScale$[ebp]
	fstp	DWORD PTR _fOneCharHeight$[ebp]

; 782  : 
; 783  : 		InitNoClipTextScreenRect( bAutoWrap, fCurX, fOffsetX, fOneCharWidth, fCurY, fOffsetY, fOneCharHeight );

	push	ecx
	fld	DWORD PTR _fOneCharHeight$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fOffsetY$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _fCurY$[ebp]
	push	ecx
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _fOneCharWidth$[ebp]
	push	ecx
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fOffsetX$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _fCurX$[ebp]
	push	ecx
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [esp]
	movzx	edx, BYTE PTR _bAutoWrap$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitNoClipTextScreenRect@RFontBase@Ogre@@AAEX_NMMMMMM@Z ; Ogre::RFontBase::InitNoClipTextScreenRect

; 784  : 
; 785  : 		//
; 786  : 		if ( !IsWidthEnoughToPutOneNewText( limitRect, bAutoWrap ) )

	movzx	eax, BYTE PTR _bAutoWrap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _limitRect$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsWidthEnoughToPutOneNewText@RFontBase@Ogre@@AAE_NABV?$TRect@M@2@_N@Z ; Ogre::RFontBase::IsWidthEnoughToPutOneNewText
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@PrepareRen@2

; 787  : 		{
; 788  : 			pszParseText	+= nPassBytes;

	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nPassBytes$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	DWORD PTR [eax], ecx

; 789  : 			fCurX			+= fOneCharWidth;

	mov	ecx, DWORD PTR _fCurX$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _fOneCharWidth$[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _fCurX$[ebp]
	fstp	DWORD PTR [eax]

; 790  : 			return false;

	xor	al, al
	jmp	SHORT $LN4@PrepareRen@2
$LN1@PrepareRen@2:

; 791  : 		}
; 792  : 
; 793  : 		//
; 794  : 		CalculateNoClipAndOffsetScreenRect( limitRect, bAutoWrap );

	movzx	ecx, BYTE PTR _bAutoWrap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _limitRect$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateNoClipAndOffsetScreenRect@RFontBase@Ogre@@AAEXABV?$TRect@M@2@_N@Z ; Ogre::RFontBase::CalculateNoClipAndOffsetScreenRect

; 795  : 
; 796  : 		return true;

	mov	al, 1
$LN4@PrepareRen@2:

; 797  : 	}

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
?PrepareRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAE_NAAMAAH00AAV?$TRect@M@2@AAPBDPAEM_N5MM@Z ENDP ; Ogre::RFontBase::PrepareRenderOneCharacterOnLimitRect
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefontbase.h
_TEXT	ENDS
;	COMDAT ?OnAutoWrapNewLine@RFontBase@Ogre@@AAE_NAAM0AAV?$TRect@M@2@AAPBDM_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nSpace$58641 = -8					; size = 4
_fOneLineWidth$ = -4					; size = 4
_fCurX$ = 8						; size = 4
_fCurY$ = 12						; size = 4
_limitRect$ = 16					; size = 4
_pszParseText$ = 20					; size = 4
_fScale$ = 24						; size = 4
_bDoTransfer$ = 28					; size = 1
?OnAutoWrapNewLine@RFontBase@Ogre@@AAE_NAAM0AAV?$TRect@M@2@AAPBDM_N@Z PROC ; Ogre::RFontBase::OnAutoWrapNewLine, COMDAT
; _this$ = ecx

; 428  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 429  : 		float fOneLineWidth = MinDisToNewLine( pszParseText, bDoTransfer );

	movzx	eax, BYTE PTR _bDoTransfer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszParseText$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MinDisToNewLine@RFontBase@Ogre@@IAEMPBD_N@Z ; Ogre::RFontBase::MinDisToNewLine
	fstp	DWORD PTR _fOneLineWidth$[ebp]

; 430  : 
; 431  : 		if ( fOneLineWidth > limitRect.getWidth() )

	mov	ecx, DWORD PTR _limitRect$[ebp]
	call	?getWidth@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getWidth
	fld	DWORD PTR _fOneLineWidth$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@OnAutoWrap

; 432  : 		{
; 433  : 			limitRect.m_Right = limitRect.m_Left + fOneLineWidth;

	mov	eax, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR _fOneLineWidth$[ebp]
	mov	ecx, DWORD PTR _limitRect$[ebp]
	fstp	DWORD PTR [ecx+8]
$LN3@OnAutoWrap:

; 434  : 		}
; 435  : 
; 436  : 		if ( ( fOneLineWidth + fCurX ) > limitRect.m_Right )

	fld	DWORD PTR _fOneLineWidth$[ebp]
	mov	edx, DWORD PTR _fCurX$[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [eax+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@OnAutoWrap

; 437  : 		{
; 438  : 			//X
; 439  : 			fCurX		= limitRect.m_Left;

	mov	ecx, DWORD PTR _fCurX$[ebp]
	mov	edx, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [ecx]

; 440  : 			fCurY		+= ( m_fCharHeight + m_fLineInterval )  * fScale;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+60]
	fmul	DWORD PTR _fScale$[ebp]
	mov	edx, DWORD PTR _fCurY$[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _fCurY$[ebp]
	fstp	DWORD PTR [eax]

; 441  : 			int nSpace	= m_pCharacterCoding->JumpOverSpaces( pszParseText );

	mov	ecx, DWORD PTR _pszParseText$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR _nSpace$58641[ebp], eax

; 442  : 			if ( nSpace != 0 )

	cmp	DWORD PTR _nSpace$58641[ebp], 0
	je	SHORT $LN1@OnAutoWrap

; 443  : 			{
; 444  : 				pszParseText += nSpace;

	mov	ecx, DWORD PTR _pszParseText$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _nSpace$58641[ebp]
	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	DWORD PTR [eax], edx

; 445  : 				return false;

	xor	al, al
	jmp	SHORT $LN4@OnAutoWrap
$LN1@OnAutoWrap:

; 446  : 			}
; 447  : 		}
; 448  : 
; 449  : 		return true;

	mov	al, 1
$LN4@OnAutoWrap:

; 450  : 	}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?OnAutoWrapNewLine@RFontBase@Ogre@@AAE_NAAM0AAV?$TRect@M@2@AAPBDM_N@Z ENDP ; Ogre::RFontBase::OnAutoWrapNewLine
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsWidthEnoughToPutOneNewText@RFontBase@Ogre@@AAE_NABV?$TRect@M@2@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_limitRect$ = 8						; size = 4
_bAutoWrap$ = 12					; size = 1
?IsWidthEnoughToPutOneNewText@RFontBase@Ogre@@AAE_NABV?$TRect@M@2@_N@Z PROC ; Ogre::RFontBase::IsWidthEnoughToPutOneNewText, COMDAT
; _this$ = ecx

; 453  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 454  : 		if ( ms_curParseTextNoClipScreenRect.m_Top >= limitRect.m_Bottom )

	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+4
	mov	eax, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN5@IsWidthEno

; 455  : 		{
; 456  : 			return false;

	xor	al, al
	jmp	SHORT $LN6@IsWidthEno
$LN5@IsWidthEno:

; 457  : 		}
; 458  : 
; 459  : 		if ( ms_curParseTextNoClipScreenRect.m_Bottom <= limitRect.m_Top )

	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+12
	mov	ecx, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [ecx+4]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN4@IsWidthEno

; 460  : 		{
; 461  : 			return false;

	xor	al, al
	jmp	SHORT $LN6@IsWidthEno
$LN4@IsWidthEno:

; 462  : 		}
; 463  : 
; 464  : 		if ( bAutoWrap )

	movzx	edx, BYTE PTR _bAutoWrap$[ebp]
	test	edx, edx
	je	SHORT $LN3@IsWidthEno

; 465  : 		{
; 466  : 			return true;

	mov	al, 1
	jmp	SHORT $LN6@IsWidthEno
$LN3@IsWidthEno:

; 467  : 		}
; 468  : 
; 469  : 		if ( ms_curParseTextNoClipScreenRect.m_Left >= limitRect.m_Right )

	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A
	mov	eax, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [eax+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN2@IsWidthEno

; 470  : 		{
; 471  : 			return false;

	xor	al, al
	jmp	SHORT $LN6@IsWidthEno
$LN2@IsWidthEno:

; 472  : 		}
; 473  : 
; 474  : 		if ( ms_curParseTextNoClipScreenRect.m_Right <= limitRect.m_Left )

	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+8
	mov	ecx, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN1@IsWidthEno

; 475  : 		{
; 476  : 			return false;

	xor	al, al
	jmp	SHORT $LN6@IsWidthEno
$LN1@IsWidthEno:

; 477  : 		}
; 478  : 
; 479  : 		return true;

	mov	al, 1
$LN6@IsWidthEno:

; 480  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?IsWidthEnoughToPutOneNewText@RFontBase@Ogre@@AAE_NABV?$TRect@M@2@_N@Z ENDP ; Ogre::RFontBase::IsWidthEnoughToPutOneNewText
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?InitNoClipTextScreenRect@RFontBase@Ogre@@AAEX_NMMMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bAutoWrap$ = 8						; size = 1
_fCurX$ = 12						; size = 4
_fOffsetX$ = 16						; size = 4
_fOneCharWidth$ = 20					; size = 4
_fCurY$ = 24						; size = 4
_fOffsetY$ = 28						; size = 4
_fOneCharHeight$ = 32					; size = 4
?InitNoClipTextScreenRect@RFontBase@Ogre@@AAEX_NMMMMMM@Z PROC ; Ogre::RFontBase::InitNoClipTextScreenRect, COMDAT
; _this$ = ecx

; 484  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 485  : 		if ( bAutoWrap )

	movzx	eax, BYTE PTR _bAutoWrap$[ebp]
	test	eax, eax
	je	SHORT $LN2@InitNoClip

; 486  : 		{
; 487  : 			ms_curParseTextNoClipScreenRect.m_Left = fCurX;

	fld	DWORD PTR _fCurX$[ebp]
	fstp	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A

; 488  : 		}
; 489  : 		else

	jmp	SHORT $LN1@InitNoClip
$LN2@InitNoClip:

; 490  : 		{
; 491  : 			ms_curParseTextNoClipScreenRect.m_Left	= fCurX + fOffsetX;

	fld	DWORD PTR _fCurX$[ebp]
	fadd	DWORD PTR _fOffsetX$[ebp]
	fstp	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A
$LN1@InitNoClip:

; 492  : 		}
; 493  : 
; 494  : 		ms_curParseTextNoClipScreenRect.m_Right = ms_curParseTextNoClipScreenRect.m_Left + fOneCharWidth;

	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A
	fadd	DWORD PTR _fOneCharWidth$[ebp]
	fstp	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+8

; 495  : 
; 496  : 		ms_curParseTextNoClipScreenRect.m_Top		= fCurY + fOffsetY;

	fld	DWORD PTR _fCurY$[ebp]
	fadd	DWORD PTR _fOffsetY$[ebp]
	fstp	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+4

; 497  : 		ms_curParseTextNoClipScreenRect.m_Bottom	= ms_curParseTextNoClipScreenRect.m_Top + fOneCharHeight;

	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+4
	fadd	DWORD PTR _fOneCharHeight$[ebp]
	fstp	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+12

; 498  : 	}

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?InitNoClipTextScreenRect@RFontBase@Ogre@@AAEX_NMMMMMM@Z ENDP ; Ogre::RFontBase::InitNoClipTextScreenRect
_TEXT	ENDS
;	COMDAT ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A
; File i:\svnroot\client\ogremain\ogrefontbase.cpp
_BSS	SEGMENT
?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A DB 010H DUP (?) ; `Ogre::RFontBase::DoRenderOneCharacterOnLimitRect'::`2'::rectUV
_BSS	ENDS
;	COMDAT ?$S6@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4IA
_BSS	SEGMENT
?$S6@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4IA DD 01H DUP (?) ; `Ogre::RFontBase::DoRenderOneCharacterOnLimitRect'::`2'::$S6
_BSS	ENDS
xdata$x	SEGMENT
__unwindtable$?DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@2@ABV32@IPAEHM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@2@ABV32@IPAEHM@Z$0
__ehfuncinfo$?DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@2@ABV32@IPAEHM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@2@ABV32@IPAEHM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -28						; size = 4
_vWidth$120993 = -24					; size = 4
_uWidth$120992 = -20					; size = 4
_hUiResTp$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_fCurX$ = 8						; size = 4
_pszParseText$ = 12					; size = 4
_shadowColor$ = 16					; size = 4
_curColor$ = 20						; size = 4
_dwStyle$ = 24						; size = 4
_szCurRenderCharacter$ = 28				; size = 4
_nPassBytes$ = 32					; size = 4
_fOneCharWidth$ = 36					; size = 4
?DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@2@ABV32@IPAEHM@Z PROC ; Ogre::RFontBase::DoRenderOneCharacterOnLimitRect
; _this$ = ecx

; 803  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@2@ABV32@IPAEHM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 804  : 		static RectFloat rectUV;

	mov	eax, DWORD PTR ?$S6@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4IA
	and	eax, 1
	jne	SHORT $LN8@DoRenderOn@2
	mov	ecx, DWORD PTR ?$S6@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S6@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4IA, ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A
	call	??0?$TRect@M@Ogre@@QAE@XZ		; Ogre::TRect<float>::TRect<float>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN8@DoRenderOn@2:

; 805  : 		HUIRES hUiResTp	= NULL;

	mov	DWORD PTR _hUiResTp$[ebp], 0

; 806  : 		//
; 807  : 		TextureMap( szCurRenderCharacter, hUiResTp, rectUV );

	push	OFFSET ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A
	lea	edx, DWORD PTR _hUiResTp$[ebp]
	push	edx
	mov	eax, DWORD PTR _szCurRenderCharacter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 808  : 
; 809  : 		if ( NULL == m_hUiRes )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	jne	SHORT $LN7@DoRenderOn@2

; 810  : 		{
; 811  : 			m_hUiRes = hUiResTp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _hUiResTp$[ebp]
	mov	DWORD PTR [edx+92], eax
$LN7@DoRenderOn@2:

; 812  : 		}
; 813  : 
; 814  : 		if ( m_hUiRes == hUiResTp )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	cmp	edx, DWORD PTR _hUiResTp$[ebp]
	jne	$LN6@DoRenderOn@2

; 815  : 		{
; 816  : 			//
; 817  : 			float uWidth	= rectUV.getWidth();

	mov	ecx, OFFSET ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A
	call	?getWidth@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getWidth
	fstp	DWORD PTR _uWidth$120992[ebp]

; 818  : 			float vWidth	= rectUV.getHeight();

	mov	ecx, OFFSET ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A
	call	?getHeight@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getHeight
	fstp	DWORD PTR _vWidth$120993[ebp]

; 819  : 			rectUV.m_Top	+= ms_curParseTextOffsetScreenRect.m_Top	* vWidth;

	fld	DWORD PTR ?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+4
	fmul	DWORD PTR _vWidth$120993[ebp]
	fadd	DWORD PTR ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A+4
	fstp	DWORD PTR ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A+4

; 820  : 			rectUV.m_Bottom -= ms_curParseTextOffsetScreenRect.m_Bottom * vWidth;

	fld	DWORD PTR ?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+12
	fmul	DWORD PTR _vWidth$120993[ebp]
	fsubr	DWORD PTR ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A+12
	fstp	DWORD PTR ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A+12

; 821  : 			rectUV.m_Left	+= ms_curParseTextOffsetScreenRect.m_Left	* uWidth;

	fld	DWORD PTR ?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A
	fmul	DWORD PTR _uWidth$120992[ebp]
	fadd	DWORD PTR ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A
	fstp	DWORD PTR ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A

; 822  : 			rectUV.m_Right	-= ms_curParseTextOffsetScreenRect.m_Right	* uWidth;

	fld	DWORD PTR ?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+8
	fmul	DWORD PTR _uWidth$120992[ebp]
	fsubr	DWORD PTR ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A+8
	fstp	DWORD PTR ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A+8

; 823  : 			shadowColor.a	= curColor.a;

	mov	eax, DWORD PTR _shadowColor$[ebp]
	mov	ecx, DWORD PTR _curColor$[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 824  : 
; 825  : 			if ( dwStyle == FONTSYTLE_SHADOW )

	cmp	DWORD PTR _dwStyle$[ebp], 1
	jne	SHORT $LN5@DoRenderOn@2

; 826  : 			{
; 827  : 				DoRenderOneShadowCharacter( 
; 828  : 								ms_curParseTextNoClipScreenRect.m_Left, 
; 829  : 								ms_curParseTextNoClipScreenRect.m_Top, 
; 830  : 								ms_curParseTextNoClipScreenRect.getWidth(), 
; 831  : 								ms_curParseTextNoClipScreenRect.getHeight(), 
; 832  : 								rectUV, shadowColor );

	mov	eax, DWORD PTR _shadowColor$[ebp]
	push	eax
	push	OFFSET ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A
	mov	ecx, OFFSET ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextNoClipScreenRect
	call	?getHeight@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getHeight
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextNoClipScreenRect
	call	?getWidth@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getWidth
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+4
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRenderOneShadowCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::DoRenderOneShadowCharacter
	jmp	$LN1@DoRenderOn@2
$LN5@DoRenderOn@2:

; 833  : 			}
; 834  : 			else if ( dwStyle == FONTSYTLE_BORDER )

	cmp	DWORD PTR _dwStyle$[ebp], 2
	jne	SHORT $LN3@DoRenderOn@2

; 835  : 			{
; 836  : 				DoRenderOneBorderCharacter( 
; 837  : 								ms_curParseTextNoClipScreenRect.m_Left, 
; 838  : 								ms_curParseTextNoClipScreenRect.m_Top, 
; 839  : 								ms_curParseTextNoClipScreenRect.getWidth(), 
; 840  : 								ms_curParseTextNoClipScreenRect.getHeight(), 
; 841  : 								rectUV, shadowColor );

	mov	ecx, DWORD PTR _shadowColor$[ebp]
	push	ecx
	push	OFFSET ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A
	mov	ecx, OFFSET ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextNoClipScreenRect
	call	?getHeight@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getHeight
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextNoClipScreenRect
	call	?getWidth@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getWidth
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+4
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRenderOneBorderCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::DoRenderOneBorderCharacter
	jmp	SHORT $LN1@DoRenderOn@2
$LN3@DoRenderOn@2:

; 842  : 			}
; 843  : 			else if ( dwStyle == FONTSYTLE_EMBOLDEN )

	cmp	DWORD PTR _dwStyle$[ebp], 3
	jne	SHORT $LN1@DoRenderOn@2

; 844  : 			{
; 845  : 				DoRenderOneEmBoldenCharacter( 
; 846  : 					ms_curParseTextNoClipScreenRect.m_Left, 
; 847  : 					ms_curParseTextNoClipScreenRect.m_Top, 
; 848  : 					ms_curParseTextNoClipScreenRect.getWidth(), 
; 849  : 					ms_curParseTextNoClipScreenRect.getHeight(), 
; 850  : 					rectUV, shadowColor );

	mov	edx, DWORD PTR _shadowColor$[ebp]
	push	edx
	push	OFFSET ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A
	mov	ecx, OFFSET ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextNoClipScreenRect
	call	?getHeight@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getHeight
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextNoClipScreenRect
	call	?getWidth@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getWidth
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+4
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRenderOneEmBoldenCharacter@RFontBase@Ogre@@AAEXMMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::DoRenderOneEmBoldenCharacter
$LN1@DoRenderOn@2:

; 851  : 			}
; 852  : 
; 853  : 			SetupCharPoly( 
; 854  : 							&m_vecDrawRect[0] + m_nShowPolyNum, 
; 855  : 							ms_curParseTextNoClipScreenRect.m_Left, 
; 856  : 							ms_curParseTextNoClipScreenRect.m_Top, 
; 857  : 							ms_curParseTextNoClipScreenRect.getWidth(), 
; 858  : 							ms_curParseTextNoClipScreenRect.getHeight(), 
; 859  : 							rectUV, curColor );

	mov	eax, DWORD PTR _curColor$[ebp]
	push	eax
	push	OFFSET ?rectUV@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4V?$TRect@M@3@A
	mov	ecx, OFFSET ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextNoClipScreenRect
	call	?getHeight@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getHeight
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextNoClipScreenRect
	call	?getWidth@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getWidth
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+4
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A
	fstp	DWORD PTR [esp]
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??A?$vector@UDrawRect@Ogre@@V?$allocator@UDrawRect@Ogre@@@std@@@std@@QAEAAUDrawRect@Ogre@@I@Z ; std::vector<Ogre::DrawRect,std::allocator<Ogre::DrawRect> >::operator[]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	imul	edx, 36					; 00000024H
	add	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupCharPoly@RFontBase@Ogre@@AAEXPAUDrawRect@2@MMMMABV?$TRect@M@2@ABVColorQuad@2@@Z ; Ogre::RFontBase::SetupCharPoly

; 860  : 
; 861  : 			m_nShowPolyNum++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+84], ecx

; 862  : 			/*SetupCharPoly(&m_vecDrawRect[0] + m_nShowPolyNum, xx1, yy1, xx2 - xx1, yy2 - yy1, rectUV, curColor);
; 863  : 			m_nShowPolyNum++;*/
; 864  : 
; 865  : 			++m_nShowCharNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], ecx

; 866  : 			pszParseText	+= nPassBytes;

	mov	eax, DWORD PTR _pszParseText$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _nPassBytes$[ebp]
	mov	edx, DWORD PTR _pszParseText$[ebp]
	mov	DWORD PTR [edx], ecx

; 867  : 			fCurX			+= fOneCharWidth;

	mov	eax, DWORD PTR _fCurX$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR _fOneCharWidth$[ebp]
	mov	ecx, DWORD PTR _fCurX$[ebp]
	fstp	DWORD PTR [ecx]
$LN6@DoRenderOn@2:

; 868  : 		}
; 869  : 
; 870  : 		//
; 871  : 		ValidateMaxCharactersToRender( hUiResTp, 0.0f );

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _hUiResTp$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateMaxCharactersToRender@RFontBase@Ogre@@AAEXPAXM@Z ; Ogre::RFontBase::ValidateMaxCharactersToRender

; 872  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@2@ABV32@IPAEHM@Z$0:
	mov	eax, DWORD PTR ?$S6@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S6@?1??DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@3@ABV43@IPAEHM@Z@4IA, eax
	ret	0
__ehhandler$?DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@2@ABV32@IPAEHM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@2@ABV32@IPAEHM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoRenderOneCharacterOnLimitRect@RFontBase@Ogre@@AAEXAAMAAPBDAAVColorQuad@2@ABV32@IPAEHM@Z ENDP ; Ogre::RFontBase::DoRenderOneCharacterOnLimitRect
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -28						; size = 4
_fAbsRightOffset$121014 = -24				; size = 4
_fAbsLeftOffset$121012 = -20				; size = 4
_fAbsBottomOffset$121008 = -16				; size = 4
_fAbsTopOffset$121006 = -12				; size = 4
_fNoClipScreenRectHeight$ = -8				; size = 4
_fNoClipScreenRectWidth$ = -4				; size = 4
_limitRect$ = 8						; size = 4
_bAutoWrap$ = 12					; size = 1
?CalculateNoClipAndOffsetScreenRect@RFontBase@Ogre@@AAEXABV?$TRect@M@2@_N@Z PROC ; Ogre::RFontBase::CalculateNoClipAndOffsetScreenRect
; _this$ = ecx

; 875  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		//
; 877  : 		ms_curParseTextOffsetScreenRect.set( 0.0f, 0.0f, 0.0f, 0.0f );

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextOffsetScreenRect
	call	?set@?$TRect@M@Ogre@@QAEXMMMM@Z		; Ogre::TRect<float>::set

; 878  : 
; 879  : 		float fNoClipScreenRectHeight = ms_curParseTextNoClipScreenRect.getHeight();

	mov	ecx, OFFSET ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextNoClipScreenRect
	call	?getHeight@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getHeight
	fstp	DWORD PTR _fNoClipScreenRectHeight$[ebp]

; 880  : 		if ( ms_curParseTextNoClipScreenRect.m_Top < limitRect.m_Top )

	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+4
	mov	eax, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [eax+4]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN5@CalculateN

; 881  : 		{
; 882  : 			float fAbsTopOffset						= limitRect.m_Top - ms_curParseTextNoClipScreenRect.m_Top;

	mov	ecx, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+4
	fstp	DWORD PTR _fAbsTopOffset$121006[ebp]

; 883  : 			ms_curParseTextOffsetScreenRect.m_Top	= fAbsTopOffset / fNoClipScreenRectHeight;

	fld	DWORD PTR _fAbsTopOffset$121006[ebp]
	fdiv	DWORD PTR _fNoClipScreenRectHeight$[ebp]
	fstp	DWORD PTR ?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+4

; 884  : 			ms_curParseTextNoClipScreenRect.m_Top	= limitRect.m_Top;

	mov	edx, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [edx+4]
	fstp	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+4
$LN5@CalculateN:

; 885  : 		}
; 886  : 
; 887  : 		if ( ms_curParseTextNoClipScreenRect.m_Bottom > limitRect.m_Bottom )

	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+12
	mov	eax, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@CalculateN

; 888  : 		{
; 889  : 			float fAbsBottomOffset						= ms_curParseTextNoClipScreenRect.m_Bottom - limitRect.m_Bottom;

	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+12
	mov	ecx, DWORD PTR _limitRect$[ebp]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _fAbsBottomOffset$121008[ebp]

; 890  : 			ms_curParseTextOffsetScreenRect.m_Bottom	= fAbsBottomOffset / fNoClipScreenRectHeight;

	fld	DWORD PTR _fAbsBottomOffset$121008[ebp]
	fdiv	DWORD PTR _fNoClipScreenRectHeight$[ebp]
	fstp	DWORD PTR ?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+12

; 891  : 			ms_curParseTextNoClipScreenRect.m_Bottom	= limitRect.m_Bottom;

	mov	edx, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+12
$LN4@CalculateN:

; 892  : 		}
; 893  : 
; 894  : 		if ( bAutoWrap )

	movzx	eax, BYTE PTR _bAutoWrap$[ebp]
	test	eax, eax
	je	SHORT $LN3@CalculateN

; 895  : 		{
; 896  : 			return;

	jmp	$LN6@CalculateN
$LN3@CalculateN:

; 897  : 		}
; 898  : 
; 899  : 		float fNoClipScreenRectWidth = ms_curParseTextNoClipScreenRect.getWidth();

	mov	ecx, OFFSET ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextNoClipScreenRect
	call	?getWidth@?$TRect@M@Ogre@@QBEMXZ	; Ogre::TRect<float>::getWidth
	fstp	DWORD PTR _fNoClipScreenRectWidth$[ebp]

; 900  : 		if ( ms_curParseTextNoClipScreenRect.m_Left < limitRect.m_Left )

	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A
	mov	ecx, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@CalculateN

; 901  : 		{
; 902  : 			float fAbsLeftOffset					= limitRect.m_Left - ms_curParseTextNoClipScreenRect.m_Left;

	mov	edx, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A
	fstp	DWORD PTR _fAbsLeftOffset$121012[ebp]

; 903  : 			ms_curParseTextOffsetScreenRect.m_Left	= fAbsLeftOffset / fNoClipScreenRectWidth; 

	fld	DWORD PTR _fAbsLeftOffset$121012[ebp]
	fdiv	DWORD PTR _fNoClipScreenRectWidth$[ebp]
	fstp	DWORD PTR ?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A

; 904  : 			ms_curParseTextNoClipScreenRect.m_Left	= limitRect.m_Left;

	mov	eax, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A
$LN2@CalculateN:

; 905  : 		}
; 906  : 
; 907  : 		if ( ms_curParseTextNoClipScreenRect.m_Right > limitRect.m_Right )

	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+8
	mov	ecx, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [ecx+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@CalculateN

; 908  : 		{
; 909  : 			float fAbsRightOffset					= ms_curParseTextNoClipScreenRect.m_Right - limitRect.m_Right;

	fld	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+8
	mov	edx, DWORD PTR _limitRect$[ebp]
	fsub	DWORD PTR [edx+8]
	fstp	DWORD PTR _fAbsRightOffset$121014[ebp]

; 910  : 			ms_curParseTextOffsetScreenRect.m_Right = fAbsRightOffset / fNoClipScreenRectWidth;

	fld	DWORD PTR _fAbsRightOffset$121014[ebp]
	fdiv	DWORD PTR _fNoClipScreenRectWidth$[ebp]
	fstp	DWORD PTR ?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+8

; 911  : 			ms_curParseTextNoClipScreenRect.m_Right = limitRect.m_Right;

	mov	eax, DWORD PTR _limitRect$[ebp]
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A+8
$LN1@CalculateN:
$LN6@CalculateN:

; 912  : 		}
; 913  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?CalculateNoClipAndOffsetScreenRect@RFontBase@Ogre@@AAEXABV?$TRect@M@2@_N@Z ENDP ; Ogre::RFontBase::CalculateNoClipAndOffsetScreenRect
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrerect.h
_TEXT	ENDS
;	COMDAT ??0?$TRect@M@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$TRect@M@Ogre@@QAE@XZ PROC				; Ogre::TRect<float>::TRect<float>, COMDAT
; _this$ = ecx

; 13   : 		TRect(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$TRect@M@Ogre@@QAE@XZ ENDP				; Ogre::TRect<float>::TRect<float>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?set@?$TRect@M@Ogre@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_left$ = 8						; size = 4
_top$ = 12						; size = 4
_right$ = 16						; size = 4
_bottom$ = 20						; size = 4
?set@?$TRect@M@Ogre@@QAEXMMMM@Z PROC			; Ogre::TRect<float>::set, COMDAT
; _this$ = ecx

; 19   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 			m_Left = left, m_Top = top, m_Right = right, m_Bottom = bottom;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _left$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _top$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _right$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _bottom$[ebp]
	fstp	DWORD PTR [eax+12]

; 21   : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?set@?$TRect@M@Ogre@@QAEXMMMM@Z ENDP			; Ogre::TRect<float>::set
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getWidth@?$TRect@M@Ogre@@QBEMXZ
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
?getWidth@?$TRect@M@Ogre@@QBEMXZ PROC			; Ogre::TRect<float>::getWidth, COMDAT
; _this$ = ecx

; 23   : 		T getWidth() const{ return m_Right-m_Left; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR tv71[ebp]
	fld	DWORD PTR tv71[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?getWidth@?$TRect@M@Ogre@@QBEMXZ ENDP			; Ogre::TRect<float>::getWidth
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getHeight@?$TRect@M@Ogre@@QBEMXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?getHeight@?$TRect@M@Ogre@@QBEMXZ PROC			; Ogre::TRect<float>::getHeight, COMDAT
; _this$ = ecx

; 24   : 		T getHeight() const{ return m_Bottom-m_Top; }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR tv72[ebp]
	fld	DWORD PTR tv72[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?getHeight@?$TRect@M@Ogre@@QBEMXZ ENDP			; Ogre::TRect<float>::getHeight
_TEXT	ENDS
PUBLIC	?size@?$vector@UDrawRect@Ogre@@V?$allocator@UDrawRect@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::DrawRect,std::allocator<Ogre::DrawRect> >::size
EXTRN	__imp___invalid_parameter_noinfo:PROC
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@UDrawRect@Ogre@@V?$allocator@UDrawRect@Ogre@@@std@@@std@@QAEAAUDrawRect@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UDrawRect@Ogre@@V?$allocator@UDrawRect@Ogre@@@std@@@std@@QAEAAUDrawRect@Ogre@@I@Z PROC ; std::vector<Ogre::DrawRect,std::allocator<Ogre::DrawRect> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UDrawRect@Ogre@@V?$allocator@UDrawRect@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::DrawRect,std::allocator<Ogre::DrawRect> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@9
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@9:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UDrawRect@Ogre@@V?$allocator@UDrawRect@Ogre@@@std@@@std@@QAEAAUDrawRect@Ogre@@I@Z ENDP ; std::vector<Ogre::DrawRect,std::allocator<Ogre::DrawRect> >::operator[]
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEABVVertexElement@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEABVVertexElement@Ogre@@I@Z PROC ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::operator[], COMDAT
; _this$ = ecx

; 759  : 		{	// subscript nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@10
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@10:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 771  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEABVVertexElement@Ogre@@I@Z ENDP ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$Singleton@VUIRenderer@Ogre@@@Ogre@@QAE@XZ	; Ogre::Singleton<Ogre::UIRenderer>::Singleton<Ogre::UIRenderer>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogresingleton.h
;	COMDAT ??0?$Singleton@VUIRenderer@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
??0?$Singleton@VUIRenderer@Ogre@@@Ogre@@QAE@XZ PROC	; Ogre::Singleton<Ogre::UIRenderer>::Singleton<Ogre::UIRenderer>, COMDAT
; _this$ = ecx

; 64   : 		Singleton( void )

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 		{
; 66   : 			assert( !ms_Singleton );
; 67   : #if defined( _MSC_VER ) && _MSC_VER < 1200	 
; 68   : 			int offset = (int)(T*)1 - (int)(Singleton <T>*)(T*)1;
; 69   : 			ms_Singleton = (T*)((int)this + offset);
; 70   : #else
; 71   : 			ms_Singleton = static_cast< T* >( this );

	cmp	DWORD PTR _this$[ebp], 0
	je	SHORT $LN3@Singleton
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 636				; 0000027cH
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@Singleton
$LN3@Singleton:
	mov	DWORD PTR tv68[ebp], 0
$LN4@Singleton:
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR ?ms_Singleton@?$Singleton@VUIRenderer@Ogre@@@Ogre@@1PAVUIRenderer@2@A, ecx ; Ogre::Singleton<Ogre::UIRenderer>::ms_Singleton

; 72   : #endif
; 73   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Singleton@VUIRenderer@Ogre@@@Ogre@@QAE@XZ ENDP	; Ogre::Singleton<Ogre::UIRenderer>::Singleton<Ogre::UIRenderer>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$Singleton@VUIRenderer@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$Singleton@VUIRenderer@Ogre@@@Ogre@@QAE@XZ PROC	; Ogre::Singleton<Ogre::UIRenderer>::~Singleton<Ogre::UIRenderer>, COMDAT
; _this$ = ecx

; 75   : 		{  assert( ms_Singleton );  ms_Singleton = 0;  }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR ?ms_Singleton@?$Singleton@VUIRenderer@Ogre@@@Ogre@@1PAVUIRenderer@2@A, 0 ; Ogre::Singleton<Ogre::UIRenderer>::ms_Singleton
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$Singleton@VUIRenderer@Ogre@@@Ogre@@QAE@XZ ENDP	; Ogre::Singleton<Ogre::UIRenderer>::~Singleton<Ogre::UIRenderer>
_TEXT	ENDS
PUBLIC	?getSingleton@?$Singleton@VUIRenderer@Ogre@@@Ogre@@SAAAVUIRenderer@2@XZ ; Ogre::Singleton<Ogre::UIRenderer>::getSingleton
; Function compile flags: /Odtp
;	COMDAT ?getSingleton@?$Singleton@VUIRenderer@Ogre@@@Ogre@@SAAAVUIRenderer@2@XZ
_TEXT	SEGMENT
?getSingleton@?$Singleton@VUIRenderer@Ogre@@@Ogre@@SAAAVUIRenderer@2@XZ PROC ; Ogre::Singleton<Ogre::UIRenderer>::getSingleton, COMDAT

; 77   : 		{	assert( ms_Singleton );  return ( *ms_Singleton ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?ms_Singleton@?$Singleton@VUIRenderer@Ogre@@@Ogre@@1PAVUIRenderer@2@A ; Ogre::Singleton<Ogre::UIRenderer>::ms_Singleton
	pop	ebp
	ret	0
?getSingleton@?$Singleton@VUIRenderer@Ogre@@@Ogre@@SAAAVUIRenderer@2@XZ ENDP ; Ogre::Singleton<Ogre::UIRenderer>::getSingleton
_TEXT	ENDS
PUBLIC	?getSingletonPtr@?$Singleton@VUIRenderer@Ogre@@@Ogre@@SAPAVUIRenderer@2@XZ ; Ogre::Singleton<Ogre::UIRenderer>::getSingletonPtr
; Function compile flags: /Odtp
;	COMDAT ?getSingletonPtr@?$Singleton@VUIRenderer@Ogre@@@Ogre@@SAPAVUIRenderer@2@XZ
_TEXT	SEGMENT
?getSingletonPtr@?$Singleton@VUIRenderer@Ogre@@@Ogre@@SAPAVUIRenderer@2@XZ PROC ; Ogre::Singleton<Ogre::UIRenderer>::getSingletonPtr, COMDAT

; 79   : 		{ return ms_Singleton; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?ms_Singleton@?$Singleton@VUIRenderer@Ogre@@@Ogre@@1PAVUIRenderer@2@A ; Ogre::Singleton<Ogre::UIRenderer>::ms_Singleton
	pop	ebp
	ret	0
?getSingletonPtr@?$Singleton@VUIRenderer@Ogre@@@Ogre@@SAPAVUIRenderer@2@XZ ENDP ; Ogre::Singleton<Ogre::UIRenderer>::getSingletonPtr
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree_val<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tidy
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Copy
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Init
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree_val<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::key_comp
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::get_allocator
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T130221 = -21						; size = 1
$T130220 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T130220[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?get_allocator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::get_allocator
	lea	ecx, DWORD PTR $T130221[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?key_comp@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::key_comp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree_val<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 529  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Init

; 530  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 531  : 		_Copy(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Copy
	jmp	SHORT $LN4@Tree
__catch$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 535  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@Tree
	ret	0
$LN4@Tree:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree:

; 536  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::erase
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::end
; Function compile flags: /Odtp
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T130252 = -40						; size = 8
$T130251 = -32						; size = 8
$T130250 = -24						; size = 8
$T130249 = -16						; size = 8
$T130248 = -8						; size = 8
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator@11

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	lea	ecx, DWORD PTR $T130249[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T130248[ebp], edx
	mov	DWORD PTR $T130248[ebp+4], eax
	lea	ecx, DWORD PTR $T130251[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::begin
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T130250[ebp], edx
	mov	DWORD PTR $T130250[ebp+4], eax
	mov	ecx, DWORD PTR $T130248[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T130248[ebp]
	push	edx
	mov	eax, DWORD PTR $T130250[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T130250[ebp]
	push	ecx
	lea	edx, DWORD PTR $T130252[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Copy
$LN1@operator@11:

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 552  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::IFont *,std::allocator<Ogre::IFont *> >::~_Vector_val<Ogre::IFont *,std::allocator<Ogre::IFont *> >
PUBLIC	?_Tidy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEPAPAVIFont@Ogre@@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Ucopy<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> > >
PUBLIC	?begin@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::begin
PUBLIC	?end@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::end
PUBLIC	?_Buy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Buy
PUBLIC	?size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::size
PUBLIC	??0?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z ; std::_Vector_val<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_val<Ogre::IFont *,std::allocator<Ogre::IFont *> >
PUBLIC	??0?$allocator@PAVIFont@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::IFont *>::allocator<Ogre::IFont *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T130257 = -36						; size = 8
$T130256 = -28						; size = 8
$T130255 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T130255[ebp], esp
	push	eax
	call	??0?$allocator@PAVIFont@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::IFont *>::allocator<Ogre::IFont *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z ; std::_Vector_val<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_val<Ogre::IFont *,std::allocator<Ogre::IFont *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@17

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T130256[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T130257[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEPAPAVIFont@Ogre@@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Ucopy<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@17
__catch$??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@17
	ret	0
$LN5@vector@17:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@17:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@17:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::~vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::~vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >
PUBLIC	?deallocate@?$allocator@PAVIFont@Ogre@@@std@@QAEXPAPAVIFont@Ogre@@I@Z ; std::allocator<Ogre::IFont *>::deallocate
PUBLIC	??$_Ucopy@PAPAVIFont@Ogre@@@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEPAPAVIFont@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Ucopy<Ogre::IFont * *>
PUBLIC	?capacity@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEXPAPAVIFont@Ogre@@0@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVIFont@Ogre@@PAPAV12@@stdext@@YAPAPAVIFont@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::IFont * *,Ogre::IFont * *>
PUBLIC	?clear@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$122677 = -8					; size = 4
__Ptr$122667 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@12

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@12

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::clear
	jmp	$LN9@operator@12
$LN8@operator@12:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@12

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVIFont@Ogre@@PAPAV12@@stdext@@YAPAPAVIFont@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::IFont * *,Ogre::IFont * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$122667[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$122667[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEXPAPAVIFont@Ogre@@0@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@12
$LN6@operator@12:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@12

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$122677[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$122677[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVIFont@Ogre@@PAPAV12@@stdext@@YAPAPAVIFont@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::IFont * *,Ogre::IFont * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$122677[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVIFont@Ogre@@@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEPAPAVIFont@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Ucopy<Ogre::IFont * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@12
$LN4@operator@12:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@12

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEXPAPAVIFont@Ogre@@0@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVIFont@Ogre@@@std@@QAEXPAPAVIFont@Ogre@@I@Z ; std::allocator<Ogre::IFont *>::deallocate
$LN2@operator@12:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@12

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVIFont@Ogre@@@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEPAPAVIFont@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Ucopy<Ogre::IFont * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@12:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::operator=
_TEXT	ENDS
PUBLIC	??_GElement@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAEPAXI@Z ; Ogre::HashTable<Ogre::FixedString,Ogre::UIRenderer::UIResObject,Ogre::FixedStringHashCoder>::Element::`scalar deleting destructor'
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrehashtable.h
;	COMDAT ??1?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ
_TEXT	SEGMENT
tv76 = -32						; size = 4
_this$ = -28						; size = 4
$T130289 = -24						; size = 4
$T130286 = -20						; size = 4
$T130285 = -16						; size = 4
_ptmp$122696 = -12					; size = 4
_pcur$122692 = -8					; size = 4
_i$122688 = -4						; size = 4
??1?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ PROC ; Ogre::HashTable<Ogre::FixedString,Ogre::UIRenderer::UIResObject,Ogre::FixedStringHashCoder>::~HashTable<Ogre::FixedString,Ogre::UIRenderer::UIResObject,Ogre::FixedStringHashCoder>, COMDAT
; _this$ = ecx

; 45   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 46   : 			for( size_t i=0; i<m_MaxSlot; i++ )

	mov	DWORD PTR _i$122688[ebp], 0
	jmp	SHORT $LN5@HashTable
$LN4@HashTable:
	mov	eax, DWORD PTR _i$122688[ebp]
	add	eax, 1
	mov	DWORD PTR _i$122688[ebp], eax
$LN5@HashTable:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$122688[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN3@HashTable

; 47   : 			{
; 48   : 				Element *pcur = m_Table[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$122688[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _pcur$122692[ebp], eax
$LN2@HashTable:

; 49   : 				while( pcur )

	cmp	DWORD PTR _pcur$122692[ebp], 0
	je	SHORT $LN1@HashTable

; 50   : 				{
; 51   : 					Element *ptmp = pcur;

	mov	ecx, DWORD PTR _pcur$122692[ebp]
	mov	DWORD PTR _ptmp$122696[ebp], ecx

; 52   : 					pcur = pcur->pnext;

	mov	edx, DWORD PTR _pcur$122692[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _pcur$122692[ebp], eax

; 53   : 					delete ptmp;

	mov	ecx, DWORD PTR _ptmp$122696[ebp]
	mov	DWORD PTR $T130286[ebp], ecx
	mov	edx, DWORD PTR $T130286[ebp]
	mov	DWORD PTR $T130285[ebp], edx
	cmp	DWORD PTR $T130285[ebp], 0
	je	SHORT $LN8@HashTable
	push	1
	mov	ecx, DWORD PTR $T130285[ebp]
	call	??_GElement@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN9@HashTable
$LN8@HashTable:
	mov	DWORD PTR tv76[ebp], 0
$LN9@HashTable:

; 54   : 				}

	jmp	SHORT $LN2@HashTable
$LN1@HashTable:

; 55   : 			}

	jmp	SHORT $LN4@HashTable
$LN3@HashTable:

; 56   : 			delete[] m_Table;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T130289[ebp], ecx
	mov	edx, DWORD PTR $T130289[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 57   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ ENDP ; Ogre::HashTable<Ogre::FixedString,Ogre::UIRenderer::UIResObject,Ogre::FixedStringHashCoder>::~HashTable<Ogre::FixedString,Ogre::UIRenderer::UIResObject,Ogre::FixedStringHashCoder>
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::~_Vector_val<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
PUBLIC	?_Tidy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEPAV?$TRect@M@Ogre@@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@1@0PAV23@@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Ucopy<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > > >
PUBLIC	?begin@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::begin
PUBLIC	?end@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::end
PUBLIC	?_Buy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Buy
PUBLIC	?size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::size
PUBLIC	??0?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z ; std::_Vector_val<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_val<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
PUBLIC	??0?$allocator@V?$TRect@M@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TRect<float> >::allocator<Ogre::TRect<float> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T130294 = -36						; size = 8
$T130293 = -28						; size = 8
$T130292 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T130292[ebp], esp
	push	eax
	call	??0?$allocator@V?$TRect@M@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TRect<float> >::allocator<Ogre::TRect<float> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z ; std::_Vector_val<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_val<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@18

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T130293[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T130294[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEPAV?$TRect@M@Ogre@@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@1@0PAV23@@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Ucopy<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@18
__catch$??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@18
	ret	0
$LN5@vector@18:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@18:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@18:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::~vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::~vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
PUBLIC	?deallocate@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@I@Z ; std::allocator<Ogre::TRect<float> >::deallocate
PUBLIC	??$_Ucopy@PAV?$TRect@M@Ogre@@@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEPAV?$TRect@M@Ogre@@PAV23@00@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Ucopy<Ogre::TRect<float> *>
PUBLIC	?capacity@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::capacity
PUBLIC	?_Destroy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEXPAV?$TRect@M@Ogre@@0@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Destroy
PUBLIC	??$unchecked_copy@PAV?$TRect@M@Ogre@@PAV12@@stdext@@YAPAV?$TRect@M@Ogre@@PAV12@00@Z ; stdext::unchecked_copy<Ogre::TRect<float> *,Ogre::TRect<float> *>
PUBLIC	?clear@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$122859 = -8					; size = 4
__Ptr$122849 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@13

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::size
	test	eax, eax
	jne	SHORT $LN8@operator@13

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::clear
	jmp	$LN9@operator@13
$LN8@operator@13:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@13

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAV?$TRect@M@Ogre@@PAV12@@stdext@@YAPAV?$TRect@M@Ogre@@PAV12@00@Z ; stdext::unchecked_copy<Ogre::TRect<float> *,Ogre::TRect<float> *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$122849[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$122849[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEXPAV?$TRect@M@Ogre@@0@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::size
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@13
$LN6@operator@13:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@13

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::size
	shl	eax, 4
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$122859[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$122859[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAV?$TRect@M@Ogre@@PAV12@@stdext@@YAPAV?$TRect@M@Ogre@@PAV12@00@Z ; stdext::unchecked_copy<Ogre::TRect<float> *,Ogre::TRect<float> *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$122859[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAV?$TRect@M@Ogre@@@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEPAV?$TRect@M@Ogre@@PAV23@00@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Ucopy<Ogre::TRect<float> *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@13
$LN4@operator@13:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@13

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEXPAV?$TRect@M@Ogre@@0@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@I@Z ; std::allocator<Ogre::TRect<float> >::deallocate
$LN2@operator@13:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@13

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAV?$TRect@M@Ogre@@@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEPAV?$TRect@M@Ogre@@PAV23@00@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Ucopy<Ogre::TRect<float> *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@13:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree_ptr<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree_val<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree_val<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::IFont *,std::allocator<Ogre::IFont *> >::~_Vector_val<Ogre::IFont *,std::allocator<Ogre::IFont *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >
__ehhandler$??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::IFont *,std::allocator<Ogre::IFont *> >::~_Vector_val<Ogre::IFont *,std::allocator<Ogre::IFont *> >
PUBLIC	??1Element@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ ; Ogre::HashTable<Ogre::FixedString,Ogre::UIRenderer::UIResObject,Ogre::FixedStringHashCoder>::Element::~Element
; Function compile flags: /Odtp
;	COMDAT ??_GElement@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GElement@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAEPAXI@Z PROC ; Ogre::HashTable<Ogre::FixedString,Ogre::UIRenderer::UIResObject,Ogre::FixedStringHashCoder>::Element::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Element@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@16
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@16:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GElement@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAEPAXI@Z ENDP ; Ogre::HashTable<Ogre::FixedString,Ogre::UIRenderer::UIResObject,Ogre::FixedStringHashCoder>::Element::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::~_Vector_val<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >
__ehhandler$??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::~_Vector_val<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree_ptr<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree_ptr<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Element@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Element@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ$0
__ehfuncinfo$??1Element@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1Element@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1Element@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Element@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ PROC ; Ogre::HashTable<Ogre::FixedString,Ogre::UIRenderer::UIResObject,Ogre::FixedStringHashCoder>::Element::~Element, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Element@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Element@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??1Element@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Element@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Element@?$HashTable@VFixedString@Ogre@@UUIResObject@UIRenderer@2@VFixedStringHashCoder@2@@Ogre@@QAE@XZ ENDP ; Ogre::HashTable<Ogre::FixedString,Ogre::UIRenderer::UIResObject,Ogre::FixedStringHashCoder>::Element::~Element
PUBLIC	??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0>::~_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ
__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::~_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0>::~_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >
__ehhandler$??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0>::~_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0>
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@UDrawRect@Ogre@@V?$allocator@UDrawRect@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UDrawRect@Ogre@@V?$allocator@UDrawRect@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::DrawRect,std::allocator<Ogre::DrawRect> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	cdq
	mov	ecx, 36					; 00000024H
	idiv	ecx

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UDrawRect@Ogre@@V?$allocator@UDrawRect@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::DrawRect,std::allocator<Ogre::DrawRect> >::size
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::iterator::iterator
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lmost
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::begin, COMDAT
; _this$ = ecx

; 555  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 557  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::end, COMDAT
; _this$ = ecx

; 565  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 567  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::end
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >
; Function compile flags: /Odtp
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 615  : 		{	// return allocator object for values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 617  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::get_allocator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 620  : 		{	// return object for comparing keys

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 622  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Make_iter
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::erase
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator++
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator!=
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::clear
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T130400 = -32						; size = 8
$T130399 = -24						; size = 8
$T130398 = -16						; size = 8
$T130397 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	lea	eax, DWORD PTR $T130397[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@erase
	lea	edx, DWORD PTR $T130398[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@erase

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::clear

; 938  : 			return (begin());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::begin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase
$LN2@erase:

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@erase

; 943  : 				erase(_First++);

	push	0
	lea	ecx, DWORD PTR $T130399[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator++
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T130400[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::erase
	jmp	SHORT $LN2@erase
$LN1@erase:

; 944  : 			return (_Make_iter(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rmost
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Min
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::size
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Copy
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
; Function compile flags: /Odtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	DWORD PTR [eax], esi

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 1065 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN2@Copy

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Min
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lmost
	mov	DWORD PTR [eax], esi

; 1068 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Max@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Max
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rmost
	mov	DWORD PTR [eax], esi

; 1069 : 			}
; 1070 : 		else

	jmp	SHORT $LN3@Copy
$LN2@Copy:

; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
$LN3@Copy:

; 1072 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1182 : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::deallocate
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::destroy
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T130411 = -40						; size = 8
$T130410 = -32						; size = 8
$T130409 = -24						; size = 8
$T130408 = -16						; size = 8
$T130407 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T130408[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T130407[ebp], ecx
	mov	DWORD PTR $T130407[ebp+4], edx
	lea	eax, DWORD PTR $T130410[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T130409[ebp], ecx
	mov	DWORD PTR $T130409[ebp+4], edx
	mov	eax, DWORD PTR $T130407[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T130407[ebp]
	push	ecx
	mov	edx, DWORD PTR $T130409[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T130409[ebp]
	push	eax
	lea	ecx, DWORD PTR $T130411[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::destroy

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::destroy

; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::destroy

; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::deallocate

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree_ptr<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T130414 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree_val<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T130414[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree_ptr<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >

; 98   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_val@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree_val<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
PUBLIC	??1_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::~_Container_base_aux
PUBLIC	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >
; Function compile flags: /Odtp
;	COMDAT ??1_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::~_Container_base_aux, COMDAT
; _this$ = ecx

; 402  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 		// Do nothing: ~_Container_base_aux_alloc_real() previously destroyed the aux object.
; 404  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::~_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity
$LN3@capacity:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@PAPAVIFont@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@PAPAVIFont@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@PAPAVIFont@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::erase
PUBLIC	?begin@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::begin
PUBLIC	?end@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T130449 = -40						; size = 8
$T130448 = -32						; size = 8
$T130447 = -24						; size = 8
$T130446 = -16						; size = 8
$T130445 = -8						; size = 8
?clear@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T130446[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T130445[ebp], ecx
	mov	DWORD PTR $T130445[ebp+4], edx
	lea	eax, DWORD PTR $T130448[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T130447[ebp], ecx
	mov	DWORD PTR $T130447[ebp+4], edx
	mov	eax, DWORD PTR $T130445[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T130445[ebp]
	push	ecx
	mov	edx, DWORD PTR $T130447[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T130447[ebp]
	push	eax
	lea	ecx, DWORD PTR $T130449[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVIFont@Ogre@@@std@@QAEPAPAVIFont@Ogre@@I@Z ; std::allocator<Ogre::IFont *>::allocate
PUBLIC	?_Xlen@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVIFont@Ogre@@@std@@QAEPAPAVIFont@Ogre@@I@Z ; std::allocator<Ogre::IFont *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAXPAPAVIFont@Ogre@@0AAV?$allocator@PAVIFont@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::IFont *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEXPAPAVIFont@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEXPAPAVIFont@Ogre@@0@Z PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAXPAPAVIFont@Ogre@@0AAV?$allocator@PAVIFont@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::IFont *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEXPAPAVIFont@Ogre@@0@Z ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEXPAPAVIFont@Ogre@@0@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVIFont@Ogre@@@std@@QAEXPAPAVIFont@Ogre@@I@Z ; std::allocator<Ogre::IFont *>::deallocate
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T130458 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_val<Ogre::IFont *,std::allocator<Ogre::IFont *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T130458[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVIFont@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::IFont *>::allocator<Ogre::IFont *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVIFont@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::IFont *>::allocator<Ogre::IFont *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >
__ehhandler$??0?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_val<Ogre::IFont *,std::allocator<Ogre::IFont *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVIFont@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVIFont@Ogre@@@std@@QAE@ABV01@@Z PROC	; std::allocator<Ogre::IFont *>::allocator<Ogre::IFont *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVIFont@Ogre@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<Ogre::IFont *>::allocator<Ogre::IFont *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVIFont@Ogre@@@std@@QAEXPAPAVIFont@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVIFont@Ogre@@@std@@QAEXPAPAVIFont@Ogre@@I@Z PROC ; std::allocator<Ogre::IFont *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVIFont@Ogre@@@std@@QAEXPAPAVIFont@Ogre@@I@Z ENDP ; std::allocator<Ogre::IFont *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@2
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@2
$LN3@capacity@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@2:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@PAV?$TRect@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@PAV?$TRect@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@PAV?$TRect@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 4

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::erase
PUBLIC	?begin@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::begin
PUBLIC	?end@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T130495 = -40						; size = 8
$T130494 = -32						; size = 8
$T130493 = -24						; size = 8
$T130492 = -16						; size = 8
$T130491 = -8						; size = 8
?clear@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T130492[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T130491[ebp], ecx
	mov	DWORD PTR $T130491[ebp+4], edx
	lea	eax, DWORD PTR $T130494[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T130493[ebp], ecx
	mov	DWORD PTR $T130493[ebp+4], edx
	mov	eax, DWORD PTR $T130491[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T130491[ebp]
	push	ecx
	mov	edx, DWORD PTR $T130493[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T130493[ebp]
	push	eax
	lea	ecx, DWORD PTR $T130495[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@V?$TRect@M@Ogre@@@std@@QAEPAV?$TRect@M@Ogre@@I@Z ; std::allocator<Ogre::TRect<float> >::allocate
PUBLIC	?_Xlen@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Xlen
PUBLIC	?max_size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2
$LN2@Buy@2:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@V?$TRect@M@Ogre@@@std@@QAEPAV?$TRect@M@Ogre@@I@Z ; std::allocator<Ogre::TRect<float> >::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAXPAV?$TRect@M@Ogre@@0AAV?$allocator@V?$TRect@M@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TRect<float> > >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEXPAV?$TRect@M@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEXPAV?$TRect@M@Ogre@@0@Z PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAXPAV?$TRect@M@Ogre@@0AAV?$allocator@V?$TRect@M@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TRect<float> > >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEXPAV?$TRect@M@Ogre@@0@Z ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEXPAV?$TRect@M@Ogre@@0@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@I@Z ; std::allocator<Ogre::TRect<float> >::deallocate
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >::_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T130504 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_val<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T130504[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@V?$TRect@M@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TRect<float> >::allocator<Ogre::TRect<float> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >::_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$TRect@M@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TRect<float> >::allocator<Ogre::TRect<float> >

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >
__ehhandler$??0?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_val<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@V?$TRect@M@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@V?$TRect@M@Ogre@@@std@@QAE@ABV01@@Z PROC	; std::allocator<Ogre::TRect<float> >::allocator<Ogre::TRect<float> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@V?$TRect@M@Ogre@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<Ogre::TRect<float> >::allocator<Ogre::TRect<float> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@I@Z PROC ; std::allocator<Ogre::TRect<float> >::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@I@Z ENDP ; std::allocator<Ogre::TRect<float> >::deallocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil, COMDAT

; 156  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 53					; 00000035H

; 158  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left, COMDAT

; 166  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 168  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent, COMDAT

; 171  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 173  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right, COMDAT

; 176  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 178  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T130537 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 575  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	lea	ecx, DWORD PTR $T130537[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::iterator::iterator
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 577  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::size, COMDAT
; _this$ = ecx

; 600  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 602  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::size
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::destroy
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lrotate
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator++
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::_Mynode
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -108						; size = 4
tv165 = -104						; size = 4
_this$ = -100						; size = 4
$T130543 = -96						; size = 28
$T130542 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN40@erase@2

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T130543[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T130543[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T130542[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T130542[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T130543[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN40@erase@2:

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Erasednode$[ebp], eax

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator++

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN39@erase@2

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@2
$LN39@erase@2:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN37@erase@2

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@2
$LN37@erase@2:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], eax
$LN38@erase@2:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	$LN35@erase@2

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 797  : 			if (!_Isnil(_Fixnode))

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN34@erase@2

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], ecx
$LN34@erase@2:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN33@erase@2

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN32@erase@2
$LN33@erase@2:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN31@erase@2

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], edx

; 804  : 			else

	jmp	SHORT $LN32@erase@2
$LN31@erase@2:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN32@erase@2:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN29@erase@2

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@erase@2
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], edx
	jmp	SHORT $LN44@erase@2
$LN43@erase@2:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Min@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Min
	add	esp, 4
	mov	DWORD PTR tv165[ebp], eax
$LN44@erase@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lmost
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@erase@2:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@2

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN45@erase@2
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN46@erase@2
$LN45@erase@2:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR tv177[ebp], eax
$LN46@erase@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rmost
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR [eax], ecx
$LN28@erase@2:

; 816  : 			}
; 817  : 		else

	jmp	$LN27@erase@2
$LN35@erase@2:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN26@erase@2

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 824  : 			else

	jmp	$LN25@erase@2
$LN26@erase@2:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN24@erase@2

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], edx
$LN24@erase@2:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN25@erase@2:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN23@erase@2

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN22@erase@2
$LN23@erase@2:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN21@erase@2

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN22@erase@2
$LN21@erase@2:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN22@erase@2:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	push	eax
	call	??$swap@D@std@@YAXAAD0@Z		; std::swap<char>
	add	esp, 8
$LN27@erase@2:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	$LN19@erase@2

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN18@erase@2
$LN17@erase@2:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	edx, DWORD PTR __Fixnode$[ebp]
	cmp	edx, DWORD PTR [eax]
	je	$LN16@erase@2
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	$LN16@erase@2

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN15@erase@2

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN14@erase@2

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@2:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN13@erase@2

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@2
$LN13@erase@2:

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@2
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@2

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	$LN12@erase@2
$LN11@erase@2:

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 1
	jne	SHORT $LN9@erase@2

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN9@erase@2:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN16@erase@2
$LN12@erase@2:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@2
$LN15@erase@2:

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN7@erase@2

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN7@erase@2:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@erase@2

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], edx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@2
$LN6@erase@2:

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@2
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@2

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 902  : 						}
; 903  : 					else

	jmp	$LN8@erase@2
$LN4@erase@2:

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN2@erase@2

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 909  : 							_Lrotate(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@2:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@2
$LN8@erase@2:

; 918  : 						}
; 919  : 					}

	jmp	$LN17@erase@2
$LN16@erase@2:

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1
$LN19@erase@2:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::destroy

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	1
	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::deallocate

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jbe	SHORT $LN1@erase@2

; 928  : 			--_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx
$LN1@erase@2:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@2:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T130543[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::erase
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1logic_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$1
__ehfuncinfo$??1logic_error@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1logic_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 31   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1logic_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??1logic_error@std@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1logic_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@17
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@17:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1out_of_range@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1out_of_range@std@@UAE@XZ$0
__ehfuncinfo$??1out_of_range@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1out_of_range@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1out_of_range@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 134  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1out_of_range@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1out_of_range@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1out_of_range@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odtp
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ		; std::out_of_range::~out_of_range
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@18
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@18:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Buynode
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Myval
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
__Pnode$124651 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	$LN3@Copy@2

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Myval
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Buynode
	mov	DWORD PTR __Pnode$124651[ebp], eax

; 1082 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@Copy@2

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$124651[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@2:

; 1084 : 
; 1085 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$124651[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Copy
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$124651[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	DWORD PTR [eax], esi

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR __Pnode$124651[ebp]
	push	ecx
	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR __Pnode$124651[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN6@Copy@2
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1091 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Copy@2
	ret	0
$LN6@Copy@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@2:

; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@2:

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Copy
; Function compile flags: /Odtp
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1280 : 		{	// return leftmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4

; 1282 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Max, COMDAT

; 1305 : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Max:

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Max

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1309 : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Max
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Min, COMDAT

; 1312 : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Min:

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Min

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1316 : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Min
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1319 : 		{	// return rightmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4

; 1321 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1324 : 		{	// return root of nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4

; 1326 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::construct
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T130649 = -36						; size = 4
$T130648 = -32						; size = 4
$T130647 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T130647[ebp], 0
	lea	eax, DWORD PTR $T130647[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::construct

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T130648[ebp], 0
	lea	eax, DWORD PTR $T130648[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::construct

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T130649[ebp], 0
	lea	eax, DWORD PTR $T130649[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::construct
	jmp	SHORT $LN6@Buynode
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 1
	jle	SHORT $LN2@Buynode

; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::destroy
$LN2@Buynode:

; 1396 : 		if (0 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 0
	jle	SHORT $LN1@Buynode

; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::destroy
$LN1@Buynode:

; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::deallocate

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ$1
	ret	0
$LN6@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ$1:

; 1401 : 		_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T130665 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree_ptr<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T130665[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >

; 79   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_ptr@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree_ptr<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@PAPAVIFont@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@PAPAVIFont@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@PAPAVIFont@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVIFont@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::IFont *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVIFont@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::IFont *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$124715 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVIFont@Ogre@@PAPAV12@@stdext@@YAPAPAVIFont@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::IFont * *,Ogre::IFont * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$124715[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$124715[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEXPAPAVIFont@Ogre@@0@Z ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$124715[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@3:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::erase
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T130690 = -80						; size = 28
$T130689 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T130690[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T130690[ebp]
	push	eax
	lea	ecx, DWORD PTR $T130689[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T130689[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T130690[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T130690[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Xlen
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1length_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1length_error@std@@UAE@XZ$0
__ehfuncinfo$??1length_error@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1length_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1length_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1length_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1length_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1length_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@19
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@19:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
PUBLIC	??$?0PAVIFont@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVIFont@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::IFont *>
PUBLIC	??0_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::_Container_base_aux
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T130722 = -24						; size = 4
$T130721 = -20						; size = 4
$T130720 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVIFont@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVIFont@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::IFont *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T130722[ebp], eax
	mov	ecx, DWORD PTR $T130722[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T130721[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T130721[ebp], 0
	je	SHORT $LN3@Container_
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T130721[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_
$LN3@Container_:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T130720[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T130720[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T130722[ebp]
	push	eax
	mov	ecx, DWORD PTR $T130721[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAE@V?$allocator@PAVIFont@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::IFont *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 58   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 60   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z PROC	; std::_Aux_cont::_Aux_cont, COMDAT
; _this$ = ecx

; 364  : 	explicit _Aux_cont(const _Container_base_aux * const _Pcont)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ENDP	; std::_Aux_cont::_Aux_cont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::_Container_base_aux, COMDAT
; _this$ = ecx

; 379  : 	_Container_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		{
; 381  : 		// Do nothing: _Container_base_aux_alloc_real() will construct the aux object.
; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::_Container_base_aux
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::IFont *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVIFont@Ogre@@@std@@QAEPAPAVIFont@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVIFont@Ogre@@@std@@QAEPAPAVIFont@Ogre@@I@Z PROC ; std::allocator<Ogre::IFont *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::IFont *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVIFont@Ogre@@@std@@QAEPAPAVIFont@Ogre@@I@Z ENDP ; std::allocator<Ogre::IFont *>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@PAV?$TRect@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@PAV?$TRect@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@PAV?$TRect@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@V?$TRect@M@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::TRect<float> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@V?$TRect@M@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::TRect<float> >::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::operator!=
PUBLIC	?_Make_iter@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$124759 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@4

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAV?$TRect@M@Ogre@@PAV12@@stdext@@YAPAV?$TRect@M@Ogre@@PAV12@00@Z ; stdext::unchecked_copy<Ogre::TRect<float> *,Ogre::TRect<float> *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$124759[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$124759[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEXPAV?$TRect@M@Ogre@@0@Z ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$124759[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@4:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T130754 = -80						; size = 28
$T130753 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T130754[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T130754[ebp]
	push	eax
	lea	ecx, DWORD PTR $T130753[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T130753[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T130754[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T130754[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Xlen
PUBLIC	??$?0V?$TRect@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$TRect@M@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TRect<float> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T130766 = -24						; size = 4
$T130765 = -20						; size = 4
$T130764 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >::_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0V?$TRect@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$TRect@M@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TRect<float> >

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T130766[ebp], eax
	mov	ecx, DWORD PTR $T130766[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T130765[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T130765[ebp], 0
	je	SHORT $LN3@Container_@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T130765[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@2
$LN3@Container_@2:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@2:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T130764[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T130764[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T130766[ebp]
	push	eax
	mov	ecx, DWORD PTR $T130765[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAE@V?$allocator@V?$TRect@M@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >::_Container_base_aux_alloc_real<std::allocator<Ogre::TRect<float> > >
PUBLIC	??$_Allocate@V?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@IPAV12@@Z ; std::_Allocate<Ogre::TRect<float> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$TRect@M@Ogre@@@std@@QAEPAV?$TRect@M@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$TRect@M@Ogre@@@std@@QAEPAV?$TRect@M@Ogre@@I@Z PROC ; std::allocator<Ogre::TRect<float> >::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@IPAV12@@Z ; std::_Allocate<Ogre::TRect<float> >
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V?$TRect@M@Ogre@@@std@@QAEPAV?$TRect@M@Ogre@@I@Z ENDP ; std::allocator<Ogre::TRect<float> >::allocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 451  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::const_iterator

; 452  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::iterator::iterator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 279  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 281  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator++

; 282  : 			return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  : 			}

	mov	esp, ebp
	pop	ebp
	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 299  : 			{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@14
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@14
$LN1@operator@14:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@14:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 312  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = ecx

; 462  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Other$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al

; 464  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 467  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 		return _Myaux != 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	al, cl

; 469  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 315  : 			{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 317  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
PUBLIC	??0?$_Ranit@PAVIFont@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::IFont *,int,Ogre::IFont * const *,Ogre::IFont * const &>::_Ranit<Ogre::IFont *,int,Ogre::IFont * const *,Ogre::IFont * const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@PAPAVIFont@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@PAPAVIFont@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVIFont@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con
$LN1@Vector_con:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@PAPAVIFont@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = ecx

; 452  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 454  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
_TEXT	ENDS
PUBLIC	??0?$_Ranit@V?$TRect@M@Ogre@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<Ogre::TRect<float>,int,Ogre::TRect<float> const *,Ogre::TRect<float> const &>::_Ranit<Ogre::TRect<float>,int,Ogre::TRect<float> const *,Ogre::TRect<float> const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@PAV?$TRect@M@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@PAV?$TRect@M@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@V?$TRect@M@Ogre@@HPBV12@ABV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@2
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@2
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@2
$LN1@Vector_con@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@2:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@PAV?$TRect@M@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVIFont@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::IFont *,int,Ogre::IFont * const *,Ogre::IFont * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::IFont *,int,Ogre::IFont * const *,Ogre::IFont * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVIFont@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVIFont@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::IFont *,int,Ogre::IFont * const *,Ogre::IFont * const &>::_Ranit<Ogre::IFont *,int,Ogre::IFont * const *,Ogre::IFont * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVIFont@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVIFont@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::IFont *,int,Ogre::IFont * const *,Ogre::IFont * const &>::_Ranit<Ogre::IFont *,int,Ogre::IFont * const *,Ogre::IFont * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$TRect@M@Ogre@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TRect<float>,int,Ogre::TRect<float> const *,Ogre::TRect<float> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TRect<float>,int,Ogre::TRect<float> const *,Ogre::TRect<float> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@V?$TRect@M@Ogre@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@V?$TRect@M@Ogre@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::TRect<float>,int,Ogre::TRect<float> const *,Ogre::TRect<float> const &>::_Ranit<Ogre::TRect<float>,int,Ogre::TRect<float> const *,Ogre::TRect<float> const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$TRect@M@Ogre@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@V?$TRect@M@Ogre@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::TRect<float>,int,Ogre::TRect<float> const *,Ogre::TRect<float> const &>::_Ranit<Ogre::TRect<float>,int,Ogre::TRect<float> const *,Ogre::TRect<float> const &>
_TEXT	ENDS
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVIFont@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVIFont@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::IFont *,int,Ogre::IFont * const *,Ogre::IFont * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::IFont *,int,Ogre::IFont * const *,Ogre::IFont * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVIFont@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::IFont *,int,Ogre::IFont * const *,Ogre::IFont * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::IFont *,int,Ogre::IFont * const *,Ogre::IFont * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = ecx

; 448  : 	_Iterator_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$TRect@M@Ogre@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$TRect@M@Ogre@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TRect<float>,int,Ogre::TRect<float> const *,Ogre::TRect<float> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TRect<float>,int,Ogre::TRect<float> const *,Ogre::TRect<float> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$TRect@M@Ogre@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TRect<float>,int,Ogre::TRect<float> const *,Ogre::TRect<float> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TRect<float>,int,Ogre::TRect<float> const *,Ogre::TRect<float> const &,std::_Iterator_base_aux>
_TEXT	ENDS
PUBLIC	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color, COMDAT

; 151  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 52					; 00000034H

; 153  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Color
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Myval, COMDAT

; 181  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 183  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Myval
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$124989 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$124989[ebp], eax
	jmp	SHORT $LN3@Erase
$LN2@Erase:
	mov	ecx, DWORD PTR __Pnode$124989[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN3@Erase:
	mov	edx, DWORD PTR __Pnode$124989[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Erase

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$124989[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$124989[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$124989[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::destroy

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	1
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::deallocate

; 1173 : 			}

	jmp	SHORT $LN2@Erase
$LN4@Erase:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Lrotate
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1297 : 		else

	jmp	SHORT $LN3@Lrotate
$LN2@Lrotate:

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Lrotate:

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1302 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Rrotate
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1341 : 		else

	jmp	SHORT $LN3@Rrotate
$LN2@Rrotate:

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Rrotate:

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1346 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node::_Node
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z$3
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z
_TEXT	SEGMENT
tv86 = -36						; size = 4
_this$ = -32						; size = 4
$T130831 = -28						; size = 4
$T130830 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	56					; 00000038H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T130831[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T130831[ebp], 0
	je	SHORT $LN4@Buynode@2
	movzx	ecx, BYTE PTR __Carg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Rarg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Larg$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T130831[ebp]
	call	??0_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node::_Node
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN5@Buynode@2
$LN4@Buynode@2:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@2:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T130830[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Buynode@2
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::deallocate

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z$1
	ret	0
$LN6@Buynode@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@2:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T130831[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >
PUBLIC	??0?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0>::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T130850 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T130850[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0>::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >

; 53   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@XZ
__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::construct
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@PAPAVIFont@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVIFont@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVIFont@Ogre@@@std@@QBEIXZ PROC	; std::allocator<Ogre::IFont *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVIFont@Ogre@@@std@@QBEIXZ ENDP	; std::allocator<Ogre::IFont *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@PAV?$TRect@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$TRect@M@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@V?$TRect@M@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::TRect<float> >::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 268435455	; 0fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@2
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@2
$LN3@max_size@2:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@V?$TRect@M@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::TRect<float> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_Bidit@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>,int,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const &>::_Bidit<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>,int,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 234  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	cmp	DWORD PTR __Plist$[ebp], 0
	jne	SHORT $LN1@const_iter
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@const_iter:

; 236  : 			this->_Set_container(_Plist);

	mov	edx, DWORD PTR __Plist$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 237  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 			_Inc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 276  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 409  : 			{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 411  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@PAPAVIFont@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@PAPAVIFont@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@PAPAVIFont@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QAE@PAPAVIFont@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Vector_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@PAV?$TRect@M@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@PAV?$TRect@M@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@PAV?$TRect@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QAE@PAV?$TRect@M@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Vector_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>,int,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>,int,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Bidit@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Bidit@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>,int,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const &>::_Bidit<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>,int,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Bidit@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>,int,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const &>::_Bidit<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>,int,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const &>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>,int,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>,int,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>,int,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>,int,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> const &,std::_Iterator_base_aux>
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??0?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T130896 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z PROC ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0>::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T130896[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 40   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >
__ehhandler$??0?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@QAE@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ENDP ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0>::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$125166 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@Inc
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Inc:

; 389  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	$LN8@Inc
$LN6@Inc:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Min
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 398  : 			else

	jmp	SHORT $LN8@Inc
$LN2@Inc:

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$125166[ebp], edx
	mov	eax, DWORD PTR __Pnode$125166[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@Inc
	mov	edx, DWORD PTR __Pnode$125166[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$125166[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$125166[ebp]
	mov	DWORD PTR [edx+4], eax
$LN8@Inc:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@15
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@15
$LN1@operator@15:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@15:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@16
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@16
$LN1@operator@16:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@16:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::operator==
_TEXT	ENDS
PUBLIC	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>
PUBLIC	??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@ABU01@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??0_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z$0
__ehfuncinfo$??0_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@ABU01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+52], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+53], 0

; 39   : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ
__ehhandler$??0_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node::_Node
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@ABU01@@Z$0
__ehfuncinfo$??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@ABU01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@ABU01@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 28					; 0000001cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@ABU01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@ABU01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@ABU01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@ABU01@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect>
PUBLIC	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T130941 = -24						; size = 4
$T130940 = -20						; size = 4
$T130939 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T130941[ebp], eax
	mov	ecx, DWORD PTR $T130941[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T130940[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T130940[ebp], 0
	je	SHORT $LN3@Container_@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T130940[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@3
$LN3@Container_@3:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@3:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T130939[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T130939[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z$1:
	mov	eax, DWORD PTR $T130941[ebp]
	push	eax
	mov	ecx, DWORD PTR $T130940[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> > >
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
;	COMDAT ??$Abs@M@Ogre@@YAMABM@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
_x$ = 8							; size = 4
??$Abs@M@Ogre@@YAMABM@Z PROC				; Ogre::Abs<float>, COMDAT

; 125  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 126  : 		return (x<0.0f) ? (-x) : x;

	mov	eax, DWORD PTR _x$[ebp]
	fld	DWORD PTR [eax]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@Abs
	mov	ecx, DWORD PTR _x$[ebp]
	fld	DWORD PTR [ecx]
	fchs
	fstp	DWORD PTR tv68[ebp]
	jmp	SHORT $LN4@Abs
$LN3@Abs:
	mov	edx, DWORD PTR _x$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR tv68[ebp]
$LN4@Abs:
	fld	DWORD PTR tv68[ebp]

; 127  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$Abs@M@Ogre@@YAMABM@Z ENDP				; Ogre::Abs<float>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$Max@M@Ogre@@YAMABM0@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$Max@M@Ogre@@YAMABM0@Z PROC				; Ogre::Max<float>, COMDAT

; 120  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 121  : 		return ( (a) > (b) ? (a) : (b) );

	mov	eax, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@Max@2
	mov	edx, DWORD PTR _a$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR tv67[ebp]
	jmp	SHORT $LN4@Max@2
$LN3@Max@2:
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR tv67[ebp]
$LN4@Max@2:
	fld	DWORD PTR tv67[ebp]

; 122  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$Max@M@Ogre@@YAMABM0@Z ENDP				; Ogre::Max<float>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$Min@M@Ogre@@YAMABM0@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$Min@M@Ogre@@YAMABM0@Z PROC				; Ogre::Min<float>, COMDAT

; 115  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 116  : 		return ( (a) < (b) ? (a) : (b) );

	mov	eax, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@Min@2
	mov	edx, DWORD PTR _a$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR tv67[ebp]
	jmp	SHORT $LN4@Min@2
$LN3@Min@2:
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR tv67[ebp]
$LN4@Min@2:
	fld	DWORD PTR tv67[ebp]

; 117  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$Min@M@Ogre@@YAMABM0@Z ENDP				; Ogre::Min<float>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@PAPAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@2@@stdext@@YAPAPAVIFont@Ogre@@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVIFont@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >,Ogre::IFont * *,std::allocator<Ogre::IFont *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEPAPAVIFont@Ogre@@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEPAPAVIFont@Ogre@@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Ucopy<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@PAPAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@2@@stdext@@YAPAPAVIFont@Ogre@@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVIFont@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >,Ogre::IFont * *,std::allocator<Ogre::IFont *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEPAPAVIFont@Ogre@@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Ucopy<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVIFont@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVIFont@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::IFont * *,Ogre::IFont * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::IFont * *>
PUBLIC	??$_Iter_random@PAPAVIFont@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVIFont@Ogre@@0@Z ; std::_Iter_random<Ogre::IFont * *,Ogre::IFont * *>
PUBLIC	??$_Ptr_cat@PAPAVIFont@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVIFont@Ogre@@0@Z ; std::_Ptr_cat<Ogre::IFont * *,Ogre::IFont * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVIFont@Ogre@@PAPAV12@@stdext@@YAPAPAVIFont@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T130970 = -3						; size = 1
$T130969 = -2						; size = 1
$T130968 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVIFont@Ogre@@PAPAV12@@stdext@@YAPAPAVIFont@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::IFont * *,Ogre::IFont * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T130968[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVIFont@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVIFont@Ogre@@0@Z ; std::_Ptr_cat<Ogre::IFont * *,Ogre::IFont * *>
	add	esp, 8
	mov	BYTE PTR $T130969[ebp], al
	movzx	eax, BYTE PTR $T130968[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T130969[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T130970[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVIFont@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVIFont@Ogre@@0@Z ; std::_Iter_random<Ogre::IFont * *,Ogre::IFont * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::IFont * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::IFont * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVIFont@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVIFont@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::IFont * *,Ogre::IFont * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVIFont@Ogre@@PAPAV12@@stdext@@YAPAPAVIFont@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::IFont * *,Ogre::IFont * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@stdext@@YAPAPAVIFont@Ogre@@PAPAV12@00AAV?$allocator@PAVIFont@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::IFont * *,Ogre::IFont * *,std::allocator<Ogre::IFont *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVIFont@Ogre@@@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEPAPAVIFont@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVIFont@Ogre@@@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEPAPAVIFont@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Ucopy<Ogre::IFont * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@stdext@@YAPAPAVIFont@Ogre@@PAPAV12@00AAV?$allocator@PAVIFont@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::IFont * *,Ogre::IFont * *,std::allocator<Ogre::IFont *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVIFont@Ogre@@@?$vector@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@IAEPAPAVIFont@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Ucopy<Ogre::IFont * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@PAV?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@2@@stdext@@YAPAV?$TRect@M@Ogre@@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEPAV?$TRect@M@Ogre@@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@1@0PAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEPAV?$TRect@M@Ogre@@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@1@0PAV23@@Z PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Ucopy<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@PAV?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@2@@stdext@@YAPAV?$TRect@M@Ogre@@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEPAV?$TRect@M@Ogre@@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@1@0PAV23@@Z ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Ucopy<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAV?$TRect@M@Ogre@@PAV12@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::TRect<float> *,Ogre::TRect<float> *>
PUBLIC	??$_Checked_base@PAV?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@AAPAV12@@Z ; std::_Checked_base<Ogre::TRect<float> *>
PUBLIC	??$_Iter_random@PAV?$TRect@M@Ogre@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$TRect@M@Ogre@@0@Z ; std::_Iter_random<Ogre::TRect<float> *,Ogre::TRect<float> *>
PUBLIC	??$_Ptr_cat@PAV?$TRect@M@Ogre@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$TRect@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TRect<float> *,Ogre::TRect<float> *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAV?$TRect@M@Ogre@@PAV12@@stdext@@YAPAV?$TRect@M@Ogre@@PAV12@00@Z
_TEXT	SEGMENT
$T130979 = -3						; size = 1
$T130978 = -2						; size = 1
$T130977 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAV?$TRect@M@Ogre@@PAV12@@stdext@@YAPAV?$TRect@M@Ogre@@PAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::TRect<float> *,Ogre::TRect<float> *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T130977[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAV?$TRect@M@Ogre@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$TRect@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TRect<float> *,Ogre::TRect<float> *>
	add	esp, 8
	mov	BYTE PTR $T130978[ebp], al
	movzx	eax, BYTE PTR $T130977[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T130978[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T130979[ebp]
	push	ecx
	call	??$_Iter_random@PAV?$TRect@M@Ogre@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$TRect@M@Ogre@@0@Z ; std::_Iter_random<Ogre::TRect<float> *,Ogre::TRect<float> *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAV?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@AAPAV12@@Z ; std::_Checked_base<Ogre::TRect<float> *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAV?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@AAPAV12@@Z ; std::_Checked_base<Ogre::TRect<float> *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAV?$TRect@M@Ogre@@PAV12@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::TRect<float> *,Ogre::TRect<float> *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAV?$TRect@M@Ogre@@PAV12@@stdext@@YAPAV?$TRect@M@Ogre@@PAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::TRect<float> *,Ogre::TRect<float> *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@stdext@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::TRect<float> *,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAV?$TRect@M@Ogre@@@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEPAV?$TRect@M@Ogre@@PAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAV?$TRect@M@Ogre@@@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEPAV?$TRect@M@Ogre@@PAV23@00@Z PROC ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Ucopy<Ogre::TRect<float> *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@stdext@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::TRect<float> *,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAV?$TRect@M@Ogre@@@?$vector@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@IAEPAV?$TRect@M@Ogre@@PAV23@00@Z ENDP ; std::vector<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Ucopy<Ogre::TRect<float> *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAXPAPAVIFont@Ogre@@0AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::IFont *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAXPAPAVIFont@Ogre@@0AAV?$allocator@PAVIFont@Ogre@@@0@@Z
_TEXT	SEGMENT
$T130984 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAXPAPAVIFont@Ogre@@0AAV?$allocator@PAVIFont@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::IFont *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVIFont@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVIFont@Ogre@@0@Z ; std::_Ptr_cat<Ogre::IFont * *,Ogre::IFont * *>
	add	esp, 8
	mov	BYTE PTR $T130984[ebp], al
	movzx	edx, BYTE PTR $T130984[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAXPAPAVIFont@Ogre@@0AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::IFont *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAXPAPAVIFont@Ogre@@0AAV?$allocator@PAVIFont@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::IFont *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAXPAV?$TRect@M@Ogre@@0AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TRect<float> > >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAXPAV?$TRect@M@Ogre@@0AAV?$allocator@V?$TRect@M@Ogre@@@0@@Z
_TEXT	SEGMENT
$T130987 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAXPAV?$TRect@M@Ogre@@0AAV?$allocator@V?$TRect@M@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::TRect<float> > >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAV?$TRect@M@Ogre@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$TRect@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TRect<float> *,Ogre::TRect<float> *>
	add	esp, 8
	mov	BYTE PTR $T130987[ebp], al
	movzx	edx, BYTE PTR $T130987[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAXPAV?$TRect@M@Ogre@@0AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TRect<float> > >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAXPAV?$TRect@M@Ogre@@0AAV?$allocator@V?$TRect@M@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::TRect<float> > >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$126294 = -1					; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	ecx

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR __Tmp$126294[ebp], dl

; 21   : 
; 22   : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 23   : 		_Right = _Tmp;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR __Tmp$126294[ebp]
	mov	BYTE PTR [eax], cl
$LN2@swap:

; 24   : 		}
; 25   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVIFont@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVIFont@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVIFont@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVIFont@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::IFont *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVIFont@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVIFont@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::IFont *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T130998 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::IFont *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T130998[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T130998[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::IFont *>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_alloc@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0
__ehfuncinfo$??1bad_alloc@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_alloc@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 381  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??1bad_alloc@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1bad_alloc@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@20
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@20:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0V?$TRect@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$TRect@M@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0V?$TRect@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$TRect@M@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TRect<float> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V?$TRect@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$TRect@M@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TRect<float> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@IPAV12@@Z
_TEXT	SEGMENT
$T131023 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@IPAV12@@Z PROC ; std::_Allocate<Ogre::TRect<float> >, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T131023[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T131023[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@IPAV12@@Z ENDP ; std::_Allocate<Ogre::TRect<float> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z
_TEXT	SEGMENT
$T131026 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z PROC ; std::_Allocate<std::_Aux_cont>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T131026[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T131026[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T131031 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 56					; 00000038H
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T131031[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T131031[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 56					; 00000038H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??_G_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_G_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z

; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T131036 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T131036[ebp], eax
	cmp	DWORD PTR $T131036[ebp], 0
	je	SHORT $LN3@Construct
	mov	edx, DWORD PTR $T131036[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T131036[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct
$LN3@Construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
PUBLIC	??1_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node::~_Node
; Function compile flags: /Odtp
;	COMDAT ??_G_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z PROC ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@21
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@21:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node::~_Node, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@QAE@XZ
__ehhandler$??1_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Node@?$_Tree_nod@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UUITargetEffect@Ogre@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Ogre::UITargetEffect,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Ogre::UITargetEffect> >,0> >::_Node::~_Node
PUBLIC	??$_Uninit_copy@PBQAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAPAPAVIFont@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::IFont * const *,Ogre::IFont * *,std::allocator<Ogre::IFont *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@@std@@YAPBQAVIFont@Ogre@@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@PAPAVIFont@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@AAPAPAVIFont@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >,Ogre::IFont * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@PAPAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@2@@stdext@@YAPAPAVIFont@Ogre@@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVIFont@Ogre@@@4@@Z
_TEXT	SEGMENT
$T131064 = -2						; size = 1
$T131063 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@PAPAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@2@@stdext@@YAPAPAVIFont@Ogre@@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVIFont@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >,Ogre::IFont * *,std::allocator<Ogre::IFont *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T131063[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@PAPAVIFont@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@AAPAPAVIFont@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >,Ogre::IFont * *>
	add	esp, 8
	mov	BYTE PTR $T131064[ebp], al
	movzx	eax, BYTE PTR $T131063[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T131064[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@@std@@YAPBQAVIFont@Ogre@@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@@std@@YAPBQAVIFont@Ogre@@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAPAPAVIFont@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::IFont * const *,Ogre::IFont * *,std::allocator<Ogre::IFont *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@PAPAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@2@@stdext@@YAPAPAVIFont@Ogre@@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVIFont@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >,Ogre::IFont * *,std::allocator<Ogre::IFont *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::IFont * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::IFont * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::IFont * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::IFont * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVIFont@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVIFont@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVIFont@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVIFont@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::IFont * *,Ogre::IFont * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVIFont@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVIFont@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::IFont * *,Ogre::IFont * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVIFont@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVIFont@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVIFont@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVIFont@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::IFont * *,Ogre::IFont * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVIFont@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVIFont@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::IFont * *,Ogre::IFont * *>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAPAVIFont@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVIFont@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVIFont@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVIFont@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::IFont * *,Ogre::IFont * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVIFont@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVIFont@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::IFont * *,Ogre::IFont * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAPAPAVIFont@Ogre@@PAPAV12@00AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::IFont * *,Ogre::IFont * *,std::allocator<Ogre::IFont *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@stdext@@YAPAPAVIFont@Ogre@@PAPAV12@00AAV?$allocator@PAVIFont@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T131076 = -2						; size = 1
$T131075 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@stdext@@YAPAPAVIFont@Ogre@@PAPAV12@00AAV?$allocator@PAVIFont@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::IFont * *,Ogre::IFont * *,std::allocator<Ogre::IFont *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T131075[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVIFont@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVIFont@Ogre@@0@Z ; std::_Ptr_cat<Ogre::IFont * *,Ogre::IFont * *>
	add	esp, 8
	mov	BYTE PTR $T131076[ebp], al
	movzx	eax, BYTE PTR $T131075[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T131076[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::IFont * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::IFont * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAPAPAVIFont@Ogre@@PAPAV12@00AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::IFont * *,Ogre::IFont * *,std::allocator<Ogre::IFont *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@stdext@@YAPAPAVIFont@Ogre@@PAPAV12@00AAV?$allocator@PAVIFont@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::IFont * *,Ogre::IFont * *,std::allocator<Ogre::IFont *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::TRect<float> const *,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@@std@@YAPBV?$TRect@M@Ogre@@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@PAV?$TRect@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@AAPAV?$TRect@M@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >,Ogre::TRect<float> *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@PAV?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@2@@stdext@@YAPAV?$TRect@M@Ogre@@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@4@@Z
_TEXT	SEGMENT
$T131080 = -2						; size = 1
$T131079 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@PAV?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@2@@stdext@@YAPAV?$TRect@M@Ogre@@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T131079[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@PAV?$TRect@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@AAPAV?$TRect@M@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >,Ogre::TRect<float> *>
	add	esp, 8
	mov	BYTE PTR $T131080[ebp], al
	movzx	eax, BYTE PTR $T131079[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T131080[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@@std@@YAPBV?$TRect@M@Ogre@@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@@std@@YAPBV?$TRect@M@Ogre@@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::TRect<float> const *,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@PAV?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@2@@stdext@@YAPAV?$TRect@M@Ogre@@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAV?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::TRect<float> *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAV?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@AAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAV?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@AAPAV12@@Z PROC ; std::_Checked_base<Ogre::TRect<float> *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAV?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::TRect<float> *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAV?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@AAPAV12@@Z ENDP ; std::_Checked_base<Ogre::TRect<float> *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAV?$TRect@M@Ogre@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$TRect@M@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAV?$TRect@M@Ogre@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$TRect@M@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::TRect<float> *,Ogre::TRect<float> *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAV?$TRect@M@Ogre@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$TRect@M@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::TRect<float> *,Ogre::TRect<float> *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAV?$TRect@M@Ogre@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$TRect@M@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$TRect@M@Ogre@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$TRect@M@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::TRect<float> *,Ogre::TRect<float> *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAV?$TRect@M@Ogre@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$TRect@M@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::TRect<float> *,Ogre::TRect<float> *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAV?$TRect@M@Ogre@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::TRect<float> *,Ogre::TRect<float> *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAV?$TRect@M@Ogre@@PAV12@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T131091 = -7						; size = 1
$T131090 = -6						; size = 1
$T131089 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAV?$TRect@M@Ogre@@PAV12@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::TRect<float> *,Ogre::TRect<float> *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	shl	eax, 4
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	ecx, ecx
	mov	BYTE PTR $T131089[ebp], cl
	xor	edx, edx
	mov	BYTE PTR $T131090[ebp], dl
	movzx	eax, BYTE PTR $T131089[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T131090[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T131091[ebp]
	push	edx
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Checked_base@PAV?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@AAPAV12@@Z ; std::_Checked_base<Ogre::TRect<float> *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_opt@PAV?$TRect@M@Ogre@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::TRect<float> *,Ogre::TRect<float> *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAV?$TRect@M@Ogre@@PAV12@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::TRect<float> *,Ogre::TRect<float> *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::TRect<float> *,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@stdext@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T131095 = -2						; size = 1
$T131094 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@stdext@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::TRect<float> *,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T131094[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAV?$TRect@M@Ogre@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$TRect@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TRect<float> *,Ogre::TRect<float> *>
	add	esp, 8
	mov	BYTE PTR $T131095[ebp], al
	movzx	eax, BYTE PTR $T131094[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T131095[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAV?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@AAPAV12@@Z ; std::_Checked_base<Ogre::TRect<float> *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAV?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@AAPAV12@@Z ; std::_Checked_base<Ogre::TRect<float> *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::TRect<float> *,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@stdext@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::TRect<float> *,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAXPAPAVIFont@Ogre@@0AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAXPAPAVIFont@Ogre@@0AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::IFont *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAXPAPAVIFont@Ogre@@0AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::IFont *> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@@Z ; std::allocator<Ogre::TRect<float> >::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAXPAV?$TRect@M@Ogre@@0AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAXPAV?$TRect@M@Ogre@@0AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::TRect<float> > >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@@Z ; std::allocator<Ogre::TRect<float> >::destroy
	jmp	SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAXPAV?$TRect@M@Ogre@@0AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::TRect<float> > >
_TEXT	ENDS
PUBLIC	??$_Destroy@V?$TRect@M@Ogre@@@std@@YAXPAV?$TRect@M@Ogre@@@Z ; std::_Destroy<Ogre::TRect<float> >
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@@Z PROC ; std::allocator<Ogre::TRect<float> >::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@V?$TRect@M@Ogre@@@std@@YAXPAV?$TRect@M@Ogre@@@Z ; std::_Destroy<Ogre::TRect<float> >
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@@Z ENDP ; std::allocator<Ogre::TRect<float> >::destroy
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVIFont@Ogre@@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@@std@@YAPBQAVIFont@Ogre@@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@@std@@YAPBQAVIFont@Ogre@@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVIFont@Ogre@@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@@std@@YAPBQAVIFont@Ogre@@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@PAPAVIFont@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@AAPAPAVIFont@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@PAPAVIFont@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@AAPAPAVIFont@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >,Ogre::IFont * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@PAPAVIFont@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@AAPAPAVIFont@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >,Ogre::IFont * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAPAPAVIFont@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAPAPAVIFont@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::IFont * const *,Ogre::IFont * *,std::allocator<Ogre::IFont *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAPAPAVIFont@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::IFont * const *,Ogre::IFont * *,std::allocator<Ogre::IFont *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::IFont * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVIFont@Ogre@@@std@@YAPAPAVIFont@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::IFont * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAPAPAVIFont@Ogre@@PAPAV12@00AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAPAPAVIFont@Ogre@@PAPAV12@00AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::IFont * *,Ogre::IFont * *,std::allocator<Ogre::IFont *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@2:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVIFont@Ogre@@PAPAV12@V?$allocator@PAVIFont@Ogre@@@std@@@std@@YAPAPAVIFont@Ogre@@PAPAV12@00AAV?$allocator@PAVIFont@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::IFont * *,Ogre::IFont * *,std::allocator<Ogre::IFont *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBV?$TRect@M@Ogre@@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@@std@@YAPBV?$TRect@M@Ogre@@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@@std@@YAPBV?$TRect@M@Ogre@@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBV?$TRect@M@Ogre@@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@@std@@YAPBV?$TRect@M@Ogre@@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@PAV?$TRect@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@AAPAV?$TRect@M@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@PAV?$TRect@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@AAPAV?$TRect@M@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >,Ogre::TRect<float> *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@PAV?$TRect@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@AAPAV?$TRect@M@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >,Ogre::TRect<float> *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@ABV34@@Z ; std::allocator<Ogre::TRect<float> >::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::TRect<float> const *,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@3
$LN5@Uninit_cop@3:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@3:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@3

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@ABV34@@Z ; std::allocator<Ogre::TRect<float> >::construct
	jmp	SHORT $LN5@Uninit_cop@3
$LN4@Uninit_cop@3:
	jmp	SHORT $LN10@Uninit_cop@3
__catch$??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@3
$LN2@Uninit_cop@3:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@3:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@3

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@@Z ; std::allocator<Ogre::TRect<float> >::destroy
	jmp	SHORT $LN2@Uninit_cop@3
$LN1@Uninit_cop@3:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@3:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PBV12@0PAV12@AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::TRect<float> const *,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAV?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAV?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::TRect<float> *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAV?$TRect@M@Ogre@@@std@@YAPAV?$TRect@M@Ogre@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::TRect<float> *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAV?$TRect@M@Ogre@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAV?$TRect@M@Ogre@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::TRect<float> *,Ogre::TRect<float> *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@2
$LN2@Copy_opt@2:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@2:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@2

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN2@Copy_opt@2
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAV?$TRect@M@Ogre@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::TRect<float> *,Ogre::TRect<float> *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::TRect<float> *,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@4
$LN5@Uninit_cop@4:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@4:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@4

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@ABV34@@Z ; std::allocator<Ogre::TRect<float> >::construct
	jmp	SHORT $LN5@Uninit_cop@4
$LN4@Uninit_cop@4:
	jmp	SHORT $LN10@Uninit_cop@4
__catch$??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@4
$LN2@Uninit_cop@4:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@4:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@4

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@@Z ; std::allocator<Ogre::TRect<float> >::destroy
	jmp	SHORT $LN2@Uninit_cop@4
$LN1@Uninit_cop@4:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@4:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAV?$TRect@M@Ogre@@PAV12@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@YAPAV?$TRect@M@Ogre@@PAV12@00AAV?$allocator@V?$TRect@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::TRect<float> *,Ogre::TRect<float> *,std::allocator<Ogre::TRect<float> > >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@V?$TRect@M@Ogre@@@std@@YAXPAV?$TRect@M@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@V?$TRect@M@Ogre@@@std@@YAXPAV?$TRect@M@Ogre@@@Z PROC ; std::_Destroy<Ogre::TRect<float> >, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@V?$TRect@M@Ogre@@@std@@YAXPAV?$TRect@M@Ogre@@@Z ENDP ; std::_Destroy<Ogre::TRect<float> >
_TEXT	ENDS
PUBLIC	??$_Construct@V?$TRect@M@Ogre@@V12@@std@@YAXPAV?$TRect@M@Ogre@@ABV12@@Z ; std::_Construct<Ogre::TRect<float>,Ogre::TRect<float> >
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@ABV34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@ABV34@@Z PROC ; std::allocator<Ogre::TRect<float> >::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@V?$TRect@M@Ogre@@V12@@std@@YAXPAV?$TRect@M@Ogre@@ABV12@@Z ; std::_Construct<Ogre::TRect<float>,Ogre::TRect<float> >
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@V?$TRect@M@Ogre@@@std@@QAEXPAV?$TRect@M@Ogre@@ABV34@@Z ENDP ; std::allocator<Ogre::TRect<float> >::construct
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEPBQAVIFont@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Checked_iterator_base
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVIFont@Ogre@@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVIFont@Ogre@@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEPBQAVIFont@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVIFont@Ogre@@AAV?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEPBV?$TRect@M@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBV?$TRect@M@Ogre@@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBV?$TRect@M@Ogre@@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEPBV?$TRect@M@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBV?$TRect@M@Ogre@@AAV?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@V?$TRect@M@Ogre@@V12@@std@@YAXPAV?$TRect@M@Ogre@@ABV12@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T131160 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@V?$TRect@M@Ogre@@V12@@std@@YAXPAV?$TRect@M@Ogre@@ABV12@@Z PROC ; std::_Construct<Ogre::TRect<float>,Ogre::TRect<float> >, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T131160[ebp], eax
	cmp	DWORD PTR $T131160[ebp], 0
	je	SHORT $LN3@Construct@2
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T131160[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T131160[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@2
$LN3@Construct@2:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@2:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@V?$TRect@M@Ogre@@V12@@std@@YAXPAV?$TRect@M@Ogre@@ABV12@@Z ENDP ; std::_Construct<Ogre::TRect<float>,Ogre::TRect<float> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEPBQAVIFont@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEPBQAVIFont@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVIFont@Ogre@@V?$allocator@PAVIFont@Ogre@@@std@@@std@@QBEPBQAVIFont@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::IFont *,std::allocator<Ogre::IFont *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEPBV?$TRect@M@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEPBV?$TRect@M@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@V?$TRect@M@Ogre@@V?$allocator@V?$TRect@M@Ogre@@@std@@@std@@QBEPBV?$TRect@M@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::TRect<float>,std::allocator<Ogre::TRect<float> > >::_Checked_iterator_base
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
_TEXT	ENDS
;	COMDAT ??__ETWO_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__ETWO_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'TWO_PI'', COMDAT

; 10   : 	const float TWO_PI = ONE_PI*2;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _TWO_PI
	pop	ebp
	ret	0
??__ETWO_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'TWO_PI''
text$yc	ENDS
PUBLIC	__real@3fe0000000000000
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??__EHALF_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__EHALF_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'HALF_PI'', COMDAT

; 11   : 	const float	HALF_PI = ONE_PI*0.5f;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	DWORD PTR _HALF_PI
	pop	ebp
	ret	0
??__EHALF_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'HALF_PI''
text$yc	ENDS
PUBLIC	??0ColorQuad@Ogre@@QAE@EEEE@Z			; Ogre::ColorQuad::ColorQuad
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreuirendertypes.h
;	COMDAT ??__EFONT_SHADOW_COLOR@@YAXXZ
text$yc	SEGMENT
??__EFONT_SHADOW_COLOR@@YAXXZ PROC			; `dynamic initializer for 'FONT_SHADOW_COLOR'', COMDAT

; 25   : const Ogre::ColorQuad FONT_SHADOW_COLOR(0,0,0);

	push	ebp
	mov	ebp, esp
	push	255					; 000000ffH
	push	0
	push	0
	push	0
	mov	ecx, OFFSET _FONT_SHADOW_COLOR
	call	??0ColorQuad@Ogre@@QAE@EEEE@Z		; Ogre::ColorQuad::ColorQuad
	pop	ebp
	ret	0
??__EFONT_SHADOW_COLOR@@YAXXZ ENDP			; `dynamic initializer for 'FONT_SHADOW_COLOR''
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrecolourvalue.h
text$yc	ENDS
;	COMDAT ??0ColorQuad@Ogre@@QAE@EEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r1$ = 8						; size = 1
_g1$ = 12						; size = 1
_b1$ = 16						; size = 1
_a1$ = 20						; size = 1
??0ColorQuad@Ogre@@QAE@EEEE@Z PROC			; Ogre::ColorQuad::ColorQuad, COMDAT
; _this$ = ecx

; 351  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _b1$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _g1$[ebp]
	mov	BYTE PTR [edx+1], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _r1$[ebp]
	mov	BYTE PTR [ecx+2], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _a1$[ebp]
	mov	BYTE PTR [eax+3], cl

; 352  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0ColorQuad@Ogre@@QAE@EEEE@Z ENDP			; Ogre::ColorQuad::ColorQuad
_TEXT	ENDS
PUBLIC	??0?$TRect@H@Ogre@@QAE@HHHH@Z			; Ogre::TRect<int>::TRect<int>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreuirendertypes.h
;	COMDAT ??__EEMPTY_RECT_INT@Ogre@@YAXXZ
text$yc	SEGMENT
??__EEMPTY_RECT_INT@Ogre@@YAXXZ PROC			; Ogre::`dynamic initializer for 'EMPTY_RECT_INT'', COMDAT

; 63   : 	static RectInt EMPTY_RECT_INT(0,0,0,0);

	push	ebp
	mov	ebp, esp
	push	0
	push	0
	push	0
	push	0
	mov	ecx, OFFSET _EMPTY_RECT_INT
	call	??0?$TRect@H@Ogre@@QAE@HHHH@Z		; Ogre::TRect<int>::TRect<int>
	pop	ebp
	ret	0
??__EEMPTY_RECT_INT@Ogre@@YAXXZ ENDP			; Ogre::`dynamic initializer for 'EMPTY_RECT_INT''
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrerect.h
text$yc	ENDS
;	COMDAT ??0?$TRect@H@Ogre@@QAE@HHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_left$ = 8						; size = 4
_top$ = 12						; size = 4
_right$ = 16						; size = 4
_bottom$ = 20						; size = 4
??0?$TRect@H@Ogre@@QAE@HHHH@Z PROC			; Ogre::TRect<int>::TRect<int>, COMDAT
; _this$ = ecx

; 15   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _top$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _right$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _bottom$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 16   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0?$TRect@H@Ogre@@QAE@HHHH@Z ENDP			; Ogre::TRect<int>::TRect<int>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefontbase.cpp
_TEXT	ENDS
;	COMDAT ??__E?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A@@YAXXZ
text$yc	SEGMENT
??__E?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A@@YAXXZ PROC ; `dynamic initializer for 'Ogre::RFontBase::ms_curParseTextNoClipScreenRect'', COMDAT

; 19   : 	RectFloat RFontBase::ms_curParseTextNoClipScreenRect;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextNoClipScreenRect
	call	??0?$TRect@M@Ogre@@QAE@XZ		; Ogre::TRect<float>::TRect<float>
	pop	ebp
	ret	0
??__E?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A@@YAXXZ ENDP ; `dynamic initializer for 'Ogre::RFontBase::ms_curParseTextNoClipScreenRect''
; Function compile flags: /Odtp
text$yc	ENDS
;	COMDAT ??__E?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A@@YAXXZ
text$yc	SEGMENT
??__E?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A@@YAXXZ PROC ; `dynamic initializer for 'Ogre::RFontBase::ms_curParseTextOffsetScreenRect'', COMDAT

; 20   : 	RectFloat RFontBase::ms_curParseTextOffsetScreenRect;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextOffsetScreenRect
	call	??0?$TRect@M@Ogre@@QAE@XZ		; Ogre::TRect<float>::TRect<float>
	pop	ebp
	ret	0
??__E?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A@@YAXXZ ENDP ; `dynamic initializer for 'Ogre::RFontBase::ms_curParseTextOffsetScreenRect''
text$yc	ENDS
PUBLIC	?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextOffsetScreenRect
PUBLIC	?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A ; Ogre::RFontBase::ms_curParseTextNoClipScreenRect
_BSS	SEGMENT
?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A DB 010H DUP (?) ; Ogre::RFontBase::ms_curParseTextOffsetScreenRect
?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A DB 010H DUP (?) ; Ogre::RFontBase::ms_curParseTextNoClipScreenRect
_EMPTY_RECT_INT DB 010H DUP (?)
_TWO_PI	DD	01H DUP (?)
_HALF_PI DD	01H DUP (?)
_FONT_SHADOW_COLOR DD 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_TWO_PI$initializer$ DD FLAT:??__ETWO_PI@Ogre@@YAXXZ
_HALF_PI$initializer$ DD FLAT:??__EHALF_PI@Ogre@@YAXXZ
_FONT_SHADOW_COLOR$initializer$ DD FLAT:??__EFONT_SHADOW_COLOR@@YAXXZ
_EMPTY_RECT_INT$initializer$ DD FLAT:??__EEMPTY_RECT_INT@Ogre@@YAXXZ
?ms_curParseTextNoClipScreenRect$initializer$@RFontBase@Ogre@@1P6AXXZA DD FLAT:??__E?ms_curParseTextNoClipScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A@@YAXXZ ; Ogre::RFontBase::ms_curParseTextNoClipScreenRect$initializer$
?ms_curParseTextOffsetScreenRect$initializer$@RFontBase@Ogre@@1P6AXXZA DD FLAT:??__E?ms_curParseTextOffsetScreenRect@RFontBase@Ogre@@1V?$TRect@M@2@A@@YAXXZ ; Ogre::RFontBase::ms_curParseTextOffsetScreenRect$initializer$
CRT$XCU	ENDS
END

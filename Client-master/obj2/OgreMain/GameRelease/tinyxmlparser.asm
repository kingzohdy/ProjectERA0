; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\tinyxmlparser.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?entity@TiXmlBase@@0PAUEntity@1@A		; TiXmlBase::entity
PUBLIC	?utf8ByteTable@TiXmlBase@@2QBHB			; TiXmlBase::utf8ByteTable
_DATA	SEGMENT
?entity@TiXmlBase@@0PAUEntity@1@A DD FLAT:$SG7004	; TiXmlBase::entity
	DD	05H
	DB	026H
	ORG $+3
	DD	FLAT:$SG7005
	DD	04H
	DB	03cH
	ORG $+3
	DD	FLAT:$SG7006
	DD	04H
	DB	03eH
	ORG $+3
	DD	FLAT:$SG7007
	DD	06H
	DB	022H
	ORG $+3
	DD	FLAT:$SG7008
	DD	06H
	DB	027H
	ORG $+3
_DATA	ENDS
CONST	SEGMENT
$SG7004	DB	'&amp;', 00H
$SG7150	DB	00H
$SG7245	DB	00H
$SG7005	DB	'&lt;', 00H
$SG7351	DB	00H
$SG7365	DB	00H
$SG7455	DB	00H
$SG7006	DB	'&gt;', 00H
$SG7484	DB	00H
$SG7498	DB	00H
$SG7505	DB	00H
$SG7007	DB	'&quot;', 00H
$SG7538	DB	00H
$SG7008	DB	'&apos;', 00H
$SG7551	DB	00H
?utf8ByteTable@TiXmlBase@@2QBHB DD 01H			; TiXmlBase::utf8ByteTable
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
$SG7298	DB	'UTF-8', 00H
$SG7583	DB	00H
$SG7584	DB	00H
$SG7301	DB	'UTF8', 00H
$SG7585	DB	00H
	ORG $+2
$SG7326	DB	'<?xml', 00H
	ORG $+2
$SG7328	DB	'<!--', 00H
	ORG $+3
$SG7330	DB	'<!', 00H
	ORG $+1
$SG7332	DB	'<![CDATA[', 00H
	ORG $+2
$SG7392	DB	'</', 00H
	ORG $+1
$SG7393	DB	'>', 00H
	ORG $+2
$SG7466	DB	'</', 00H
	ORG $+1
$SG7501	DB	'<!--', 00H
	ORG $+3
$SG7503	DB	'-->', 00H
$SG7533	DB	'''', 00H
	ORG $+2
$SG7536	DB	'"', 00H
	ORG $+2
$SG7555	DB	'<![CDATA[', 00H
	ORG $+2
$SG7557	DB	']]>', 00H
$SG7569	DB	'<', 00H
	ORG $+2
$SG7580	DB	'<?xml', 00H
	ORG $+2
$SG7591	DB	'version', 00H
$SG7595	DB	'encoding', 00H
	ORG $+3
$SG7599	DB	'standalone', 00H
CONST	ENDS
PUBLIC	?ConvertUTF32ToUTF8@TiXmlBase@@KAXKPADPAH@Z	; TiXmlBase::ConvertUTF32ToUTF8
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxmlparser.cpp
_TEXT	SEGMENT
tv69 = -40						; size = 4
_BYTE_MARK$ = -36					; size = 4
_BYTE_MASK$ = -32					; size = 4
_FIRST_BYTE_MARK$ = -28					; size = 28
_input$ = 8						; size = 4
_output$ = 12						; size = 4
_length$ = 16						; size = 4
?ConvertUTF32ToUTF8@TiXmlBase@@KAXKPADPAH@Z PROC	; TiXmlBase::ConvertUTF32ToUTF8

; 89   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 90   : 	const unsigned long BYTE_MASK = 0xBF;

	mov	DWORD PTR _BYTE_MASK$[ebp], 191		; 000000bfH

; 91   : 	const unsigned long BYTE_MARK = 0x80;

	mov	DWORD PTR _BYTE_MARK$[ebp], 128		; 00000080H

; 92   : 	const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };

	mov	DWORD PTR _FIRST_BYTE_MARK$[ebp], 0
	mov	DWORD PTR _FIRST_BYTE_MARK$[ebp+4], 0
	mov	DWORD PTR _FIRST_BYTE_MARK$[ebp+8], 192	; 000000c0H
	mov	DWORD PTR _FIRST_BYTE_MARK$[ebp+12], 224 ; 000000e0H
	mov	DWORD PTR _FIRST_BYTE_MARK$[ebp+16], 240 ; 000000f0H
	mov	DWORD PTR _FIRST_BYTE_MARK$[ebp+20], 248 ; 000000f8H
	mov	DWORD PTR _FIRST_BYTE_MARK$[ebp+24], 252 ; 000000fcH

; 93   : 
; 94   : 	if (input < 0x80) 

	cmp	DWORD PTR _input$[ebp], 128		; 00000080H
	jae	SHORT $LN14@ConvertUTF

; 95   : 		*length = 1;

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax], 1
	jmp	SHORT $LN13@ConvertUTF
$LN14@ConvertUTF:

; 96   : 	else if ( input < 0x800 )

	cmp	DWORD PTR _input$[ebp], 2048		; 00000800H
	jae	SHORT $LN12@ConvertUTF

; 97   : 		*length = 2;

	mov	ecx, DWORD PTR _length$[ebp]
	mov	DWORD PTR [ecx], 2
	jmp	SHORT $LN13@ConvertUTF
$LN12@ConvertUTF:

; 98   : 	else if ( input < 0x10000 )

	cmp	DWORD PTR _input$[ebp], 65536		; 00010000H
	jae	SHORT $LN10@ConvertUTF

; 99   : 		*length = 3;

	mov	edx, DWORD PTR _length$[ebp]
	mov	DWORD PTR [edx], 3
	jmp	SHORT $LN13@ConvertUTF
$LN10@ConvertUTF:

; 100  : 	else if ( input < 0x200000 )

	cmp	DWORD PTR _input$[ebp], 2097152		; 00200000H
	jae	SHORT $LN8@ConvertUTF

; 101  : 		*length = 4;

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax], 4

; 102  : 	else

	jmp	SHORT $LN13@ConvertUTF
$LN8@ConvertUTF:

; 103  : 		{ *length = 0; return; }	// This code won't covert this correctly anyway.

	mov	ecx, DWORD PTR _length$[ebp]
	mov	DWORD PTR [ecx], 0
	jmp	$LN15@ConvertUTF
$LN13@ConvertUTF:

; 104  : 
; 105  : 	output += *length;

	mov	edx, DWORD PTR _length$[ebp]
	mov	eax, DWORD PTR _output$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _output$[ebp], eax

; 106  : 
; 107  : 	// Scary scary fall throughs.
; 108  : 	switch (*length) 

	mov	ecx, DWORD PTR _length$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv69[ebp], edx
	mov	eax, DWORD PTR tv69[ebp]
	sub	eax, 1
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 3
	ja	$LN15@ConvertUTF
	mov	ecx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN17@ConvertUTF[ecx*4]
$LN4@ConvertUTF:

; 109  : 	{
; 110  : 		case 4:
; 111  : 			--output; 

	mov	edx, DWORD PTR _output$[ebp]
	sub	edx, 1
	mov	DWORD PTR _output$[ebp], edx

; 112  : 			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 

	mov	eax, DWORD PTR _input$[ebp]
	or	eax, 128				; 00000080H
	and	eax, 191				; 000000bfH
	mov	ecx, DWORD PTR _output$[ebp]
	mov	BYTE PTR [ecx], al

; 113  : 			input >>= 6;

	mov	edx, DWORD PTR _input$[ebp]
	shr	edx, 6
	mov	DWORD PTR _input$[ebp], edx
$LN3@ConvertUTF:

; 114  : 		case 3:
; 115  : 			--output; 

	mov	eax, DWORD PTR _output$[ebp]
	sub	eax, 1
	mov	DWORD PTR _output$[ebp], eax

; 116  : 			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 

	mov	ecx, DWORD PTR _input$[ebp]
	or	ecx, 128				; 00000080H
	and	ecx, 191				; 000000bfH
	mov	edx, DWORD PTR _output$[ebp]
	mov	BYTE PTR [edx], cl

; 117  : 			input >>= 6;

	mov	eax, DWORD PTR _input$[ebp]
	shr	eax, 6
	mov	DWORD PTR _input$[ebp], eax
$LN2@ConvertUTF:

; 118  : 		case 2:
; 119  : 			--output; 

	mov	ecx, DWORD PTR _output$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _output$[ebp], ecx

; 120  : 			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 

	mov	edx, DWORD PTR _input$[ebp]
	or	edx, 128				; 00000080H
	and	edx, 191				; 000000bfH
	mov	eax, DWORD PTR _output$[ebp]
	mov	BYTE PTR [eax], dl

; 121  : 			input >>= 6;

	mov	ecx, DWORD PTR _input$[ebp]
	shr	ecx, 6
	mov	DWORD PTR _input$[ebp], ecx
$LN1@ConvertUTF:

; 122  : 		case 1:
; 123  : 			--output; 

	mov	edx, DWORD PTR _output$[ebp]
	sub	edx, 1
	mov	DWORD PTR _output$[ebp], edx

; 124  : 			*output = (char)(input | FIRST_BYTE_MARK[*length]);

	mov	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _input$[ebp]
	or	edx, DWORD PTR _FIRST_BYTE_MARK$[ebp+ecx*4]
	mov	eax, DWORD PTR _output$[ebp]
	mov	BYTE PTR [eax], dl
$LN15@ConvertUTF:

; 125  : 	}
; 126  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN17@ConvertUTF:
	DD	$LN1@ConvertUTF
	DD	$LN2@ConvertUTF
	DD	$LN3@ConvertUTF
	DD	$LN4@ConvertUTF
?ConvertUTF32ToUTF8@TiXmlBase@@KAXKPADPAH@Z ENDP	; TiXmlBase::ConvertUTF32ToUTF8
_TEXT	ENDS
PUBLIC	?IsAlpha@TiXmlBase@@KAHEW4TiXmlEncoding@@@Z	; TiXmlBase::IsAlpha
EXTRN	__imp__isalpha:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_anyByte$ = 8						; size = 1
___formal$ = 12						; size = 4
?IsAlpha@TiXmlBase@@KAHEW4TiXmlEncoding@@@Z PROC	; TiXmlBase::IsAlpha

; 130  : {

	push	ebp
	mov	ebp, esp

; 131  : 	// This will only work for low-ascii, everything else is assumed to be a valid
; 132  : 	// letter. I'm not sure this is the best approach, but it is quite tricky trying
; 133  : 	// to figure out alhabetical vs. not across encoding. So take a very 
; 134  : 	// conservative approach.
; 135  : 
; 136  : //	if ( encoding == TIXML_ENCODING_UTF8 )
; 137  : //	{
; 138  : 		if ( anyByte < 127 )

	movzx	eax, BYTE PTR _anyByte$[ebp]
	cmp	eax, 127				; 0000007fH
	jge	SHORT $LN2@IsAlpha

; 139  : 			return isalpha( anyByte );

	movzx	ecx, BYTE PTR _anyByte$[ebp]
	push	ecx
	call	DWORD PTR __imp__isalpha
	add	esp, 4
	jmp	SHORT $LN3@IsAlpha

; 140  : 		else

	jmp	SHORT $LN3@IsAlpha
$LN2@IsAlpha:

; 141  : 			return 1;	// What else to do? The unicode set is huge...get the english ones right.

	mov	eax, 1
$LN3@IsAlpha:

; 142  : //	}
; 143  : //	else
; 144  : //	{
; 145  : //		return isalpha( anyByte );
; 146  : //	}
; 147  : }

	pop	ebp
	ret	0
?IsAlpha@TiXmlBase@@KAHEW4TiXmlEncoding@@@Z ENDP	; TiXmlBase::IsAlpha
_TEXT	ENDS
PUBLIC	?IsAlphaNum@TiXmlBase@@KAHEW4TiXmlEncoding@@@Z	; TiXmlBase::IsAlphaNum
EXTRN	__imp__isalnum:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_anyByte$ = 8						; size = 1
___formal$ = 12						; size = 4
?IsAlphaNum@TiXmlBase@@KAHEW4TiXmlEncoding@@@Z PROC	; TiXmlBase::IsAlphaNum

; 151  : {

	push	ebp
	mov	ebp, esp

; 152  : 	// This will only work for low-ascii, everything else is assumed to be a valid
; 153  : 	// letter. I'm not sure this is the best approach, but it is quite tricky trying
; 154  : 	// to figure out alhabetical vs. not across encoding. So take a very 
; 155  : 	// conservative approach.
; 156  : 
; 157  : //	if ( encoding == TIXML_ENCODING_UTF8 )
; 158  : //	{
; 159  : 		if ( anyByte < 127 )

	movzx	eax, BYTE PTR _anyByte$[ebp]
	cmp	eax, 127				; 0000007fH
	jge	SHORT $LN2@IsAlphaNum

; 160  : 			return isalnum( anyByte );

	movzx	ecx, BYTE PTR _anyByte$[ebp]
	push	ecx
	call	DWORD PTR __imp__isalnum
	add	esp, 4
	jmp	SHORT $LN3@IsAlphaNum

; 161  : 		else

	jmp	SHORT $LN3@IsAlphaNum
$LN2@IsAlphaNum:

; 162  : 			return 1;	// What else to do? The unicode set is huge...get the english ones right.

	mov	eax, 1
$LN3@IsAlphaNum:

; 163  : //	}
; 164  : //	else
; 165  : //	{
; 166  : //		return isalnum( anyByte );
; 167  : //	}
; 168  : }

	pop	ebp
	ret	0
?IsAlphaNum@TiXmlBase@@KAHEW4TiXmlEncoding@@@Z ENDP	; TiXmlBase::IsAlphaNum
_TEXT	ENDS
PUBLIC	?Stamp@TiXmlParsingData@@QAEXPBDW4TiXmlEncoding@@@Z ; TiXmlParsingData::Stamp
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv70 = -28						; size = 4
_this$ = -24						; size = 4
_step$7112 = -20					; size = 4
_pU$7088 = -16						; size = 4
_row$ = -12						; size = 4
_col$ = -8						; size = 4
_p$ = -4						; size = 4
_now$ = 8						; size = 4
_encoding$ = 12						; size = 4
?Stamp@TiXmlParsingData@@QAEXPBDW4TiXmlEncoding@@@Z PROC ; TiXmlParsingData::Stamp
; _this$ = ecx

; 197  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 	assert( now );
; 199  : 
; 200  : 	// Do nothing if the tabsize is 0.
; 201  : 	if ( tabsize < 1 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 1
	jge	SHORT $LN25@Stamp

; 202  : 	{
; 203  : 		return;

	jmp	$LN26@Stamp
$LN25@Stamp:

; 204  : 	}
; 205  : 
; 206  : 	// Get the current row, column.
; 207  : 	int row = cursor.row;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _row$[ebp], edx

; 208  : 	int col = cursor.col;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _col$[ebp], ecx

; 209  : 	const char* p = stamp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _p$[ebp], eax
$LN24@Stamp:

; 210  : 	assert( p );
; 211  : 
; 212  : 	while ( p < now )

	mov	ecx, DWORD PTR _p$[ebp]
	cmp	ecx, DWORD PTR _now$[ebp]
	jae	$LN23@Stamp

; 213  : 	{
; 214  : 		// Treat p as unsigned, so we have a happy compiler.
; 215  : 		const unsigned char* pU = (const unsigned char*)p;

	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _pU$7088[ebp], edx

; 216  : 
; 217  : 		// Code contributed by Fletcher Dunn: (modified by lee)
; 218  : 		switch (*pU) {

	mov	eax, DWORD PTR _pU$7088[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv70[ebp], ecx
	cmp	DWORD PTR tv70[ebp], 239		; 000000efH
	ja	$LN4@Stamp
	mov	edx, DWORD PTR tv70[ebp]
	movzx	eax, BYTE PTR $LN28@Stamp[edx]
	jmp	DWORD PTR $LN29@Stamp[eax*4]
$LN20@Stamp:

; 219  : 			case 0:
; 220  : 				// We *should* never get here, but in case we do, don't
; 221  : 				// advance past the terminating null character, ever
; 222  : 				return;

	jmp	$LN26@Stamp
$LN19@Stamp:

; 223  : 
; 224  : 			case '\r':
; 225  : 				// bump down to the next line
; 226  : 				++row;

	mov	ecx, DWORD PTR _row$[ebp]
	add	ecx, 1
	mov	DWORD PTR _row$[ebp], ecx

; 227  : 				col = 0;				

	mov	DWORD PTR _col$[ebp], 0

; 228  : 				// Eat the character
; 229  : 				++p;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 230  : 
; 231  : 				// Check for \r\n sequence, and treat this as a single character
; 232  : 				if (*p == '\n') {

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN18@Stamp

; 233  : 					++p;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx
$LN18@Stamp:

; 234  : 				}
; 235  : 				break;

	jmp	$LN21@Stamp
$LN17@Stamp:

; 236  : 
; 237  : 			case '\n':
; 238  : 				// bump down to the next line
; 239  : 				++row;

	mov	eax, DWORD PTR _row$[ebp]
	add	eax, 1
	mov	DWORD PTR _row$[ebp], eax

; 240  : 				col = 0;

	mov	DWORD PTR _col$[ebp], 0

; 241  : 
; 242  : 				// Eat the character
; 243  : 				++p;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 244  : 
; 245  : 				// Check for \n\r sequence, and treat this as a single
; 246  : 				// character.  (Yes, this bizarre thing does occur still
; 247  : 				// on some arcane platforms...)
; 248  : 				if (*p == '\r') {

	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN16@Stamp

; 249  : 					++p;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
$LN16@Stamp:

; 250  : 				}
; 251  : 				break;

	jmp	$LN21@Stamp
$LN15@Stamp:

; 252  : 
; 253  : 			case '\t':
; 254  : 				// Eat the character
; 255  : 				++p;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 256  : 
; 257  : 				// Skip to next tab stop
; 258  : 				col = (col / tabsize + 1) * tabsize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	cdq
	idiv	DWORD PTR [ecx+12]
	add	eax, 1
	mov	edx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _col$[ebp], eax

; 259  : 				break;

	jmp	$LN21@Stamp
$LN14@Stamp:

; 260  : 
; 261  : 			case TIXML_UTF_LEAD_0:
; 262  : 				if ( encoding == TIXML_ENCODING_UTF8 )

	cmp	DWORD PTR _encoding$[ebp], 1
	jne	$LN13@Stamp

; 263  : 				{
; 264  : 					if ( *(p+1) && *(p+2) )

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	$LN12@Stamp
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	test	eax, eax
	je	$LN12@Stamp

; 265  : 					{
; 266  : 						// In these cases, don't advance the column. These are
; 267  : 						// 0-width spaces.
; 268  : 						if ( *(pU+1)==TIXML_UTF_LEAD_1 && *(pU+2)==TIXML_UTF_LEAD_2 )

	mov	ecx, DWORD PTR _pU$7088[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 187				; 000000bbH
	jne	SHORT $LN11@Stamp
	mov	eax, DWORD PTR _pU$7088[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 191				; 000000bfH
	jne	SHORT $LN11@Stamp

; 269  : 							p += 3;	

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 3
	mov	DWORD PTR _p$[ebp], edx
	jmp	SHORT $LN12@Stamp
$LN11@Stamp:

; 270  : 						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbeU )

	mov	eax, DWORD PTR _pU$7088[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 191				; 000000bfH
	jne	SHORT $LN9@Stamp
	mov	edx, DWORD PTR _pU$7088[ebp]
	movzx	eax, BYTE PTR [edx+2]
	cmp	eax, 190				; 000000beH
	jne	SHORT $LN9@Stamp

; 271  : 							p += 3;	

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 3
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN12@Stamp
$LN9@Stamp:

; 272  : 						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbfU )

	mov	edx, DWORD PTR _pU$7088[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 191				; 000000bfH
	jne	SHORT $LN7@Stamp
	mov	ecx, DWORD PTR _pU$7088[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	cmp	edx, 191				; 000000bfH
	jne	SHORT $LN7@Stamp

; 273  : 							p += 3;	

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 3
	mov	DWORD PTR _p$[ebp], eax

; 274  : 						else

	jmp	SHORT $LN12@Stamp
$LN7@Stamp:

; 275  : 							{ p +=3; ++col; }	// A normal character.

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 3
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _col$[ebp]
	add	edx, 1
	mov	DWORD PTR _col$[ebp], edx
$LN12@Stamp:

; 276  : 					}
; 277  : 				}
; 278  : 				else

	jmp	SHORT $LN5@Stamp
$LN13@Stamp:

; 279  : 				{
; 280  : 					++p;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 281  : 					++col;

	mov	ecx, DWORD PTR _col$[ebp]
	add	ecx, 1
	mov	DWORD PTR _col$[ebp], ecx
$LN5@Stamp:

; 282  : 				}
; 283  : 				break;

	jmp	SHORT $LN21@Stamp
$LN4@Stamp:

; 284  : 
; 285  : 			default:
; 286  : 				if ( encoding == TIXML_ENCODING_UTF8 )

	cmp	DWORD PTR _encoding$[ebp], 1
	jne	SHORT $LN3@Stamp

; 287  : 				{
; 288  : 					// Eat the 1 to 4 byte utf8 character.
; 289  : 					int step = TiXmlBase::utf8ByteTable[*((const unsigned char*)p)];

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR ?utf8ByteTable@TiXmlBase@@2QBHB[eax*4]
	mov	DWORD PTR _step$7112[ebp], ecx

; 290  : 					if ( step == 0 )

	cmp	DWORD PTR _step$7112[ebp], 0
	jne	SHORT $LN2@Stamp

; 291  : 						step = 1;		// Error case from bad encoding, but handle gracefully.

	mov	DWORD PTR _step$7112[ebp], 1
$LN2@Stamp:

; 292  : 					p += step;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, DWORD PTR _step$7112[ebp]
	mov	DWORD PTR _p$[ebp], edx

; 293  : 
; 294  : 					// Just advance one column, of course.
; 295  : 					++col;

	mov	eax, DWORD PTR _col$[ebp]
	add	eax, 1
	mov	DWORD PTR _col$[ebp], eax

; 296  : 				}
; 297  : 				else

	jmp	SHORT $LN21@Stamp
$LN3@Stamp:

; 298  : 				{
; 299  : 					++p;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 300  : 					++col;

	mov	edx, DWORD PTR _col$[ebp]
	add	edx, 1
	mov	DWORD PTR _col$[ebp], edx
$LN21@Stamp:

; 301  : 				}
; 302  : 				break;
; 303  : 		}
; 304  : 	}

	jmp	$LN24@Stamp
$LN23@Stamp:

; 305  : 	cursor.row = row;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _row$[ebp]
	mov	DWORD PTR [eax], ecx

; 306  : 	cursor.col = col;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _col$[ebp]
	mov	DWORD PTR [edx+4], eax

; 307  : 	assert( cursor.row >= -1 );
; 308  : 	assert( cursor.col >= -1 );
; 309  : 	stamp = p;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN26@Stamp:

; 310  : 	assert( stamp );
; 311  : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN29@Stamp:
	DD	$LN20@Stamp
	DD	$LN15@Stamp
	DD	$LN17@Stamp
	DD	$LN19@Stamp
	DD	$LN14@Stamp
	DD	$LN4@Stamp
$LN28@Stamp:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
?Stamp@TiXmlParsingData@@QAEXPBDW4TiXmlEncoding@@@Z ENDP ; TiXmlParsingData::Stamp
_TEXT	ENDS
PUBLIC	?IsWhiteSpace@TiXmlBase@@KA_ND@Z		; TiXmlBase::IsWhiteSpace
PUBLIC	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pU$7129 = -4						; size = 4
_p$ = 8							; size = 4
_encoding$ = 12						; size = 4
?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z PROC ; TiXmlBase::SkipWhiteSpace

; 315  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 316  : 	if ( !p || !*p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN17@SkipWhiteS
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN18@SkipWhiteS
$LN17@SkipWhiteS:

; 317  : 	{
; 318  : 		return 0;

	xor	eax, eax
	jmp	$LN19@SkipWhiteS
$LN18@SkipWhiteS:

; 319  : 	}
; 320  : 	if ( encoding == TIXML_ENCODING_UTF8 )

	cmp	DWORD PTR _encoding$[ebp], 1
	jne	$LN4@SkipWhiteS
$LN15@SkipWhiteS:

; 321  : 	{
; 322  : 		while ( *p )

	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN14@SkipWhiteS

; 323  : 		{
; 324  : 			const unsigned char* pU = (const unsigned char*)p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _pU$7129[ebp], ecx

; 325  : 			
; 326  : 			// Skip the stupid Microsoft UTF-8 Byte order marks
; 327  : 			if (	*(pU+0)==TIXML_UTF_LEAD_0
; 328  : 				 && *(pU+1)==TIXML_UTF_LEAD_1 
; 329  : 				 && *(pU+2)==TIXML_UTF_LEAD_2 )

	mov	edx, DWORD PTR _pU$7129[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 239				; 000000efH
	jne	SHORT $LN13@SkipWhiteS
	mov	ecx, DWORD PTR _pU$7129[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 187				; 000000bbH
	jne	SHORT $LN13@SkipWhiteS
	mov	eax, DWORD PTR _pU$7129[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 191				; 000000bfH
	jne	SHORT $LN13@SkipWhiteS

; 330  : 			{
; 331  : 				p += 3;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 3
	mov	DWORD PTR _p$[ebp], edx

; 332  : 				continue;

	jmp	SHORT $LN15@SkipWhiteS

; 333  : 			}
; 334  : 			else if(*(pU+0)==TIXML_UTF_LEAD_0

	jmp	SHORT $LN12@SkipWhiteS
$LN13@SkipWhiteS:

; 335  : 				 && *(pU+1)==0xbfU
; 336  : 				 && *(pU+2)==0xbeU )

	mov	eax, DWORD PTR _pU$7129[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 239				; 000000efH
	jne	SHORT $LN11@SkipWhiteS
	mov	edx, DWORD PTR _pU$7129[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 191				; 000000bfH
	jne	SHORT $LN11@SkipWhiteS
	mov	ecx, DWORD PTR _pU$7129[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	cmp	edx, 190				; 000000beH
	jne	SHORT $LN11@SkipWhiteS

; 337  : 			{
; 338  : 				p += 3;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 3
	mov	DWORD PTR _p$[ebp], eax

; 339  : 				continue;

	jmp	$LN15@SkipWhiteS

; 340  : 			}
; 341  : 			else if(*(pU+0)==TIXML_UTF_LEAD_0

	jmp	SHORT $LN12@SkipWhiteS
$LN11@SkipWhiteS:

; 342  : 				 && *(pU+1)==0xbfU
; 343  : 				 && *(pU+2)==0xbfU )

	mov	ecx, DWORD PTR _pU$7129[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 239				; 000000efH
	jne	SHORT $LN12@SkipWhiteS
	mov	eax, DWORD PTR _pU$7129[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 191				; 000000bfH
	jne	SHORT $LN12@SkipWhiteS
	mov	edx, DWORD PTR _pU$7129[ebp]
	movzx	eax, BYTE PTR [edx+2]
	cmp	eax, 191				; 000000bfH
	jne	SHORT $LN12@SkipWhiteS

; 344  : 			{
; 345  : 				p += 3;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 3
	mov	DWORD PTR _p$[ebp], ecx

; 346  : 				continue;

	jmp	$LN15@SkipWhiteS
$LN12@SkipWhiteS:

; 347  : 			}
; 348  : 
; 349  : 			if ( IsWhiteSpace( *p ) || *p == '\n' || *p =='\r' )		// Still using old rules for white space.

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	?IsWhiteSpace@TiXmlBase@@KA_ND@Z	; TiXmlBase::IsWhiteSpace
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@SkipWhiteS
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN7@SkipWhiteS
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN8@SkipWhiteS
$LN7@SkipWhiteS:

; 350  : 				++p;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 351  : 			else

	jmp	SHORT $LN6@SkipWhiteS
$LN8@SkipWhiteS:

; 352  : 				break;

	jmp	SHORT $LN14@SkipWhiteS
$LN6@SkipWhiteS:

; 353  : 		}

	jmp	$LN15@SkipWhiteS
$LN14@SkipWhiteS:

; 354  : 	}
; 355  : 	else

	jmp	SHORT $LN5@SkipWhiteS
$LN4@SkipWhiteS:

; 356  : 	{
; 357  : 		while ( *p && IsWhiteSpace( *p ) || *p == '\n' || *p =='\r' )

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN1@SkipWhiteS
	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	?IsWhiteSpace@TiXmlBase@@KA_ND@Z	; TiXmlBase::IsWhiteSpace
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@SkipWhiteS
$LN1@SkipWhiteS:
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN2@SkipWhiteS
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN5@SkipWhiteS
$LN2@SkipWhiteS:

; 358  : 			++p;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN4@SkipWhiteS
$LN5@SkipWhiteS:

; 359  : 	}
; 360  : 
; 361  : 	return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN19@SkipWhiteS:

; 362  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ENDP ; TiXmlBase::SkipWhiteSpace
_TEXT	ENDS
EXTRN	__imp__isspace:PROC
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxml.h
;	COMDAT ?IsWhiteSpace@TiXmlBase@@KA_ND@Z
_TEXT	SEGMENT
tv72 = -4						; size = 4
_c$ = 8							; size = 1
?IsWhiteSpace@TiXmlBase@@KA_ND@Z PROC			; TiXmlBase::IsWhiteSpace, COMDAT

; 292  : 	{ 

	push	ebp
	mov	ebp, esp
	push	ecx

; 293  : 		return ( isspace( (unsigned char) c ) || c == '\n' || c == '\r' ); 

	movzx	eax, BYTE PTR _c$[ebp]
	push	eax
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@IsWhiteSpa
	movsx	ecx, BYTE PTR _c$[ebp]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN3@IsWhiteSpa
	movsx	edx, BYTE PTR _c$[ebp]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN3@IsWhiteSpa
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@IsWhiteSpa
$LN3@IsWhiteSpa:
	mov	DWORD PTR tv72[ebp], 1
$LN4@IsWhiteSpa:
	mov	al, BYTE PTR tv72[ebp]

; 294  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?IsWhiteSpace@TiXmlBase@@KA_ND@Z ENDP			; TiXmlBase::IsWhiteSpace
_TEXT	ENDS
PUBLIC	??4TiXmlString@@QAEAAV0@PBD@Z			; TiXmlString::operator=
PUBLIC	?ReadName@TiXmlBase@@KAPBDPBDPAVTiXmlString@@W4TiXmlEncoding@@@Z ; TiXmlBase::ReadName
EXTRN	?assign@TiXmlString@@QAEAAV1@PBDI@Z:PROC	; TiXmlString::assign
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxmlparser.cpp
_TEXT	SEGMENT
_start$7155 = -4					; size = 4
_p$ = 8							; size = 4
_name$ = 12						; size = 4
_encoding$ = 16						; size = 4
?ReadName@TiXmlBase@@KAPBDPBDPAVTiXmlString@@W4TiXmlEncoding@@@Z PROC ; TiXmlBase::ReadName

; 402  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 403  : 	// Oddly, not supported on some comilers,
; 404  : 	//name->clear();
; 405  : 	// So use this:
; 406  : 	*name = "";

	push	OFFSET $SG7150
	mov	ecx, DWORD PTR _name$[ebp]
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=

; 407  : 	assert( p );
; 408  : 
; 409  : 	// Names start with letters or underscores.
; 410  : 	// Of course, in unicode, tinyxml has no idea what a letter *is*. The
; 411  : 	// algorithm is generous.
; 412  : 	//
; 413  : 	// After that, they can be letters, underscores, numbers,
; 414  : 	// hyphens, or colons. (Colons are valid ony for namespaces,
; 415  : 	// but tinyxml can't tell namespaces from names.)
; 416  : 	if (    p && *p 
; 417  : 		 && ( IsAlpha( (unsigned char) *p, encoding ) || *p == '_' ) )

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN6@ReadName
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN6@ReadName
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	?IsAlpha@TiXmlBase@@KAHEW4TiXmlEncoding@@@Z ; TiXmlBase::IsAlpha
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@ReadName
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 95					; 0000005fH
	jne	$LN6@ReadName
$LN5@ReadName:

; 418  : 	{
; 419  : 		const char* start = p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _start$7155[ebp], ecx
$LN4@ReadName:

; 420  : 		while(		p && *p
; 421  : 				&&	(		IsAlphaNum( (unsigned char ) *p, encoding ) 
; 422  : 						 || *p == '_'
; 423  : 						 || *p == '-'
; 424  : 						 || *p == '.'
; 425  : 						 || *p == ':' ) )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@ReadName
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@ReadName
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	?IsAlphaNum@TiXmlBase@@KAHEW4TiXmlEncoding@@@Z ; TiXmlBase::IsAlphaNum
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@ReadName
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 95					; 0000005fH
	je	SHORT $LN2@ReadName
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN2@ReadName
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN2@ReadName
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	jne	SHORT $LN3@ReadName
$LN2@ReadName:

; 426  : 		{
; 427  : 			//(*name) += *p; // expensive
; 428  : 			++p;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 429  : 		}

	jmp	SHORT $LN4@ReadName
$LN3@ReadName:

; 430  : 		if ( p-start > 0 ) {

	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, DWORD PTR _start$7155[ebp]
	test	ecx, ecx
	jle	SHORT $LN1@ReadName

; 431  : 			name->assign( start, p-start );

	mov	edx, DWORD PTR _p$[ebp]
	sub	edx, DWORD PTR _start$7155[ebp]
	push	edx
	mov	eax, DWORD PTR _start$7155[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	call	?assign@TiXmlString@@QAEAAV1@PBDI@Z	; TiXmlString::assign
$LN1@ReadName:

; 432  : 		}
; 433  : 		return p;

	mov	eax, DWORD PTR _p$[ebp]
	jmp	SHORT $LN7@ReadName
$LN6@ReadName:

; 434  : 	}
; 435  : 	return 0;

	xor	eax, eax
$LN7@ReadName:

; 436  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ReadName@TiXmlBase@@KAPBDPBDPAVTiXmlString@@W4TiXmlEncoding@@@Z ENDP ; TiXmlBase::ReadName
_TEXT	ENDS
EXTRN	_strlen:PROC
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinystr.h
;	COMDAT ??4TiXmlString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_copy$ = 8						; size = 4
??4TiXmlString@@QAEAAV0@PBD@Z PROC			; TiXmlString::operator=, COMDAT
; _this$ = ecx

; 111  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		return assign( copy, (size_type)strlen(copy));

	mov	eax, DWORD PTR _copy$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _copy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@TiXmlString@@QAEAAV1@PBDI@Z	; TiXmlString::assign

; 113  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??4TiXmlString@@QAEAAV0@PBD@Z ENDP			; TiXmlString::operator=
_TEXT	ENDS
PUBLIC	??1TiXmlString@@QAE@XZ				; TiXmlString::~TiXmlString
PUBLIC	??0TiXmlString@@QAE@XZ				; TiXmlString::TiXmlString
PUBLIC	?GetEntity@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z ; TiXmlBase::GetEntity
EXTRN	__imp__strncmp:PROC
EXTRN	__imp__strchr:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
xdata$x	SEGMENT
__unwindtable$?GetEntity@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetEntity@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z$0
__ehfuncinfo$?GetEntity@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetEntity@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxmlparser.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T7887 = -76						; size = 4
$T7886 = -72						; size = 4
$T7885 = -68						; size = 4
$T7884 = -64						; size = 4
$T7883 = -60						; size = 4
$T7882 = -56						; size = 4
$T7881 = -52						; size = 4
$T7880 = -48						; size = 4
$T7879 = -44						; size = 4
_q$7194 = -40						; size = 4
_q$7177 = -36						; size = 4
_mult$7173 = -32					; size = 4
_ucs$7171 = -28						; size = 4
_delta$7172 = -24					; size = 4
_ent$ = -20						; size = 4
_i$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_p$ = 8							; size = 4
_value$ = 12						; size = 4
_length$ = 16						; size = 4
_encoding$ = 20						; size = 4
?GetEntity@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z PROC ; TiXmlBase::GetEntity

; 439  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetEntity@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 440  : 	// Presume an entity, and pull it out.
; 441  :     TIXML_STRING ent;

	lea	ecx, DWORD PTR _ent$[ebp]
	call	??0TiXmlString@@QAE@XZ			; TiXmlString::TiXmlString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 442  : 	int i;
; 443  : 	*length = 0;

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax], 0

; 444  : 
; 445  : 	if ( *(p+1) && *(p+1) == '#' && *(p+2) )

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	test	edx, edx
	je	$LN27@GetEntity
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 35					; 00000023H
	jne	$LN27@GetEntity
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	test	eax, eax
	je	$LN27@GetEntity

; 446  : 	{
; 447  : 		unsigned long ucs = 0;

	mov	DWORD PTR _ucs$7171[ebp], 0

; 448  : 		ptrdiff_t delta = 0;

	mov	DWORD PTR _delta$7172[ebp], 0

; 449  : 		unsigned mult = 1;

	mov	DWORD PTR _mult$7173[ebp], 1

; 450  : 
; 451  : 		if ( *(p+2) == 'x' )

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 120				; 00000078H
	jne	$LN26@GetEntity

; 452  : 		{
; 453  : 			// Hexadecimal.
; 454  : 			if ( !*(p+3) ) return 0;

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+3]
	test	ecx, ecx
	jne	SHORT $LN25@GetEntity
	mov	DWORD PTR $T7879[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ent$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T7879[ebp]
	jmp	$LN28@GetEntity
$LN25@GetEntity:

; 455  : 
; 456  : 			const char* q = p+3;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 3
	mov	DWORD PTR _q$7177[ebp], edx

; 457  : 			q = strchr( q, ';' );

	push	59					; 0000003bH
	mov	eax, DWORD PTR _q$7177[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _q$7177[ebp], eax

; 458  : 
; 459  : 			if ( !q || !*q ) return 0;

	cmp	DWORD PTR _q$7177[ebp], 0
	je	SHORT $LN23@GetEntity
	mov	ecx, DWORD PTR _q$7177[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN24@GetEntity
$LN23@GetEntity:
	mov	DWORD PTR $T7880[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ent$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T7880[ebp]
	jmp	$LN28@GetEntity
$LN24@GetEntity:

; 460  : 
; 461  : 			delta = q-p;

	mov	eax, DWORD PTR _q$7177[ebp]
	sub	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _delta$7172[ebp], eax

; 462  : 			--q;

	mov	ecx, DWORD PTR _q$7177[ebp]
	sub	ecx, 1
	mov	DWORD PTR _q$7177[ebp], ecx
$LN22@GetEntity:

; 463  : 
; 464  : 			while ( *q != 'x' )

	mov	edx, DWORD PTR _q$7177[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 120				; 00000078H
	je	$LN21@GetEntity

; 465  : 			{
; 466  : 				if ( *q >= '0' && *q <= '9' )

	mov	ecx, DWORD PTR _q$7177[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN20@GetEntity
	mov	eax, DWORD PTR _q$7177[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN20@GetEntity

; 467  : 					ucs += mult * (*q - '0');

	mov	edx, DWORD PTR _q$7177[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	eax, 48					; 00000030H
	imul	eax, DWORD PTR _mult$7173[ebp]
	add	eax, DWORD PTR _ucs$7171[ebp]
	mov	DWORD PTR _ucs$7171[ebp], eax
	jmp	SHORT $LN19@GetEntity
$LN20@GetEntity:

; 468  : 				else if ( *q >= 'a' && *q <= 'f' )

	mov	ecx, DWORD PTR _q$7177[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN18@GetEntity
	mov	eax, DWORD PTR _q$7177[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 102				; 00000066H
	jg	SHORT $LN18@GetEntity

; 469  : 					ucs += mult * (*q - 'a' + 10);

	mov	edx, DWORD PTR _q$7177[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	eax, 87					; 00000057H
	imul	eax, DWORD PTR _mult$7173[ebp]
	add	eax, DWORD PTR _ucs$7171[ebp]
	mov	DWORD PTR _ucs$7171[ebp], eax
	jmp	SHORT $LN19@GetEntity
$LN18@GetEntity:

; 470  : 				else if ( *q >= 'A' && *q <= 'F' )

	mov	ecx, DWORD PTR _q$7177[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN16@GetEntity
	mov	eax, DWORD PTR _q$7177[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 70					; 00000046H
	jg	SHORT $LN16@GetEntity

; 471  : 					ucs += mult * (*q - 'A' + 10 );

	mov	edx, DWORD PTR _q$7177[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	eax, 55					; 00000037H
	imul	eax, DWORD PTR _mult$7173[ebp]
	add	eax, DWORD PTR _ucs$7171[ebp]
	mov	DWORD PTR _ucs$7171[ebp], eax

; 472  : 				else 

	jmp	SHORT $LN19@GetEntity
$LN16@GetEntity:

; 473  : 					return 0;

	mov	DWORD PTR $T7881[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ent$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T7881[ebp]
	jmp	$LN28@GetEntity
$LN19@GetEntity:

; 474  : 				mult *= 16;

	mov	ecx, DWORD PTR _mult$7173[ebp]
	shl	ecx, 4
	mov	DWORD PTR _mult$7173[ebp], ecx

; 475  : 				--q;

	mov	edx, DWORD PTR _q$7177[ebp]
	sub	edx, 1
	mov	DWORD PTR _q$7177[ebp], edx

; 476  : 			}

	jmp	$LN22@GetEntity
$LN21@GetEntity:

; 477  : 		}
; 478  : 		else

	jmp	$LN14@GetEntity
$LN26@GetEntity:

; 479  : 		{
; 480  : 			// Decimal.
; 481  : 			if ( !*(p+2) ) return 0;

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	test	ecx, ecx
	jne	SHORT $LN13@GetEntity
	mov	DWORD PTR $T7882[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ent$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T7882[ebp]
	jmp	$LN28@GetEntity
$LN13@GetEntity:

; 482  : 
; 483  : 			const char* q = p+2;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 2
	mov	DWORD PTR _q$7194[ebp], edx

; 484  : 			q = strchr( q, ';' );

	push	59					; 0000003bH
	mov	eax, DWORD PTR _q$7194[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _q$7194[ebp], eax

; 485  : 
; 486  : 			if ( !q || !*q ) return 0;

	cmp	DWORD PTR _q$7194[ebp], 0
	je	SHORT $LN11@GetEntity
	mov	ecx, DWORD PTR _q$7194[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN12@GetEntity
$LN11@GetEntity:
	mov	DWORD PTR $T7883[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ent$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T7883[ebp]
	jmp	$LN28@GetEntity
$LN12@GetEntity:

; 487  : 
; 488  : 			delta = q-p;

	mov	eax, DWORD PTR _q$7194[ebp]
	sub	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _delta$7172[ebp], eax

; 489  : 			--q;

	mov	ecx, DWORD PTR _q$7194[ebp]
	sub	ecx, 1
	mov	DWORD PTR _q$7194[ebp], ecx
$LN10@GetEntity:

; 490  : 
; 491  : 			while ( *q != '#' )

	mov	edx, DWORD PTR _q$7194[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 35					; 00000023H
	je	SHORT $LN14@GetEntity

; 492  : 			{
; 493  : 				if ( *q >= '0' && *q <= '9' )

	mov	ecx, DWORD PTR _q$7194[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN8@GetEntity
	mov	eax, DWORD PTR _q$7194[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN8@GetEntity

; 494  : 					ucs += mult * (*q - '0');

	mov	edx, DWORD PTR _q$7194[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	eax, 48					; 00000030H
	imul	eax, DWORD PTR _mult$7173[ebp]
	add	eax, DWORD PTR _ucs$7171[ebp]
	mov	DWORD PTR _ucs$7171[ebp], eax

; 495  : 				else 

	jmp	SHORT $LN7@GetEntity
$LN8@GetEntity:

; 496  : 					return 0;

	mov	DWORD PTR $T7884[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ent$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T7884[ebp]
	jmp	$LN28@GetEntity
$LN7@GetEntity:

; 497  : 				mult *= 10;

	mov	ecx, DWORD PTR _mult$7173[ebp]
	imul	ecx, 10					; 0000000aH
	mov	DWORD PTR _mult$7173[ebp], ecx

; 498  : 				--q;

	mov	edx, DWORD PTR _q$7194[ebp]
	sub	edx, 1
	mov	DWORD PTR _q$7194[ebp], edx

; 499  : 			}

	jmp	SHORT $LN10@GetEntity
$LN14@GetEntity:

; 500  : 		}
; 501  : 		if ( encoding == TIXML_ENCODING_UTF8 )

	cmp	DWORD PTR _encoding$[ebp], 1
	jne	SHORT $LN6@GetEntity

; 502  : 		{
; 503  : 			// convert the UCS to UTF-8
; 504  : 			ConvertUTF32ToUTF8( ucs, value, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ucs$7171[ebp]
	push	edx
	call	?ConvertUTF32ToUTF8@TiXmlBase@@KAXKPADPAH@Z ; TiXmlBase::ConvertUTF32ToUTF8
	add	esp, 12					; 0000000cH

; 505  : 		}
; 506  : 		else

	jmp	SHORT $LN5@GetEntity
$LN6@GetEntity:

; 507  : 		{
; 508  : 			*value = (char)ucs;

	mov	eax, DWORD PTR _value$[ebp]
	mov	cl, BYTE PTR _ucs$7171[ebp]
	mov	BYTE PTR [eax], cl

; 509  : 			*length = 1;

	mov	edx, DWORD PTR _length$[ebp]
	mov	DWORD PTR [edx], 1
$LN5@GetEntity:

; 510  : 		}
; 511  : 		return p + delta + 1;

	mov	eax, DWORD PTR _delta$7172[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR $T7885[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ent$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T7885[ebp]
	jmp	$LN28@GetEntity
$LN27@GetEntity:

; 512  : 	}
; 513  : 
; 514  : 	// Now try to match it.
; 515  : 	for( i=0; i<NUM_ENTITY; ++i )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GetEntity
$LN3@GetEntity:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GetEntity:
	cmp	DWORD PTR _i$[ebp], 5
	jge	SHORT $LN2@GetEntity

; 516  : 	{
; 517  : 		if ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?entity@TiXmlBase@@0PAUEntity@1@A[ecx+4]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?entity@TiXmlBase@@0PAUEntity@1@A[ecx]
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@GetEntity

; 518  : 		{
; 519  : 			assert( strlen( entity[i].str ) == entity[i].strLength );
; 520  : 			*value = entity[i].chr;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _value$[ebp]
	mov	dl, BYTE PTR ?entity@TiXmlBase@@0PAUEntity@1@A[eax+8]
	mov	BYTE PTR [ecx], dl

; 521  : 			*length = 1;

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax], 1

; 522  : 			return ( p + entity[i].strLength );

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, DWORD PTR ?entity@TiXmlBase@@0PAUEntity@1@A[ecx+4]
	mov	DWORD PTR $T7886[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ent$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T7886[ebp]
	jmp	SHORT $LN28@GetEntity
$LN1@GetEntity:

; 523  : 		}
; 524  : 	}

	jmp	SHORT $LN3@GetEntity
$LN2@GetEntity:

; 525  : 
; 526  : 	// So it wasn't an entity, its unrecognized, or something like that.
; 527  : 	*value = *p;	// Don't put back the last one, since we return it!

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 528  : 	//*length = 1;	// Leave unrecognized entities - this doesn't really work.
; 529  : 					// Just writes strange XML.
; 530  : 	return p+1;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR $T7887[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ent$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T7887[ebp]
$LN28@GetEntity:

; 531  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetEntity@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z$0:
	lea	ecx, DWORD PTR _ent$[ebp]
	jmp	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
__ehhandler$?GetEntity@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetEntity@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetEntity@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z ENDP ; TiXmlBase::GetEntity
EXTRN	?nullrep_@TiXmlString@@0URep@1@A:BYTE		; TiXmlString::nullrep_
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinystr.h
;	COMDAT ??0TiXmlString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TiXmlString@@QAE@XZ PROC				; TiXmlString::TiXmlString, COMDAT
; _this$ = ecx

; 79   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ?nullrep_@TiXmlString@@0URep@1@A ; TiXmlString::nullrep_

; 80   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0TiXmlString@@QAE@XZ ENDP				; TiXmlString::TiXmlString
_TEXT	ENDS
PUBLIC	?quit@TiXmlString@@AAEXXZ			; TiXmlString::quit
; Function compile flags: /Odtp
;	COMDAT ??1TiXmlString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TiXmlString@@QAE@XZ PROC				; TiXmlString::~TiXmlString, COMDAT
; _this$ = ecx

; 105  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 106  : 		quit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?quit@TiXmlString@@AAEXXZ		; TiXmlString::quit

; 107  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1TiXmlString@@QAE@XZ ENDP				; TiXmlString::~TiXmlString
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ?quit@TiXmlString@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T7903 = -4						; size = 4
?quit@TiXmlString@@AAEXXZ PROC				; TiXmlString::quit, COMDAT
; _this$ = ecx

; 254  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 255  : 		if (rep_ != &nullrep_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], OFFSET ?nullrep_@TiXmlString@@0URep@1@A ; TiXmlString::nullrep_
	je	SHORT $LN2@quit

; 256  : 		{
; 257  : 			// The rep_ is really an array of ints. (see the allocator, above).
; 258  : 			// Cast it back before delete, so the compiler won't incorrectly call destructors.
; 259  : 			delete [] ( reinterpret_cast<int*>( rep_ ) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T7903[ebp], edx
	mov	eax, DWORD PTR $T7903[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@quit:

; 260  : 		}
; 261  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?quit@TiXmlString@@AAEXXZ ENDP				; TiXmlString::quit
_TEXT	ENDS
PUBLIC	?ToLower@TiXmlBase@@KAHHW4TiXmlEncoding@@@Z	; TiXmlBase::ToLower
PUBLIC	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxmlparser.cpp
_TEXT	SEGMENT
_q$ = -4						; size = 4
_p$ = 8							; size = 4
_tag$ = 12						; size = 4
_ignoreCase$ = 16					; size = 1
_encoding$ = 20						; size = 4
?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z PROC ; TiXmlBase::StringEqual

; 538  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 539  : 	assert( p );
; 540  : 	assert( tag );
; 541  : 	if ( !p || !*p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN9@StringEqua
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN10@StringEqua
$LN9@StringEqua:

; 542  : 	{
; 543  : 		assert( 0 );
; 544  : 		return false;

	xor	al, al
	jmp	$LN11@StringEqua
$LN10@StringEqua:

; 545  : 	}
; 546  : 
; 547  : 	const char* q = p;

	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _q$[ebp], edx

; 548  : 
; 549  : 	if ( ignoreCase )

	movzx	eax, BYTE PTR _ignoreCase$[ebp]
	test	eax, eax
	je	SHORT $LN3@StringEqua
$LN7@StringEqua:

; 550  : 	{
; 551  : 		while ( *q && *tag && ToLower( *q, encoding ) == ToLower( *tag, encoding ) )

	mov	ecx, DWORD PTR _q$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN6@StringEqua
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@StringEqua
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _q$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	?ToLower@TiXmlBase@@KAHHW4TiXmlEncoding@@@Z ; TiXmlBase::ToLower
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	?ToLower@TiXmlBase@@KAHHW4TiXmlEncoding@@@Z ; TiXmlBase::ToLower
	add	esp, 8
	cmp	esi, eax
	jne	SHORT $LN6@StringEqua

; 552  : 		{
; 553  : 			++q;

	mov	edx, DWORD PTR _q$[ebp]
	add	edx, 1
	mov	DWORD PTR _q$[ebp], edx

; 554  : 			++tag;

	mov	eax, DWORD PTR _tag$[ebp]
	add	eax, 1
	mov	DWORD PTR _tag$[ebp], eax

; 555  : 		}

	jmp	SHORT $LN7@StringEqua
$LN6@StringEqua:

; 556  : 
; 557  : 		if ( *tag == 0 )

	mov	ecx, DWORD PTR _tag$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN5@StringEqua

; 558  : 			return true;

	mov	al, 1
	jmp	SHORT $LN11@StringEqua
$LN5@StringEqua:

; 559  : 	}
; 560  : 	else

	jmp	SHORT $LN4@StringEqua
$LN3@StringEqua:

; 561  : 	{
; 562  : 		while ( *q && *tag && *q == *tag )

	mov	eax, DWORD PTR _q$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@StringEqua
	mov	edx, DWORD PTR _tag$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN2@StringEqua
	mov	ecx, DWORD PTR _q$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _tag$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN2@StringEqua

; 563  : 		{
; 564  : 			++q;

	mov	edx, DWORD PTR _q$[ebp]
	add	edx, 1
	mov	DWORD PTR _q$[ebp], edx

; 565  : 			++tag;

	mov	eax, DWORD PTR _tag$[ebp]
	add	eax, 1
	mov	DWORD PTR _tag$[ebp], eax

; 566  : 		}

	jmp	SHORT $LN3@StringEqua
$LN2@StringEqua:

; 567  : 
; 568  : 		if ( *tag == 0 )		// Have we found the end of the tag, and everything equal?

	mov	ecx, DWORD PTR _tag$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN4@StringEqua

; 569  : 			return true;

	mov	al, 1
	jmp	SHORT $LN11@StringEqua
$LN4@StringEqua:

; 570  : 	}
; 571  : 	return false;

	xor	al, al
$LN11@StringEqua:

; 572  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ENDP ; TiXmlBase::StringEqual
_TEXT	ENDS
EXTRN	__imp__tolower:PROC
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxml.h
;	COMDAT ?ToLower@TiXmlBase@@KAHHW4TiXmlEncoding@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_encoding$ = 12						; size = 4
?ToLower@TiXmlBase@@KAHHW4TiXmlEncoding@@@Z PROC	; TiXmlBase::ToLower, COMDAT

; 384  : 	{

	push	ebp
	mov	ebp, esp

; 385  : 		if ( encoding == TIXML_ENCODING_UTF8 )

	cmp	DWORD PTR _encoding$[ebp], 1
	jne	SHORT $LN3@ToLower

; 386  : 		{
; 387  : 			if ( v < 128 ) return tolower( v );

	cmp	DWORD PTR _v$[ebp], 128			; 00000080H
	jge	SHORT $LN2@ToLower
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	call	DWORD PTR __imp__tolower
	add	esp, 4
	jmp	SHORT $LN4@ToLower
$LN2@ToLower:

; 388  : 			return v;

	mov	eax, DWORD PTR _v$[ebp]
	jmp	SHORT $LN4@ToLower

; 389  : 		}
; 390  : 		else

	jmp	SHORT $LN4@ToLower
$LN3@ToLower:

; 391  : 		{
; 392  : 			return tolower( v );

	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	call	DWORD PTR __imp__tolower
	add	esp, 4
$LN4@ToLower:

; 393  : 		}
; 394  : 	}

	pop	ebp
	ret	0
?ToLower@TiXmlBase@@KAHHW4TiXmlEncoding@@@Z ENDP	; TiXmlBase::ToLower
_TEXT	ENDS
PUBLIC	??YTiXmlString@@QAEAAV0@D@Z			; TiXmlString::operator+=
PUBLIC	?GetChar@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z ; TiXmlBase::GetChar
PUBLIC	?ReadText@TiXmlBase@@KAPBDPBDPAVTiXmlString@@_N02W4TiXmlEncoding@@@Z ; TiXmlBase::ReadText
EXTRN	?append@TiXmlString@@QAEAAV1@PBDI@Z:PROC	; TiXmlString::append
EXTRN	?condenseWhiteSpace@TiXmlBase@@0_NA:BYTE	; TiXmlBase::condenseWhiteSpace
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxmlparser.cpp
_TEXT	SEGMENT
_cArr$7265 = -20					; size = 4
_len$7264 = -16						; size = 4
_whitespace$7254 = -9					; size = 1
_cArr$7252 = -8						; size = 4
_len$7251 = -4						; size = 4
_p$ = 8							; size = 4
_text$ = 12						; size = 4
_trimWhiteSpace$ = 16					; size = 1
_endTag$ = 20						; size = 4
_caseInsensitive$ = 24					; size = 1
_encoding$ = 28						; size = 4
?ReadText@TiXmlBase@@KAPBDPBDPAVTiXmlString@@_N02W4TiXmlEncoding@@@Z PROC ; TiXmlBase::ReadText

; 580  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 581  :     *text = "";

	push	OFFSET $SG7245
	mov	ecx, DWORD PTR _text$[ebp]
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=

; 582  : 	if (    !trimWhiteSpace			// certain tags always keep whitespace
; 583  : 		 || !condenseWhiteSpace )	// if true, whitespace is always kept

	movzx	eax, BYTE PTR _trimWhiteSpace$[ebp]
	test	eax, eax
	je	SHORT $LN14@ReadText
	movzx	ecx, BYTE PTR ?condenseWhiteSpace@TiXmlBase@@0_NA ; TiXmlBase::condenseWhiteSpace
	test	ecx, ecx
	jne	SHORT $LN16@ReadText
$LN14@ReadText:

; 584  : 	{
; 585  : 		// Keep all the white space.
; 586  : 		while (	   p && *p
; 587  : 				&& !StringEqual( p, endTag, caseInsensitive, encoding )
; 588  : 			  )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN13@ReadText
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN13@ReadText
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _caseInsensitive$[ebp]
	push	edx
	mov	eax, DWORD PTR _endTag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN13@ReadText

; 589  : 		{
; 590  : 			int len;
; 591  : 			char cArr[4] = { 0, 0, 0, 0 };

	mov	BYTE PTR _cArr$7252[ebp], 0
	mov	BYTE PTR _cArr$7252[ebp+1], 0
	mov	BYTE PTR _cArr$7252[ebp+2], 0
	mov	BYTE PTR _cArr$7252[ebp+3], 0

; 592  : 			p = GetChar( p, cArr, &len, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	lea	ecx, DWORD PTR _len$7251[ebp]
	push	ecx
	lea	edx, DWORD PTR _cArr$7252[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?GetChar@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z ; TiXmlBase::GetChar
	add	esp, 16					; 00000010H
	mov	DWORD PTR _p$[ebp], eax

; 593  : 			text->append( cArr, len );

	mov	ecx, DWORD PTR _len$7251[ebp]
	push	ecx
	lea	edx, DWORD PTR _cArr$7252[ebp]
	push	edx
	mov	ecx, DWORD PTR _text$[ebp]
	call	?append@TiXmlString@@QAEAAV1@PBDI@Z	; TiXmlString::append

; 594  : 		}

	jmp	SHORT $LN14@ReadText
$LN13@ReadText:

; 595  : 	}
; 596  : 	else

	jmp	$LN12@ReadText
$LN16@ReadText:

; 597  : 	{
; 598  : 		bool whitespace = false;

	mov	BYTE PTR _whitespace$7254[ebp], 0

; 599  : 
; 600  : 		// Remove leading white space:
; 601  : 		p = SkipWhiteSpace( p, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax
$LN11@ReadText:

; 602  : 		while (	   p && *p
; 603  : 				&& !StringEqual( p, endTag, caseInsensitive, encoding ) )

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN12@ReadText
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN12@ReadText
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _caseInsensitive$[ebp]
	push	edx
	mov	eax, DWORD PTR _endTag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	jne	$LN12@ReadText

; 604  : 		{
; 605  : 			if ( *p == '\r' || *p == '\n' )

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN8@ReadText
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN9@ReadText
$LN8@ReadText:

; 606  : 			{
; 607  : 				whitespace = true;

	mov	BYTE PTR _whitespace$7254[ebp], 1

; 608  : 				++p;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
	jmp	$LN7@ReadText
$LN9@ReadText:

; 609  : 			}
; 610  : 			else if ( IsWhiteSpace( *p ) )

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	?IsWhiteSpace@TiXmlBase@@KA_ND@Z	; TiXmlBase::IsWhiteSpace
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@ReadText

; 611  : 			{
; 612  : 				whitespace = true;

	mov	BYTE PTR _whitespace$7254[ebp], 1

; 613  : 				++p;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 614  : 			}
; 615  : 			else

	jmp	SHORT $LN7@ReadText
$LN6@ReadText:

; 616  : 			{
; 617  : 				// If we've found whitespace, add it before the
; 618  : 				// new character. Any whitespace just becomes a space.
; 619  : 				if ( whitespace )

	movzx	eax, BYTE PTR _whitespace$7254[ebp]
	test	eax, eax
	je	SHORT $LN4@ReadText

; 620  : 				{
; 621  : 					(*text) += ' ';

	push	32					; 00000020H
	mov	ecx, DWORD PTR _text$[ebp]
	call	??YTiXmlString@@QAEAAV0@D@Z		; TiXmlString::operator+=

; 622  : 					whitespace = false;

	mov	BYTE PTR _whitespace$7254[ebp], 0
$LN4@ReadText:

; 623  : 				}
; 624  : 				int len;
; 625  : 				char cArr[4] = { 0, 0, 0, 0 };

	mov	BYTE PTR _cArr$7265[ebp], 0
	mov	BYTE PTR _cArr$7265[ebp+1], 0
	mov	BYTE PTR _cArr$7265[ebp+2], 0
	mov	BYTE PTR _cArr$7265[ebp+3], 0

; 626  : 				p = GetChar( p, cArr, &len, encoding );

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	lea	edx, DWORD PTR _len$7264[ebp]
	push	edx
	lea	eax, DWORD PTR _cArr$7265[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?GetChar@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z ; TiXmlBase::GetChar
	add	esp, 16					; 00000010H
	mov	DWORD PTR _p$[ebp], eax

; 627  : 				if ( len == 1 )

	cmp	DWORD PTR _len$7264[ebp], 1
	jne	SHORT $LN3@ReadText

; 628  : 					(*text) += cArr[0];	// more efficient

	movzx	edx, BYTE PTR _cArr$7265[ebp]
	push	edx
	mov	ecx, DWORD PTR _text$[ebp]
	call	??YTiXmlString@@QAEAAV0@D@Z		; TiXmlString::operator+=

; 629  : 				else

	jmp	SHORT $LN7@ReadText
$LN3@ReadText:

; 630  : 					text->append( cArr, len );

	mov	eax, DWORD PTR _len$7264[ebp]
	push	eax
	lea	ecx, DWORD PTR _cArr$7265[ebp]
	push	ecx
	mov	ecx, DWORD PTR _text$[ebp]
	call	?append@TiXmlString@@QAEAAV1@PBDI@Z	; TiXmlString::append
$LN7@ReadText:

; 631  : 			}
; 632  : 		}

	jmp	$LN11@ReadText
$LN12@ReadText:

; 633  : 	}
; 634  : 	if ( p ) 

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN1@ReadText

; 635  : 		p += strlen( endTag );

	mov	edx, DWORD PTR _endTag$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN1@ReadText:

; 636  : 	return p;

	mov	eax, DWORD PTR _p$[ebp]

; 637  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ReadText@TiXmlBase@@KAPBDPBDPAVTiXmlString@@_N02W4TiXmlEncoding@@@Z ENDP ; TiXmlBase::ReadText
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinystr.h
_TEXT	ENDS
;	COMDAT ??YTiXmlString@@QAEAAV0@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_single$ = 8						; size = 1
??YTiXmlString@@QAEAAV0@D@Z PROC			; TiXmlString::operator+=, COMDAT
; _this$ = ecx

; 130  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 131  : 		return append(&single, 1);

	push	1
	lea	eax, DWORD PTR _single$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@TiXmlString@@QAEAAV1@PBDI@Z	; TiXmlString::append

; 132  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??YTiXmlString@@QAEAAV0@D@Z ENDP			; TiXmlString::operator+=
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxml.h
_TEXT	ENDS
;	COMDAT ?GetChar@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z
_TEXT	SEGMENT
_i$6116 = -4						; size = 4
_p$ = 8							; size = 4
__value$ = 12						; size = 4
_length$ = 16						; size = 4
_encoding$ = 20						; size = 4
?GetChar@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z PROC ; TiXmlBase::GetChar, COMDAT

; 329  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 330  : 		assert( p );
; 331  : 		if ( encoding == TIXML_ENCODING_UTF8 )

	cmp	DWORD PTR _encoding$[ebp], 1
	jne	SHORT $LN10@GetChar

; 332  : 		{
; 333  : 			*length = utf8ByteTable[ *((const unsigned char*)p) ];

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _length$[ebp]
	mov	eax, DWORD PTR ?utf8ByteTable@TiXmlBase@@2QBHB[ecx*4]
	mov	DWORD PTR [edx], eax

; 334  : 			assert( *length >= 0 && *length < 5 );
; 335  : 		}
; 336  : 		else

	jmp	SHORT $LN9@GetChar
$LN10@GetChar:

; 337  : 		{
; 338  : 			*length = 1;

	mov	ecx, DWORD PTR _length$[ebp]
	mov	DWORD PTR [ecx], 1
$LN9@GetChar:

; 339  : 		}
; 340  : 
; 341  : 		if ( *length == 1 )

	mov	edx, DWORD PTR _length$[ebp]
	cmp	DWORD PTR [edx], 1
	jne	SHORT $LN8@GetChar

; 342  : 		{
; 343  : 			if ( *p == '&' )

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 38					; 00000026H
	jne	SHORT $LN7@GetChar

; 344  : 				return GetEntity( p, _value, length, encoding );

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR __value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?GetEntity@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z ; TiXmlBase::GetEntity
	add	esp, 16					; 00000010H
	jmp	SHORT $LN11@GetChar
$LN7@GetChar:

; 345  : 			*_value = *p;

	mov	eax, DWORD PTR __value$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 346  : 			return p+1;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	jmp	SHORT $LN11@GetChar
	jmp	SHORT $LN11@GetChar
$LN8@GetChar:

; 347  : 		}
; 348  : 		else if ( *length )

	mov	eax, DWORD PTR _length$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@GetChar

; 349  : 		{
; 350  : 			//strncpy( _value, p, *length );	// lots of compilers don't like this function (unsafe),
; 351  : 												// and the null terminator isn't needed
; 352  : 			for( int i=0; p[i] && i<*length; ++i ) {

	mov	DWORD PTR _i$6116[ebp], 0
	jmp	SHORT $LN4@GetChar
$LN3@GetChar:
	mov	ecx, DWORD PTR _i$6116[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$6116[ebp], ecx
$LN4@GetChar:
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, DWORD PTR _i$6116[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN2@GetChar
	mov	ecx, DWORD PTR _length$[ebp]
	mov	edx, DWORD PTR _i$6116[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN2@GetChar

; 353  : 				_value[i] = p[i];

	mov	eax, DWORD PTR __value$[ebp]
	add	eax, DWORD PTR _i$6116[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _i$6116[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 354  : 			}

	jmp	SHORT $LN3@GetChar
$LN2@GetChar:

; 355  : 			return p + (*length);

	mov	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	eax, ecx
	jmp	SHORT $LN11@GetChar

; 356  : 		}
; 357  : 		else

	jmp	SHORT $LN11@GetChar
$LN5@GetChar:

; 358  : 		{
; 359  : 			// Not valid text.
; 360  : 			return 0;

	xor	eax, eax
$LN11@GetChar:

; 361  : 		}
; 362  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetChar@TiXmlBase@@KAPBDPBDPADPAHW4TiXmlEncoding@@@Z ENDP ; TiXmlBase::GetChar
_TEXT	ENDS
PUBLIC	?Encoding@TiXmlDeclaration@@QBEPBDXZ		; TiXmlDeclaration::Encoding
PUBLIC	?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z ; TiXmlNode::Identify
PUBLIC	?Cursor@TiXmlParsingData@@QAEABUTiXmlCursor@@XZ	; TiXmlParsingData::Cursor
PUBLIC	??0TiXmlParsingData@@AAE@PBDHHH@Z		; TiXmlParsingData::TiXmlParsingData
PUBLIC	?TabSize@TiXmlDocument@@QBEHXZ			; TiXmlDocument::TabSize
PUBLIC	?Clear@TiXmlCursor@@QAEXXZ			; TiXmlCursor::Clear
PUBLIC	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
PUBLIC	?ClearError@TiXmlDocument@@QAEXXZ		; TiXmlDocument::ClearError
PUBLIC	?Parse@TiXmlDocument@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::Parse
EXTRN	?LinkEndChild@TiXmlNode@@QAEPAV1@PAV1@@Z:PROC	; TiXmlNode::LinkEndChild
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxmlparser.cpp
_TEXT	SEGMENT
_this$ = -36						; size = 4
_enc$7293 = -32						; size = 4
_dec$7292 = -28						; size = 4
_node$7288 = -24					; size = 4
_pU$7281 = -20						; size = 4
_data$ = -16						; size = 16
_p$ = 8							; size = 4
_prevData$ = 12						; size = 4
_encoding$ = 16						; size = 4
?Parse@TiXmlDocument@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z PROC ; TiXmlDocument::Parse
; _this$ = ecx

; 705  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 706  : 	ClearError();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearError@TiXmlDocument@@QAEXXZ	; TiXmlDocument::ClearError

; 707  : 
; 708  : 	// Parse away, at the document level. Since a document
; 709  : 	// contains nothing but other tags, most of what happens
; 710  : 	// here is skipping white space.
; 711  : 	if ( !p || !*p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN18@Parse
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN19@Parse
$LN18@Parse:

; 712  : 	{
; 713  : 		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );

	push	0
	push	0
	push	0
	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError

; 714  : 		return 0;

	xor	eax, eax
	jmp	$LN20@Parse
$LN19@Parse:

; 715  : 	}
; 716  : 
; 717  : 	// Note that, for a document, this needs to come
; 718  : 	// before the while space skip, so that parsing
; 719  : 	// starts from the pointer we are given.
; 720  : 	location.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Clear@TiXmlCursor@@QAEXXZ		; TiXmlCursor::Clear

; 721  : 	if ( prevData )

	cmp	DWORD PTR _prevData$[ebp], 0
	je	SHORT $LN17@Parse

; 722  : 	{
; 723  : 		location.row = prevData->cursor.row;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _prevData$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], ecx

; 724  : 		location.col = prevData->cursor.col;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _prevData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 725  : 	}
; 726  : 	else

	jmp	SHORT $LN16@Parse
$LN17@Parse:

; 727  : 	{
; 728  : 		location.row = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 729  : 		location.col = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN16@Parse:

; 730  : 	}
; 731  : 	TiXmlParsingData data( p, TabSize(), location.row, location.col );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TabSize@TiXmlDocument@@QBEHXZ		; TiXmlDocument::TabSize
	push	eax
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	lea	ecx, DWORD PTR _data$[ebp]
	call	??0TiXmlParsingData@@AAE@PBDHHH@Z	; TiXmlParsingData::TiXmlParsingData

; 732  : 	location = data.Cursor();

	lea	ecx, DWORD PTR _data$[ebp]
	call	?Cursor@TiXmlParsingData@@QAEABUTiXmlCursor@@XZ ; TiXmlParsingData::Cursor
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx

; 733  : 
; 734  : 	if ( encoding == TIXML_ENCODING_UNKNOWN )

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	SHORT $LN15@Parse

; 735  : 	{
; 736  : 		// Check for the Microsoft UTF-8 lead bytes.
; 737  : 		const unsigned char* pU = (const unsigned char*)p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _pU$7281[ebp], ecx

; 738  : 		if (	*(pU+0) && *(pU+0) == TIXML_UTF_LEAD_0
; 739  : 			 && *(pU+1) && *(pU+1) == TIXML_UTF_LEAD_1
; 740  : 			 && *(pU+2) && *(pU+2) == TIXML_UTF_LEAD_2 )

	mov	edx, DWORD PTR _pU$7281[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN15@Parse
	mov	ecx, DWORD PTR _pU$7281[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 239				; 000000efH
	jne	SHORT $LN15@Parse
	mov	eax, DWORD PTR _pU$7281[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN15@Parse
	mov	edx, DWORD PTR _pU$7281[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 187				; 000000bbH
	jne	SHORT $LN15@Parse
	mov	ecx, DWORD PTR _pU$7281[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	test	edx, edx
	je	SHORT $LN15@Parse
	mov	eax, DWORD PTR _pU$7281[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 191				; 000000bfH
	jne	SHORT $LN15@Parse

; 741  : 		{
; 742  : 			encoding = TIXML_ENCODING_UTF8;

	mov	DWORD PTR _encoding$[ebp], 1

; 743  : 			useMicrosoftBOM = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+68], 1
$LN15@Parse:

; 744  : 		}
; 745  : 	}
; 746  : 
; 747  :     p = SkipWhiteSpace( p, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 748  : 	if ( !p )

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN12@Parse

; 749  : 	{
; 750  : 		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );

	push	0
	push	0
	push	0
	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError

; 751  : 		return 0;

	xor	eax, eax
	jmp	$LN20@Parse
$LN12@Parse:

; 752  : 	}
; 753  : 
; 754  : 	while ( p && *p )

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN11@Parse
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN11@Parse

; 755  : 	{
; 756  : 		TiXmlNode* node = Identify( p, encoding );

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z ; TiXmlNode::Identify
	mov	DWORD PTR _node$7288[ebp], eax

; 757  : 		if ( node )

	cmp	DWORD PTR _node$7288[ebp], 0
	je	SHORT $LN10@Parse

; 758  : 		{
; 759  : 			p = node->Parse( p, &data, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$7288[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _node$7288[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR _p$[ebp], eax

; 760  : 			LinkEndChild( node );

	mov	ecx, DWORD PTR _node$7288[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkEndChild@TiXmlNode@@QAEPAV1@PAV1@@Z ; TiXmlNode::LinkEndChild

; 761  : 		}
; 762  : 		else

	jmp	SHORT $LN9@Parse
$LN10@Parse:

; 763  : 		{
; 764  : 			break;

	jmp	$LN11@Parse
$LN9@Parse:

; 765  : 		}
; 766  : 
; 767  : 		// Did we get encoding info?
; 768  : 		if (    encoding == TIXML_ENCODING_UNKNOWN
; 769  : 			 && node->ToDeclaration() )

	cmp	DWORD PTR _encoding$[ebp], 0
	jne	$LN8@Parse
	mov	edx, DWORD PTR _node$7288[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _node$7288[ebp]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	test	eax, eax
	je	SHORT $LN8@Parse

; 770  : 		{
; 771  : 			TiXmlDeclaration* dec = node->ToDeclaration();

	mov	eax, DWORD PTR _node$7288[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _node$7288[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	mov	DWORD PTR _dec$7292[ebp], eax

; 772  : 			const char* enc = dec->Encoding();

	mov	ecx, DWORD PTR _dec$7292[ebp]
	call	?Encoding@TiXmlDeclaration@@QBEPBDXZ	; TiXmlDeclaration::Encoding
	mov	DWORD PTR _enc$7293[ebp], eax

; 773  : 			assert( enc );
; 774  : 
; 775  : 			if ( *enc == 0 )

	mov	ecx, DWORD PTR _enc$7293[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN7@Parse

; 776  : 				encoding = TIXML_ENCODING_UTF8;

	mov	DWORD PTR _encoding$[ebp], 1
	jmp	SHORT $LN8@Parse
$LN7@Parse:

; 777  : 			else if ( StringEqual( enc, "UTF-8", true, TIXML_ENCODING_UNKNOWN ) )

	push	0
	push	1
	push	OFFSET $SG7298
	mov	eax, DWORD PTR _enc$7293[ebp]
	push	eax
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@Parse

; 778  : 				encoding = TIXML_ENCODING_UTF8;

	mov	DWORD PTR _encoding$[ebp], 1
	jmp	SHORT $LN8@Parse
$LN5@Parse:

; 779  : 			else if ( StringEqual( enc, "UTF8", true, TIXML_ENCODING_UNKNOWN ) )

	push	0
	push	1
	push	OFFSET $SG7301
	mov	edx, DWORD PTR _enc$7293[ebp]
	push	edx
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Parse

; 780  : 				encoding = TIXML_ENCODING_UTF8;	// incorrect, but be nice

	mov	DWORD PTR _encoding$[ebp], 1

; 781  : 			else 

	jmp	SHORT $LN8@Parse
$LN3@Parse:

; 782  : 				encoding = TIXML_ENCODING_LEGACY;

	mov	DWORD PTR _encoding$[ebp], 2
$LN8@Parse:

; 783  : 		}
; 784  : 
; 785  : 		p = SkipWhiteSpace( p, encoding );

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 786  : 	}

	jmp	$LN12@Parse
$LN11@Parse:

; 787  : 
; 788  : 	// Was this empty?
; 789  : 	if ( !firstChild ) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN1@Parse

; 790  : 		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, encoding );

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	push	0
	push	0
	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError

; 791  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN20@Parse
$LN1@Parse:

; 792  : 	}
; 793  : 
; 794  : 	// All is well.
; 795  : 	return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN20@Parse:

; 796  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Parse@TiXmlDocument@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ENDP ; TiXmlDocument::Parse
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxml.h
_TEXT	ENDS
;	COMDAT ?Clear@TiXmlCursor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@TiXmlCursor@@QAEXXZ PROC				; TiXmlCursor::Clear, COMDAT
; _this$ = ecx

; 104  : 	void Clear()		{ row = col = -1; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], -1
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@TiXmlCursor@@QAEXXZ ENDP				; TiXmlCursor::Clear
_TEXT	ENDS
PUBLIC	?c_str@TiXmlString@@QBEPBDXZ			; TiXmlString::c_str
; Function compile flags: /Odtp
;	COMDAT ?Encoding@TiXmlDeclaration@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Encoding@TiXmlDeclaration@@QBEPBDXZ PROC		; TiXmlDeclaration::Encoding, COMDAT
; _this$ = ecx

; 1303 : 	const char *Encoding() const		{ return encoding.c_str (); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?c_str@TiXmlString@@QBEPBDXZ		; TiXmlString::c_str
	mov	esp, ebp
	pop	ebp
	ret	0
?Encoding@TiXmlDeclaration@@QBEPBDXZ ENDP		; TiXmlDeclaration::Encoding
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinystr.h
_TEXT	ENDS
;	COMDAT ?c_str@TiXmlString@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@TiXmlString@@QBEPBDXZ PROC			; TiXmlString::c_str, COMDAT
; _this$ = ecx

; 142  : 	const char * c_str () const { return rep_->str; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, 8
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@TiXmlString@@QBEPBDXZ ENDP			; TiXmlString::c_str
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxml.h
_TEXT	ENDS
;	COMDAT ?TabSize@TiXmlDocument@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TabSize@TiXmlDocument@@QBEHXZ PROC			; TiXmlDocument::TabSize, COMDAT
; _this$ = ecx

; 1505 : 	int TabSize() const	{ return tabsize; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?TabSize@TiXmlDocument@@QBEHXZ ENDP			; TiXmlDocument::TabSize
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?ClearError@TiXmlDocument@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearError@TiXmlDocument@@QAEXXZ PROC			; TiXmlDocument::ClearError, COMDAT
; _this$ = ecx

; 1510 : 	void ClearError()						{	error = false; 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+44], 0

; 1511 : 												errorId = 0; 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 1512 : 												errorDesc = ""; 

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=

; 1513 : 												errorLocation.row = errorLocation.col = 0; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], 0

; 1514 : 												//errorLocation.last = 0; 
; 1515 : 											}

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearError@TiXmlDocument@@QAEXXZ ENDP			; TiXmlDocument::ClearError
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxmlparser.cpp
_TEXT	ENDS
;	COMDAT ?Cursor@TiXmlParsingData@@QAEABUTiXmlCursor@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Cursor@TiXmlParsingData@@QAEABUTiXmlCursor@@XZ PROC	; TiXmlParsingData::Cursor, COMDAT
; _this$ = ecx

; 177  : 	const TiXmlCursor& Cursor()	{ return cursor; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?Cursor@TiXmlParsingData@@QAEABUTiXmlCursor@@XZ ENDP	; TiXmlParsingData::Cursor
_TEXT	ENDS
PUBLIC	??0TiXmlCursor@@QAE@XZ				; TiXmlCursor::TiXmlCursor
; Function compile flags: /Odtp
;	COMDAT ??0TiXmlParsingData@@AAE@PBDHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_start$ = 8						; size = 4
__tabsize$ = 12						; size = 4
_row$ = 16						; size = 4
_col$ = 20						; size = 4
??0TiXmlParsingData@@AAE@PBDHHH@Z PROC			; TiXmlParsingData::TiXmlParsingData, COMDAT
; _this$ = ecx

; 181  : 	TiXmlParsingData( const char* start, int _tabsize, int row, int col )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0TiXmlCursor@@QAE@XZ			; TiXmlCursor::TiXmlCursor

; 182  : 	{
; 183  : 		assert( start );
; 184  : 		stamp = start;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 185  : 		tabsize = _tabsize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __tabsize$[ebp]
	mov	DWORD PTR [edx+12], eax

; 186  : 		cursor.row = row;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _row$[ebp]
	mov	DWORD PTR [ecx], edx

; 187  : 		cursor.col = col;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 188  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0TiXmlParsingData@@AAE@PBDHHH@Z ENDP			; TiXmlParsingData::TiXmlParsingData
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxml.h
_TEXT	ENDS
;	COMDAT ??0TiXmlCursor@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TiXmlCursor@@QAE@XZ PROC				; TiXmlCursor::TiXmlCursor, COMDAT
; _this$ = ecx

; 103  : 	TiXmlCursor()		{ Clear(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@TiXmlCursor@@QAEXXZ		; TiXmlCursor::Clear
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0TiXmlCursor@@QAE@XZ ENDP				; TiXmlCursor::TiXmlCursor
_TEXT	ENDS
EXTRN	?errorString@TiXmlBase@@1PAPBDA:BYTE		; TiXmlBase::errorString
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxmlparser.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_err$ = 8						; size = 4
_pError$ = 12						; size = 4
_data$ = 16						; size = 4
_encoding$ = 20						; size = 4
?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z PROC ; TiXmlDocument::SetError
; _this$ = ecx

; 799  : {	

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 800  : 	// The first error in a chain is more accurate - don't set again!
; 801  : 	if ( error )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+44]
	test	ecx, ecx
	je	SHORT $LN2@SetError

; 802  : 		return;

	jmp	SHORT $LN3@SetError
$LN2@SetError:

; 803  : 
; 804  : 	assert( err > 0 && err < TIXML_ERROR_STRING_COUNT );
; 805  : 	error   = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+44], 1

; 806  : 	errorId = err;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _err$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 807  : 	errorDesc = errorString[ errorId ];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR ?errorString@TiXmlBase@@1PAPBDA[eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=

; 808  : 
; 809  : 	errorLocation.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?Clear@TiXmlCursor@@QAEXXZ		; TiXmlCursor::Clear

; 810  : 	if ( pError && data )

	cmp	DWORD PTR _pError$[ebp], 0
	je	SHORT $LN3@SetError
	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN3@SetError

; 811  : 	{
; 812  : 		data->Stamp( pError, encoding );

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _pError$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	call	?Stamp@TiXmlParsingData@@QAEXPBDW4TiXmlEncoding@@@Z ; TiXmlParsingData::Stamp

; 813  : 		errorLocation = data->Cursor();

	mov	ecx, DWORD PTR _data$[ebp]
	call	?Cursor@TiXmlParsingData@@QAEABUTiXmlCursor@@XZ ; TiXmlParsingData::Cursor
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], ecx
	mov	DWORD PTR [eax+64], edx
$LN3@SetError:

; 814  : 	}
; 815  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ENDP ; TiXmlDocument::SetError
_TEXT	ENDS
PUBLIC	??0TiXmlUnknown@@QAE@XZ				; TiXmlUnknown::TiXmlUnknown
PUBLIC	?SetCDATA@TiXmlText@@QAEX_N@Z			; TiXmlText::SetCDATA
PUBLIC	??0TiXmlText@@QAE@PBD@Z				; TiXmlText::TiXmlText
PUBLIC	??0TiXmlComment@@QAE@XZ				; TiXmlComment::TiXmlComment
PUBLIC	??0TiXmlDeclaration@@QAE@XZ			; TiXmlDeclaration::TiXmlDeclaration
PUBLIC	?GetDocument@TiXmlNode@@QAEPAVTiXmlDocument@@XZ	; TiXmlNode::GetDocument
EXTRN	??0TiXmlElement@@QAE@PBD@Z:PROC			; TiXmlElement::TiXmlElement
EXTRN	??2@YAPAXI@Z:PROC				; operator new
xdata$x	SEGMENT
__ehfuncinfo$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv217 = -116						; size = 4
tv206 = -112						; size = 4
tv186 = -108						; size = 4
tv163 = -104						; size = 4
tv147 = -100						; size = 4
tv129 = -96						; size = 4
_this$ = -92						; size = 4
$T7953 = -88						; size = 4
$T7952 = -84						; size = 4
$T7949 = -80						; size = 4
$T7948 = -76						; size = 4
$T7945 = -72						; size = 4
$T7944 = -68						; size = 4
$T7941 = -64						; size = 4
$T7940 = -60						; size = 4
$T7937 = -56						; size = 4
$T7936 = -52						; size = 4
$T7933 = -48						; size = 4
$T7932 = -44						; size = 4
_text$7346 = -40					; size = 4
_doc$ = -36						; size = 4
_commentHeader$ = -32					; size = 4
_dtdHeader$ = -28					; size = 4
_xmlHeader$ = -24					; size = 4
_returnNode$ = -20					; size = 4
_cdataHeader$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_p$ = 8							; size = 4
_encoding$ = 12						; size = 4
?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z PROC ; TiXmlNode::Identify
; _this$ = ecx

; 819  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 820  : 	TiXmlNode* returnNode = 0;

	mov	DWORD PTR _returnNode$[ebp], 0

; 821  : 
; 822  : 	p = SkipWhiteSpace( p, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 823  : 	if( !p || !*p || *p != '<' )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN17@Identify
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN17@Identify
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 60					; 0000003cH
	je	SHORT $LN18@Identify
$LN17@Identify:

; 824  : 	{
; 825  : 		return 0;

	xor	eax, eax
	jmp	$LN19@Identify
$LN18@Identify:

; 826  : 	}
; 827  : 
; 828  : 	TiXmlDocument* doc = GetDocument();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDocument@TiXmlNode@@QAEPAVTiXmlDocument@@XZ ; TiXmlNode::GetDocument
	mov	DWORD PTR _doc$[ebp], eax

; 829  : 	p = SkipWhiteSpace( p, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 830  : 
; 831  : 	if ( !p || !*p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN15@Identify
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN16@Identify
$LN15@Identify:

; 832  : 	{
; 833  : 		return 0;

	xor	eax, eax
	jmp	$LN19@Identify
$LN16@Identify:

; 834  : 	}
; 835  : 
; 836  : 	// What is this thing? 
; 837  : 	// - Elements start with a letter or underscore, but xml is reserved.
; 838  : 	// - Comments: <!--
; 839  : 	// - Decleration: <?xml
; 840  : 	// - Everthing else is unknown to tinyxml.
; 841  : 	//
; 842  : 
; 843  : 	const char* xmlHeader = { "<?xml" };

	mov	DWORD PTR _xmlHeader$[ebp], OFFSET $SG7326

; 844  : 	const char* commentHeader = { "<!--" };

	mov	DWORD PTR _commentHeader$[ebp], OFFSET $SG7328

; 845  : 	const char* dtdHeader = { "<!" };

	mov	DWORD PTR _dtdHeader$[ebp], OFFSET $SG7330

; 846  : 	const char* cdataHeader = { "<![CDATA[" };

	mov	DWORD PTR _cdataHeader$[ebp], OFFSET $SG7332

; 847  : 
; 848  : 	if ( StringEqual( p, xmlHeader, true, encoding ) )

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _xmlHeader$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@Identify

; 849  : 	{
; 850  : 		#ifdef DEBUG_PARSER
; 851  : 			TIXML_LOG( "XML parsing Declaration\n" );
; 852  : 		#endif
; 853  : 		returnNode = new TiXmlDeclaration();

	push	56					; 00000038H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7933[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7933[ebp], 0
	je	SHORT $LN21@Identify
	mov	ecx, DWORD PTR $T7933[ebp]
	call	??0TiXmlDeclaration@@QAE@XZ		; TiXmlDeclaration::TiXmlDeclaration
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN22@Identify
$LN21@Identify:
	mov	DWORD PTR tv129[ebp], 0
$LN22@Identify:
	mov	edx, DWORD PTR tv129[ebp]
	mov	DWORD PTR $T7932[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T7932[ebp]
	mov	DWORD PTR _returnNode$[ebp], eax
	jmp	$LN13@Identify
$LN14@Identify:

; 854  : 	}
; 855  : 	else if ( StringEqual( p, commentHeader, false, encoding ) )

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _commentHeader$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@Identify

; 856  : 	{
; 857  : 		#ifdef DEBUG_PARSER
; 858  : 			TIXML_LOG( "XML parsing Comment\n" );
; 859  : 		#endif
; 860  : 		returnNode = new TiXmlComment();

	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7937[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T7937[ebp], 0
	je	SHORT $LN23@Identify
	mov	ecx, DWORD PTR $T7937[ebp]
	call	??0TiXmlComment@@QAE@XZ			; TiXmlComment::TiXmlComment
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN24@Identify
$LN23@Identify:
	mov	DWORD PTR tv147[ebp], 0
$LN24@Identify:
	mov	edx, DWORD PTR tv147[ebp]
	mov	DWORD PTR $T7936[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T7936[ebp]
	mov	DWORD PTR _returnNode$[ebp], eax
	jmp	$LN13@Identify
$LN12@Identify:

; 861  : 	}
; 862  : 	else if ( StringEqual( p, cdataHeader, false, encoding ) )

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _cdataHeader$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@Identify

; 863  : 	{
; 864  : 		#ifdef DEBUG_PARSER
; 865  : 			TIXML_LOG( "XML parsing CDATA\n" );
; 866  : 		#endif
; 867  : 		TiXmlText* text = new TiXmlText( "" );

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7941[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T7941[ebp], 0
	je	SHORT $LN25@Identify
	push	OFFSET $SG7351
	mov	ecx, DWORD PTR $T7941[ebp]
	call	??0TiXmlText@@QAE@PBD@Z			; TiXmlText::TiXmlText
	mov	DWORD PTR tv163[ebp], eax
	jmp	SHORT $LN26@Identify
$LN25@Identify:
	mov	DWORD PTR tv163[ebp], 0
$LN26@Identify:
	mov	edx, DWORD PTR tv163[ebp]
	mov	DWORD PTR $T7940[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T7940[ebp]
	mov	DWORD PTR _text$7346[ebp], eax

; 868  : 		text->SetCDATA( true );

	push	1
	mov	ecx, DWORD PTR _text$7346[ebp]
	call	?SetCDATA@TiXmlText@@QAEX_N@Z		; TiXmlText::SetCDATA

; 869  : 		returnNode = text;

	mov	ecx, DWORD PTR _text$7346[ebp]
	mov	DWORD PTR _returnNode$[ebp], ecx
	jmp	$LN13@Identify
$LN10@Identify:

; 870  : 	}
; 871  : 	else if ( StringEqual( p, dtdHeader, false, encoding ) )

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _dtdHeader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@Identify

; 872  : 	{
; 873  : 		#ifdef DEBUG_PARSER
; 874  : 			TIXML_LOG( "XML parsing Unknown(1)\n" );
; 875  : 		#endif
; 876  : 		returnNode = new TiXmlUnknown();

	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7945[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T7945[ebp], 0
	je	SHORT $LN27@Identify
	mov	ecx, DWORD PTR $T7945[ebp]
	call	??0TiXmlUnknown@@QAE@XZ			; TiXmlUnknown::TiXmlUnknown
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN28@Identify
$LN27@Identify:
	mov	DWORD PTR tv186[ebp], 0
$LN28@Identify:
	mov	eax, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T7944[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T7944[ebp]
	mov	DWORD PTR _returnNode$[ebp], ecx

; 877  : 	}
; 878  : 	else if (    IsAlpha( *(p+1), encoding )

	jmp	$LN13@Identify
$LN8@Identify:

; 879  : 			  || *(p+1) == '_' )

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	push	ecx
	call	?IsAlpha@TiXmlBase@@KAHEW4TiXmlEncoding@@@Z ; TiXmlBase::IsAlpha
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@Identify
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 95					; 0000005fH
	jne	SHORT $LN6@Identify
$LN5@Identify:

; 880  : 	{
; 881  : 		#ifdef DEBUG_PARSER
; 882  : 			TIXML_LOG( "XML parsing Element\n" );
; 883  : 		#endif
; 884  : 		returnNode = new TiXmlElement( "" );

	push	80					; 00000050H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7949[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T7949[ebp], 0
	je	SHORT $LN29@Identify
	push	OFFSET $SG7365
	mov	ecx, DWORD PTR $T7949[ebp]
	call	??0TiXmlElement@@QAE@PBD@Z		; TiXmlElement::TiXmlElement
	mov	DWORD PTR tv206[ebp], eax
	jmp	SHORT $LN30@Identify
$LN29@Identify:
	mov	DWORD PTR tv206[ebp], 0
$LN30@Identify:
	mov	ecx, DWORD PTR tv206[ebp]
	mov	DWORD PTR $T7948[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T7948[ebp]
	mov	DWORD PTR _returnNode$[ebp], edx

; 885  : 	}
; 886  : 	else

	jmp	SHORT $LN13@Identify
$LN6@Identify:

; 887  : 	{
; 888  : 		#ifdef DEBUG_PARSER
; 889  : 			TIXML_LOG( "XML parsing Unknown(2)\n" );
; 890  : 		#endif
; 891  : 		returnNode = new TiXmlUnknown();

	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7953[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T7953[ebp], 0
	je	SHORT $LN31@Identify
	mov	ecx, DWORD PTR $T7953[ebp]
	call	??0TiXmlUnknown@@QAE@XZ			; TiXmlUnknown::TiXmlUnknown
	mov	DWORD PTR tv217[ebp], eax
	jmp	SHORT $LN32@Identify
$LN31@Identify:
	mov	DWORD PTR tv217[ebp], 0
$LN32@Identify:
	mov	eax, DWORD PTR tv217[ebp]
	mov	DWORD PTR $T7952[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T7952[ebp]
	mov	DWORD PTR _returnNode$[ebp], ecx
$LN13@Identify:

; 892  : 	}
; 893  : 
; 894  : 	if ( returnNode )

	cmp	DWORD PTR _returnNode$[ebp], 0
	je	SHORT $LN3@Identify

; 895  : 	{
; 896  : 		// Set the parent, so it can report errors
; 897  : 		returnNode->parent = this;

	mov	edx, DWORD PTR _returnNode$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax

; 898  : 	}
; 899  : 	else

	jmp	SHORT $LN2@Identify
$LN3@Identify:

; 900  : 	{
; 901  : 		if ( doc )

	cmp	DWORD PTR _doc$[ebp], 0
	je	SHORT $LN2@Identify

; 902  : 			doc->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );

	push	0
	push	0
	push	0
	push	3
	mov	ecx, DWORD PTR _doc$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN2@Identify:

; 903  : 	}
; 904  : 	return returnNode;

	mov	eax, DWORD PTR _returnNode$[ebp]
$LN19@Identify:

; 905  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z$0:
	mov	eax, DWORD PTR $T7933[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z$1:
	mov	eax, DWORD PTR $T7937[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z$2:
	mov	eax, DWORD PTR $T7941[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z$3:
	mov	eax, DWORD PTR $T7945[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z$4:
	mov	eax, DWORD PTR $T7949[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z$5:
	mov	eax, DWORD PTR $T7953[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z ENDP ; TiXmlNode::Identify
EXTRN	?GetDocument@TiXmlNode@@QBEPBVTiXmlDocument@@XZ:PROC ; TiXmlNode::GetDocument
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxml.h
;	COMDAT ?GetDocument@TiXmlNode@@QAEPAVTiXmlDocument@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDocument@TiXmlNode@@QAEPAVTiXmlDocument@@XZ PROC	; TiXmlNode::GetDocument, COMDAT
; _this$ = ecx

; 691  : 	TiXmlDocument* GetDocument() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 692  : 		return const_cast< TiXmlDocument* >( (const_cast< const TiXmlNode* >(this))->GetDocument() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDocument@TiXmlNode@@QBEPBVTiXmlDocument@@XZ ; TiXmlNode::GetDocument

; 693  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDocument@TiXmlNode@@QAEPAVTiXmlDocument@@XZ ENDP	; TiXmlNode::GetDocument
_TEXT	ENDS
PUBLIC	??_7TiXmlComment@@6B@				; TiXmlComment::`vftable'
PUBLIC	??_R4TiXmlComment@@6B@				; TiXmlComment::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTiXmlComment@@@8			; TiXmlComment `RTTI Type Descriptor'
PUBLIC	??_R3TiXmlComment@@8				; TiXmlComment::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TiXmlComment@@8				; TiXmlComment::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TiXmlComment@@8			; TiXmlComment::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@TiXmlNode@@8			; TiXmlNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVTiXmlNode@@@8				; TiXmlNode `RTTI Type Descriptor'
PUBLIC	??_R3TiXmlNode@@8				; TiXmlNode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TiXmlNode@@8				; TiXmlNode::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TiXmlBase@@8			; TiXmlBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVTiXmlBase@@@8				; TiXmlBase `RTTI Type Descriptor'
PUBLIC	??_R3TiXmlBase@@8				; TiXmlBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TiXmlBase@@8				; TiXmlBase::`RTTI Base Class Array'
PUBLIC	?Parse@TiXmlComment@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlComment::Parse
PUBLIC	?ToDocument@TiXmlNode@@UAEPAVTiXmlDocument@@XZ	; TiXmlNode::ToDocument
PUBLIC	?ToDocument@TiXmlNode@@UBEPBVTiXmlDocument@@XZ	; TiXmlNode::ToDocument
PUBLIC	?ToElement@TiXmlNode@@UAEPAVTiXmlElement@@XZ	; TiXmlNode::ToElement
PUBLIC	?ToElement@TiXmlNode@@UBEPBVTiXmlElement@@XZ	; TiXmlNode::ToElement
PUBLIC	?ToComment@TiXmlComment@@UAEPAV1@XZ		; TiXmlComment::ToComment
PUBLIC	?ToComment@TiXmlComment@@UBEPBV1@XZ		; TiXmlComment::ToComment
PUBLIC	?ToUnknown@TiXmlNode@@UAEPAVTiXmlUnknown@@XZ	; TiXmlNode::ToUnknown
PUBLIC	?ToUnknown@TiXmlNode@@UBEPBVTiXmlUnknown@@XZ	; TiXmlNode::ToUnknown
PUBLIC	?ToText@TiXmlNode@@UAEPAVTiXmlText@@XZ		; TiXmlNode::ToText
PUBLIC	?ToText@TiXmlNode@@UBEPBVTiXmlText@@XZ		; TiXmlNode::ToText
PUBLIC	?ToDeclaration@TiXmlNode@@UAEPAVTiXmlDeclaration@@XZ ; TiXmlNode::ToDeclaration
PUBLIC	?ToDeclaration@TiXmlNode@@UBEPBVTiXmlDeclaration@@XZ ; TiXmlNode::ToDeclaration
EXTRN	??1TiXmlNode@@UAE@XZ:PROC			; TiXmlNode::~TiXmlNode
EXTRN	??0TiXmlNode@@IAE@W4NodeType@0@@Z:PROC		; TiXmlNode::TiXmlNode
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ETiXmlComment@@UAEPAXI@Z:PROC		; TiXmlComment::`vector deleting destructor'
EXTRN	?Print@TiXmlComment@@UBEXPAU_iobuf@@H@Z:PROC	; TiXmlComment::Print
EXTRN	?Clone@TiXmlComment@@UBEPAVTiXmlNode@@XZ:PROC	; TiXmlComment::Clone
EXTRN	?Accept@TiXmlComment@@UBE_NPAVTiXmlVisitor@@@Z:PROC ; TiXmlComment::Accept
;	COMDAT ??_R2TiXmlBase@@8
rdata$r	SEGMENT
??_R2TiXmlBase@@8 DD FLAT:??_R1A@?0A@EA@TiXmlBase@@8	; TiXmlBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3TiXmlBase@@8
rdata$r	SEGMENT
??_R3TiXmlBase@@8 DD 00H				; TiXmlBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2TiXmlBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTiXmlBase@@@8
_DATA	SEGMENT
??_R0?AVTiXmlBase@@@8 DD FLAT:??_7type_info@@6B@	; TiXmlBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTiXmlBase@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@TiXmlBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TiXmlBase@@8 DD FLAT:??_R0?AVTiXmlBase@@@8 ; TiXmlBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TiXmlBase@@8
rdata$r	ENDS
;	COMDAT ??_R2TiXmlNode@@8
rdata$r	SEGMENT
??_R2TiXmlNode@@8 DD FLAT:??_R1A@?0A@EA@TiXmlNode@@8	; TiXmlNode::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@TiXmlBase@@8
rdata$r	ENDS
;	COMDAT ??_R3TiXmlNode@@8
rdata$r	SEGMENT
??_R3TiXmlNode@@8 DD 00H				; TiXmlNode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2TiXmlNode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTiXmlNode@@@8
_DATA	SEGMENT
??_R0?AVTiXmlNode@@@8 DD FLAT:??_7type_info@@6B@	; TiXmlNode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTiXmlNode@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@TiXmlNode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TiXmlNode@@8 DD FLAT:??_R0?AVTiXmlNode@@@8 ; TiXmlNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TiXmlNode@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@TiXmlComment@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TiXmlComment@@8 DD FLAT:??_R0?AVTiXmlComment@@@8 ; TiXmlComment::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TiXmlComment@@8
rdata$r	ENDS
;	COMDAT ??_R2TiXmlComment@@8
rdata$r	SEGMENT
??_R2TiXmlComment@@8 DD FLAT:??_R1A@?0A@EA@TiXmlComment@@8 ; TiXmlComment::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@TiXmlNode@@8
	DD	FLAT:??_R1A@?0A@EA@TiXmlBase@@8
rdata$r	ENDS
;	COMDAT ??_R3TiXmlComment@@8
rdata$r	SEGMENT
??_R3TiXmlComment@@8 DD 00H				; TiXmlComment::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2TiXmlComment@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTiXmlComment@@@8
_DATA	SEGMENT
??_R0?AVTiXmlComment@@@8 DD FLAT:??_7type_info@@6B@	; TiXmlComment `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTiXmlComment@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TiXmlComment@@6B@
rdata$r	SEGMENT
??_R4TiXmlComment@@6B@ DD 00H				; TiXmlComment::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTiXmlComment@@@8
	DD	FLAT:??_R3TiXmlComment@@8
rdata$r	ENDS
;	COMDAT ??_7TiXmlComment@@6B@
CONST	SEGMENT
??_7TiXmlComment@@6B@ DD FLAT:??_R4TiXmlComment@@6B@	; TiXmlComment::`vftable'
	DD	FLAT:??_ETiXmlComment@@UAEPAXI@Z
	DD	FLAT:?Print@TiXmlComment@@UBEXPAU_iobuf@@H@Z
	DD	FLAT:?Parse@TiXmlComment@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	DD	FLAT:?ToDocument@TiXmlNode@@UAEPAVTiXmlDocument@@XZ
	DD	FLAT:?ToDocument@TiXmlNode@@UBEPBVTiXmlDocument@@XZ
	DD	FLAT:?ToElement@TiXmlNode@@UAEPAVTiXmlElement@@XZ
	DD	FLAT:?ToElement@TiXmlNode@@UBEPBVTiXmlElement@@XZ
	DD	FLAT:?ToComment@TiXmlComment@@UAEPAV1@XZ
	DD	FLAT:?ToComment@TiXmlComment@@UBEPBV1@XZ
	DD	FLAT:?ToUnknown@TiXmlNode@@UAEPAVTiXmlUnknown@@XZ
	DD	FLAT:?ToUnknown@TiXmlNode@@UBEPBVTiXmlUnknown@@XZ
	DD	FLAT:?ToText@TiXmlNode@@UAEPAVTiXmlText@@XZ
	DD	FLAT:?ToText@TiXmlNode@@UBEPBVTiXmlText@@XZ
	DD	FLAT:?ToDeclaration@TiXmlNode@@UAEPAVTiXmlDeclaration@@XZ
	DD	FLAT:?ToDeclaration@TiXmlNode@@UBEPBVTiXmlDeclaration@@XZ
	DD	FLAT:?Clone@TiXmlComment@@UBEPAVTiXmlNode@@XZ
	DD	FLAT:?Accept@TiXmlComment@@UBE_NPAVTiXmlVisitor@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0TiXmlComment@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0TiXmlComment@@QAE@XZ$0
__ehfuncinfo$??0TiXmlComment@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0TiXmlComment@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0TiXmlComment@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0TiXmlComment@@QAE@XZ PROC				; TiXmlComment::TiXmlComment, COMDAT
; _this$ = ecx

; 1158 : 	TiXmlComment() : TiXmlNode( TiXmlNode::COMMENT ) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0TiXmlComment@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0TiXmlNode@@IAE@W4NodeType@0@@Z	; TiXmlNode::TiXmlNode
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TiXmlComment@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0TiXmlComment@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1TiXmlNode@@UAE@XZ			; TiXmlNode::~TiXmlNode
__ehhandler$??0TiXmlComment@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0TiXmlComment@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0TiXmlComment@@QAE@XZ ENDP				; TiXmlComment::TiXmlComment
; Function compile flags: /Odtp
;	COMDAT ?ToDocument@TiXmlNode@@UBEPBVTiXmlDocument@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToDocument@TiXmlNode@@UBEPBVTiXmlDocument@@XZ PROC	; TiXmlNode::ToDocument, COMDAT
; _this$ = ecx

; 698  : 	virtual const TiXmlDocument*    ToDocument()    const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ToDocument@TiXmlNode@@UBEPBVTiXmlDocument@@XZ ENDP	; TiXmlNode::ToDocument
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToElement@TiXmlNode@@UBEPBVTiXmlElement@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToElement@TiXmlNode@@UBEPBVTiXmlElement@@XZ PROC	; TiXmlNode::ToElement, COMDAT
; _this$ = ecx

; 699  : 	virtual const TiXmlElement*     ToElement()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ToElement@TiXmlNode@@UBEPBVTiXmlElement@@XZ ENDP	; TiXmlNode::ToElement
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToUnknown@TiXmlNode@@UBEPBVTiXmlUnknown@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToUnknown@TiXmlNode@@UBEPBVTiXmlUnknown@@XZ PROC	; TiXmlNode::ToUnknown, COMDAT
; _this$ = ecx

; 701  : 	virtual const TiXmlUnknown*     ToUnknown()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ToUnknown@TiXmlNode@@UBEPBVTiXmlUnknown@@XZ ENDP	; TiXmlNode::ToUnknown
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToText@TiXmlNode@@UBEPBVTiXmlText@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToText@TiXmlNode@@UBEPBVTiXmlText@@XZ PROC		; TiXmlNode::ToText, COMDAT
; _this$ = ecx

; 702  : 	virtual const TiXmlText*        ToText()        const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ToText@TiXmlNode@@UBEPBVTiXmlText@@XZ ENDP		; TiXmlNode::ToText
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToDeclaration@TiXmlNode@@UBEPBVTiXmlDeclaration@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToDeclaration@TiXmlNode@@UBEPBVTiXmlDeclaration@@XZ PROC ; TiXmlNode::ToDeclaration, COMDAT
; _this$ = ecx

; 703  : 	virtual const TiXmlDeclaration* ToDeclaration() const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ToDeclaration@TiXmlNode@@UBEPBVTiXmlDeclaration@@XZ ENDP ; TiXmlNode::ToDeclaration
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToDocument@TiXmlNode@@UAEPAVTiXmlDocument@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToDocument@TiXmlNode@@UAEPAVTiXmlDocument@@XZ PROC	; TiXmlNode::ToDocument, COMDAT
; _this$ = ecx

; 705  : 	virtual TiXmlDocument*          ToDocument()    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ToDocument@TiXmlNode@@UAEPAVTiXmlDocument@@XZ ENDP	; TiXmlNode::ToDocument
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToElement@TiXmlNode@@UAEPAVTiXmlElement@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToElement@TiXmlNode@@UAEPAVTiXmlElement@@XZ PROC	; TiXmlNode::ToElement, COMDAT
; _this$ = ecx

; 706  : 	virtual TiXmlElement*           ToElement()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ToElement@TiXmlNode@@UAEPAVTiXmlElement@@XZ ENDP	; TiXmlNode::ToElement
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToUnknown@TiXmlNode@@UAEPAVTiXmlUnknown@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToUnknown@TiXmlNode@@UAEPAVTiXmlUnknown@@XZ PROC	; TiXmlNode::ToUnknown, COMDAT
; _this$ = ecx

; 708  : 	virtual TiXmlUnknown*           ToUnknown()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ToUnknown@TiXmlNode@@UAEPAVTiXmlUnknown@@XZ ENDP	; TiXmlNode::ToUnknown
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToText@TiXmlNode@@UAEPAVTiXmlText@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToText@TiXmlNode@@UAEPAVTiXmlText@@XZ PROC		; TiXmlNode::ToText, COMDAT
; _this$ = ecx

; 709  : 	virtual TiXmlText*	            ToText()        { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ToText@TiXmlNode@@UAEPAVTiXmlText@@XZ ENDP		; TiXmlNode::ToText
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToDeclaration@TiXmlNode@@UAEPAVTiXmlDeclaration@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToDeclaration@TiXmlNode@@UAEPAVTiXmlDeclaration@@XZ PROC ; TiXmlNode::ToDeclaration, COMDAT
; _this$ = ecx

; 710  : 	virtual TiXmlDeclaration*       ToDeclaration() { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ToDeclaration@TiXmlNode@@UAEPAVTiXmlDeclaration@@XZ ENDP ; TiXmlNode::ToDeclaration
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToComment@TiXmlComment@@UBEPBV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToComment@TiXmlComment@@UBEPBV1@XZ PROC		; TiXmlComment::ToComment, COMDAT
; _this$ = ecx

; 1178 : 	virtual const TiXmlComment*  ToComment() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?ToComment@TiXmlComment@@UBEPBV1@XZ ENDP		; TiXmlComment::ToComment
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToComment@TiXmlComment@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToComment@TiXmlComment@@UAEPAV1@XZ PROC		; TiXmlComment::ToComment, COMDAT
; _this$ = ecx

; 1179 : 	virtual TiXmlComment*  ToComment() { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?ToComment@TiXmlComment@@UAEPAV1@XZ ENDP		; TiXmlComment::ToComment
_TEXT	ENDS
PUBLIC	??1TiXmlComment@@UAE@XZ				; TiXmlComment::~TiXmlComment
; Function compile flags: /Odtp
;	COMDAT ??_GTiXmlComment@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTiXmlComment@@UAEPAXI@Z PROC			; TiXmlComment::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TiXmlComment@@UAE@XZ			; TiXmlComment::~TiXmlComment
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTiXmlComment@@UAEPAXI@Z ENDP			; TiXmlComment::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1TiXmlComment@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1TiXmlComment@@UAE@XZ$0
__ehfuncinfo$??1TiXmlComment@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1TiXmlComment@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1TiXmlComment@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TiXmlComment@@UAE@XZ PROC				; TiXmlComment::~TiXmlComment, COMDAT
; _this$ = ecx

; 1166 : 	virtual ~TiXmlComment()	{}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1TiXmlComment@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TiXmlComment@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TiXmlNode@@UAE@XZ			; TiXmlNode::~TiXmlNode
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1TiXmlComment@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1TiXmlNode@@UAE@XZ			; TiXmlNode::~TiXmlNode
__ehhandler$??1TiXmlComment@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1TiXmlComment@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1TiXmlComment@@UAE@XZ ENDP				; TiXmlComment::~TiXmlComment
PUBLIC	?SetValue@TiXmlNode@@QAEXPBD@Z			; TiXmlNode::SetValue
PUBLIC	??_7TiXmlText@@6B@				; TiXmlText::`vftable'
PUBLIC	??_R4TiXmlText@@6B@				; TiXmlText::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTiXmlText@@@8				; TiXmlText `RTTI Type Descriptor'
PUBLIC	??_R3TiXmlText@@8				; TiXmlText::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TiXmlText@@8				; TiXmlText::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TiXmlText@@8			; TiXmlText::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Parse@TiXmlText@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlText::Parse
PUBLIC	?ToComment@TiXmlNode@@UAEPAVTiXmlComment@@XZ	; TiXmlNode::ToComment
PUBLIC	?ToComment@TiXmlNode@@UBEPBVTiXmlComment@@XZ	; TiXmlNode::ToComment
PUBLIC	?ToText@TiXmlText@@UAEPAV1@XZ			; TiXmlText::ToText
PUBLIC	?ToText@TiXmlText@@UBEPBV1@XZ			; TiXmlText::ToText
EXTRN	??_ETiXmlText@@UAEPAXI@Z:PROC			; TiXmlText::`vector deleting destructor'
EXTRN	?Print@TiXmlText@@UBEXPAU_iobuf@@H@Z:PROC	; TiXmlText::Print
EXTRN	?Clone@TiXmlText@@MBEPAVTiXmlNode@@XZ:PROC	; TiXmlText::Clone
EXTRN	?Accept@TiXmlText@@UBE_NPAVTiXmlVisitor@@@Z:PROC ; TiXmlText::Accept
;	COMDAT ??_R1A@?0A@EA@TiXmlText@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TiXmlText@@8 DD FLAT:??_R0?AVTiXmlText@@@8 ; TiXmlText::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TiXmlText@@8
rdata$r	ENDS
;	COMDAT ??_R2TiXmlText@@8
rdata$r	SEGMENT
??_R2TiXmlText@@8 DD FLAT:??_R1A@?0A@EA@TiXmlText@@8	; TiXmlText::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@TiXmlNode@@8
	DD	FLAT:??_R1A@?0A@EA@TiXmlBase@@8
rdata$r	ENDS
;	COMDAT ??_R3TiXmlText@@8
rdata$r	SEGMENT
??_R3TiXmlText@@8 DD 00H				; TiXmlText::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2TiXmlText@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTiXmlText@@@8
_DATA	SEGMENT
??_R0?AVTiXmlText@@@8 DD FLAT:??_7type_info@@6B@	; TiXmlText `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTiXmlText@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TiXmlText@@6B@
rdata$r	SEGMENT
??_R4TiXmlText@@6B@ DD 00H				; TiXmlText::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTiXmlText@@@8
	DD	FLAT:??_R3TiXmlText@@8
rdata$r	ENDS
;	COMDAT ??_7TiXmlText@@6B@
CONST	SEGMENT
??_7TiXmlText@@6B@ DD FLAT:??_R4TiXmlText@@6B@		; TiXmlText::`vftable'
	DD	FLAT:??_ETiXmlText@@UAEPAXI@Z
	DD	FLAT:?Print@TiXmlText@@UBEXPAU_iobuf@@H@Z
	DD	FLAT:?Parse@TiXmlText@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	DD	FLAT:?ToDocument@TiXmlNode@@UAEPAVTiXmlDocument@@XZ
	DD	FLAT:?ToDocument@TiXmlNode@@UBEPBVTiXmlDocument@@XZ
	DD	FLAT:?ToElement@TiXmlNode@@UAEPAVTiXmlElement@@XZ
	DD	FLAT:?ToElement@TiXmlNode@@UBEPBVTiXmlElement@@XZ
	DD	FLAT:?ToComment@TiXmlNode@@UAEPAVTiXmlComment@@XZ
	DD	FLAT:?ToComment@TiXmlNode@@UBEPBVTiXmlComment@@XZ
	DD	FLAT:?ToUnknown@TiXmlNode@@UAEPAVTiXmlUnknown@@XZ
	DD	FLAT:?ToUnknown@TiXmlNode@@UBEPBVTiXmlUnknown@@XZ
	DD	FLAT:?ToText@TiXmlText@@UAEPAV1@XZ
	DD	FLAT:?ToText@TiXmlText@@UBEPBV1@XZ
	DD	FLAT:?ToDeclaration@TiXmlNode@@UAEPAVTiXmlDeclaration@@XZ
	DD	FLAT:?ToDeclaration@TiXmlNode@@UBEPBVTiXmlDeclaration@@XZ
	DD	FLAT:?Clone@TiXmlText@@MBEPAVTiXmlNode@@XZ
	DD	FLAT:?Accept@TiXmlText@@UBE_NPAVTiXmlVisitor@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0TiXmlText@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0TiXmlText@@QAE@PBD@Z$0
__ehfuncinfo$??0TiXmlText@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0TiXmlText@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0TiXmlText@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_initValue$ = 8						; size = 4
??0TiXmlText@@QAE@PBD@Z PROC				; TiXmlText::TiXmlText, COMDAT
; _this$ = ecx

; 1213 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0TiXmlText@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0TiXmlNode@@IAE@W4NodeType@0@@Z	; TiXmlNode::TiXmlNode
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TiXmlText@@6B@

; 1214 : 		SetValue( initValue );

	mov	ecx, DWORD PTR _initValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetValue@TiXmlNode@@QAEXPBD@Z		; TiXmlNode::SetValue

; 1215 : 		cdata = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+44], 0

; 1216 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0TiXmlText@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1TiXmlNode@@UAE@XZ			; TiXmlNode::~TiXmlNode
__ehhandler$??0TiXmlText@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0TiXmlText@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0TiXmlText@@QAE@PBD@Z ENDP				; TiXmlText::TiXmlText
; Function compile flags: /Odtp
;	COMDAT ?SetValue@TiXmlNode@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__value$ = 8						; size = 4
?SetValue@TiXmlNode@@QAEXPBD@Z PROC			; TiXmlNode::SetValue, COMDAT
; _this$ = ecx

; 509  : 	void SetValue(const char * _value) { value = _value;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=
	mov	esp, ebp
	pop	ebp
	ret	4
?SetValue@TiXmlNode@@QAEXPBD@Z ENDP			; TiXmlNode::SetValue
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToComment@TiXmlNode@@UBEPBVTiXmlComment@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToComment@TiXmlNode@@UBEPBVTiXmlComment@@XZ PROC	; TiXmlNode::ToComment, COMDAT
; _this$ = ecx

; 700  : 	virtual const TiXmlComment*     ToComment()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ToComment@TiXmlNode@@UBEPBVTiXmlComment@@XZ ENDP	; TiXmlNode::ToComment
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToComment@TiXmlNode@@UAEPAVTiXmlComment@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToComment@TiXmlNode@@UAEPAVTiXmlComment@@XZ PROC	; TiXmlNode::ToComment, COMDAT
; _this$ = ecx

; 707  : 	virtual TiXmlComment*           ToComment()     { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?ToComment@TiXmlNode@@UAEPAVTiXmlComment@@XZ ENDP	; TiXmlNode::ToComment
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetCDATA@TiXmlText@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__cdata$ = 8						; size = 1
?SetCDATA@TiXmlText@@QAEX_N@Z PROC			; TiXmlText::SetCDATA, COMDAT
; _this$ = ecx

; 1237 : 	void SetCDATA( bool _cdata )	{ cdata = _cdata; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR __cdata$[ebp]
	mov	BYTE PTR [eax+44], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?SetCDATA@TiXmlText@@QAEX_N@Z ENDP			; TiXmlText::SetCDATA
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToText@TiXmlText@@UBEPBV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToText@TiXmlText@@UBEPBV1@XZ PROC			; TiXmlText::ToText, COMDAT
; _this$ = ecx

; 1241 : 	virtual const TiXmlText* ToText() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?ToText@TiXmlText@@UBEPBV1@XZ ENDP			; TiXmlText::ToText
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToText@TiXmlText@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToText@TiXmlText@@UAEPAV1@XZ PROC			; TiXmlText::ToText, COMDAT
; _this$ = ecx

; 1242 : 	virtual TiXmlText*       ToText()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?ToText@TiXmlText@@UAEPAV1@XZ ENDP			; TiXmlText::ToText
_TEXT	ENDS
PUBLIC	??1TiXmlText@@UAE@XZ				; TiXmlText::~TiXmlText
; Function compile flags: /Odtp
;	COMDAT ??_GTiXmlText@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTiXmlText@@UAEPAXI@Z PROC				; TiXmlText::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TiXmlText@@UAE@XZ			; TiXmlText::~TiXmlText
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTiXmlText@@UAEPAXI@Z ENDP				; TiXmlText::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1TiXmlText@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1TiXmlText@@UAE@XZ$0
__ehfuncinfo$??1TiXmlText@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1TiXmlText@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1TiXmlText@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TiXmlText@@UAE@XZ PROC				; TiXmlText::~TiXmlText, COMDAT
; _this$ = ecx

; 1217 : 	virtual ~TiXmlText() {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1TiXmlText@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TiXmlText@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TiXmlNode@@UAE@XZ			; TiXmlNode::~TiXmlNode
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1TiXmlText@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1TiXmlNode@@UAE@XZ			; TiXmlNode::~TiXmlNode
__ehhandler$??1TiXmlText@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1TiXmlText@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1TiXmlText@@UAE@XZ ENDP				; TiXmlText::~TiXmlText
PUBLIC	??_7TiXmlDeclaration@@6B@			; TiXmlDeclaration::`vftable'
PUBLIC	??_R4TiXmlDeclaration@@6B@			; TiXmlDeclaration::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTiXmlDeclaration@@@8			; TiXmlDeclaration `RTTI Type Descriptor'
PUBLIC	??_R3TiXmlDeclaration@@8			; TiXmlDeclaration::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TiXmlDeclaration@@8			; TiXmlDeclaration::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TiXmlDeclaration@@8		; TiXmlDeclaration::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Print@TiXmlDeclaration@@UBEXPAU_iobuf@@H@Z	; TiXmlDeclaration::Print
PUBLIC	?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDeclaration::Parse
PUBLIC	?ToDeclaration@TiXmlDeclaration@@UAEPAV1@XZ	; TiXmlDeclaration::ToDeclaration
PUBLIC	?ToDeclaration@TiXmlDeclaration@@UBEPBV1@XZ	; TiXmlDeclaration::ToDeclaration
EXTRN	??_ETiXmlDeclaration@@UAEPAXI@Z:PROC		; TiXmlDeclaration::`vector deleting destructor'
EXTRN	?Clone@TiXmlDeclaration@@UBEPAVTiXmlNode@@XZ:PROC ; TiXmlDeclaration::Clone
EXTRN	?Accept@TiXmlDeclaration@@UBE_NPAVTiXmlVisitor@@@Z:PROC ; TiXmlDeclaration::Accept
EXTRN	?Print@TiXmlDeclaration@@UBEXPAU_iobuf@@HPAVTiXmlString@@@Z:PROC ; TiXmlDeclaration::Print
;	COMDAT ??_R1A@?0A@EA@TiXmlDeclaration@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TiXmlDeclaration@@8 DD FLAT:??_R0?AVTiXmlDeclaration@@@8 ; TiXmlDeclaration::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TiXmlDeclaration@@8
rdata$r	ENDS
;	COMDAT ??_R2TiXmlDeclaration@@8
rdata$r	SEGMENT
??_R2TiXmlDeclaration@@8 DD FLAT:??_R1A@?0A@EA@TiXmlDeclaration@@8 ; TiXmlDeclaration::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@TiXmlNode@@8
	DD	FLAT:??_R1A@?0A@EA@TiXmlBase@@8
rdata$r	ENDS
;	COMDAT ??_R3TiXmlDeclaration@@8
rdata$r	SEGMENT
??_R3TiXmlDeclaration@@8 DD 00H				; TiXmlDeclaration::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2TiXmlDeclaration@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTiXmlDeclaration@@@8
_DATA	SEGMENT
??_R0?AVTiXmlDeclaration@@@8 DD FLAT:??_7type_info@@6B@	; TiXmlDeclaration `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTiXmlDeclaration@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TiXmlDeclaration@@6B@
rdata$r	SEGMENT
??_R4TiXmlDeclaration@@6B@ DD 00H			; TiXmlDeclaration::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTiXmlDeclaration@@@8
	DD	FLAT:??_R3TiXmlDeclaration@@8
rdata$r	ENDS
;	COMDAT ??_7TiXmlDeclaration@@6B@
CONST	SEGMENT
??_7TiXmlDeclaration@@6B@ DD FLAT:??_R4TiXmlDeclaration@@6B@ ; TiXmlDeclaration::`vftable'
	DD	FLAT:??_ETiXmlDeclaration@@UAEPAXI@Z
	DD	FLAT:?Print@TiXmlDeclaration@@UBEXPAU_iobuf@@H@Z
	DD	FLAT:?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	DD	FLAT:?ToDocument@TiXmlNode@@UAEPAVTiXmlDocument@@XZ
	DD	FLAT:?ToDocument@TiXmlNode@@UBEPBVTiXmlDocument@@XZ
	DD	FLAT:?ToElement@TiXmlNode@@UAEPAVTiXmlElement@@XZ
	DD	FLAT:?ToElement@TiXmlNode@@UBEPBVTiXmlElement@@XZ
	DD	FLAT:?ToComment@TiXmlNode@@UAEPAVTiXmlComment@@XZ
	DD	FLAT:?ToComment@TiXmlNode@@UBEPBVTiXmlComment@@XZ
	DD	FLAT:?ToUnknown@TiXmlNode@@UAEPAVTiXmlUnknown@@XZ
	DD	FLAT:?ToUnknown@TiXmlNode@@UBEPBVTiXmlUnknown@@XZ
	DD	FLAT:?ToText@TiXmlNode@@UAEPAVTiXmlText@@XZ
	DD	FLAT:?ToText@TiXmlNode@@UBEPBVTiXmlText@@XZ
	DD	FLAT:?ToDeclaration@TiXmlDeclaration@@UAEPAV1@XZ
	DD	FLAT:?ToDeclaration@TiXmlDeclaration@@UBEPBV1@XZ
	DD	FLAT:?Clone@TiXmlDeclaration@@UBEPAVTiXmlNode@@XZ
	DD	FLAT:?Accept@TiXmlDeclaration@@UBE_NPAVTiXmlVisitor@@@Z
	DD	FLAT:?Print@TiXmlDeclaration@@UBEXPAU_iobuf@@HPAVTiXmlString@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0TiXmlDeclaration@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0TiXmlDeclaration@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0TiXmlDeclaration@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0TiXmlDeclaration@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0TiXmlDeclaration@@QAE@XZ$3
__ehfuncinfo$??0TiXmlDeclaration@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0TiXmlDeclaration@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0TiXmlDeclaration@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0TiXmlDeclaration@@QAE@XZ PROC			; TiXmlDeclaration::TiXmlDeclaration, COMDAT
; _this$ = ecx

; 1281 : 	TiXmlDeclaration()   : TiXmlNode( TiXmlNode::DECLARATION ) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0TiXmlDeclaration@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0TiXmlNode@@IAE@W4NodeType@0@@Z	; TiXmlNode::TiXmlNode
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TiXmlDeclaration@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0TiXmlString@@QAE@XZ			; TiXmlString::TiXmlString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0TiXmlString@@QAE@XZ			; TiXmlString::TiXmlString
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	??0TiXmlString@@QAE@XZ			; TiXmlString::TiXmlString
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0TiXmlDeclaration@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1TiXmlNode@@UAE@XZ			; TiXmlNode::~TiXmlNode
__unwindfunclet$??0TiXmlDeclaration@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
__unwindfunclet$??0TiXmlDeclaration@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	jmp	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
__unwindfunclet$??0TiXmlDeclaration@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	jmp	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
__ehhandler$??0TiXmlDeclaration@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0TiXmlDeclaration@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0TiXmlDeclaration@@QAE@XZ ENDP			; TiXmlDeclaration::TiXmlDeclaration
; Function compile flags: /Odtp
;	COMDAT ?Print@TiXmlDeclaration@@UBEXPAU_iobuf@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cfile$ = 8						; size = 4
_depth$ = 12						; size = 4
?Print@TiXmlDeclaration@@UBEXPAU_iobuf@@H@Z PROC	; TiXmlDeclaration::Print, COMDAT
; _this$ = ecx

; 1311 : 	virtual void Print( FILE* cfile, int depth ) const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1312 : 		Print( cfile, depth, 0 );

	push	0
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cfile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+68]
	call	edx

; 1313 : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Print@TiXmlDeclaration@@UBEXPAU_iobuf@@H@Z ENDP	; TiXmlDeclaration::Print
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToDeclaration@TiXmlDeclaration@@UBEPBV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToDeclaration@TiXmlDeclaration@@UBEPBV1@XZ PROC	; TiXmlDeclaration::ToDeclaration, COMDAT
; _this$ = ecx

; 1317 : 	virtual const TiXmlDeclaration* ToDeclaration() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?ToDeclaration@TiXmlDeclaration@@UBEPBV1@XZ ENDP	; TiXmlDeclaration::ToDeclaration
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToDeclaration@TiXmlDeclaration@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToDeclaration@TiXmlDeclaration@@UAEPAV1@XZ PROC	; TiXmlDeclaration::ToDeclaration, COMDAT
; _this$ = ecx

; 1318 : 	virtual TiXmlDeclaration*       ToDeclaration()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?ToDeclaration@TiXmlDeclaration@@UAEPAV1@XZ ENDP	; TiXmlDeclaration::ToDeclaration
_TEXT	ENDS
PUBLIC	??1TiXmlDeclaration@@UAE@XZ			; TiXmlDeclaration::~TiXmlDeclaration
; Function compile flags: /Odtp
;	COMDAT ??_GTiXmlDeclaration@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTiXmlDeclaration@@UAEPAXI@Z PROC			; TiXmlDeclaration::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TiXmlDeclaration@@UAE@XZ		; TiXmlDeclaration::~TiXmlDeclaration
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTiXmlDeclaration@@UAEPAXI@Z ENDP			; TiXmlDeclaration::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1TiXmlDeclaration@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1TiXmlDeclaration@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1TiXmlDeclaration@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1TiXmlDeclaration@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1TiXmlDeclaration@@UAE@XZ$3
__ehfuncinfo$??1TiXmlDeclaration@@UAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1TiXmlDeclaration@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1TiXmlDeclaration@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TiXmlDeclaration@@UAE@XZ PROC			; TiXmlDeclaration::~TiXmlDeclaration, COMDAT
; _this$ = ecx

; 1298 : 	virtual ~TiXmlDeclaration()	{}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1TiXmlDeclaration@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TiXmlDeclaration@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TiXmlNode@@UAE@XZ			; TiXmlNode::~TiXmlNode
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1TiXmlDeclaration@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1TiXmlNode@@UAE@XZ			; TiXmlNode::~TiXmlNode
__unwindfunclet$??1TiXmlDeclaration@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
__unwindfunclet$??1TiXmlDeclaration@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	jmp	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
__unwindfunclet$??1TiXmlDeclaration@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	jmp	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
__ehhandler$??1TiXmlDeclaration@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1TiXmlDeclaration@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1TiXmlDeclaration@@UAE@XZ ENDP			; TiXmlDeclaration::~TiXmlDeclaration
PUBLIC	??_7TiXmlUnknown@@6B@				; TiXmlUnknown::`vftable'
PUBLIC	??_R4TiXmlUnknown@@6B@				; TiXmlUnknown::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTiXmlUnknown@@@8			; TiXmlUnknown `RTTI Type Descriptor'
PUBLIC	??_R3TiXmlUnknown@@8				; TiXmlUnknown::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TiXmlUnknown@@8				; TiXmlUnknown::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TiXmlUnknown@@8			; TiXmlUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Parse@TiXmlUnknown@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlUnknown::Parse
PUBLIC	?ToUnknown@TiXmlUnknown@@UAEPAV1@XZ		; TiXmlUnknown::ToUnknown
PUBLIC	?ToUnknown@TiXmlUnknown@@UBEPBV1@XZ		; TiXmlUnknown::ToUnknown
EXTRN	??_ETiXmlUnknown@@UAEPAXI@Z:PROC		; TiXmlUnknown::`vector deleting destructor'
EXTRN	?Print@TiXmlUnknown@@UBEXPAU_iobuf@@H@Z:PROC	; TiXmlUnknown::Print
EXTRN	?Clone@TiXmlUnknown@@UBEPAVTiXmlNode@@XZ:PROC	; TiXmlUnknown::Clone
EXTRN	?Accept@TiXmlUnknown@@UBE_NPAVTiXmlVisitor@@@Z:PROC ; TiXmlUnknown::Accept
;	COMDAT ??_R1A@?0A@EA@TiXmlUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TiXmlUnknown@@8 DD FLAT:??_R0?AVTiXmlUnknown@@@8 ; TiXmlUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TiXmlUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R2TiXmlUnknown@@8
rdata$r	SEGMENT
??_R2TiXmlUnknown@@8 DD FLAT:??_R1A@?0A@EA@TiXmlUnknown@@8 ; TiXmlUnknown::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@TiXmlNode@@8
	DD	FLAT:??_R1A@?0A@EA@TiXmlBase@@8
rdata$r	ENDS
;	COMDAT ??_R3TiXmlUnknown@@8
rdata$r	SEGMENT
??_R3TiXmlUnknown@@8 DD 00H				; TiXmlUnknown::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2TiXmlUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTiXmlUnknown@@@8
_DATA	SEGMENT
??_R0?AVTiXmlUnknown@@@8 DD FLAT:??_7type_info@@6B@	; TiXmlUnknown `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTiXmlUnknown@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TiXmlUnknown@@6B@
rdata$r	SEGMENT
??_R4TiXmlUnknown@@6B@ DD 00H				; TiXmlUnknown::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTiXmlUnknown@@@8
	DD	FLAT:??_R3TiXmlUnknown@@8
rdata$r	ENDS
;	COMDAT ??_7TiXmlUnknown@@6B@
CONST	SEGMENT
??_7TiXmlUnknown@@6B@ DD FLAT:??_R4TiXmlUnknown@@6B@	; TiXmlUnknown::`vftable'
	DD	FLAT:??_ETiXmlUnknown@@UAEPAXI@Z
	DD	FLAT:?Print@TiXmlUnknown@@UBEXPAU_iobuf@@H@Z
	DD	FLAT:?Parse@TiXmlUnknown@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	DD	FLAT:?ToDocument@TiXmlNode@@UAEPAVTiXmlDocument@@XZ
	DD	FLAT:?ToDocument@TiXmlNode@@UBEPBVTiXmlDocument@@XZ
	DD	FLAT:?ToElement@TiXmlNode@@UAEPAVTiXmlElement@@XZ
	DD	FLAT:?ToElement@TiXmlNode@@UBEPBVTiXmlElement@@XZ
	DD	FLAT:?ToComment@TiXmlNode@@UAEPAVTiXmlComment@@XZ
	DD	FLAT:?ToComment@TiXmlNode@@UBEPBVTiXmlComment@@XZ
	DD	FLAT:?ToUnknown@TiXmlUnknown@@UAEPAV1@XZ
	DD	FLAT:?ToUnknown@TiXmlUnknown@@UBEPBV1@XZ
	DD	FLAT:?ToText@TiXmlNode@@UAEPAVTiXmlText@@XZ
	DD	FLAT:?ToText@TiXmlNode@@UBEPBVTiXmlText@@XZ
	DD	FLAT:?ToDeclaration@TiXmlNode@@UAEPAVTiXmlDeclaration@@XZ
	DD	FLAT:?ToDeclaration@TiXmlNode@@UBEPBVTiXmlDeclaration@@XZ
	DD	FLAT:?Clone@TiXmlUnknown@@UBEPAVTiXmlNode@@XZ
	DD	FLAT:?Accept@TiXmlUnknown@@UBE_NPAVTiXmlVisitor@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0TiXmlUnknown@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0TiXmlUnknown@@QAE@XZ$0
__ehfuncinfo$??0TiXmlUnknown@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0TiXmlUnknown@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0TiXmlUnknown@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0TiXmlUnknown@@QAE@XZ PROC				; TiXmlUnknown::TiXmlUnknown, COMDAT
; _this$ = ecx

; 1349 : 	TiXmlUnknown() : TiXmlNode( TiXmlNode::UNKNOWN )	{}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0TiXmlUnknown@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0TiXmlNode@@IAE@W4NodeType@0@@Z	; TiXmlNode::TiXmlNode
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TiXmlUnknown@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0TiXmlUnknown@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1TiXmlNode@@UAE@XZ			; TiXmlNode::~TiXmlNode
__ehhandler$??0TiXmlUnknown@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0TiXmlUnknown@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0TiXmlUnknown@@QAE@XZ ENDP				; TiXmlUnknown::TiXmlUnknown
; Function compile flags: /Odtp
;	COMDAT ?ToUnknown@TiXmlUnknown@@UBEPBV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToUnknown@TiXmlUnknown@@UBEPBV1@XZ PROC		; TiXmlUnknown::ToUnknown, COMDAT
; _this$ = ecx

; 1362 : 	virtual const TiXmlUnknown*     ToUnknown()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?ToUnknown@TiXmlUnknown@@UBEPBV1@XZ ENDP		; TiXmlUnknown::ToUnknown
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ToUnknown@TiXmlUnknown@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToUnknown@TiXmlUnknown@@UAEPAV1@XZ PROC		; TiXmlUnknown::ToUnknown, COMDAT
; _this$ = ecx

; 1363 : 	virtual TiXmlUnknown*           ToUnknown()	    { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?ToUnknown@TiXmlUnknown@@UAEPAV1@XZ ENDP		; TiXmlUnknown::ToUnknown
_TEXT	ENDS
PUBLIC	??1TiXmlUnknown@@UAE@XZ				; TiXmlUnknown::~TiXmlUnknown
; Function compile flags: /Odtp
;	COMDAT ??_GTiXmlUnknown@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTiXmlUnknown@@UAEPAXI@Z PROC			; TiXmlUnknown::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TiXmlUnknown@@UAE@XZ			; TiXmlUnknown::~TiXmlUnknown
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTiXmlUnknown@@UAEPAXI@Z ENDP			; TiXmlUnknown::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1TiXmlUnknown@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1TiXmlUnknown@@UAE@XZ$0
__ehfuncinfo$??1TiXmlUnknown@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1TiXmlUnknown@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1TiXmlUnknown@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TiXmlUnknown@@UAE@XZ PROC				; TiXmlUnknown::~TiXmlUnknown, COMDAT
; _this$ = ecx

; 1350 : 	virtual ~TiXmlUnknown() {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1TiXmlUnknown@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TiXmlUnknown@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TiXmlNode@@UAE@XZ			; TiXmlNode::~TiXmlNode
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1TiXmlUnknown@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1TiXmlNode@@UAE@XZ			; TiXmlNode::~TiXmlNode
__ehhandler$??1TiXmlUnknown@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1TiXmlUnknown@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1TiXmlUnknown@@UAE@XZ ENDP				; TiXmlUnknown::~TiXmlUnknown
PUBLIC	?SetValue@TiXmlAttribute@@QAEXPBD@Z		; TiXmlAttribute::SetValue
PUBLIC	?Value@TiXmlAttribute@@QBEPBDXZ			; TiXmlAttribute::Value
PUBLIC	?Find@TiXmlAttributeSet@@QAEPAVTiXmlAttribute@@PBD@Z ; TiXmlAttributeSet::Find
PUBLIC	?Name@TiXmlAttribute@@QBEPBDXZ			; TiXmlAttribute::Name
PUBLIC	?SetDocument@TiXmlAttribute@@QAEXPAVTiXmlDocument@@@Z ; TiXmlAttribute::SetDocument
PUBLIC	??0TiXmlAttribute@@QAE@XZ			; TiXmlAttribute::TiXmlAttribute
PUBLIC	?length@TiXmlString@@QBEIXZ			; TiXmlString::length
PUBLIC	?ReadValue@TiXmlElement@@IAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlElement::ReadValue
PUBLIC	??YTiXmlString@@QAEAAV0@PBD@Z			; TiXmlString::operator+=
PUBLIC	??YTiXmlString@@QAEAAV0@ABV0@@Z			; TiXmlString::operator+=
PUBLIC	??0TiXmlString@@QAE@PBD@Z			; TiXmlString::TiXmlString
PUBLIC	?Parse@TiXmlElement@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlElement::Parse
EXTRN	?Add@TiXmlAttributeSet@@QAEXPAVTiXmlAttribute@@@Z:PROC ; TiXmlAttributeSet::Add
xdata$x	SEGMENT
__unwindtable$?Parse@TiXmlElement@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Parse@TiXmlElement@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Parse@TiXmlElement@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z$1
__ehfuncinfo$?Parse@TiXmlElement@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Parse@TiXmlElement@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxmlparser.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv299 = -112						; size = 4
tv277 = -108						; size = 4
tv238 = -104						; size = 4
_this$ = -100						; size = 4
$T8122 = -96						; size = 4
$T8121 = -92						; size = 4
$T8118 = -88						; size = 4
$T8117 = -84						; size = 4
$T8116 = -80						; size = 4
$T8113 = -76						; size = 4
$T8112 = -72						; size = 4
$T8111 = -68						; size = 4
$T8108 = -64						; size = 4
$T8107 = -60						; size = 4
$T8106 = -56						; size = 4
$T8105 = -52						; size = 4
$T8104 = -48						; size = 4
$T8103 = -44						; size = 4
$T8102 = -40						; size = 4
$T8101 = -36						; size = 4
_node$7432 = -32					; size = 4
_attrib$7418 = -28					; size = 4
_endTag$ = -24						; size = 4
_document$ = -20					; size = 4
_pErr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_p$ = 8							; size = 4
_data$ = 12						; size = 4
_encoding$ = 16						; size = 4
?Parse@TiXmlElement@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z PROC ; TiXmlElement::Parse
; _this$ = ecx

; 1050 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Parse@TiXmlElement@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1051 : 	p = SkipWhiteSpace( p, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 1052 : 	TiXmlDocument* document = GetDocument();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDocument@TiXmlNode@@QAEPAVTiXmlDocument@@XZ ; TiXmlNode::GetDocument
	mov	DWORD PTR _document$[ebp], eax

; 1053 : 
; 1054 : 	if ( !p || !*p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN31@Parse@2
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN32@Parse@2
$LN31@Parse@2:

; 1055 : 	{
; 1056 : 		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, 0, 0, encoding );

	cmp	DWORD PTR _document$[ebp], 0
	je	SHORT $LN30@Parse@2
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	push	0
	push	0
	push	4
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN30@Parse@2:

; 1057 : 		return 0;

	xor	eax, eax
	jmp	$LN33@Parse@2
$LN32@Parse@2:

; 1058 : 	}
; 1059 : 
; 1060 : 	if ( data )

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN29@Parse@2

; 1061 : 	{
; 1062 : 		data->Stamp( p, encoding );

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	call	?Stamp@TiXmlParsingData@@QAEXPBDW4TiXmlEncoding@@@Z ; TiXmlParsingData::Stamp

; 1063 : 		location = data->Cursor();

	mov	ecx, DWORD PTR _data$[ebp]
	call	?Cursor@TiXmlParsingData@@QAEABUTiXmlCursor@@XZ ; TiXmlParsingData::Cursor
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
$LN29@Parse@2:

; 1064 : 	}
; 1065 : 
; 1066 : 	if ( *p != '<' )

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 60					; 0000003cH
	je	SHORT $LN28@Parse@2

; 1067 : 	{
; 1068 : 		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, p, data, encoding );

	cmp	DWORD PTR _document$[ebp], 0
	je	SHORT $LN27@Parse@2
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	push	4
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN27@Parse@2:

; 1069 : 		return 0;

	xor	eax, eax
	jmp	$LN33@Parse@2
$LN28@Parse@2:

; 1070 : 	}
; 1071 : 
; 1072 : 	p = SkipWhiteSpace( p+1, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	push	ecx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 1073 : 
; 1074 : 	// Read the name.
; 1075 : 	const char* pErr = p;

	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _pErr$[ebp], edx

; 1076 : 
; 1077 :     p = ReadName( p, &value, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?ReadName@TiXmlBase@@KAPBDPBDPAVTiXmlString@@W4TiXmlEncoding@@@Z ; TiXmlBase::ReadName
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _p$[ebp], eax

; 1078 : 	if ( !p || !*p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN25@Parse@2
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN26@Parse@2
$LN25@Parse@2:

; 1079 : 	{
; 1080 : 		if ( document )	document->SetError( TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data, encoding );

	cmp	DWORD PTR _document$[ebp], 0
	je	SHORT $LN24@Parse@2
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pErr$[ebp]
	push	ecx
	push	5
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN24@Parse@2:

; 1081 : 		return 0;

	xor	eax, eax
	jmp	$LN33@Parse@2
$LN26@Parse@2:

; 1082 : 	}
; 1083 : 
; 1084 :     TIXML_STRING endTag ("</");

	push	OFFSET $SG7392
	lea	ecx, DWORD PTR _endTag$[ebp]
	call	??0TiXmlString@@QAE@PBD@Z		; TiXmlString::TiXmlString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1085 : 	endTag += value;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	lea	ecx, DWORD PTR _endTag$[ebp]
	call	??YTiXmlString@@QAEAAV0@ABV0@@Z		; TiXmlString::operator+=

; 1086 : 	endTag += ">";

	push	OFFSET $SG7393
	lea	ecx, DWORD PTR _endTag$[ebp]
	call	??YTiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator+=
$LN23@Parse@2:

; 1087 : 
; 1088 : 	// Check for and read attributes. Also look for an empty
; 1089 : 	// tag or an end tag.
; 1090 : 	while ( p && *p )

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN22@Parse@2
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN22@Parse@2

; 1091 : 	{
; 1092 : 		pErr = p;

	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _pErr$[ebp], edx

; 1093 : 		p = SkipWhiteSpace( p, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 1094 : 		if ( !p || !*p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN20@Parse@2
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN21@Parse@2
$LN20@Parse@2:

; 1095 : 		{
; 1096 : 			if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );

	cmp	DWORD PTR _document$[ebp], 0
	je	SHORT $LN19@Parse@2
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _pErr$[ebp]
	push	eax
	push	7
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN19@Parse@2:

; 1097 : 			return 0;

	mov	DWORD PTR $T8101[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _endTag$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T8101[ebp]
	jmp	$LN33@Parse@2
$LN21@Parse@2:

; 1098 : 		}
; 1099 : 		if ( *p == '/' )

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN18@Parse@2

; 1100 : 		{
; 1101 : 			++p;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 1102 : 			// Empty tag.
; 1103 : 			if ( *p  != '>' )

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	je	SHORT $LN17@Parse@2

; 1104 : 			{
; 1105 : 				if ( document ) document->SetError( TIXML_ERROR_PARSING_EMPTY, p, data, encoding );		

	cmp	DWORD PTR _document$[ebp], 0
	je	SHORT $LN16@Parse@2
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	push	8
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN16@Parse@2:

; 1106 : 				return 0;

	mov	DWORD PTR $T8102[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _endTag$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T8102[ebp]
	jmp	$LN33@Parse@2
$LN17@Parse@2:

; 1107 : 			}
; 1108 : 			return (p+1);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR $T8103[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _endTag$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T8103[ebp]
	jmp	$LN33@Parse@2
	jmp	$LN15@Parse@2
$LN18@Parse@2:

; 1109 : 		}
; 1110 : 		else if ( *p == '>' )

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	jne	$LN14@Parse@2

; 1111 : 		{
; 1112 : 			// Done with attributes (if there were any.)
; 1113 : 			// Read the value -- which can include other
; 1114 : 			// elements -- read the end tag, and return.
; 1115 : 			++p;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 1116 : 			p = ReadValue( p, data, encoding );		// Note this is an Element method, and will set the error if one happens.

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadValue@TiXmlElement@@IAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlElement::ReadValue
	mov	DWORD PTR _p$[ebp], eax

; 1117 : 			if ( !p || !*p ) {

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN12@Parse@2
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN13@Parse@2
$LN12@Parse@2:

; 1118 : 				// We were looking for the end tag, but found nothing.
; 1119 : 				// Fix for [ 1663758 ] Failure to report error on bad XML
; 1120 : 				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );

	cmp	DWORD PTR _document$[ebp], 0
	je	SHORT $LN11@Parse@2
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	push	9
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN11@Parse@2:

; 1121 : 				return 0;

	mov	DWORD PTR $T8104[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _endTag$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T8104[ebp]
	jmp	$LN33@Parse@2
$LN13@Parse@2:

; 1122 : 			}
; 1123 : 
; 1124 : 			// We should find the end tag now
; 1125 : 			if ( StringEqual( p, endTag.c_str(), false, encoding ) )

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _endTag$[ebp]
	call	?c_str@TiXmlString@@QBEPBDXZ		; TiXmlString::c_str
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@Parse@2

; 1126 : 			{
; 1127 : 				p += endTag.length();

	lea	ecx, DWORD PTR _endTag$[ebp]
	call	?length@TiXmlString@@QBEIXZ		; TiXmlString::length
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 1128 : 				return p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR $T8105[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _endTag$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T8105[ebp]
	jmp	$LN33@Parse@2

; 1129 : 			}
; 1130 : 			else

	jmp	SHORT $LN9@Parse@2
$LN10@Parse@2:

; 1131 : 			{
; 1132 : 				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );

	cmp	DWORD PTR _document$[ebp], 0
	je	SHORT $LN8@Parse@2
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	9
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN8@Parse@2:

; 1133 : 				return 0;

	mov	DWORD PTR $T8106[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _endTag$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T8106[ebp]
	jmp	$LN33@Parse@2
$LN9@Parse@2:

; 1134 : 			}
; 1135 : 		}
; 1136 : 		else

	jmp	$LN15@Parse@2
$LN14@Parse@2:

; 1137 : 		{
; 1138 : 			// Try to read an attribute:
; 1139 : 			TiXmlAttribute* attrib = new TiXmlAttribute();

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8108[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T8108[ebp], 0
	je	SHORT $LN35@Parse@2
	mov	ecx, DWORD PTR $T8108[ebp]
	call	??0TiXmlAttribute@@QAE@XZ		; TiXmlAttribute::TiXmlAttribute
	mov	DWORD PTR tv238[ebp], eax
	jmp	SHORT $LN36@Parse@2
$LN35@Parse@2:
	mov	DWORD PTR tv238[ebp], 0
$LN36@Parse@2:
	mov	ecx, DWORD PTR tv238[ebp]
	mov	DWORD PTR $T8107[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR $T8107[ebp]
	mov	DWORD PTR _attrib$7418[ebp], edx

; 1140 : 			if ( !attrib )

	cmp	DWORD PTR _attrib$7418[ebp], 0
	jne	SHORT $LN6@Parse@2

; 1141 : 			{
; 1142 : 				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, pErr, data, encoding );

	cmp	DWORD PTR _document$[ebp], 0
	je	SHORT $LN5@Parse@2
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pErr$[ebp]
	push	edx
	push	3
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN5@Parse@2:

; 1143 : 				return 0;

	mov	DWORD PTR $T8111[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _endTag$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T8111[ebp]
	jmp	$LN33@Parse@2
$LN6@Parse@2:

; 1144 : 			}
; 1145 : 
; 1146 : 			attrib->SetDocument( document );

	mov	eax, DWORD PTR _document$[ebp]
	push	eax
	mov	ecx, DWORD PTR _attrib$7418[ebp]
	call	?SetDocument@TiXmlAttribute@@QAEXPAVTiXmlDocument@@@Z ; TiXmlAttribute::SetDocument

; 1147 : 			pErr = p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _pErr$[ebp], ecx

; 1148 : 			p = attrib->Parse( p, data, encoding );

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _attrib$7418[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _attrib$7418[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	DWORD PTR _p$[ebp], eax

; 1149 : 
; 1150 : 			if ( !p || !*p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@Parse@2
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN4@Parse@2
$LN3@Parse@2:

; 1151 : 			{
; 1152 : 				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );

	cmp	DWORD PTR _document$[ebp], 0
	je	SHORT $LN2@Parse@2
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pErr$[ebp]
	push	ecx
	push	4
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN2@Parse@2:

; 1153 : 				delete attrib;

	mov	edx, DWORD PTR _attrib$7418[ebp]
	mov	DWORD PTR $T8113[ebp], edx
	mov	eax, DWORD PTR $T8113[ebp]
	mov	DWORD PTR $T8112[ebp], eax
	cmp	DWORD PTR $T8112[ebp], 0
	je	SHORT $LN37@Parse@2
	push	1
	mov	ecx, DWORD PTR $T8112[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T8112[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN38@Parse@2
$LN37@Parse@2:
	mov	DWORD PTR tv277[ebp], 0
$LN38@Parse@2:

; 1154 : 				return 0;

	mov	DWORD PTR $T8116[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _endTag$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T8116[ebp]
	jmp	$LN33@Parse@2
$LN4@Parse@2:

; 1155 : 			}
; 1156 : 
; 1157 : 			// Handle the strange case of double attributes:
; 1158 : 			#ifdef TIXML_USE_STL
; 1159 : 			TiXmlAttribute* node = attributeSet.Find( attrib->NameTStr() );
; 1160 : 			#else
; 1161 : 			TiXmlAttribute* node = attributeSet.Find( attrib->Name() );

	mov	ecx, DWORD PTR _attrib$7418[ebp]
	call	?Name@TiXmlAttribute@@QBEPBDXZ		; TiXmlAttribute::Name
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?Find@TiXmlAttributeSet@@QAEPAVTiXmlAttribute@@PBD@Z ; TiXmlAttributeSet::Find
	mov	DWORD PTR _node$7432[ebp], eax

; 1162 : 			#endif
; 1163 : 			if ( node )

	cmp	DWORD PTR _node$7432[ebp], 0
	je	SHORT $LN1@Parse@2

; 1164 : 			{
; 1165 : 				node->SetValue( attrib->Value() );

	mov	ecx, DWORD PTR _attrib$7418[ebp]
	call	?Value@TiXmlAttribute@@QBEPBDXZ		; TiXmlAttribute::Value
	push	eax
	mov	ecx, DWORD PTR _node$7432[ebp]
	call	?SetValue@TiXmlAttribute@@QAEXPBD@Z	; TiXmlAttribute::SetValue

; 1166 : 				delete attrib;

	mov	ecx, DWORD PTR _attrib$7418[ebp]
	mov	DWORD PTR $T8118[ebp], ecx
	mov	edx, DWORD PTR $T8118[ebp]
	mov	DWORD PTR $T8117[ebp], edx
	cmp	DWORD PTR $T8117[ebp], 0
	je	SHORT $LN39@Parse@2
	push	1
	mov	eax, DWORD PTR $T8117[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T8117[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv299[ebp], eax
	jmp	SHORT $LN40@Parse@2
$LN39@Parse@2:
	mov	DWORD PTR tv299[ebp], 0
$LN40@Parse@2:

; 1167 : 				return 0;

	mov	DWORD PTR $T8121[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _endTag$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T8121[ebp]
	jmp	SHORT $LN33@Parse@2
$LN1@Parse@2:

; 1168 : 			}
; 1169 : 
; 1170 : 			attributeSet.Add( attrib );

	mov	ecx, DWORD PTR _attrib$7418[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	?Add@TiXmlAttributeSet@@QAEXPAVTiXmlAttribute@@@Z ; TiXmlAttributeSet::Add
$LN15@Parse@2:

; 1171 : 		}
; 1172 : 	}

	jmp	$LN23@Parse@2
$LN22@Parse@2:

; 1173 : 	return p;

	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR $T8122[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _endTag$[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T8122[ebp]
$LN33@Parse@2:

; 1174 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Parse@TiXmlElement@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z$0:
	lea	ecx, DWORD PTR _endTag$[ebp]
	jmp	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
__unwindfunclet$?Parse@TiXmlElement@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z$1:
	mov	eax, DWORD PTR $T8108[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Parse@TiXmlElement@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Parse@TiXmlElement@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Parse@TiXmlElement@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ENDP ; TiXmlElement::Parse
PUBLIC	?start@TiXmlString@@ABEPADXZ			; TiXmlString::start
PUBLIC	?init@TiXmlString@@AAEXI@Z			; TiXmlString::init
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinystr.h
;	COMDAT ??0TiXmlString@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_copy$ = 8						; size = 4
??0TiXmlString@@QAE@PBD@Z PROC				; TiXmlString::TiXmlString, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 92   : 		init( static_cast<size_type>( strlen(copy) ));

	mov	ecx, DWORD PTR _copy$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?init@TiXmlString@@AAEXI@Z		; TiXmlString::init

; 93   : 		memcpy(start(), copy, length());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?length@TiXmlString@@QBEIXZ		; TiXmlString::length
	push	eax
	mov	edx, DWORD PTR _copy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?start@TiXmlString@@ABEPADXZ		; TiXmlString::start
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 94   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0TiXmlString@@QAE@PBD@Z ENDP				; TiXmlString::TiXmlString
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??YTiXmlString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_suffix$ = 8						; size = 4
??YTiXmlString@@QAEAAV0@PBD@Z PROC			; TiXmlString::operator+=, COMDAT
; _this$ = ecx

; 124  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 		return append(suffix, static_cast<size_type>( strlen(suffix) ));

	mov	eax, DWORD PTR _suffix$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _suffix$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@TiXmlString@@QAEAAV1@PBDI@Z	; TiXmlString::append

; 126  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??YTiXmlString@@QAEAAV0@PBD@Z ENDP			; TiXmlString::operator+=
_TEXT	ENDS
PUBLIC	?data@TiXmlString@@QBEPBDXZ			; TiXmlString::data
; Function compile flags: /Odtp
;	COMDAT ??YTiXmlString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_suffix$ = 8						; size = 4
??YTiXmlString@@QAEAAV0@ABV0@@Z PROC			; TiXmlString::operator+=, COMDAT
; _this$ = ecx

; 136  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 		return append(suffix.data(), suffix.length());

	mov	ecx, DWORD PTR _suffix$[ebp]
	call	?length@TiXmlString@@QBEIXZ		; TiXmlString::length
	push	eax
	mov	ecx, DWORD PTR _suffix$[ebp]
	call	?data@TiXmlString@@QBEPBDXZ		; TiXmlString::data
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@TiXmlString@@QAEAAV1@PBDI@Z	; TiXmlString::append

; 138  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??YTiXmlString@@QAEAAV0@ABV0@@Z ENDP			; TiXmlString::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?data@TiXmlString@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?data@TiXmlString@@QBEPBDXZ PROC			; TiXmlString::data, COMDAT
; _this$ = ecx

; 145  : 	const char * data () const { return rep_->str; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, 8
	mov	esp, ebp
	pop	ebp
	ret	0
?data@TiXmlString@@QBEPBDXZ ENDP			; TiXmlString::data
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?length@TiXmlString@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?length@TiXmlString@@QBEIXZ PROC			; TiXmlString::length, COMDAT
; _this$ = ecx

; 148  : 	size_type length () const { return rep_->size; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	mov	esp, ebp
	pop	ebp
	ret	0
?length@TiXmlString@@QBEIXZ ENDP			; TiXmlString::length
_TEXT	ENDS
PUBLIC	?init@TiXmlString@@AAEXII@Z			; TiXmlString::init
; Function compile flags: /Odtp
;	COMDAT ?init@TiXmlString@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_sz$ = 8						; size = 4
?init@TiXmlString@@AAEXI@Z PROC				; TiXmlString::init, COMDAT
; _this$ = ecx

; 220  : 	void init(size_type sz) { init(sz, sz); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?init@TiXmlString@@AAEXII@Z		; TiXmlString::init
	mov	esp, ebp
	pop	ebp
	ret	4
?init@TiXmlString@@AAEXI@Z ENDP				; TiXmlString::init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?start@TiXmlString@@ABEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?start@TiXmlString@@ABEPADXZ PROC			; TiXmlString::start, COMDAT
; _this$ = ecx

; 222  : 	char* start() const { return rep_->str; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, 8
	mov	esp, ebp
	pop	ebp
	ret	0
?start@TiXmlString@@ABEPADXZ ENDP			; TiXmlString::start
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?init@TiXmlString@@AAEXII@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T8144 = -12						; size = 4
_intsNeeded$5788 = -8					; size = 4
_bytesNeeded$5786 = -4					; size = 4
_sz$ = 8						; size = 4
_cap$ = 12						; size = 4
?init@TiXmlString@@AAEXII@Z PROC			; TiXmlString::init, COMDAT
; _this$ = ecx

; 232  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		if (cap)

	cmp	DWORD PTR _cap$[ebp], 0
	je	SHORT $LN2@init

; 234  : 		{
; 235  : 			// Lee: the original form:
; 236  : 			//	rep_ = static_cast<Rep*>(operator new(sizeof(Rep) + cap));
; 237  : 			// doesn't work in some cases of new being overloaded. Switching
; 238  : 			// to the normal allocation, although use an 'int' for systems
; 239  : 			// that are overly picky about structure alignment.
; 240  : 			const size_type bytesNeeded = sizeof(Rep) + cap;

	mov	eax, DWORD PTR _cap$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _bytesNeeded$5786[ebp], eax

; 241  : 			const size_type intsNeeded = ( bytesNeeded + sizeof(int) - 1 ) / sizeof( int ); 

	mov	ecx, DWORD PTR _bytesNeeded$5786[ebp]
	add	ecx, 3
	shr	ecx, 2
	mov	DWORD PTR _intsNeeded$5788[ebp], ecx

; 242  : 			rep_ = reinterpret_cast<Rep*>( new int[ intsNeeded ] );

	xor	ecx, ecx
	mov	eax, DWORD PTR _intsNeeded$5788[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8144[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T8144[ebp]
	mov	DWORD PTR [eax], ecx

; 243  : 
; 244  : 			rep_->str[ rep_->size = sz ] = '\0';

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _sz$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _sz$[ebp]
	mov	BYTE PTR [eax+ecx+8], 0

; 245  : 			rep_->capacity = cap;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cap$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 246  : 		}
; 247  : 		else

	jmp	SHORT $LN3@init
$LN2@init:

; 248  : 		{
; 249  : 			rep_ = &nullrep_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ?nullrep_@TiXmlString@@0URep@1@A ; TiXmlString::nullrep_
$LN3@init:

; 250  : 		}
; 251  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?init@TiXmlString@@AAEXII@Z ENDP			; TiXmlString::init
_TEXT	ENDS
PUBLIC	??1TiXmlBase@@UAE@XZ				; TiXmlBase::~TiXmlBase
PUBLIC	??_7TiXmlAttribute@@6B@				; TiXmlAttribute::`vftable'
PUBLIC	??0TiXmlBase@@QAE@XZ				; TiXmlBase::TiXmlBase
PUBLIC	??_R4TiXmlAttribute@@6B@			; TiXmlAttribute::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTiXmlAttribute@@@8			; TiXmlAttribute `RTTI Type Descriptor'
PUBLIC	??_R3TiXmlAttribute@@8				; TiXmlAttribute::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TiXmlAttribute@@8				; TiXmlAttribute::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TiXmlAttribute@@8			; TiXmlAttribute::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Print@TiXmlAttribute@@UBEXPAU_iobuf@@H@Z	; TiXmlAttribute::Print
PUBLIC	?Parse@TiXmlAttribute@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlAttribute::Parse
EXTRN	??_ETiXmlAttribute@@UAEPAXI@Z:PROC		; TiXmlAttribute::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@TiXmlAttribute@@8
; File i:\svnroot\client\ogremain\tinyxml.h
rdata$r	SEGMENT
??_R1A@?0A@EA@TiXmlAttribute@@8 DD FLAT:??_R0?AVTiXmlAttribute@@@8 ; TiXmlAttribute::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TiXmlAttribute@@8
rdata$r	ENDS
;	COMDAT ??_R2TiXmlAttribute@@8
rdata$r	SEGMENT
??_R2TiXmlAttribute@@8 DD FLAT:??_R1A@?0A@EA@TiXmlAttribute@@8 ; TiXmlAttribute::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@TiXmlBase@@8
rdata$r	ENDS
;	COMDAT ??_R3TiXmlAttribute@@8
rdata$r	SEGMENT
??_R3TiXmlAttribute@@8 DD 00H				; TiXmlAttribute::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2TiXmlAttribute@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTiXmlAttribute@@@8
_DATA	SEGMENT
??_R0?AVTiXmlAttribute@@@8 DD FLAT:??_7type_info@@6B@	; TiXmlAttribute `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTiXmlAttribute@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TiXmlAttribute@@6B@
rdata$r	SEGMENT
??_R4TiXmlAttribute@@6B@ DD 00H				; TiXmlAttribute::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTiXmlAttribute@@@8
	DD	FLAT:??_R3TiXmlAttribute@@8
rdata$r	ENDS
;	COMDAT ??_7TiXmlAttribute@@6B@
CONST	SEGMENT
??_7TiXmlAttribute@@6B@ DD FLAT:??_R4TiXmlAttribute@@6B@ ; TiXmlAttribute::`vftable'
	DD	FLAT:??_ETiXmlAttribute@@UAEPAXI@Z
	DD	FLAT:?Print@TiXmlAttribute@@UBEXPAU_iobuf@@H@Z
	DD	FLAT:?Parse@TiXmlAttribute@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0TiXmlAttribute@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0TiXmlAttribute@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0TiXmlAttribute@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0TiXmlAttribute@@QAE@XZ$2
__ehfuncinfo$??0TiXmlAttribute@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0TiXmlAttribute@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0TiXmlAttribute@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0TiXmlAttribute@@QAE@XZ PROC				; TiXmlAttribute::TiXmlAttribute, COMDAT
; _this$ = ecx

; 787  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0TiXmlAttribute@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0TiXmlBase@@QAE@XZ			; TiXmlBase::TiXmlBase
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TiXmlAttribute@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0TiXmlString@@QAE@XZ			; TiXmlString::TiXmlString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0TiXmlString@@QAE@XZ			; TiXmlString::TiXmlString
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 788  : 		document = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 789  : 		prev = next = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 790  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0TiXmlAttribute@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1TiXmlBase@@UAE@XZ			; TiXmlBase::~TiXmlBase
__unwindfunclet$??0TiXmlAttribute@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
__unwindfunclet$??0TiXmlAttribute@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
__ehhandler$??0TiXmlAttribute@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0TiXmlAttribute@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0TiXmlAttribute@@QAE@XZ ENDP				; TiXmlAttribute::TiXmlAttribute
PUBLIC	??_7TiXmlBase@@6B@				; TiXmlBase::`vftable'
PUBLIC	??_R4TiXmlBase@@6B@				; TiXmlBase::`RTTI Complete Object Locator'
EXTRN	??_ETiXmlBase@@UAEPAXI@Z:PROC			; TiXmlBase::`vector deleting destructor'
EXTRN	__purecall:PROC
;	COMDAT ??_R4TiXmlBase@@6B@
rdata$r	SEGMENT
??_R4TiXmlBase@@6B@ DD 00H				; TiXmlBase::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTiXmlBase@@@8
	DD	FLAT:??_R3TiXmlBase@@8
rdata$r	ENDS
;	COMDAT ??_7TiXmlBase@@6B@
CONST	SEGMENT
??_7TiXmlBase@@6B@ DD FLAT:??_R4TiXmlBase@@6B@		; TiXmlBase::`vftable'
	DD	FLAT:??_ETiXmlBase@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0TiXmlBase@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TiXmlBase@@QAE@XZ PROC				; TiXmlBase::TiXmlBase, COMDAT
; _this$ = ecx

; 202  : 	TiXmlBase()	:	userData(0)		{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TiXmlBase@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0TiXmlCursor@@QAE@XZ			; TiXmlCursor::TiXmlCursor
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0TiXmlBase@@QAE@XZ ENDP				; TiXmlBase::TiXmlBase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1TiXmlBase@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TiXmlBase@@UAE@XZ PROC				; TiXmlBase::~TiXmlBase, COMDAT
; _this$ = ecx

; 203  : 	virtual ~TiXmlBase()			{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TiXmlBase@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1TiXmlBase@@UAE@XZ ENDP				; TiXmlBase::~TiXmlBase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_GTiXmlBase@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTiXmlBase@@UAEPAXI@Z PROC				; TiXmlBase::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TiXmlBase@@UAE@XZ			; TiXmlBase::~TiXmlBase
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTiXmlBase@@UAEPAXI@Z ENDP				; TiXmlBase::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Name@TiXmlAttribute@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Name@TiXmlAttribute@@QBEPBDXZ PROC			; TiXmlAttribute::Name, COMDAT
; _this$ = ecx

; 812  : 	const char*		Name()  const		{ return name.c_str(); }		///< Return the name of this attribute.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?c_str@TiXmlString@@QBEPBDXZ		; TiXmlString::c_str
	mov	esp, ebp
	pop	ebp
	ret	0
?Name@TiXmlAttribute@@QBEPBDXZ ENDP			; TiXmlAttribute::Name
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Value@TiXmlAttribute@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Value@TiXmlAttribute@@QBEPBDXZ PROC			; TiXmlAttribute::Value, COMDAT
; _this$ = ecx

; 813  : 	const char*		Value() const		{ return value.c_str(); }		///< Return the value of this attribute.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?c_str@TiXmlString@@QBEPBDXZ		; TiXmlString::c_str
	mov	esp, ebp
	pop	ebp
	ret	0
?Value@TiXmlAttribute@@QBEPBDXZ ENDP			; TiXmlAttribute::Value
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetValue@TiXmlAttribute@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__value$ = 8						; size = 4
?SetValue@TiXmlAttribute@@QAEXPBD@Z PROC		; TiXmlAttribute::SetValue, COMDAT
; _this$ = ecx

; 837  : 	void SetValue( const char* _value )	{ value = _value; }				///< Set the value.

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=
	mov	esp, ebp
	pop	ebp
	ret	4
?SetValue@TiXmlAttribute@@QAEXPBD@Z ENDP		; TiXmlAttribute::SetValue
_TEXT	ENDS
EXTRN	?Print@TiXmlAttribute@@QBEXPAU_iobuf@@HPAVTiXmlString@@@Z:PROC ; TiXmlAttribute::Print
; Function compile flags: /Odtp
;	COMDAT ?Print@TiXmlAttribute@@UBEXPAU_iobuf@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cfile$ = 8						; size = 4
_depth$ = 12						; size = 4
?Print@TiXmlAttribute@@UBEXPAU_iobuf@@H@Z PROC		; TiXmlAttribute::Print, COMDAT
; _this$ = ecx

; 871  : 	virtual void Print( FILE* cfile, int depth ) const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 872  : 		Print( cfile, depth, 0 );

	push	0
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cfile$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Print@TiXmlAttribute@@QBEXPAU_iobuf@@HPAVTiXmlString@@@Z ; TiXmlAttribute::Print

; 873  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Print@TiXmlAttribute@@UBEXPAU_iobuf@@H@Z ENDP		; TiXmlAttribute::Print
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetDocument@TiXmlAttribute@@QAEXPAVTiXmlDocument@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_doc$ = 8						; size = 4
?SetDocument@TiXmlAttribute@@QAEXPAVTiXmlDocument@@@Z PROC ; TiXmlAttribute::SetDocument, COMDAT
; _this$ = ecx

; 878  : 	void SetDocument( TiXmlDocument* doc )	{ document = doc; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _doc$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDocument@TiXmlAttribute@@QAEXPAVTiXmlDocument@@@Z ENDP ; TiXmlAttribute::SetDocument
_TEXT	ENDS
PUBLIC	??1TiXmlAttribute@@UAE@XZ			; TiXmlAttribute::~TiXmlAttribute
; Function compile flags: /Odtp
;	COMDAT ??_GTiXmlAttribute@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTiXmlAttribute@@UAEPAXI@Z PROC			; TiXmlAttribute::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TiXmlAttribute@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTiXmlAttribute@@UAEPAXI@Z ENDP			; TiXmlAttribute::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1TiXmlAttribute@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1TiXmlAttribute@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1TiXmlAttribute@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1TiXmlAttribute@@UAE@XZ$2
__ehfuncinfo$??1TiXmlAttribute@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1TiXmlAttribute@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1TiXmlAttribute@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TiXmlAttribute@@UAE@XZ PROC				; TiXmlAttribute::~TiXmlAttribute, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1TiXmlAttribute@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TiXmlBase@@UAE@XZ			; TiXmlBase::~TiXmlBase
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1TiXmlAttribute@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1TiXmlBase@@UAE@XZ			; TiXmlBase::~TiXmlBase
__unwindfunclet$??1TiXmlAttribute@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
__unwindfunclet$??1TiXmlAttribute@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
__ehhandler$??1TiXmlAttribute@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1TiXmlAttribute@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1TiXmlAttribute@@UAE@XZ ENDP				; TiXmlAttribute::~TiXmlAttribute
EXTRN	?Find@TiXmlAttributeSet@@QBEPBVTiXmlAttribute@@PBD@Z:PROC ; TiXmlAttributeSet::Find
; Function compile flags: /Odtp
;	COMDAT ?Find@TiXmlAttributeSet@@QAEPAVTiXmlAttribute@@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__name$ = 8						; size = 4
?Find@TiXmlAttributeSet@@QAEPAVTiXmlAttribute@@PBD@Z PROC ; TiXmlAttributeSet::Find, COMDAT
; _this$ = ecx

; 919  : 	TiXmlAttribute*	Find( const char* _name ) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 920  : 		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttributeSet* >(this))->Find( _name ) );

	mov	eax, DWORD PTR __name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Find@TiXmlAttributeSet@@QBEPBVTiXmlAttribute@@PBD@Z ; TiXmlAttributeSet::Find

; 921  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Find@TiXmlAttributeSet@@QAEPAVTiXmlAttribute@@PBD@Z ENDP ; TiXmlAttributeSet::Find
_TEXT	ENDS
PUBLIC	?Blank@TiXmlText@@IBE_NXZ			; TiXmlText::Blank
PUBLIC	?IsWhiteSpaceCondensed@TiXmlBase@@SA_NXZ	; TiXmlBase::IsWhiteSpaceCondensed
xdata$x	SEGMENT
__unwindtable$?ReadValue@TiXmlElement@@IAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadValue@TiXmlElement@@IAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z$0
__ehfuncinfo$?ReadValue@TiXmlElement@@IAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ReadValue@TiXmlElement@@IAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxmlparser.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv174 = -56						; size = 4
tv86 = -52						; size = 4
_this$ = -48						; size = 4
$T8194 = -44						; size = 4
$T8193 = -40						; size = 4
$T8190 = -36						; size = 4
$T8189 = -32						; size = 4
_node$7468 = -28					; size = 4
_textNode$7450 = -24					; size = 4
_pWithWhiteSpace$ = -20					; size = 4
_document$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_p$ = 8							; size = 4
_data$ = 12						; size = 4
_encoding$ = 16						; size = 4
?ReadValue@TiXmlElement@@IAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z PROC ; TiXmlElement::ReadValue
; _this$ = ecx

; 1178 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ReadValue@TiXmlElement@@IAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1179 : 	TiXmlDocument* document = GetDocument();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDocument@TiXmlNode@@QAEPAVTiXmlDocument@@XZ ; TiXmlNode::GetDocument
	mov	DWORD PTR _document$[ebp], eax

; 1180 : 
; 1181 : 	// Read in text and elements in any order.
; 1182 : 	const char* pWithWhiteSpace = p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _pWithWhiteSpace$[ebp], eax

; 1183 : 	p = SkipWhiteSpace( p, encoding );

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax
$LN16@ReadValue:

; 1184 : 
; 1185 : 	while ( p && *p )

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN15@ReadValue
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN15@ReadValue

; 1186 : 	{
; 1187 : 		if ( *p != '<' )

	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 60					; 0000003cH
	je	$LN14@ReadValue

; 1188 : 		{
; 1189 : 			// Take what we have, make a text element.
; 1190 : 			TiXmlText* textNode = new TiXmlText( "" );

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8190[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T8190[ebp], 0
	je	SHORT $LN19@ReadValue
	push	OFFSET $SG7455
	mov	ecx, DWORD PTR $T8190[ebp]
	call	??0TiXmlText@@QAE@PBD@Z			; TiXmlText::TiXmlText
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN20@ReadValue
$LN19@ReadValue:
	mov	DWORD PTR tv86[ebp], 0
$LN20@ReadValue:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T8189[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T8189[ebp]
	mov	DWORD PTR _textNode$7450[ebp], edx

; 1191 : 
; 1192 : 			if ( !textNode )

	cmp	DWORD PTR _textNode$7450[ebp], 0
	jne	SHORT $LN13@ReadValue

; 1193 : 			{
; 1194 : 				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, encoding );

	cmp	DWORD PTR _document$[ebp], 0
	je	SHORT $LN12@ReadValue
	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	push	0
	push	0
	push	3
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN12@ReadValue:

; 1195 : 				    return 0;

	xor	eax, eax
	jmp	$LN17@ReadValue
$LN13@ReadValue:

; 1196 : 			}
; 1197 : 
; 1198 : 			if ( TiXmlBase::IsWhiteSpaceCondensed() )

	call	?IsWhiteSpaceCondensed@TiXmlBase@@SA_NXZ ; TiXmlBase::IsWhiteSpaceCondensed
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@ReadValue

; 1199 : 			{
; 1200 : 				p = textNode->Parse( p, data, encoding );

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _textNode$7450[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _textNode$7450[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	DWORD PTR _p$[ebp], eax

; 1201 : 			}
; 1202 : 			else

	jmp	SHORT $LN10@ReadValue
$LN11@ReadValue:

; 1203 : 			{
; 1204 : 				// Special case: we want to keep the white space
; 1205 : 				// so that leading spaces aren't removed.
; 1206 : 				p = textNode->Parse( pWithWhiteSpace, data, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pWithWhiteSpace$[ebp]
	push	edx
	mov	eax, DWORD PTR _textNode$7450[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _textNode$7450[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR _p$[ebp], eax
$LN10@ReadValue:

; 1207 : 			}
; 1208 : 
; 1209 : 			if ( !textNode->Blank() )

	mov	ecx, DWORD PTR _textNode$7450[ebp]
	call	?Blank@TiXmlText@@IBE_NXZ		; TiXmlText::Blank
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN9@ReadValue

; 1210 : 				LinkEndChild( textNode );

	mov	edx, DWORD PTR _textNode$7450[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkEndChild@TiXmlNode@@QAEPAV1@PAV1@@Z ; TiXmlNode::LinkEndChild

; 1211 : 			else

	jmp	SHORT $LN8@ReadValue
$LN9@ReadValue:

; 1212 : 				delete textNode;

	mov	eax, DWORD PTR _textNode$7450[ebp]
	mov	DWORD PTR $T8194[ebp], eax
	mov	ecx, DWORD PTR $T8194[ebp]
	mov	DWORD PTR $T8193[ebp], ecx
	cmp	DWORD PTR $T8193[ebp], 0
	je	SHORT $LN21@ReadValue
	push	1
	mov	edx, DWORD PTR $T8193[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T8193[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv174[ebp], eax
	jmp	SHORT $LN8@ReadValue
$LN21@ReadValue:
	mov	DWORD PTR tv174[ebp], 0
$LN8@ReadValue:

; 1213 : 		} 
; 1214 : 		else 

	jmp	SHORT $LN7@ReadValue
$LN14@ReadValue:

; 1215 : 		{
; 1216 : 			// We hit a '<'
; 1217 : 			// Have we hit a new element or an end tag? This could also be
; 1218 : 			// a TiXmlText in the "CDATA" style.
; 1219 : 			if ( StringEqual( p, "</", false, encoding ) )

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	push	0
	push	OFFSET $SG7466
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@ReadValue

; 1220 : 			{
; 1221 : 				return p;

	mov	eax, DWORD PTR _p$[ebp]
	jmp	$LN17@ReadValue

; 1222 : 			}
; 1223 : 			else

	jmp	SHORT $LN7@ReadValue
$LN6@ReadValue:

; 1224 : 			{
; 1225 : 				TiXmlNode* node = Identify( p, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Identify@TiXmlNode@@IAEPAV1@PBDW4TiXmlEncoding@@@Z ; TiXmlNode::Identify
	mov	DWORD PTR _node$7468[ebp], eax

; 1226 : 				if ( node )

	cmp	DWORD PTR _node$7468[ebp], 0
	je	SHORT $LN4@ReadValue

; 1227 : 				{
; 1228 : 					p = node->Parse( p, data, encoding );

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$7468[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _node$7468[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	DWORD PTR _p$[ebp], eax

; 1229 : 					LinkEndChild( node );

	mov	eax, DWORD PTR _node$7468[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkEndChild@TiXmlNode@@QAEPAV1@PAV1@@Z ; TiXmlNode::LinkEndChild

; 1230 : 				}				
; 1231 : 				else

	jmp	SHORT $LN7@ReadValue
$LN4@ReadValue:

; 1232 : 				{
; 1233 : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN17@ReadValue
$LN7@ReadValue:

; 1234 : 				}
; 1235 : 			}
; 1236 : 		}
; 1237 : 		pWithWhiteSpace = p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _pWithWhiteSpace$[ebp], ecx

; 1238 : 		p = SkipWhiteSpace( p, encoding );

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 1239 : 	}

	jmp	$LN16@ReadValue
$LN15@ReadValue:

; 1240 : 
; 1241 : 	if ( !p )

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN2@ReadValue

; 1242 : 	{
; 1243 : 		if ( document ) document->SetError( TIXML_ERROR_READING_ELEMENT_VALUE, 0, 0, encoding );

	cmp	DWORD PTR _document$[ebp], 0
	je	SHORT $LN2@ReadValue
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	push	0
	push	0
	push	6
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN2@ReadValue:

; 1244 : 	}	
; 1245 : 	return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN17@ReadValue:

; 1246 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ReadValue@TiXmlElement@@IAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z$0:
	mov	eax, DWORD PTR $T8190[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ReadValue@TiXmlElement@@IAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ReadValue@TiXmlElement@@IAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReadValue@TiXmlElement@@IAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ENDP ; TiXmlElement::ReadValue
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxml.h
;	COMDAT ?IsWhiteSpaceCondensed@TiXmlBase@@SA_NXZ
_TEXT	SEGMENT
?IsWhiteSpaceCondensed@TiXmlBase@@SA_NXZ PROC		; TiXmlBase::IsWhiteSpaceCondensed, COMDAT

; 225  : 	static bool IsWhiteSpaceCondensed()						{ return condenseWhiteSpace; }

	push	ebp
	mov	ebp, esp
	mov	al, BYTE PTR ?condenseWhiteSpace@TiXmlBase@@0_NA ; TiXmlBase::condenseWhiteSpace
	pop	ebp
	ret	0
?IsWhiteSpaceCondensed@TiXmlBase@@SA_NXZ ENDP		; TiXmlBase::IsWhiteSpaceCondensed
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinyxmlparser.cpp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -8						; size = 4
_document$ = -4						; size = 4
_p$ = 8							; size = 4
_data$ = 12						; size = 4
_encoding$ = 16						; size = 4
?Parse@TiXmlUnknown@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z PROC ; TiXmlUnknown::Parse
; _this$ = ecx

; 1275 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1276 : 	TiXmlDocument* document = GetDocument();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDocument@TiXmlNode@@QAEPAVTiXmlDocument@@XZ ; TiXmlNode::GetDocument
	mov	DWORD PTR _document$[ebp], eax

; 1277 : 	p = SkipWhiteSpace( p, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 1278 : 
; 1279 : 	if ( data )

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN9@Parse@3

; 1280 : 	{
; 1281 : 		data->Stamp( p, encoding );

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	call	?Stamp@TiXmlParsingData@@QAEXPBDW4TiXmlEncoding@@@Z ; TiXmlParsingData::Stamp

; 1282 : 		location = data->Cursor();

	mov	ecx, DWORD PTR _data$[ebp]
	call	?Cursor@TiXmlParsingData@@QAEABUTiXmlCursor@@XZ ; TiXmlParsingData::Cursor
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
$LN9@Parse@3:

; 1283 : 	}
; 1284 : 	if ( !p || !*p || *p != '<' )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN7@Parse@3
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN7@Parse@3
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 60					; 0000003cH
	je	SHORT $LN8@Parse@3
$LN7@Parse@3:

; 1285 : 	{
; 1286 : 		if ( document ) document->SetError( TIXML_ERROR_PARSING_UNKNOWN, p, data, encoding );

	cmp	DWORD PTR _document$[ebp], 0
	je	SHORT $LN6@Parse@3
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN6@Parse@3:

; 1287 : 		return 0;

	xor	eax, eax
	jmp	$LN10@Parse@3
$LN8@Parse@3:

; 1288 : 	}
; 1289 : 	++p;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 1290 :     value = "";

	push	OFFSET $SG7484
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=
$LN5@Parse@3:

; 1291 : 
; 1292 : 	while ( p && *p && *p != '>' )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN4@Parse@3
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@Parse@3
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN4@Parse@3

; 1293 : 	{
; 1294 : 		value += *p;

	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??YTiXmlString@@QAEAAV0@D@Z		; TiXmlString::operator+=

; 1295 : 		++p;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 1296 : 	}

	jmp	SHORT $LN5@Parse@3
$LN4@Parse@3:

; 1297 : 
; 1298 : 	if ( !p )

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN3@Parse@3

; 1299 : 	{
; 1300 : 		if ( document )	document->SetError( TIXML_ERROR_PARSING_UNKNOWN, 0, 0, encoding );

	cmp	DWORD PTR _document$[ebp], 0
	je	SHORT $LN3@Parse@3
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	push	0
	push	0
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN3@Parse@3:

; 1301 : 	}
; 1302 : 	if ( *p == '>' )

	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN1@Parse@3

; 1303 : 		return p+1;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	jmp	SHORT $LN10@Parse@3
$LN1@Parse@3:

; 1304 : 	return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN10@Parse@3:

; 1305 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Parse@TiXmlUnknown@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ENDP ; TiXmlUnknown::Parse
; Function compile flags: /Odtp
_this$ = -16						; size = 4
_startTag$ = -12					; size = 4
_endTag$ = -8						; size = 4
_document$ = -4						; size = 4
_p$ = 8							; size = 4
_data$ = 12						; size = 4
_encoding$ = 16						; size = 4
?Parse@TiXmlComment@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z PROC ; TiXmlComment::Parse
; _this$ = ecx

; 1336 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1337 : 	TiXmlDocument* document = GetDocument();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDocument@TiXmlNode@@QAEPAVTiXmlDocument@@XZ ; TiXmlNode::GetDocument
	mov	DWORD PTR _document$[ebp], eax

; 1338 : 	value = "";

	push	OFFSET $SG7498
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=

; 1339 : 
; 1340 : 	p = SkipWhiteSpace( p, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 1341 : 
; 1342 : 	if ( data )

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN5@Parse@4

; 1343 : 	{
; 1344 : 		data->Stamp( p, encoding );

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	call	?Stamp@TiXmlParsingData@@QAEXPBDW4TiXmlEncoding@@@Z ; TiXmlParsingData::Stamp

; 1345 : 		location = data->Cursor();

	mov	ecx, DWORD PTR _data$[ebp]
	call	?Cursor@TiXmlParsingData@@QAEABUTiXmlCursor@@XZ ; TiXmlParsingData::Cursor
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
$LN5@Parse@4:

; 1346 : 	}
; 1347 : 	const char* startTag = "<!--";

	mov	DWORD PTR _startTag$[ebp], OFFSET $SG7501

; 1348 : 	const char* endTag   = "-->";

	mov	DWORD PTR _endTag$[ebp], OFFSET $SG7503

; 1349 : 
; 1350 : 	if ( !StringEqual( p, startTag, false, encoding ) )

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _startTag$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@Parse@4

; 1351 : 	{
; 1352 : 		document->SetError( TIXML_ERROR_PARSING_COMMENT, p, data, encoding );

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError

; 1353 : 		return 0;

	xor	eax, eax
	jmp	$LN6@Parse@4
$LN4@Parse@4:

; 1354 : 	}
; 1355 : 	p += strlen( startTag );

	mov	edx, DWORD PTR _startTag$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 1356 : 
; 1357 : 	// [ 1475201 ] TinyXML parses entities in comments
; 1358 : 	// Oops - ReadText doesn't work, because we don't want to parse the entities.
; 1359 : 	// p = ReadText( p, &value, false, endTag, false, encoding );
; 1360 : 	//
; 1361 : 	// from the XML spec:
; 1362 : 	/*
; 1363 : 	 [Definition: Comments may appear anywhere in a document outside other markup; in addition, 
; 1364 : 	              they may appear within the document type declaration at places allowed by the grammar. 
; 1365 : 				  They are not part of the document's character data; an XML processor MAY, but need not, 
; 1366 : 				  make it possible for an application to retrieve the text of comments. For compatibility, 
; 1367 : 				  the string "--" (double-hyphen) MUST NOT occur within comments.] Parameter entity 
; 1368 : 				  references MUST NOT be recognized within comments.
; 1369 : 
; 1370 : 				  An example of a comment:
; 1371 : 
; 1372 : 				  <!-- declarations for <head> & <body> -->
; 1373 : 	*/
; 1374 : 
; 1375 :     value = "";

	push	OFFSET $SG7505
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=
$LN3@Parse@4:

; 1376 : 	// Keep all the white space.
; 1377 : 	while (	p && *p && !StringEqual( p, endTag, false, encoding ) )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN2@Parse@4
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@Parse@4
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _endTag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@Parse@4

; 1378 : 	{
; 1379 : 		value.append( p, 1 );

	push	1
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?append@TiXmlString@@QAEAAV1@PBDI@Z	; TiXmlString::append

; 1380 : 		++p;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 1381 : 	}

	jmp	SHORT $LN3@Parse@4
$LN2@Parse@4:

; 1382 : 	if ( p ) 

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN1@Parse@4

; 1383 : 		p += strlen( endTag );

	mov	edx, DWORD PTR _endTag$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN1@Parse@4:

; 1384 : 
; 1385 : 	return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN6@Parse@4:

; 1386 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Parse@TiXmlComment@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ENDP ; TiXmlComment::Parse
; Function compile flags: /Odtp
_this$ = -16						; size = 4
_SINGLE_QUOTE$ = -10					; size = 1
_DOUBLE_QUOTE$ = -9					; size = 1
_end$ = -8						; size = 4
_pErr$ = -4						; size = 4
_p$ = 8							; size = 4
_data$ = 12						; size = 4
_encoding$ = 16						; size = 4
?Parse@TiXmlAttribute@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z PROC ; TiXmlAttribute::Parse
; _this$ = ecx

; 1390 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1391 : 	p = SkipWhiteSpace( p, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 1392 : 	if ( !p || !*p ) return 0;

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN20@Parse@5
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN21@Parse@5
$LN20@Parse@5:
	xor	eax, eax
	jmp	$LN22@Parse@5
$LN21@Parse@5:

; 1393 : 
; 1394 : //	int tabsize = 4;
; 1395 : //	if ( document )
; 1396 : //		tabsize = document->TabSize();
; 1397 : 
; 1398 : 	if ( data )

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN19@Parse@5

; 1399 : 	{
; 1400 : 		data->Stamp( p, encoding );

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	ecx, DWORD PTR _data$[ebp]
	call	?Stamp@TiXmlParsingData@@QAEXPBDW4TiXmlEncoding@@@Z ; TiXmlParsingData::Stamp

; 1401 : 		location = data->Cursor();

	mov	ecx, DWORD PTR _data$[ebp]
	call	?Cursor@TiXmlParsingData@@QAEABUTiXmlCursor@@XZ ; TiXmlParsingData::Cursor
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
$LN19@Parse@5:

; 1402 : 	}
; 1403 : 	// Read the name, the '=' and the value.
; 1404 : 	const char* pErr = p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _pErr$[ebp], ecx

; 1405 : 	p = ReadName( p, &name, encoding );

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?ReadName@TiXmlBase@@KAPBDPBDPAVTiXmlString@@W4TiXmlEncoding@@@Z ; TiXmlBase::ReadName
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _p$[ebp], eax

; 1406 : 	if ( !p || !*p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN17@Parse@5
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN18@Parse@5
$LN17@Parse@5:

; 1407 : 	{
; 1408 : 		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN16@Parse@5
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pErr$[ebp]
	push	ecx
	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN16@Parse@5:

; 1409 : 		return 0;

	xor	eax, eax
	jmp	$LN22@Parse@5
$LN18@Parse@5:

; 1410 : 	}
; 1411 : 	p = SkipWhiteSpace( p, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 1412 : 	if ( !p || !*p || *p != '=' )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN14@Parse@5
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN14@Parse@5
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 61					; 0000003dH
	je	SHORT $LN15@Parse@5
$LN14@Parse@5:

; 1413 : 	{
; 1414 : 		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN13@Parse@5
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN13@Parse@5:

; 1415 : 		return 0;

	xor	eax, eax
	jmp	$LN22@Parse@5
$LN15@Parse@5:

; 1416 : 	}
; 1417 : 
; 1418 : 	++p;	// skip '='

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 1419 : 	p = SkipWhiteSpace( p, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 1420 : 	if ( !p || !*p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN11@Parse@5
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN12@Parse@5
$LN11@Parse@5:

; 1421 : 	{
; 1422 : 		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN10@Parse@5
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN10@Parse@5:

; 1423 : 		return 0;

	xor	eax, eax
	jmp	$LN22@Parse@5
$LN12@Parse@5:

; 1424 : 	}
; 1425 : 	
; 1426 : 	const char* end;
; 1427 : 	const char SINGLE_QUOTE = '\'';

	mov	BYTE PTR _SINGLE_QUOTE$[ebp], 39	; 00000027H

; 1428 : 	const char DOUBLE_QUOTE = '\"';

	mov	BYTE PTR _DOUBLE_QUOTE$[ebp], 34	; 00000022H

; 1429 : 
; 1430 : 	if ( *p == SINGLE_QUOTE )

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	jne	SHORT $LN9@Parse@5

; 1431 : 	{
; 1432 : 		++p;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 1433 : 		end = "\'";		// single quote in string

	mov	DWORD PTR _end$[ebp], OFFSET $SG7533

; 1434 : 		p = ReadText( p, &value, false, end, false, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?ReadText@TiXmlBase@@KAPBDPBDPAVTiXmlString@@_N02W4TiXmlEncoding@@@Z ; TiXmlBase::ReadText
	add	esp, 24					; 00000018H
	mov	DWORD PTR _p$[ebp], eax
	jmp	$LN8@Parse@5
$LN9@Parse@5:

; 1435 : 	}
; 1436 : 	else if ( *p == DOUBLE_QUOTE )

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 34					; 00000022H
	jne	SHORT $LN7@Parse@5

; 1437 : 	{
; 1438 : 		++p;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 1439 : 		end = "\"";		// double quote in string

	mov	DWORD PTR _end$[ebp], OFFSET $SG7536

; 1440 : 		p = ReadText( p, &value, false, end, false, encoding );

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?ReadText@TiXmlBase@@KAPBDPBDPAVTiXmlString@@_N02W4TiXmlEncoding@@@Z ; TiXmlBase::ReadText
	add	esp, 24					; 00000018H
	mov	DWORD PTR _p$[ebp], eax

; 1441 : 	}
; 1442 : 	else

	jmp	$LN8@Parse@5
$LN7@Parse@5:

; 1443 : 	{
; 1444 : 		// All attribute values should be in single or double quotes.
; 1445 : 		// But this is such a common error that the parser will try
; 1446 : 		// its best, even without them.
; 1447 : 		value = "";

	push	OFFSET $SG7538
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=
$LN5@Parse@5:

; 1448 : 		while (    p && *p											// existence
; 1449 : 				&& !IsWhiteSpace( *p ) && *p != '\n' && *p != '\r'	// whitespace
; 1450 : 				&& *p != '/' && *p != '>' )							// tag end

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN8@Parse@5
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN8@Parse@5
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?IsWhiteSpace@TiXmlBase@@KA_ND@Z	; TiXmlBase::IsWhiteSpace
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	$LN8@Parse@5
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN8@Parse@5
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN8@Parse@5
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN8@Parse@5
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	je	SHORT $LN8@Parse@5

; 1451 : 		{
; 1452 : 			if ( *p == SINGLE_QUOTE || *p == DOUBLE_QUOTE ) {

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	je	SHORT $LN2@Parse@5
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN3@Parse@5
$LN2@Parse@5:

; 1453 : 				// [ 1451649 ] Attribute values with trailing quotes not handled correctly
; 1454 : 				// We did not have an opening quote but seem to have a 
; 1455 : 				// closing one. Give up and throw an error.
; 1456 : 				if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN1@Parse@5
	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN1@Parse@5:

; 1457 : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN22@Parse@5
$LN3@Parse@5:

; 1458 : 			}
; 1459 : 			value += *p;

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??YTiXmlString@@QAEAAV0@D@Z		; TiXmlString::operator+=

; 1460 : 			++p;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 1461 : 		}

	jmp	$LN5@Parse@5
$LN8@Parse@5:

; 1462 : 	}
; 1463 : 	return p;

	mov	eax, DWORD PTR _p$[ebp]
$LN22@Parse@5:

; 1464 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Parse@TiXmlAttribute@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ENDP ; TiXmlAttribute::Parse
_TEXT	ENDS
xdata$x	SEGMENT
__unwindtable$?Parse@TiXmlText@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Parse@TiXmlText@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z$0
__ehfuncinfo$?Parse@TiXmlText@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Parse@TiXmlText@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T8208 = -40						; size = 4
_end$7568 = -36						; size = 4
_ignoreWhite$7567 = -29					; size = 1
_dummy$7564 = -28					; size = 4
_startTag$ = -24					; size = 4
_endTag$ = -20						; size = 4
_document$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_p$ = 8							; size = 4
_data$ = 12						; size = 4
_encoding$ = 16						; size = 4
?Parse@TiXmlText@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z PROC ; TiXmlText::Parse
; _this$ = ecx

; 1499 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Parse@TiXmlText@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1500 : 	value = "";

	push	OFFSET $SG7551
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=

; 1501 : 	TiXmlDocument* document = GetDocument();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDocument@TiXmlNode@@QAEPAVTiXmlDocument@@XZ ; TiXmlNode::GetDocument
	mov	DWORD PTR _document$[ebp], eax

; 1502 : 
; 1503 : 	if ( data )

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN8@Parse@6

; 1504 : 	{
; 1505 : 		data->Stamp( p, encoding );

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _data$[ebp]
	call	?Stamp@TiXmlParsingData@@QAEXPBDW4TiXmlEncoding@@@Z ; TiXmlParsingData::Stamp

; 1506 : 		location = data->Cursor();

	mov	ecx, DWORD PTR _data$[ebp]
	call	?Cursor@TiXmlParsingData@@QAEABUTiXmlCursor@@XZ ; TiXmlParsingData::Cursor
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
$LN8@Parse@6:

; 1507 : 	}
; 1508 : 
; 1509 : 	const char* const startTag = "<![CDATA[";

	mov	DWORD PTR _startTag$[ebp], OFFSET $SG7555

; 1510 : 	const char* const endTag   = "]]>";

	mov	DWORD PTR _endTag$[ebp], OFFSET $SG7557

; 1511 : 
; 1512 : 	if ( cdata || StringEqual( p, startTag, false, encoding ) )

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+44]
	test	eax, eax
	jne	SHORT $LN6@Parse@6
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _startTag$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@Parse@6
$LN6@Parse@6:

; 1513 : 	{
; 1514 : 		cdata = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+44], 1

; 1515 : 
; 1516 : 		if ( !StringEqual( p, startTag, false, encoding ) )

	mov	eax, DWORD PTR _encoding$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _startTag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Parse@6

; 1517 : 		{
; 1518 : 			document->SetError( TIXML_ERROR_PARSING_CDATA, p, data, encoding );

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	15					; 0000000fH
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError

; 1519 : 			return 0;

	xor	eax, eax
	jmp	$LN9@Parse@6
$LN5@Parse@6:

; 1520 : 		}
; 1521 : 		p += strlen( startTag );

	mov	ecx, DWORD PTR _startTag$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN4@Parse@6:

; 1522 : 
; 1523 : 		// Keep all the white space, ignore the encoding, etc.
; 1524 : 		while (	   p && *p
; 1525 : 				&& !StringEqual( p, endTag, false, encoding )
; 1526 : 			  )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@Parse@6
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@Parse@6
	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _endTag$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@Parse@6

; 1527 : 		{
; 1528 : 			value += *p;

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??YTiXmlString@@QAEAAV0@D@Z		; TiXmlString::operator+=

; 1529 : 			++p;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 1530 : 		}

	jmp	SHORT $LN4@Parse@6
$LN3@Parse@6:

; 1531 : 
; 1532 : 		TIXML_STRING dummy; 

	lea	ecx, DWORD PTR _dummy$7564[ebp]
	call	??0TiXmlString@@QAE@XZ			; TiXmlString::TiXmlString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1533 : 		p = ReadText( p, &dummy, false, endTag, false, encoding );

	mov	edx, DWORD PTR _encoding$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _endTag$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _dummy$7564[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?ReadText@TiXmlBase@@KAPBDPBDPAVTiXmlString@@_N02W4TiXmlEncoding@@@Z ; TiXmlBase::ReadText
	add	esp, 24					; 00000018H
	mov	DWORD PTR _p$[ebp], eax

; 1534 : 		return p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR $T8208[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _dummy$7564[ebp]
	call	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
	mov	eax, DWORD PTR $T8208[ebp]
	jmp	SHORT $LN9@Parse@6

; 1535 : 	}
; 1536 : 	else

	jmp	SHORT $LN9@Parse@6
$LN7@Parse@6:

; 1537 : 	{
; 1538 : 		bool ignoreWhite = true;

	mov	BYTE PTR _ignoreWhite$7567[ebp], 1

; 1539 : 
; 1540 : 		const char* end = "<";

	mov	DWORD PTR _end$7568[ebp], OFFSET $SG7569

; 1541 : 		p = ReadText( p, &value, ignoreWhite, end, false, encoding );

	mov	ecx, DWORD PTR _encoding$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _end$7568[ebp]
	push	edx
	movzx	eax, BYTE PTR _ignoreWhite$7567[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?ReadText@TiXmlBase@@KAPBDPBDPAVTiXmlString@@_N02W4TiXmlEncoding@@@Z ; TiXmlBase::ReadText
	add	esp, 24					; 00000018H
	mov	DWORD PTR _p$[ebp], eax

; 1542 : 		if ( p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN1@Parse@6

; 1543 : 			return p-1;	// don't truncate the '<'

	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, 1
	jmp	SHORT $LN9@Parse@6
$LN1@Parse@6:

; 1544 : 		return 0;

	xor	eax, eax
$LN9@Parse@6:

; 1545 : 	}
; 1546 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Parse@TiXmlText@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z$0:
	lea	ecx, DWORD PTR _dummy$7564[ebp]
	jmp	??1TiXmlString@@QAE@XZ			; TiXmlString::~TiXmlString
__ehhandler$?Parse@TiXmlText@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Parse@TiXmlText@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Parse@TiXmlText@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ENDP ; TiXmlText::Parse
xdata$x	SEGMENT
__unwindtable$?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z$2
__ehfuncinfo$?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -128						; size = 4
_attrib$7600 = -124					; size = 36
_attrib$7596 = -88					; size = 36
_attrib$7592 = -52					; size = 36
_document$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_p$ = 8							; size = 4
_data$ = 12						; size = 4
__encoding$ = 16					; size = 4
?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z PROC ; TiXmlDeclaration::Parse
; _this$ = ecx

; 1573 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1574 : 	p = SkipWhiteSpace( p, _encoding );

	mov	eax, DWORD PTR __encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 1575 : 	// Find the beginning, find the end, and look for
; 1576 : 	// the stuff in-between.
; 1577 : 	TiXmlDocument* document = GetDocument();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDocument@TiXmlNode@@QAEPAVTiXmlDocument@@XZ ; TiXmlNode::GetDocument
	mov	DWORD PTR _document$[ebp], eax

; 1578 : 	if ( !p || !*p || !StringEqual( p, "<?xml", true, _encoding ) )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN14@Parse@7
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN14@Parse@7
	mov	ecx, DWORD PTR __encoding$[ebp]
	push	ecx
	push	1
	push	OFFSET $SG7580
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN15@Parse@7
$LN14@Parse@7:

; 1579 : 	{
; 1580 : 		if ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0, _encoding );

	cmp	DWORD PTR _document$[ebp], 0
	je	SHORT $LN13@Parse@7
	mov	ecx, DWORD PTR __encoding$[ebp]
	push	ecx
	push	0
	push	0
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _document$[ebp]
	call	?SetError@TiXmlDocument@@QAEXHPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlDocument::SetError
$LN13@Parse@7:

; 1581 : 		return 0;

	xor	eax, eax
	jmp	$LN16@Parse@7
$LN15@Parse@7:

; 1582 : 	}
; 1583 : 	if ( data )

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN12@Parse@7

; 1584 : 	{
; 1585 : 		data->Stamp( p, _encoding );

	mov	edx, DWORD PTR __encoding$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	call	?Stamp@TiXmlParsingData@@QAEXPBDW4TiXmlEncoding@@@Z ; TiXmlParsingData::Stamp

; 1586 : 		location = data->Cursor();

	mov	ecx, DWORD PTR _data$[ebp]
	call	?Cursor@TiXmlParsingData@@QAEABUTiXmlCursor@@XZ ; TiXmlParsingData::Cursor
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
$LN12@Parse@7:

; 1587 : 	}
; 1588 : 	p += 5;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 5
	mov	DWORD PTR _p$[ebp], ecx

; 1589 : 
; 1590 : 	version = "";

	push	OFFSET $SG7583
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=

; 1591 : 	encoding = "";

	push	OFFSET $SG7584
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=

; 1592 : 	standalone = "";

	push	OFFSET $SG7585
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=
$LN11@Parse@7:

; 1593 : 
; 1594 : 	while ( p && *p )

	cmp	DWORD PTR _p$[ebp], 0
	je	$LN10@Parse@7
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN10@Parse@7

; 1595 : 	{
; 1596 : 		if ( *p == '>' )

	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 62					; 0000003eH
	jne	SHORT $LN9@Parse@7

; 1597 : 		{
; 1598 : 			++p;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 1599 : 			return p;

	mov	eax, DWORD PTR _p$[ebp]
	jmp	$LN16@Parse@7
$LN9@Parse@7:

; 1600 : 		}
; 1601 : 
; 1602 : 		p = SkipWhiteSpace( p, _encoding );

	mov	ecx, DWORD PTR __encoding$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	?SkipWhiteSpace@TiXmlBase@@KAPBDPBDW4TiXmlEncoding@@@Z ; TiXmlBase::SkipWhiteSpace
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 1603 : 		if ( StringEqual( p, "version", true, _encoding ) )

	mov	eax, DWORD PTR __encoding$[ebp]
	push	eax
	push	1
	push	OFFSET $SG7591
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@Parse@7

; 1604 : 		{
; 1605 : 			TiXmlAttribute attrib;

	lea	ecx, DWORD PTR _attrib$7592[ebp]
	call	??0TiXmlAttribute@@QAE@XZ		; TiXmlAttribute::TiXmlAttribute
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1606 : 			p = attrib.Parse( p, data, _encoding );		

	mov	eax, DWORD PTR __encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	lea	ecx, DWORD PTR _attrib$7592[ebp]
	call	?Parse@TiXmlAttribute@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlAttribute::Parse
	mov	DWORD PTR _p$[ebp], eax

; 1607 : 			version = attrib.Value();

	lea	ecx, DWORD PTR _attrib$7592[ebp]
	call	?Value@TiXmlAttribute@@QBEPBDXZ		; TiXmlAttribute::Value
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=

; 1608 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _attrib$7592[ebp]
	call	??1TiXmlAttribute@@UAE@XZ
	jmp	$LN7@Parse@7
$LN8@Parse@7:

; 1609 : 		else if ( StringEqual( p, "encoding", true, _encoding ) )

	mov	eax, DWORD PTR __encoding$[ebp]
	push	eax
	push	1
	push	OFFSET $SG7595
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@Parse@7

; 1610 : 		{
; 1611 : 			TiXmlAttribute attrib;

	lea	ecx, DWORD PTR _attrib$7596[ebp]
	call	??0TiXmlAttribute@@QAE@XZ		; TiXmlAttribute::TiXmlAttribute
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1612 : 			p = attrib.Parse( p, data, _encoding );		

	mov	eax, DWORD PTR __encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	lea	ecx, DWORD PTR _attrib$7596[ebp]
	call	?Parse@TiXmlAttribute@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlAttribute::Parse
	mov	DWORD PTR _p$[ebp], eax

; 1613 : 			encoding = attrib.Value();

	lea	ecx, DWORD PTR _attrib$7596[ebp]
	call	?Value@TiXmlAttribute@@QBEPBDXZ		; TiXmlAttribute::Value
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=

; 1614 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _attrib$7596[ebp]
	call	??1TiXmlAttribute@@UAE@XZ
	jmp	$LN7@Parse@7
$LN6@Parse@7:

; 1615 : 		else if ( StringEqual( p, "standalone", true, _encoding ) )

	mov	eax, DWORD PTR __encoding$[ebp]
	push	eax
	push	1
	push	OFFSET $SG7599
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	?StringEqual@TiXmlBase@@KA_NPBD0_NW4TiXmlEncoding@@@Z ; TiXmlBase::StringEqual
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@Parse@7

; 1616 : 		{
; 1617 : 			TiXmlAttribute attrib;

	lea	ecx, DWORD PTR _attrib$7600[ebp]
	call	??0TiXmlAttribute@@QAE@XZ		; TiXmlAttribute::TiXmlAttribute
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 1618 : 			p = attrib.Parse( p, data, _encoding );		

	mov	eax, DWORD PTR __encoding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	lea	ecx, DWORD PTR _attrib$7600[ebp]
	call	?Parse@TiXmlAttribute@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ; TiXmlAttribute::Parse
	mov	DWORD PTR _p$[ebp], eax

; 1619 : 			standalone = attrib.Value();

	lea	ecx, DWORD PTR _attrib$7600[ebp]
	call	?Value@TiXmlAttribute@@QBEPBDXZ		; TiXmlAttribute::Value
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	??4TiXmlString@@QAEAAV0@PBD@Z		; TiXmlString::operator=

; 1620 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _attrib$7600[ebp]
	call	??1TiXmlAttribute@@UAE@XZ

; 1621 : 		else

	jmp	SHORT $LN7@Parse@7
$LN2@Parse@7:

; 1622 : 		{
; 1623 : 			// Read over whatever it is.
; 1624 : 			while( p && *p && *p != '>' && !IsWhiteSpace( *p ) )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN7@Parse@7
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN7@Parse@7
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN7@Parse@7
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?IsWhiteSpace@TiXmlBase@@KA_ND@Z	; TiXmlBase::IsWhiteSpace
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@Parse@7

; 1625 : 				++p;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN2@Parse@7
$LN7@Parse@7:

; 1626 : 		}
; 1627 : 	}

	jmp	$LN11@Parse@7
$LN10@Parse@7:

; 1628 : 	return 0;

	xor	eax, eax
$LN16@Parse@7:

; 1629 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z$0:
	lea	ecx, DWORD PTR _attrib$7592[ebp]
	jmp	??1TiXmlAttribute@@UAE@XZ
__unwindfunclet$?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z$1:
	lea	ecx, DWORD PTR _attrib$7596[ebp]
	jmp	??1TiXmlAttribute@@UAE@XZ
__unwindfunclet$?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z$2:
	lea	ecx, DWORD PTR _attrib$7600[ebp]
	jmp	??1TiXmlAttribute@@UAE@XZ
__ehhandler$?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Parse@TiXmlDeclaration@@UAEPBDPBDPAVTiXmlParsingData@@W4TiXmlEncoding@@@Z ENDP ; TiXmlDeclaration::Parse
PUBLIC	??ATiXmlString@@QBEAADI@Z			; TiXmlString::operator[]
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$7608 = -4						; size = 4
?Blank@TiXmlText@@IBE_NXZ PROC				; TiXmlText::Blank
; _this$ = ecx

; 1632 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1633 : 	for ( unsigned i=0; i<value.length(); i++ )

	mov	DWORD PTR _i$7608[ebp], 0
	jmp	SHORT $LN4@Blank
$LN3@Blank:
	mov	eax, DWORD PTR _i$7608[ebp]
	add	eax, 1
	mov	DWORD PTR _i$7608[ebp], eax
$LN4@Blank:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?length@TiXmlString@@QBEIXZ		; TiXmlString::length
	cmp	DWORD PTR _i$7608[ebp], eax
	jae	SHORT $LN2@Blank

; 1634 : 		if ( !IsWhiteSpace( value[i] ) )

	mov	ecx, DWORD PTR _i$7608[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??ATiXmlString@@QBEAADI@Z		; TiXmlString::operator[]
	movzx	edx, BYTE PTR [eax]
	push	edx
	call	?IsWhiteSpace@TiXmlBase@@KA_ND@Z	; TiXmlBase::IsWhiteSpace
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@Blank

; 1635 : 			return false;

	xor	al, al
	jmp	SHORT $LN5@Blank
$LN1@Blank:

; 1636 : 	return true;

	jmp	SHORT $LN3@Blank
$LN2@Blank:
	mov	al, 1
$LN5@Blank:

; 1637 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Blank@TiXmlText@@IBE_NXZ ENDP				; TiXmlText::Blank
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\tinystr.h
_TEXT	ENDS
;	COMDAT ??ATiXmlString@@QBEAADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??ATiXmlString@@QBEAADI@Z PROC				; TiXmlString::operator[], COMDAT
; _this$ = ecx

; 169  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 		assert( index < length() );
; 171  : 		return rep_->str[ index ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [ecx+edx+8]

; 172  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??ATiXmlString@@QBEAADI@Z ENDP				; TiXmlString::operator[]
_TEXT	ENDS
END

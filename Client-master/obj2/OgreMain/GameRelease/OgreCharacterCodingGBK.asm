; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\OgreCharacterCodingGBK.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5714
_DATA	ENDS
CONST	SEGMENT
$SG5714	DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::StringUtil::operator=
; Function compile flags: /Odtp
;	COMDAT ??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::StringUtil::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::StringUtil::operator=
_TEXT	ENDS
PUBLIC	?JumpOverSpaces@CharacterCodingGbk@Ogre@@UAEHPBD@Z ; Ogre::CharacterCodingGbk::JumpOverSpaces
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrecharactercodinggbk.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nRet$ = -8						; size = 4
_p$ = -4						; size = 4
_pText$ = 8						; size = 4
?JumpOverSpaces@CharacterCodingGbk@Ogre@@UAEHPBD@Z PROC	; Ogre::CharacterCodingGbk::JumpOverSpaces
; _this$ = ecx

; 8    : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 9    : 		int nRet = 0;

	mov	DWORD PTR _nRet$[ebp], 0

; 10   : 		const unsigned char *p = (const unsigned char*)pText;

	mov	eax, DWORD PTR _pText$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN6@JumpOverSp:

; 11   : 
; 12   : 		while(1)

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN5@JumpOverSp

; 13   : 		{
; 14   : 			if(*p == ' ')							//半角空格

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN4@JumpOverSp

; 15   : 				p++ , nRet++;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _nRet$[ebp]
	add	edx, 1
	mov	DWORD PTR _nRet$[ebp], edx
	jmp	SHORT $LN3@JumpOverSp
$LN4@JumpOverSp:

; 16   : 			else if(*p == 0xa1 && *(p+1) == 0xa1)	//全角空格

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 161				; 000000a1H
	jne	SHORT $LN2@JumpOverSp
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 161				; 000000a1H
	jne	SHORT $LN2@JumpOverSp

; 17   : 				p += 2 , nRet += 2;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 2
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _nRet$[ebp]
	add	edx, 2
	mov	DWORD PTR _nRet$[ebp], edx

; 18   : 			else

	jmp	SHORT $LN3@JumpOverSp
$LN2@JumpOverSp:

; 19   : 				break;

	jmp	SHORT $LN5@JumpOverSp
$LN3@JumpOverSp:

; 20   : 		}

	jmp	SHORT $LN6@JumpOverSp
$LN5@JumpOverSp:

; 21   : 		return nRet;

	mov	eax, DWORD PTR _nRet$[ebp]

; 22   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?JumpOverSpaces@CharacterCodingGbk@Ogre@@UAEHPBD@Z ENDP	; Ogre::CharacterCodingGbk::JumpOverSpaces
_TEXT	ENDS
PUBLIC	?GetAChar@CharacterCodingGbk@Ogre@@UAEHPBDPAE@Z	; Ogre::CharacterCodingGbk::GetAChar
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -20						; size = 4
_c$ = -14						; size = 1
_c1$ = -13						; size = 1
_nStartCharInGroup$ = -12				; size = 4
_nStartGroup$ = -8					; size = 4
_p$ = -4						; size = 4
_pText$ = 8						; size = 4
_pChar$ = 12						; size = 4
?GetAChar@CharacterCodingGbk@Ogre@@UAEHPBDPAE@Z PROC	; Ogre::CharacterCodingGbk::GetAChar
; _this$ = ecx

; 25   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 26   : 		if(!pText || sizeof(pText) <= 1)

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN7@GetAChar
	xor	eax, eax
	je	SHORT $LN8@GetAChar
$LN7@GetAChar:

; 27   : 			return 0;

	xor	eax, eax
	jmp	$LN9@GetAChar
$LN8@GetAChar:

; 28   : 
; 29   : 		int nStartGroup = 0x81;

	mov	DWORD PTR _nStartGroup$[ebp], 129	; 00000081H

; 30   : 		int nStartCharInGroup = 0x40;

	mov	DWORD PTR _nStartCharInGroup$[ebp], 64	; 00000040H

; 31   : 
; 32   : 		const unsigned char *p = (unsigned char *)pText;

	mov	ecx, DWORD PTR _pText$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 33   : 		unsigned char c = *p;

	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _c$[ebp], al

; 34   : 		unsigned char c1 = *(p + 1);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _c1$[ebp], dl

; 35   : 		if(c >= nStartGroup)									//中文

	movzx	eax, BYTE PTR _c$[ebp]
	cmp	eax, DWORD PTR _nStartGroup$[ebp]
	jl	SHORT $LN6@GetAChar

; 36   : 		{
; 37   : 			pChar[0] = c;

	mov	ecx, DWORD PTR _pChar$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [ecx], dl

; 38   : 			pChar[1] = c1;

	mov	eax, DWORD PTR _pChar$[ebp]
	mov	cl, BYTE PTR _c1$[ebp]
	mov	BYTE PTR [eax+1], cl

; 39   : 			pChar[2] = 0;

	mov	edx, DWORD PTR _pChar$[ebp]
	mov	BYTE PTR [edx+2], 0

; 40   : 			if ( c1 == 0 )

	movzx	eax, BYTE PTR _c1$[ebp]
	test	eax, eax
	jne	SHORT $LN5@GetAChar

; 41   : 			{
; 42   : 				return 1;

	mov	eax, 1
	jmp	SHORT $LN9@GetAChar

; 43   : 			}
; 44   : 			else

	jmp	SHORT $LN4@GetAChar
$LN5@GetAChar:

; 45   : 			{
; 46   : 				return 2;

	mov	eax, 2
	jmp	SHORT $LN9@GetAChar
$LN4@GetAChar:

; 47   : 			}

	jmp	SHORT $LN9@GetAChar
$LN6@GetAChar:

; 48   : 		}
; 49   : 		else if ((c >= 32) && (c <= 127))				//英文，包括空格

	movzx	ecx, BYTE PTR _c$[ebp]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN2@GetAChar
	movzx	edx, BYTE PTR _c$[ebp]
	cmp	edx, 127				; 0000007fH
	jg	SHORT $LN2@GetAChar

; 50   : 		{
; 51   : 			pChar[0] = 0;

	mov	eax, DWORD PTR _pChar$[ebp]
	mov	BYTE PTR [eax], 0

; 52   : 			pChar[1] = c;

	mov	ecx, DWORD PTR _pChar$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 53   : 			pChar[2] = 0;

	mov	eax, DWORD PTR _pChar$[ebp]
	mov	BYTE PTR [eax+2], 0

; 54   : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN9@GetAChar

; 55   : 		}
; 56   : 		else

	jmp	SHORT $LN9@GetAChar
$LN2@GetAChar:

; 57   : 		{
; 58   : 			pChar[0] = 0;

	mov	ecx, DWORD PTR _pChar$[ebp]
	mov	BYTE PTR [ecx], 0

; 59   : 			pChar[1] = 0;

	mov	edx, DWORD PTR _pChar$[ebp]
	mov	BYTE PTR [edx+1], 0

; 60   : 			return 1;

	mov	eax, 1
$LN9@GetAChar:

; 61   : 		}
; 62   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?GetAChar@CharacterCodingGbk@Ogre@@UAEHPBDPAE@Z ENDP	; Ogre::CharacterCodingGbk::GetAChar
_TEXT	ENDS
PUBLIC	?GetCharBytes@CharacterCodingGbk@Ogre@@UAEHPBE@Z ; Ogre::CharacterCodingGbk::GetCharBytes
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pChar$ = 8						; size = 4
?GetCharBytes@CharacterCodingGbk@Ogre@@UAEHPBE@Z PROC	; Ogre::CharacterCodingGbk::GetCharBytes
; _this$ = ecx

; 65   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 		if( pChar[0] >= 0x81 )

	mov	eax, DWORD PTR _pChar$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 129				; 00000081H
	jl	SHORT $LN2@GetCharByt

; 67   : 			return 2;			// 中文

	mov	eax, 2
	jmp	SHORT $LN3@GetCharByt

; 68   : 		else

	jmp	SHORT $LN3@GetCharByt
$LN2@GetCharByt:

; 69   : 			return 1;			// 英文

	mov	eax, 1
$LN3@GetCharByt:

; 70   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCharBytes@CharacterCodingGbk@Ogre@@UAEHPBE@Z ENDP	; Ogre::CharacterCodingGbk::GetCharBytes
_TEXT	ENDS
PUBLIC	?GetControlCode@CharacterCodingGbk@Ogre@@UAEHPBDAAW4EControlCode@2@_N@Z ; Ogre::CharacterCodingGbk::GetControlCode
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_c$ = -6						; size = 1
_c1$ = -5						; size = 1
_p$ = -4						; size = 4
_pText$ = 8						; size = 4
_eCtrlCode$ = 12					; size = 4
_bDoTransfer$ = 16					; size = 1
?GetControlCode@CharacterCodingGbk@Ogre@@UAEHPBDAAW4EControlCode@2@_N@Z PROC ; Ogre::CharacterCodingGbk::GetControlCode
; _this$ = ecx

; 73   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 74   : 		if(!pText)

	cmp	DWORD PTR _pText$[ebp], 0
	jne	SHORT $LN10@GetControl

; 75   : 			return 0;

	xor	eax, eax
	jmp	$LN11@GetControl
$LN10@GetControl:

; 76   : 		
; 77   : 		const unsigned char *p = (unsigned char *)pText;

	mov	eax, DWORD PTR _pText$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 78   : 		unsigned char c = *p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$[ebp], dl

; 79   : 		
; 80   : 		if(c == 0)

	movzx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	jne	SHORT $LN9@GetControl

; 81   : 		{
; 82   : 			eCtrlCode = CTRLCODE_ENDOFSTRING;

	mov	ecx, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR [ecx], 3

; 83   : 			return 0;

	xor	eax, eax
	jmp	$LN11@GetControl
$LN9@GetControl:

; 84   : 		}
; 85   : 
; 86   : 		unsigned char c1 = *(p + 1);

	mov	edx, DWORD PTR _p$[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _c1$[ebp], al

; 87   : 		if(c == '\n')

	movzx	ecx, BYTE PTR _c$[ebp]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN8@GetControl

; 88   : 		{
; 89   : 			eCtrlCode = CTRLCODE_NEWLINE;

	mov	edx, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR [edx], 2

; 90   : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN11@GetControl
	jmp	SHORT $LN11@GetControl
$LN8@GetControl:

; 91   : 		}
; 92   : 		else if(c == '\\' && c1 == 'n')

	movzx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN6@GetControl
	movzx	ecx, BYTE PTR _c1$[ebp]
	cmp	ecx, 110				; 0000006eH
	jne	SHORT $LN6@GetControl

; 93   : 		{
; 94   : 			eCtrlCode = CTRLCODE_NEWLINE;

	mov	edx, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR [edx], 2

; 95   : 			return 2;

	mov	eax, 2
	jmp	SHORT $LN11@GetControl
	jmp	SHORT $LN11@GetControl
$LN6@GetControl:

; 96   : 		}
; 97   : 		else if(c == '\r')

	movzx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN4@GetControl

; 98   : 		{
; 99   : 			eCtrlCode = CTRLCODE_RETURN;

	mov	ecx, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR [ecx], 1

; 100  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN11@GetControl
	jmp	SHORT $LN11@GetControl
$LN4@GetControl:

; 101  : 		}
; 102  : 		else if( bDoTransfer && c == '#' && c1 != '#')

	movzx	edx, BYTE PTR _bDoTransfer$[ebp]
	test	edx, edx
	je	SHORT $LN2@GetControl
	movzx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN2@GetControl
	movzx	ecx, BYTE PTR _c1$[ebp]
	cmp	ecx, 35					; 00000023H
	je	SHORT $LN2@GetControl

; 103  : 		{
; 104  : 			eCtrlCode = CTRLCODE_TRANSFER;

	mov	edx, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR [edx], 4

; 105  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN11@GetControl

; 106  : 		}
; 107  : 		else

	jmp	SHORT $LN11@GetControl
$LN2@GetControl:

; 108  : 		{
; 109  : 			eCtrlCode = CTRLCODE_CHARACTER;

	mov	eax, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR [eax], 0

; 110  : 			return 0;

	xor	eax, eax
$LN11@GetControl:

; 111  : 		}
; 112  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetControlCode@CharacterCodingGbk@Ogre@@UAEHPBDAAW4EControlCode@2@_N@Z ENDP ; Ogre::CharacterCodingGbk::GetControlCode
_TEXT	ENDS
PUBLIC	?IsEnglish@CharacterCodingGbk@Ogre@@UAE_NPBE@Z	; Ogre::CharacterCodingGbk::IsEnglish
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pChar$ = 8						; size = 4
?IsEnglish@CharacterCodingGbk@Ogre@@UAE_NPBE@Z PROC	; Ogre::CharacterCodingGbk::IsEnglish
; _this$ = ecx

; 115  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		if( pChar[1] >= 33 && pChar[1] <= 127 )

	mov	eax, DWORD PTR _pChar$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 33					; 00000021H
	jl	SHORT $LN2@IsEnglish
	mov	edx, DWORD PTR _pChar$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 127				; 0000007fH
	jg	SHORT $LN2@IsEnglish

; 117  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@IsEnglish

; 118  : 		else

	jmp	SHORT $LN3@IsEnglish
$LN2@IsEnglish:

; 119  : 			return false;

	xor	al, al
$LN3@IsEnglish:

; 120  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?IsEnglish@CharacterCodingGbk@Ogre@@UAE_NPBE@Z ENDP	; Ogre::CharacterCodingGbk::IsEnglish
_TEXT	ENDS
PUBLIC	?IsPunctuation@CharacterCodingGbk@Ogre@@UAE_NPBE@Z ; Ogre::CharacterCodingGbk::IsPunctuation
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pChar$ = 8						; size = 4
?IsPunctuation@CharacterCodingGbk@Ogre@@UAE_NPBE@Z PROC	; Ogre::CharacterCodingGbk::IsPunctuation
; _this$ = ecx

; 123  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		if( pChar[0] == 0 && (pChar[1] == ',' || pChar[1] == '.' || pChar[1] == '!' || 
; 125  : 			pChar[1] == '?' || pChar[1] == ':' || pChar[1] == ';') )

	mov	eax, DWORD PTR _pChar$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@IsPunctuat
	mov	edx, DWORD PTR _pChar$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN2@IsPunctuat
	mov	ecx, DWORD PTR _pChar$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 46					; 0000002eH
	je	SHORT $LN2@IsPunctuat
	mov	eax, DWORD PTR _pChar$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 33					; 00000021H
	je	SHORT $LN2@IsPunctuat
	mov	edx, DWORD PTR _pChar$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN2@IsPunctuat
	mov	ecx, DWORD PTR _pChar$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN2@IsPunctuat
	mov	eax, DWORD PTR _pChar$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 59					; 0000003bH
	jne	SHORT $LN3@IsPunctuat
$LN2@IsPunctuat:

; 126  : 			return true;

	mov	al, 1
	jmp	SHORT $LN4@IsPunctuat

; 127  : 		else

	jmp	SHORT $LN4@IsPunctuat
$LN3@IsPunctuat:

; 128  : 			return false;

	xor	al, al
$LN4@IsPunctuat:

; 129  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?IsPunctuation@CharacterCodingGbk@Ogre@@UAE_NPBE@Z ENDP	; Ogre::CharacterCodingGbk::IsPunctuation
_TEXT	ENDS
PUBLIC	?ToUnicode@CharacterCodingGbk@Ogre@@UAEGPBE@Z	; Ogre::CharacterCodingGbk::ToUnicode
EXTRN	?AnsiToUnicode@StringUtil@Ogre@@SAHPA_WHPBDH@Z:PROC ; Ogre::StringUtil::AnsiToUnicode
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_wChar$ = -4						; size = 2
_pChar$ = 8						; size = 4
?ToUnicode@CharacterCodingGbk@Ogre@@UAEGPBE@Z PROC	; Ogre::CharacterCodingGbk::ToUnicode
; _this$ = ecx

; 132  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 133  : 		wchar_t wChar;
; 134  : 		if(pChar[0] == 0)

	mov	eax, DWORD PTR _pChar$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@ToUnicode

; 135  : 			StringUtil::AnsiToUnicode(&wChar, 1, (const char*)pChar+1, 1);

	push	1
	mov	edx, DWORD PTR _pChar$[ebp]
	add	edx, 1
	push	edx
	push	1
	lea	eax, DWORD PTR _wChar$[ebp]
	push	eax
	call	?AnsiToUnicode@StringUtil@Ogre@@SAHPA_WHPBDH@Z ; Ogre::StringUtil::AnsiToUnicode
	add	esp, 16					; 00000010H

; 136  : 		else

	jmp	SHORT $LN1@ToUnicode
$LN2@ToUnicode:

; 137  : 			StringUtil::AnsiToUnicode(&wChar, 1, (const char*)pChar, 2);

	push	2
	mov	ecx, DWORD PTR _pChar$[ebp]
	push	ecx
	push	1
	lea	edx, DWORD PTR _wChar$[ebp]
	push	edx
	call	?AnsiToUnicode@StringUtil@Ogre@@SAHPA_WHPBDH@Z ; Ogre::StringUtil::AnsiToUnicode
	add	esp, 16					; 00000010H
$LN1@ToUnicode:

; 138  : 
; 139  : 		return wChar;

	mov	ax, WORD PTR _wChar$[ebp]

; 140  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?ToUnicode@CharacterCodingGbk@Ogre@@UAEGPBE@Z ENDP	; Ogre::CharacterCodingGbk::ToUnicode
_TEXT	ENDS
PUBLIC	?ToUniqueID@CharacterCodingGbk@Ogre@@UAEIPBE@Z	; Ogre::CharacterCodingGbk::ToUniqueID
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pChar$ = 8						; size = 4
?ToUniqueID@CharacterCodingGbk@Ogre@@UAEIPBE@Z PROC	; Ogre::CharacterCodingGbk::ToUniqueID
; _this$ = ecx

; 143  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 144  : 		if( pChar[0] == 0 )

	mov	eax, DWORD PTR _pChar$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@ToUniqueID

; 145  : 			return pChar[1];

	mov	edx, DWORD PTR _pChar$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	jmp	SHORT $LN3@ToUniqueID

; 146  : 		else

	jmp	SHORT $LN3@ToUniqueID
$LN2@ToUniqueID:

; 147  : 			return ( (uint)pChar[0] ) * 256 + pChar[1];

	mov	eax, DWORD PTR _pChar$[ebp]
	movzx	eax, BYTE PTR [eax]
	shl	eax, 8
	mov	ecx, DWORD PTR _pChar$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	add	eax, edx
$LN3@ToUniqueID:

; 148  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?ToUniqueID@CharacterCodingGbk@Ogre@@UAEIPBE@Z ENDP	; Ogre::CharacterCodingGbk::ToUniqueID
_TEXT	ENDS
END

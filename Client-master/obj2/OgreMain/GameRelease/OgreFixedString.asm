; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\OgreFixedString.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5713
_DATA	ENDS
CONST	SEGMENT
$SG5713	DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z	; Ogre::FixedString::handle2Ptr
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefixedstring.h
;	COMDAT ?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z
_TEXT	SEGMENT
_h$ = 8							; size = 4
?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z PROC		; Ogre::FixedString::handle2Ptr, COMDAT

; 22   : 		{

	push	ebp
	mov	ebp, esp

; 23   : 			return (const char *)h;

	mov	eax, DWORD PTR _h$[ebp]

; 24   : 		}

	pop	ebp
	ret	0
?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ENDP		; Ogre::FixedString::handle2Ptr
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@XZ			; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0FixedString@Ogre@@QAE@XZ PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 27   : 		FixedString() : m_StrHandle(NULL){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0FixedString@Ogre@@QAE@XZ ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	?addRef@FixedString@Ogre@@SAXPAX@Z		; Ogre::FixedString::addRef
PUBLIC	??0FixedString@Ogre@@QAE@PAX@Z			; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h$ = 8							; size = 4
??0FixedString@Ogre@@QAE@PAX@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 29   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [eax], ecx

; 30   : 			addRef(h);

	mov	edx, DWORD PTR _h$[ebp]
	push	edx
	call	?addRef@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::addRef
	add	esp, 4

; 31   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@PAX@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@ABV01@@Z		; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??0FixedString@Ogre@@QAE@ABV01@@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 34   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 35   : 			addRef(m_StrHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?addRef@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::addRef
	add	esp, 4

; 36   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	?insert@FixedString@Ogre@@SAPAXPBDH@Z		; Ogre::FixedString::insert
PUBLIC	??0FixedString@Ogre@@QAE@PBD@Z			; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstr$ = 8						; size = 4
??0FixedString@Ogre@@QAE@PBD@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 38   : 		FixedString(const char *pstr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 		{
; 40   : 			m_StrHandle = insert(pstr); 

	push	-1
	mov	eax, DWORD PTR _pstr$[ebp]
	push	eax
	call	?insert@FixedString@Ogre@@SAPAXPBDH@Z	; Ogre::FixedString::insert
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 41   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@PBD@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PBDI@Z			; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstr$ = 8						; size = 4
_len$ = 12						; size = 4
??0FixedString@Ogre@@QAE@PBDI@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 43   : 		FixedString(const char *pstr, size_t len)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 		{
; 45   : 			m_StrHandle = insert(pstr, (int)len); 

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pstr$[ebp]
	push	ecx
	call	?insert@FixedString@Ogre@@SAPAXPBDH@Z	; Ogre::FixedString::insert
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 46   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0FixedString@Ogre@@QAE@PBDI@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	?release@FixedString@Ogre@@SAXPAX@Z		; Ogre::FixedString::release
PUBLIC	??1FixedString@Ogre@@QAE@XZ			; Ogre::FixedString::~FixedString
; Function compile flags: /Odtp
;	COMDAT ??1FixedString@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1FixedString@Ogre@@QAE@XZ PROC			; Ogre::FixedString::~FixedString, COMDAT
; _this$ = ecx

; 49   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 			release(m_StrHandle); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?release@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::release
	add	esp, 4

; 51   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1FixedString@Ogre@@QAE@XZ ENDP			; Ogre::FixedString::~FixedString
_TEXT	ENDS
PUBLIC	??BFixedString@Ogre@@QBEPBDXZ			; Ogre::FixedString::operator char const *
; Function compile flags: /Odtp
;	COMDAT ??BFixedString@Ogre@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BFixedString@Ogre@@QBEPBDXZ PROC			; Ogre::FixedString::operator char const *, COMDAT
; _this$ = ecx

; 54   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 			return handle2Ptr(m_StrHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ; Ogre::FixedString::handle2Ptr
	add	esp, 4

; 56   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??BFixedString@Ogre@@QBEPBDXZ ENDP			; Ogre::FixedString::operator char const *
_TEXT	ENDS
PUBLIC	?getHandle@FixedString@Ogre@@QBEPAXXZ		; Ogre::FixedString::getHandle
; Function compile flags: /Odtp
;	COMDAT ?getHandle@FixedString@Ogre@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHandle@FixedString@Ogre@@QBEPAXXZ PROC		; Ogre::FixedString::getHandle, COMDAT
; _this$ = ecx

; 59   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 			return m_StrHandle;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 61   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getHandle@FixedString@Ogre@@QBEPAXXZ ENDP		; Ogre::FixedString::getHandle
_TEXT	ENDS
PUBLIC	??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::StringUtil::operator=
; Function compile flags: /Odtp
;	COMDAT ??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::StringUtil::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::StringUtil::operator=
_TEXT	ENDS
PUBLIC	??4LockSection@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::LockSection::operator=
; Function compile flags: /Odtp
;	COMDAT ??4LockSection@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4LockSection@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::LockSection::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4LockSection@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::LockSection::operator=
_TEXT	ENDS
PUBLIC	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z	; Ogre::LockFunctor::LockFunctor
EXTRN	?Lock@LockSection@Ogre@@QAEXXZ:PROC		; Ogre::LockSection::Lock
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrelocker.h
;	COMDAT ??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSection$ = 8						; size = 4
??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z PROC	; Ogre::LockFunctor::LockFunctor, COMDAT
; _this$ = ecx

; 26   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax], ecx

; 27   : 			if(m_pSection == NULL) return;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN1@LockFuncto
	jmp	SHORT $LN2@LockFuncto
$LN1@LockFuncto:

; 28   : 			assert( m_pSection );
; 29   : 			m_pSection->Lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?Lock@LockSection@Ogre@@QAEXXZ		; Ogre::LockSection::Lock
$LN2@LockFuncto:

; 30   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ENDP	; Ogre::LockFunctor::LockFunctor
_TEXT	ENDS
PUBLIC	??1LockFunctor@Ogre@@QAE@XZ			; Ogre::LockFunctor::~LockFunctor
EXTRN	?Unlock@LockSection@Ogre@@QAEXXZ:PROC		; Ogre::LockSection::Unlock
; Function compile flags: /Odtp
;	COMDAT ??1LockFunctor@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1LockFunctor@Ogre@@QAE@XZ PROC			; Ogre::LockFunctor::~LockFunctor, COMDAT
; _this$ = ecx

; 33   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 34   : 			if( m_pSection )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@LockFuncto@2

; 35   : 			{
; 36   : 				m_pSection->Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?Unlock@LockSection@Ogre@@QAEXXZ	; Ogre::LockSection::Unlock
$LN2@LockFuncto@2:

; 37   : 			}			
; 38   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1LockFunctor@Ogre@@QAE@XZ ENDP			; Ogre::LockFunctor::~LockFunctor
_TEXT	ENDS
PUBLIC	??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::LockFunctor::operator=
; Function compile flags: /Odtp
;	COMDAT ??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::LockFunctor::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::LockFunctor::operator=
_TEXT	ENDS
PUBLIC	?StringHash@Ogre@@YAIPBDH@Z			; Ogre::StringHash
EXTRN	_memcpy:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	_strlen:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_s_HashTable DD	0201H DUP (?)
_s_pLockSection DD 01H DUP (?)
_BSS	ENDS
xdata$x	SEGMENT
__unwindtable$?insert@FixedString@Ogre@@SAPAXPBDH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?insert@FixedString@Ogre@@SAPAXPBDH@Z$0
__ehfuncinfo$?insert@FixedString@Ogre@@SAPAXPBDH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?insert@FixedString@Ogre@@SAPAXPBDH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefixedstring.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T119629 = -40						; size = 4
$T119628 = -36						; size = 4
_mylock$ = -32						; size = 4
_pcur$ = -28						; size = 4
_alloc_len$ = -24					; size = 4
_i$ = -20						; size = 4
_pdststr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pstr$ = 8						; size = 4
_len$ = 12						; size = 4
?insert@FixedString@Ogre@@SAPAXPBDH@Z PROC		; Ogre::FixedString::insert

; 37   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?insert@FixedString@Ogre@@SAPAXPBDH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 38   : 		if( pstr == NULL ) return NULL;

	cmp	DWORD PTR _pstr$[ebp], 0
	jne	SHORT $LN5@insert
	xor	eax, eax
	jmp	$LN6@insert
$LN5@insert:

; 39   : 
; 40   : 		if(len < 0) len = (int)strlen(pstr);

	cmp	DWORD PTR _len$[ebp], 0
	jge	SHORT $LN4@insert
	mov	eax, DWORD PTR _pstr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN4@insert:

; 41   : 
; 42   : 		unsigned int i = StringHash(pstr, len) % STR_HASH_BUFLEN;

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pstr$[ebp]
	push	edx
	call	?StringHash@Ogre@@YAIPBDH@Z		; Ogre::StringHash
	add	esp, 8
	xor	edx, edx
	mov	ecx, 513				; 00000201H
	div	ecx
	mov	DWORD PTR _i$[ebp], edx

; 43   : 
; 44   : 		LockFunctor mylock(s_pLockSection);

	mov	edx, DWORD PTR _s_pLockSection
	push	edx
	lea	ecx, DWORD PTR _mylock$[ebp]
	call	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ; Ogre::LockFunctor::LockFunctor
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 45   : 
; 46   : 		stShareString *pcur = s_HashTable[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _s_HashTable[eax*4]
	mov	DWORD PTR _pcur$[ebp], ecx
$LN3@insert:

; 47   : 		while(pcur != NULL)

	cmp	DWORD PTR _pcur$[ebp], 0
	je	SHORT $LN2@insert

; 48   : 		{
; 49   : 			if(len==strlen(STRUCT2STR(pcur)) && strncmp(pstr, STRUCT2STR(pcur), len) == 0 )

	mov	edx, DWORD PTR _pcur$[ebp]
	add	edx, 8
	push	edx
	call	_strlen
	add	esp, 4
	cmp	DWORD PTR _len$[ebp], eax
	jne	SHORT $LN1@insert
	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcur$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _pstr$[ebp]
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@insert

; 50   : 			{
; 51   : 				pcur->refcount++;

	mov	eax, DWORD PTR _pcur$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _pcur$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 52   : 				return (FIXED_STRING_HANDLE)STRUCT2STR(pcur);

	mov	eax, DWORD PTR _pcur$[ebp]
	add	eax, 8
	mov	DWORD PTR $T119628[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mylock$[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
	mov	eax, DWORD PTR $T119628[ebp]
	jmp	$LN6@insert
$LN1@insert:

; 53   : 			}
; 54   : 
; 55   : 			pcur = pcur->pnext;

	mov	ecx, DWORD PTR _pcur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pcur$[ebp], edx

; 56   : 		}

	jmp	SHORT $LN3@insert
$LN2@insert:

; 57   : 
; 58   : 		size_t alloc_len = len + 1 + sizeof(stShareString);

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 9
	mov	DWORD PTR _alloc_len$[ebp], eax

; 59   : 		alloc_len += sizeof(size_t) - (alloc_len%sizeof(size_t));

	mov	eax, DWORD PTR _alloc_len$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	add	eax, DWORD PTR _alloc_len$[ebp]
	mov	DWORD PTR _alloc_len$[ebp], eax

; 60   : 
; 61   : 		pcur = (stShareString *)malloc(alloc_len);

	mov	ecx, DWORD PTR _alloc_len$[ebp]
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _pcur$[ebp], eax

; 62   : 		pcur->pnext = s_HashTable[i];

	mov	edx, DWORD PTR _pcur$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _s_HashTable[eax*4]
	mov	DWORD PTR [edx], ecx

; 63   : 		s_HashTable[i] = pcur;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pcur$[ebp]
	mov	DWORD PTR _s_HashTable[edx*4], eax

; 64   : 
; 65   : 		pcur->refcount = 1;

	mov	ecx, DWORD PTR _pcur$[ebp]
	mov	DWORD PTR [ecx+4], 1

; 66   : #ifdef _DEBUG
; 67   : 		pcur->hash = StringHash(pstr, len);
; 68   : #endif
; 69   : 
; 70   : 		char *pdststr = STRUCT2STR(pcur);

	mov	edx, DWORD PTR _pcur$[ebp]
	add	edx, 8
	mov	DWORD PTR _pdststr$[ebp], edx

; 71   : 		memcpy(pdststr, pstr, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pstr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdststr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 72   : 		pdststr[len] = '\0';

	mov	eax, DWORD PTR _pdststr$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 0

; 73   : 
; 74   : 		return (FIXED_STRING_HANDLE)pdststr;

	mov	ecx, DWORD PTR _pdststr$[ebp]
	mov	DWORD PTR $T119629[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mylock$[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
	mov	eax, DWORD PTR $T119629[ebp]
$LN6@insert:

; 75   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?insert@FixedString@Ogre@@SAPAXPBDH@Z$0:
	lea	ecx, DWORD PTR _mylock$[ebp]
	jmp	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
__ehhandler$?insert@FixedString@Ogre@@SAPAXPBDH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?insert@FixedString@Ogre@@SAPAXPBDH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?insert@FixedString@Ogre@@SAPAXPBDH@Z ENDP		; Ogre::FixedString::insert
EXTRN	?hash@StringUtil@Ogre@@SAIPBDIH@Z:PROC		; Ogre::StringUtil::hash
; Function compile flags: /Odtp
;	COMDAT ?StringHash@Ogre@@YAIPBDH@Z
_TEXT	SEGMENT
_pstr$ = 8						; size = 4
_len$ = 12						; size = 4
?StringHash@Ogre@@YAIPBDH@Z PROC			; Ogre::StringHash, COMDAT

; 32   : 	{

	push	ebp
	mov	ebp, esp

; 33   : 		return StringUtil::hash(pstr, 3, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _pstr$[ebp]
	push	ecx
	call	?hash@StringUtil@Ogre@@SAIPBDIH@Z	; Ogre::StringUtil::hash
	add	esp, 12					; 0000000cH

; 34   : 	}

	pop	ebp
	ret	0
?StringHash@Ogre@@YAIPBDH@Z ENDP			; Ogre::StringHash
_TEXT	ENDS
EXTRN	__imp__InterlockedIncrement@4:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pcur$ = -4						; size = 4
_h$ = 8							; size = 4
?addRef@FixedString@Ogre@@SAXPAX@Z PROC			; Ogre::FixedString::addRef

; 78   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 79   : 		if(h == NULL) return;

	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN1@addRef
	jmp	SHORT $LN2@addRef
$LN1@addRef:

; 80   : 
; 81   : 		stShareString *pcur = STR2STRUCT(handle2Ptr(h));

	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	call	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ; Ogre::FixedString::handle2Ptr
	add	esp, 4
	sub	eax, 8
	mov	DWORD PTR _pcur$[ebp], eax

; 82   : #ifdef _DEBUG
; 83   : 		assert(pcur->hash == StringHash(handle2Ptr(h)));
; 84   : #endif
; 85   : 
; 86   : 		InterlockedIncrement(&pcur->refcount);

	mov	ecx, DWORD PTR _pcur$[ebp]
	add	ecx, 4
	push	ecx
	call	DWORD PTR __imp__InterlockedIncrement@4
$LN2@addRef:

; 87   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?addRef@FixedString@Ogre@@SAXPAX@Z ENDP			; Ogre::FixedString::addRef
_TEXT	ENDS
EXTRN	__imp__free:PROC
EXTRN	__imp__InterlockedDecrement@4:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pcur$ = -20						; size = 4
_phead$ = -16						; size = 4
_pstr$ = -12						; size = 4
_i$ = -8						; size = 4
_newrefcount$ = -4					; size = 4
_h$ = 8							; size = 4
?release@FixedString@Ogre@@SAXPAX@Z PROC		; Ogre::FixedString::release

; 90   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 91   : 		const char *pstr = handle2Ptr(h);

	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	call	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ; Ogre::FixedString::handle2Ptr
	add	esp, 4
	mov	DWORD PTR _pstr$[ebp], eax

; 92   : 		if( pstr == NULL ) return;

	cmp	DWORD PTR _pstr$[ebp], 0
	jne	SHORT $LN7@release
	jmp	$LN8@release
$LN7@release:

; 93   : 
; 94   : 		stShareString *pcur = STR2STRUCT(pstr);

	mov	ecx, DWORD PTR _pstr$[ebp]
	sub	ecx, 8
	mov	DWORD PTR _pcur$[ebp], ecx

; 95   : #ifdef _DEBUG
; 96   : 		assert( pcur->hash == StringHash(pstr) );
; 97   : #endif
; 98   : 
; 99   : 		long newrefcount = InterlockedDecrement(&pcur->refcount);

	mov	edx, DWORD PTR _pcur$[ebp]
	add	edx, 4
	push	edx
	call	DWORD PTR __imp__InterlockedDecrement@4
	mov	DWORD PTR _newrefcount$[ebp], eax

; 100  : 		if(newrefcount > 0) return;

	cmp	DWORD PTR _newrefcount$[ebp], 0
	jle	SHORT $LN6@release
	jmp	$LN8@release
$LN6@release:

; 101  : 		assert(newrefcount == 0);
; 102  : 		return; //keep the string in memory

	jmp	$LN8@release

; 103  : 
; 104  : 		unsigned int i = StringHash(pstr) % STR_HASH_BUFLEN;

	push	-1
	mov	eax, DWORD PTR _pstr$[ebp]
	push	eax
	call	?StringHash@Ogre@@YAIPBDH@Z		; Ogre::StringHash
	add	esp, 8
	xor	edx, edx
	mov	ecx, 513				; 00000201H
	div	ecx
	mov	DWORD PTR _i$[ebp], edx

; 105  : 
; 106  : 		s_pLockSection->Lock();

	mov	ecx, DWORD PTR _s_pLockSection
	call	?Lock@LockSection@Ogre@@QAEXXZ		; Ogre::LockSection::Lock

; 107  : 		stShareString *phead = s_HashTable[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _s_HashTable[edx*4]
	mov	DWORD PTR _phead$[ebp], eax

; 108  : 		if( phead == pcur )

	mov	ecx, DWORD PTR _phead$[ebp]
	cmp	ecx, DWORD PTR _pcur$[ebp]
	jne	SHORT $LN3@release

; 109  : 		{
; 110  : 			s_HashTable[i] = pcur->pnext;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pcur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s_HashTable[edx*4], ecx

; 111  : 		}
; 112  : 		else

	jmp	SHORT $LN4@release
$LN3@release:

; 113  : 		{
; 114  : 			while(1)

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN4@release

; 115  : 			{
; 116  : 				assert( phead != NULL );
; 117  : 				if( phead->pnext == pcur )

	mov	eax, DWORD PTR _phead$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _pcur$[ebp]
	jne	SHORT $LN1@release

; 118  : 				{
; 119  : 					phead->pnext = pcur->pnext;

	mov	edx, DWORD PTR _phead$[ebp]
	mov	eax, DWORD PTR _pcur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 120  : 					break;

	jmp	SHORT $LN4@release
$LN1@release:

; 121  : 				}
; 122  : 				phead = phead->pnext;

	mov	edx, DWORD PTR _phead$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _phead$[ebp], eax

; 123  : 			}

	jmp	SHORT $LN3@release
$LN4@release:

; 124  : 			assert(0);
; 125  : 		}
; 126  : 		s_pLockSection->Unlock();

	mov	ecx, DWORD PTR _s_pLockSection
	call	?Unlock@LockSection@Ogre@@QAEXXZ	; Ogre::LockSection::Unlock

; 127  : 
; 128  : 		free( pcur );

	mov	ecx, DWORD PTR _pcur$[ebp]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN8@release:

; 129  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@FixedString@Ogre@@SAXPAX@Z ENDP		; Ogre::FixedString::release
_TEXT	ENDS
PUBLIC	?sysInit@FixedString@Ogre@@SAHXZ		; Ogre::FixedString::sysInit
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??0LockSection@Ogre@@QAE@XZ:PROC		; Ogre::LockSection::LockSection
EXTRN	??2@YAPAXI@Z:PROC				; operator new
xdata$x	SEGMENT
__unwindtable$?sysInit@FixedString@Ogre@@SAHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?sysInit@FixedString@Ogre@@SAHXZ$0
__ehfuncinfo$?sysInit@FixedString@Ogre@@SAHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?sysInit@FixedString@Ogre@@SAHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv75 = -28						; size = 4
$T119646 = -24						; size = 4
$T119645 = -20						; size = 4
_i$114942 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?sysInit@FixedString@Ogre@@SAHXZ PROC			; Ogre::FixedString::sysInit

; 132  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?sysInit@FixedString@Ogre@@SAHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 133  : 		for( int i=0; i<STR_HASH_BUFLEN; i++ )

	mov	DWORD PTR _i$114942[ebp], 0
	jmp	SHORT $LN3@sysInit
$LN2@sysInit:
	mov	eax, DWORD PTR _i$114942[ebp]
	add	eax, 1
	mov	DWORD PTR _i$114942[ebp], eax
$LN3@sysInit:
	cmp	DWORD PTR _i$114942[ebp], 513		; 00000201H
	jge	SHORT $LN1@sysInit

; 134  : 		{
; 135  : 			s_HashTable[i] = NULL;

	mov	ecx, DWORD PTR _i$114942[ebp]
	mov	DWORD PTR _s_HashTable[ecx*4], 0

; 136  : 		}

	jmp	SHORT $LN2@sysInit
$LN1@sysInit:

; 137  : 		s_pLockSection = new LockSection();

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T119646[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T119646[ebp], 0
	je	SHORT $LN6@sysInit
	mov	ecx, DWORD PTR $T119646[ebp]
	call	??0LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::LockSection
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN7@sysInit
$LN6@sysInit:
	mov	DWORD PTR tv75[ebp], 0
$LN7@sysInit:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T119645[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T119645[ebp]
	mov	DWORD PTR _s_pLockSection, eax

; 138  : 		return 0;

	xor	eax, eax

; 139  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?sysInit@FixedString@Ogre@@SAHXZ$0:
	mov	eax, DWORD PTR $T119646[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?sysInit@FixedString@Ogre@@SAHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?sysInit@FixedString@Ogre@@SAHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?sysInit@FixedString@Ogre@@SAHXZ ENDP			; Ogre::FixedString::sysInit
PUBLIC	??_GLockSection@Ogre@@QAEPAXI@Z			; Ogre::LockSection::`scalar deleting destructor'
PUBLIC	?sysRelease@FixedString@Ogre@@SAHXZ		; Ogre::FixedString::sysRelease
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv74 = -24						; size = 4
$T119656 = -20						; size = 4
$T119655 = -16						; size = 4
_pnext$114960 = -12					; size = 4
_pcur$114956 = -8					; size = 4
_i$114952 = -4						; size = 4
?sysRelease@FixedString@Ogre@@SAHXZ PROC		; Ogre::FixedString::sysRelease

; 142  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 143  : 		for( int i=0; i<STR_HASH_BUFLEN; i++ )

	mov	DWORD PTR _i$114952[ebp], 0
	jmp	SHORT $LN5@sysRelease
$LN4@sysRelease:
	mov	eax, DWORD PTR _i$114952[ebp]
	add	eax, 1
	mov	DWORD PTR _i$114952[ebp], eax
$LN5@sysRelease:
	cmp	DWORD PTR _i$114952[ebp], 513		; 00000201H
	jge	SHORT $LN3@sysRelease

; 144  : 		{
; 145  : 			stShareString *pcur = s_HashTable[i];

	mov	ecx, DWORD PTR _i$114952[ebp]
	mov	edx, DWORD PTR _s_HashTable[ecx*4]
	mov	DWORD PTR _pcur$114956[ebp], edx
$LN2@sysRelease:

; 146  : 			while(pcur != NULL)

	cmp	DWORD PTR _pcur$114956[ebp], 0
	je	SHORT $LN1@sysRelease

; 147  : 			{
; 148  : 				stShareString *pnext = pcur->pnext;

	mov	eax, DWORD PTR _pcur$114956[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pnext$114960[ebp], ecx

; 149  : 				free(pcur);

	mov	edx, DWORD PTR _pcur$114956[ebp]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4

; 150  : 				pcur = pnext;

	mov	eax, DWORD PTR _pnext$114960[ebp]
	mov	DWORD PTR _pcur$114956[ebp], eax

; 151  : 			}

	jmp	SHORT $LN2@sysRelease
$LN1@sysRelease:

; 152  : 
; 153  : 			/*
; 154  : 			assert( s_HashTable[i] == NULL );
; 155  : 			if(s_HashTable[i] != NULL)
; 156  : 			{
; 157  : 			const char *p = STRUCT2STR(s_HashTable[i]);
; 158  : 			p = p;
; 159  : 			}*/
; 160  : 		}

	jmp	SHORT $LN4@sysRelease
$LN3@sysRelease:

; 161  : 		delete s_pLockSection;

	mov	ecx, DWORD PTR _s_pLockSection
	mov	DWORD PTR $T119656[ebp], ecx
	mov	edx, DWORD PTR $T119656[ebp]
	mov	DWORD PTR $T119655[ebp], edx
	cmp	DWORD PTR $T119655[ebp], 0
	je	SHORT $LN8@sysRelease
	push	1
	mov	ecx, DWORD PTR $T119655[ebp]
	call	??_GLockSection@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN9@sysRelease
$LN8@sysRelease:
	mov	DWORD PTR tv74[ebp], 0
$LN9@sysRelease:

; 162  : 		return 0;

	xor	eax, eax

; 163  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?sysRelease@FixedString@Ogre@@SAHXZ ENDP		; Ogre::FixedString::sysRelease
_TEXT	ENDS
EXTRN	??1LockSection@Ogre@@QAE@XZ:PROC		; Ogre::LockSection::~LockSection
; Function compile flags: /Odtp
;	COMDAT ??_GLockSection@Ogre@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GLockSection@Ogre@@QAEPAXI@Z PROC			; Ogre::LockSection::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GLockSection@Ogre@@QAEPAXI@Z ENDP			; Ogre::LockSection::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::FixedString::operator=
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_str$ = 8						; size = 4
??4FixedString@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::FixedString::operator=
; _this$ = ecx

; 166  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 		addRef(str.m_StrHandle);

	mov	eax, DWORD PTR _str$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?addRef@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::addRef
	add	esp, 4

; 168  : 		release(m_StrHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?release@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::release
	add	esp, 4

; 169  : 
; 170  : 		m_StrHandle = str.m_StrHandle;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _str$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 171  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 172  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??4FixedString@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::FixedString::operator=
_TEXT	ENDS
PUBLIC	??4FixedString@Ogre@@QAEAAV01@PBD@Z		; Ogre::FixedString::operator=
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstr$ = 8						; size = 4
??4FixedString@Ogre@@QAEAAV01@PBD@Z PROC		; Ogre::FixedString::operator=
; _this$ = ecx

; 175  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 176  : 		release(m_StrHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?release@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::release
	add	esp, 4

; 177  : 		m_StrHandle = insert(pstr);

	push	-1
	mov	edx, DWORD PTR _pstr$[ebp]
	push	edx
	call	?insert@FixedString@Ogre@@SAPAXPBDH@Z	; Ogre::FixedString::insert
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 178  : 
; 179  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 180  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??4FixedString@Ogre@@QAEAAV01@PBD@Z ENDP		; Ogre::FixedString::operator=
_TEXT	ENDS
PUBLIC	?length@FixedString@Ogre@@QBEIXZ		; Ogre::FixedString::length
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?length@FixedString@Ogre@@QBEIXZ PROC			; Ogre::FixedString::length
; _this$ = ecx

; 183  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 184  : 		if( m_StrHandle == NULL ) return 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@length
	xor	eax, eax
	jmp	SHORT $LN3@length
	jmp	SHORT $LN3@length
$LN2@length:

; 185  : 		else return strlen(handle2Ptr(m_StrHandle));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ; Ogre::FixedString::handle2Ptr
	add	esp, 4
	push	eax
	call	_strlen
	add	esp, 4
$LN3@length:

; 186  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@FixedString@Ogre@@QBEIXZ ENDP			; Ogre::FixedString::length
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?substr@FixedString@Ogre@@QBE?AV12@II@Z		; Ogre::FixedString::substr
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
xdata$x	SEGMENT
__unwindtable$?substr@FixedString@Ogre@@QBE?AV12@II@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?substr@FixedString@Ogre@@QBE?AV12@II@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?substr@FixedString@Ogre@@QBE?AV12@II@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?substr@FixedString@Ogre@@QBE?AV12@II@Z$2
__ehfuncinfo$?substr@FixedString@Ogre@@QBE?AV12@II@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?substr@FixedString@Ogre@@QBE?AV12@II@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv95 = -92						; size = 4
tv71 = -88						; size = 4
_this$ = -84						; size = 4
$T119668 = -80						; size = 4
$T119666 = -76						; size = 28
_str$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_p$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_start$ = 12						; size = 4
_count$ = 16						; size = 4
?substr@FixedString@Ogre@@QBE?AV12@II@Z PROC		; Ogre::FixedString::substr
; _this$ = ecx

; 189  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?substr@FixedString@Ogre@@QBE?AV12@II@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T119668[ebp], 0

; 190  : 		if(m_StrHandle == NULL) return FixedString();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@substr
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::FixedString
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T119668[ebp]
	or	ecx, 1
	mov	DWORD PTR $T119668[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN2@substr
$LN1@substr:

; 191  : 
; 192  : 		const char *p = handle2Ptr(m_StrHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ; Ogre::FixedString::handle2Ptr
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 193  : 		std::string str(p);

	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 194  : 		str = str.substr(start, count);

	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T119666[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
	mov	DWORD PTR tv71[ebp], eax
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR tv95[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR tv95[ebp]
	push	eax
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T119666[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 195  : 
; 196  : 		return FixedString(str.c_str());

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0FixedString@Ogre@@QAE@PBD@Z		; Ogre::FixedString::FixedString
	mov	ecx, DWORD PTR $T119668[ebp]
	or	ecx, 1
	mov	DWORD PTR $T119668[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN2@substr:

; 197  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?substr@FixedString@Ogre@@QBE?AV12@II@Z$0:
	mov	eax, DWORD PTR $T119668[ebp]
	and	eax, 1
	je	$LN5@substr
	and	DWORD PTR $T119668[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
$LN5@substr:
	ret	0
__unwindfunclet$?substr@FixedString@Ogre@@QBE?AV12@II@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?substr@FixedString@Ogre@@QBE?AV12@II@Z$2:
	lea	ecx, DWORD PTR $T119666[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?substr@FixedString@Ogre@@QBE?AV12@II@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?substr@FixedString@Ogre@@QBE?AV12@II@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?substr@FixedString@Ogre@@QBE?AV12@II@Z ENDP		; Ogre::FixedString::substr
PUBLIC	??8Ogre@@YA_NABVFixedString@0@PBD@Z		; Ogre::operator==
EXTRN	_strcmp:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_p$ = -4						; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
??8Ogre@@YA_NABVFixedString@0@PBD@Z PROC		; Ogre::operator==

; 200  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 201  : 		const char *p = s1;

	mov	ecx, DWORD PTR _s1$[ebp]
	call	??BFixedString@Ogre@@QBEPBDXZ		; Ogre::FixedString::operator char const *
	mov	DWORD PTR _p$[ebp], eax

; 202  : 		if( p==NULL || s2==NULL )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN2@operator
	cmp	DWORD PTR _s2$[ebp], 0
	jne	SHORT $LN3@operator
$LN2@operator:

; 203  : 		{
; 204  : 			return p==s2;

	mov	eax, DWORD PTR _p$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _s2$[ebp]
	sete	cl
	mov	al, cl
	jmp	SHORT $LN4@operator

; 205  : 		}
; 206  : 		else

	jmp	SHORT $LN4@operator
$LN3@operator:

; 207  : 		{
; 208  : 			return strcmp(p, s2)==0;

	mov	edx, DWORD PTR _s2$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	neg	eax
	sbb	eax, eax
	add	eax, 1
$LN4@operator:

; 209  : 		}
; 210  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??8Ogre@@YA_NABVFixedString@0@PBD@Z ENDP		; Ogre::operator==
_TEXT	ENDS
PUBLIC	??9Ogre@@YA_NABVFixedString@0@PBD@Z		; Ogre::operator!=
; Function compile flags: /Odtp
_TEXT	SEGMENT
_p$ = -4						; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
??9Ogre@@YA_NABVFixedString@0@PBD@Z PROC		; Ogre::operator!=

; 213  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 214  : 		const char *p = s1;

	mov	ecx, DWORD PTR _s1$[ebp]
	call	??BFixedString@Ogre@@QBEPBDXZ		; Ogre::FixedString::operator char const *
	mov	DWORD PTR _p$[ebp], eax

; 215  : 		if( p==NULL || s2==NULL )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN2@operator@2
	cmp	DWORD PTR _s2$[ebp], 0
	jne	SHORT $LN3@operator@2
$LN2@operator@2:

; 216  : 		{
; 217  : 			return p!=s2;

	mov	eax, DWORD PTR _p$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _s2$[ebp]
	setne	cl
	mov	al, cl
	jmp	SHORT $LN4@operator@2

; 218  : 		}
; 219  : 		else

	jmp	SHORT $LN4@operator@2
$LN3@operator@2:

; 220  : 		{
; 221  : 			return strcmp(p, s2)!=0;

	mov	edx, DWORD PTR _s2$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	neg	eax
	sbb	eax, eax
	neg	eax
$LN4@operator@2:

; 222  : 		}
; 223  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??9Ogre@@YA_NABVFixedString@0@PBD@Z ENDP		; Ogre::operator!=
_TEXT	ENDS
END

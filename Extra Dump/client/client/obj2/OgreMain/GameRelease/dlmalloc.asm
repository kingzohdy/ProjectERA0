; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\dlmalloc.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_malloc_global_mutex DD 01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
$SG31109 DB	'max system bytes = %10lu', 0aH, 00H
	ORG $+2
$SG31111 DB	'system bytes     = %10lu', 0aH, 00H
	ORG $+2
$SG31113 DB	'in use bytes     = %10lu', 0aH, 00H
CONST	ENDS
PUBLIC	?dlmalloc@@YAPAXI@Z				; dlmalloc
EXTRN	__imp__abort:PROC
_BSS	SEGMENT
__gm_	DB	01dcH DUP (?)
_mparams DB	018H DUP (?)
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\dlmalloc.cpp
_BSS	ENDS
_TEXT	SEGMENT
tv83 = -124						; size = 4
tv76 = -120						; size = 4
tv74 = -116						; size = 4
_r$33061 = -112						; size = 4
_rsize$33059 = -108					; size = 4
_p$33060 = -104						; size = 4
_dvs$33047 = -100					; size = 4
_r$33038 = -96						; size = 4
_rsize$33028 = -92					; size = 4
_p$33029 = -88						; size = 4
_I$32988 = -84						; size = 4
_F$32993 = -80						; size = 4
_B$32990 = -76						; size = 4
_DV$32987 = -72						; size = 4
_DVS$32985 = -68					; size = 4
_F$32957 = -64						; size = 4
_J$32952 = -60						; size = 4
_r$32945 = -56						; size = 4
_leastbit$32951 = -52					; size = 4
_leftbits$32948 = -48					; size = 4
_b$32943 = -44						; size = 4
_rsize$32946 = -40					; size = 4
_i$32947 = -36						; size = 4
_p$32944 = -32						; size = 4
_F$32924 = -28						; size = 4
_b$32920 = -24						; size = 4
_p$32921 = -20						; size = 4
_smallbits$32894 = -16					; size = 4
_idx$32893 = -12					; size = 4
_nb$32885 = -8						; size = 4
_mem$32884 = -4						; size = 4
_bytes$ = 8						; size = 4
?dlmalloc@@YAPAXI@Z PROC				; dlmalloc

; 4527 : void* dlmalloc(size_t bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	esi

; 4528 :   /*
; 4529 :      Basic algorithm:
; 4530 :      If a small request (< 256 bytes minus per-chunk overhead):
; 4531 :        1. If one exists, use a remainderless chunk in associated smallbin.
; 4532 :           (Remainderless means that there are too few excess bytes to
; 4533 :           represent as a chunk.)
; 4534 :        2. If it is big enough, use the dv chunk, which is normally the
; 4535 :           chunk adjacent to the one used for the most recent small request.
; 4536 :        3. If one exists, split the smallest available chunk in a bin,
; 4537 :           saving remainder in dv.
; 4538 :        4. If it is big enough, use the top chunk.
; 4539 :        5. If available, get memory from system and use it
; 4540 :      Otherwise, for a large request:
; 4541 :        1. Find the smallest available binned chunk that fits, and use it
; 4542 :           if it is better fitting than dv chunk, splitting if necessary.
; 4543 :        2. If better fitting than any binned chunk, use the dv chunk.
; 4544 :        3. If it is big enough, use the top chunk.
; 4545 :        4. If request size >= mmap threshold, try to directly mmap this chunk.
; 4546 :        5. If available, get memory from system and use it
; 4547 : 
; 4548 :      The ugly goto's here ensure that postaction occurs along all paths.
; 4549 :   */
; 4550 : 
; 4551 : #if USE_LOCKS
; 4552 :   ensure_initialization(); /* initialize in sys_alloc if not using locks */

	cmp	DWORD PTR _mparams, 0
	jne	SHORT $LN42@dlmalloc
	call	?init_mparams@@YAHXZ			; init_mparams
$LN42@dlmalloc:

; 4553 : #endif
; 4554 : 
; 4555 :   if (!PREACTION(gm)) {

	mov	eax, DWORD PTR __gm_+444
	and	eax, 2
	je	SHORT $LN45@dlmalloc
	mov	ecx, 1
	mov	edx, OFFSET __gm_+448
	xchg	DWORD PTR [edx], ecx
	test	ecx, ecx
	je	SHORT $LN43@dlmalloc
	push	OFFSET __gm_+448
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN44@dlmalloc
$LN43@dlmalloc:
	mov	DWORD PTR tv74[ebp], 0
$LN44@dlmalloc:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN46@dlmalloc
$LN45@dlmalloc:
	mov	DWORD PTR tv76[ebp], 0
$LN46@dlmalloc:
	cmp	DWORD PTR tv76[ebp], 0
	jne	$LN39@dlmalloc

; 4556 :     void* mem;
; 4557 :     size_t nb;
; 4558 :     if (bytes <= MAX_SMALL_REQUEST) {

	cmp	DWORD PTR _bytes$[ebp], 244		; 000000f4H
	ja	$LN38@dlmalloc

; 4559 :       bindex_t idx;
; 4560 :       binmap_t smallbits;
; 4561 :       nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);

	cmp	DWORD PTR _bytes$[ebp], 11		; 0000000bH
	jae	SHORT $LN47@dlmalloc
	mov	DWORD PTR tv83[ebp], 16			; 00000010H
	jmp	SHORT $LN48@dlmalloc
$LN47@dlmalloc:
	mov	ecx, DWORD PTR _bytes$[ebp]
	add	ecx, 11					; 0000000bH
	and	ecx, -8					; fffffff8H
	mov	DWORD PTR tv83[ebp], ecx
$LN48@dlmalloc:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _nb$32885[ebp], edx

; 4562 :       idx = small_index(nb);

	mov	eax, DWORD PTR _nb$32885[ebp]
	shr	eax, 3
	mov	DWORD PTR _idx$32893[ebp], eax

; 4563 :       smallbits = gm->smallmap >> idx;

	mov	edx, DWORD PTR __gm_
	mov	ecx, DWORD PTR _idx$32893[ebp]
	shr	edx, cl
	mov	DWORD PTR _smallbits$32894[ebp], edx

; 4564 : 
; 4565 :       if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */

	mov	eax, DWORD PTR _smallbits$32894[ebp]
	and	eax, 3
	je	$LN37@dlmalloc

; 4566 :         mchunkptr b, p;
; 4567 :         idx += ~smallbits & 1;       /* Uses next bin if idx empty */

	mov	ecx, DWORD PTR _smallbits$32894[ebp]
	not	ecx
	and	ecx, 1
	add	ecx, DWORD PTR _idx$32893[ebp]
	mov	DWORD PTR _idx$32893[ebp], ecx

; 4568 :         b = smallbin_at(gm, idx);

	mov	edx, DWORD PTR _idx$32893[ebp]
	shl	edx, 1
	lea	eax, DWORD PTR __gm_[edx*4+40]
	mov	DWORD PTR _b$32920[ebp], eax

; 4569 :         p = b->fd;

	mov	ecx, DWORD PTR _b$32920[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _p$32921[ebp], edx

; 4570 :         assert(chunksize(p) == small_index2size(idx));
; 4571 :         unlink_first_small_chunk(gm, b, p, idx);

	mov	eax, DWORD PTR _p$32921[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$32924[ebp], ecx
	mov	edx, DWORD PTR _b$32920[ebp]
	cmp	edx, DWORD PTR _F$32924[ebp]
	jne	SHORT $LN36@dlmalloc
	mov	eax, 1
	mov	ecx, DWORD PTR _idx$32893[ebp]
	shl	eax, cl
	not	eax
	and	eax, DWORD PTR __gm_
	mov	DWORD PTR __gm_, eax
	jmp	SHORT $LN35@dlmalloc
$LN36@dlmalloc:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN34@dlmalloc
	mov	edx, DWORD PTR _F$32924[ebp]
	mov	eax, DWORD PTR _b$32920[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _b$32920[ebp]
	mov	edx, DWORD PTR _F$32924[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN35@dlmalloc
$LN34@dlmalloc:
	call	DWORD PTR __imp__abort
$LN35@dlmalloc:

; 4572 :         set_inuse_and_pinuse(gm, p, small_index2size(idx));

	mov	eax, DWORD PTR _idx$32893[ebp]
	shl	eax, 3
	or	eax, 1
	or	eax, 2
	mov	ecx, DWORD PTR _p$32921[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _idx$32893[ebp]
	mov	eax, DWORD PTR _p$32921[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	or	ecx, 1
	mov	edx, DWORD PTR _idx$32893[ebp]
	mov	eax, DWORD PTR _p$32921[ebp]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 4573 :         mem = chunk2mem(p);

	mov	ecx, DWORD PTR _p$32921[ebp]
	add	ecx, 8
	mov	DWORD PTR _mem$32884[ebp], ecx
	jmp	$postaction$32938

; 4574 :         check_malloced_chunk(gm, mem, nb);
; 4575 :         goto postaction;

	jmp	$postaction$32938
	jmp	$LN31@dlmalloc
$LN37@dlmalloc:

; 4576 :       }
; 4577 : 
; 4578 :       else if (nb > gm->dvsize) {

	mov	edx, DWORD PTR _nb$32885[ebp]
	cmp	edx, DWORD PTR __gm_+8
	jbe	$LN31@dlmalloc

; 4579 :         if (smallbits != 0) { /* Use chunk in next nonempty smallbin */

	cmp	DWORD PTR _smallbits$32894[ebp], 0
	je	$LN29@dlmalloc

; 4580 :           mchunkptr b, p, r;
; 4581 :           size_t rsize;
; 4582 :           bindex_t i;
; 4583 :           binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));

	mov	eax, DWORD PTR _smallbits$32894[ebp]
	mov	ecx, DWORD PTR _idx$32893[ebp]
	shl	eax, cl
	mov	edx, 1
	mov	ecx, DWORD PTR _idx$32893[ebp]
	shl	edx, cl
	shl	edx, 1
	mov	esi, 1
	mov	ecx, DWORD PTR _idx$32893[ebp]
	shl	esi, cl
	shl	esi, 1
	neg	esi
	or	edx, esi
	and	eax, edx
	mov	DWORD PTR _leftbits$32948[ebp], eax

; 4584 :           binmap_t leastbit = least_bit(leftbits);

	mov	eax, DWORD PTR _leftbits$32948[ebp]
	neg	eax
	and	eax, DWORD PTR _leftbits$32948[ebp]
	mov	DWORD PTR _leastbit$32951[ebp], eax

; 4585 :           compute_bit2idx(leastbit, i);

	mov	ecx, DWORD PTR _leastbit$32951[ebp]
	bsf	edx, ecx
	mov	DWORD PTR _J$32952[ebp], edx
	mov	eax, DWORD PTR _J$32952[ebp]
	mov	DWORD PTR _i$32947[ebp], eax

; 4586 :           b = smallbin_at(gm, i);

	mov	ecx, DWORD PTR _i$32947[ebp]
	shl	ecx, 1
	lea	edx, DWORD PTR __gm_[ecx*4+40]
	mov	DWORD PTR _b$32943[ebp], edx

; 4587 :           p = b->fd;

	mov	eax, DWORD PTR _b$32943[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _p$32944[ebp], ecx

; 4588 :           assert(chunksize(p) == small_index2size(i));
; 4589 :           unlink_first_small_chunk(gm, b, p, i);

	mov	edx, DWORD PTR _p$32944[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _F$32957[ebp], eax
	mov	ecx, DWORD PTR _b$32943[ebp]
	cmp	ecx, DWORD PTR _F$32957[ebp]
	jne	SHORT $LN28@dlmalloc
	mov	edx, 1
	mov	ecx, DWORD PTR _i$32947[ebp]
	shl	edx, cl
	not	edx
	and	edx, DWORD PTR __gm_
	mov	DWORD PTR __gm_, edx
	jmp	SHORT $LN27@dlmalloc
$LN28@dlmalloc:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN26@dlmalloc
	mov	ecx, DWORD PTR _F$32957[ebp]
	mov	edx, DWORD PTR _b$32943[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _b$32943[ebp]
	mov	ecx, DWORD PTR _F$32957[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN27@dlmalloc
$LN26@dlmalloc:
	call	DWORD PTR __imp__abort
$LN27@dlmalloc:

; 4590 :           rsize = small_index2size(i) - nb;

	mov	edx, DWORD PTR _i$32947[ebp]
	shl	edx, 3
	sub	edx, DWORD PTR _nb$32885[ebp]
	mov	DWORD PTR _rsize$32946[ebp], edx

; 4591 :           /* Fit here cannot be remainderless if 4byte sizes */
; 4592 :           if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)

	xor	eax, eax
	je	SHORT $LN24@dlmalloc

; 4593 :             set_inuse_and_pinuse(gm, p, small_index2size(i));

	mov	ecx, DWORD PTR _i$32947[ebp]
	shl	ecx, 3
	or	ecx, 1
	or	ecx, 2
	mov	edx, DWORD PTR _p$32944[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _i$32947[ebp]
	mov	ecx, DWORD PTR _p$32944[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	or	edx, 1
	mov	eax, DWORD PTR _i$32947[ebp]
	mov	ecx, DWORD PTR _p$32944[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 4594 :           else {

	jmp	$LN23@dlmalloc
$LN24@dlmalloc:

; 4595 :             set_size_and_pinuse_of_inuse_chunk(gm, p, nb);

	mov	edx, DWORD PTR _nb$32885[ebp]
	or	edx, 1
	or	edx, 2
	mov	eax, DWORD PTR _p$32944[ebp]
	mov	DWORD PTR [eax+4], edx

; 4596 :             r = chunk_plus_offset(p, nb);

	mov	ecx, DWORD PTR _p$32944[ebp]
	add	ecx, DWORD PTR _nb$32885[ebp]
	mov	DWORD PTR _r$32945[ebp], ecx

; 4597 :             set_size_and_pinuse_of_free_chunk(r, rsize);

	mov	edx, DWORD PTR _rsize$32946[ebp]
	or	edx, 1
	mov	eax, DWORD PTR _r$32945[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _r$32945[ebp]
	add	ecx, DWORD PTR _rsize$32946[ebp]
	mov	edx, DWORD PTR _rsize$32946[ebp]
	mov	DWORD PTR [ecx], edx

; 4598 :             replace_dv(gm, r, rsize);

	mov	eax, DWORD PTR __gm_+8
	mov	DWORD PTR _DVS$32985[ebp], eax
	cmp	DWORD PTR _DVS$32985[ebp], 0
	je	$LN22@dlmalloc
	mov	ecx, DWORD PTR __gm_+20
	mov	DWORD PTR _DV$32987[ebp], ecx
	mov	edx, DWORD PTR _DVS$32985[ebp]
	shr	edx, 3
	mov	DWORD PTR _I$32988[ebp], edx
	mov	eax, DWORD PTR _I$32988[ebp]
	shl	eax, 1
	lea	ecx, DWORD PTR __gm_[eax*4+40]
	mov	DWORD PTR _B$32990[ebp], ecx
	mov	edx, DWORD PTR _B$32990[ebp]
	mov	DWORD PTR _F$32993[ebp], edx
	mov	eax, 1
	mov	ecx, DWORD PTR _I$32988[ebp]
	shl	eax, cl
	and	eax, DWORD PTR __gm_
	jne	SHORT $LN21@dlmalloc
	mov	edx, 1
	mov	ecx, DWORD PTR _I$32988[ebp]
	shl	edx, cl
	or	edx, DWORD PTR __gm_
	mov	DWORD PTR __gm_, edx
	jmp	SHORT $LN20@dlmalloc
$LN21@dlmalloc:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN19@dlmalloc
	mov	ecx, DWORD PTR _B$32990[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _F$32993[ebp], edx
	jmp	SHORT $LN20@dlmalloc
$LN19@dlmalloc:
	call	DWORD PTR __imp__abort
$LN20@dlmalloc:
	mov	eax, DWORD PTR _B$32990[ebp]
	mov	ecx, DWORD PTR _DV$32987[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _F$32993[ebp]
	mov	eax, DWORD PTR _DV$32987[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _DV$32987[ebp]
	mov	edx, DWORD PTR _F$32993[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _DV$32987[ebp]
	mov	ecx, DWORD PTR _B$32990[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN22@dlmalloc:
	mov	edx, DWORD PTR _rsize$32946[ebp]
	mov	DWORD PTR __gm_+8, edx
	mov	eax, DWORD PTR _r$32945[ebp]
	mov	DWORD PTR __gm_+20, eax
$LN23@dlmalloc:

; 4599 :           }
; 4600 :           mem = chunk2mem(p);

	mov	ecx, DWORD PTR _p$32944[ebp]
	add	ecx, 8
	mov	DWORD PTR _mem$32884[ebp], ecx
	jmp	$postaction$32938

; 4601 :           check_malloced_chunk(gm, mem, nb);
; 4602 :           goto postaction;

	jmp	$postaction$32938
	jmp	SHORT $LN31@dlmalloc
$LN29@dlmalloc:

; 4603 :         }
; 4604 : 
; 4605 :         else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {

	cmp	DWORD PTR __gm_+4, 0
	je	SHORT $LN31@dlmalloc
	mov	edx, DWORD PTR _nb$32885[ebp]
	push	edx
	push	OFFSET __gm_
	call	?tmalloc_small@@YAPAXPAUmalloc_state@@I@Z ; tmalloc_small
	add	esp, 8
	mov	DWORD PTR _mem$32884[ebp], eax
	cmp	DWORD PTR _mem$32884[ebp], 0
	je	SHORT $LN31@dlmalloc
	jmp	$postaction$32938

; 4606 :           check_malloced_chunk(gm, mem, nb);
; 4607 :           goto postaction;

	jmp	$postaction$32938
$LN31@dlmalloc:

; 4608 :         }
; 4609 :       }
; 4610 :     }

	jmp	SHORT $LN13@dlmalloc
$LN38@dlmalloc:

; 4611 :     else if (bytes >= MAX_REQUEST)

	cmp	DWORD PTR _bytes$[ebp], -64		; ffffffc0H
	jb	SHORT $LN12@dlmalloc

; 4612 :       nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */

	mov	DWORD PTR _nb$32885[ebp], -1

; 4613 :     else {

	jmp	SHORT $LN13@dlmalloc
$LN12@dlmalloc:

; 4614 :       nb = pad_request(bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	add	eax, 11					; 0000000bH
	and	eax, -8					; fffffff8H
	mov	DWORD PTR _nb$32885[ebp], eax

; 4615 :       if (gm->treemap != 0 && (mem = tmalloc_large(gm, nb)) != 0) {

	cmp	DWORD PTR __gm_+4, 0
	je	SHORT $LN13@dlmalloc
	mov	ecx, DWORD PTR _nb$32885[ebp]
	push	ecx
	push	OFFSET __gm_
	call	?tmalloc_large@@YAPAXPAUmalloc_state@@I@Z ; tmalloc_large
	add	esp, 8
	mov	DWORD PTR _mem$32884[ebp], eax
	cmp	DWORD PTR _mem$32884[ebp], 0
	je	SHORT $LN13@dlmalloc
	jmp	$postaction$32938

; 4616 :         check_malloced_chunk(gm, mem, nb);
; 4617 :         goto postaction;

	jmp	$postaction$32938
$LN13@dlmalloc:

; 4618 :       }
; 4619 :     }
; 4620 : 
; 4621 :     if (nb <= gm->dvsize) {

	mov	edx, DWORD PTR _nb$32885[ebp]
	cmp	edx, DWORD PTR __gm_+8
	ja	$LN8@dlmalloc

; 4622 :       size_t rsize = gm->dvsize - nb;

	mov	eax, DWORD PTR __gm_+8
	sub	eax, DWORD PTR _nb$32885[ebp]
	mov	DWORD PTR _rsize$33028[ebp], eax

; 4623 :       mchunkptr p = gm->dv;

	mov	ecx, DWORD PTR __gm_+20
	mov	DWORD PTR _p$33029[ebp], ecx

; 4624 :       if (rsize >= MIN_CHUNK_SIZE) { /* split dv */

	cmp	DWORD PTR _rsize$33028[ebp], 16		; 00000010H
	jb	SHORT $LN7@dlmalloc

; 4625 :         mchunkptr r = gm->dv = chunk_plus_offset(p, nb);

	mov	edx, DWORD PTR _p$33029[ebp]
	add	edx, DWORD PTR _nb$32885[ebp]
	mov	DWORD PTR __gm_+20, edx
	mov	eax, DWORD PTR __gm_+20
	mov	DWORD PTR _r$33038[ebp], eax

; 4626 :         gm->dvsize = rsize;

	mov	ecx, DWORD PTR _rsize$33028[ebp]
	mov	DWORD PTR __gm_+8, ecx

; 4627 :         set_size_and_pinuse_of_free_chunk(r, rsize);

	mov	edx, DWORD PTR _rsize$33028[ebp]
	or	edx, 1
	mov	eax, DWORD PTR _r$33038[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _r$33038[ebp]
	add	ecx, DWORD PTR _rsize$33028[ebp]
	mov	edx, DWORD PTR _rsize$33028[ebp]
	mov	DWORD PTR [ecx], edx

; 4628 :         set_size_and_pinuse_of_inuse_chunk(gm, p, nb);

	mov	eax, DWORD PTR _nb$32885[ebp]
	or	eax, 1
	or	eax, 2
	mov	ecx, DWORD PTR _p$33029[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4629 :       }
; 4630 :       else { /* exhaust dv */

	jmp	SHORT $LN6@dlmalloc
$LN7@dlmalloc:

; 4631 :         size_t dvs = gm->dvsize;

	mov	edx, DWORD PTR __gm_+8
	mov	DWORD PTR _dvs$33047[ebp], edx

; 4632 :         gm->dvsize = 0;

	mov	DWORD PTR __gm_+8, 0

; 4633 :         gm->dv = 0;

	mov	DWORD PTR __gm_+20, 0

; 4634 :         set_inuse_and_pinuse(gm, p, dvs);

	mov	eax, DWORD PTR _dvs$33047[ebp]
	or	eax, 1
	or	eax, 2
	mov	ecx, DWORD PTR _p$33029[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _p$33029[ebp]
	add	edx, DWORD PTR _dvs$33047[ebp]
	mov	eax, DWORD PTR [edx+4]
	or	eax, 1
	mov	ecx, DWORD PTR _p$33029[ebp]
	add	ecx, DWORD PTR _dvs$33047[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN6@dlmalloc:

; 4635 :       }
; 4636 :       mem = chunk2mem(p);

	mov	edx, DWORD PTR _p$33029[ebp]
	add	edx, 8
	mov	DWORD PTR _mem$32884[ebp], edx
	jmp	$postaction$32938

; 4637 :       check_malloced_chunk(gm, mem, nb);
; 4638 :       goto postaction;

	jmp	SHORT $postaction$32938
	jmp	SHORT $LN4@dlmalloc
$LN8@dlmalloc:

; 4639 :     }
; 4640 : 
; 4641 :     else if (nb < gm->topsize) { /* Split top */

	mov	eax, DWORD PTR _nb$32885[ebp]
	cmp	eax, DWORD PTR __gm_+12
	jae	SHORT $LN4@dlmalloc

; 4642 :       size_t rsize = gm->topsize -= nb;

	mov	ecx, DWORD PTR __gm_+12
	sub	ecx, DWORD PTR _nb$32885[ebp]
	mov	DWORD PTR __gm_+12, ecx
	mov	edx, DWORD PTR __gm_+12
	mov	DWORD PTR _rsize$33059[ebp], edx

; 4643 :       mchunkptr p = gm->top;

	mov	eax, DWORD PTR __gm_+24
	mov	DWORD PTR _p$33060[ebp], eax

; 4644 :       mchunkptr r = gm->top = chunk_plus_offset(p, nb);

	mov	ecx, DWORD PTR _p$33060[ebp]
	add	ecx, DWORD PTR _nb$32885[ebp]
	mov	DWORD PTR __gm_+24, ecx
	mov	edx, DWORD PTR __gm_+24
	mov	DWORD PTR _r$33061[ebp], edx

; 4645 :       r->head = rsize | PINUSE_BIT;

	mov	eax, DWORD PTR _rsize$33059[ebp]
	or	eax, 1
	mov	ecx, DWORD PTR _r$33061[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4646 :       set_size_and_pinuse_of_inuse_chunk(gm, p, nb);

	mov	edx, DWORD PTR _nb$32885[ebp]
	or	edx, 1
	or	edx, 2
	mov	eax, DWORD PTR _p$33060[ebp]
	mov	DWORD PTR [eax+4], edx

; 4647 :       mem = chunk2mem(p);

	mov	ecx, DWORD PTR _p$33060[ebp]
	add	ecx, 8
	mov	DWORD PTR _mem$32884[ebp], ecx
	jmp	SHORT $postaction$32938

; 4648 :       check_top_chunk(gm, gm->top);
; 4649 :       check_malloced_chunk(gm, mem, nb);
; 4650 :       goto postaction;

	jmp	SHORT $postaction$32938
$LN4@dlmalloc:

; 4651 :     }
; 4652 : 
; 4653 :     mem = sys_alloc(gm, nb);

	mov	edx, DWORD PTR _nb$32885[ebp]
	push	edx
	push	OFFSET __gm_
	call	?sys_alloc@@YAPAXPAUmalloc_state@@I@Z	; sys_alloc
	add	esp, 8
	mov	DWORD PTR _mem$32884[ebp], eax
$postaction$32938:

; 4654 : 
; 4655 :   postaction:
; 4656 :     POSTACTION(gm);

	mov	eax, DWORD PTR __gm_+444
	and	eax, 2
	je	SHORT $LN1@dlmalloc
	xor	ecx, ecx
	mov	edx, OFFSET __gm_+448
	xchg	DWORD PTR [edx], ecx
$LN1@dlmalloc:

; 4657 :     return mem;

	mov	eax, DWORD PTR _mem$32884[ebp]
	jmp	SHORT $LN40@dlmalloc
$LN39@dlmalloc:

; 4658 :   }
; 4659 : 
; 4660 :   return 0;

	xor	eax, eax
$LN40@dlmalloc:

; 4661 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?dlmalloc@@YAPAXI@Z ENDP				; dlmalloc
_TEXT	ENDS
EXTRN	__imp__SleepEx@8:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_spins$ = -4						; size = 4
_sl$ = 8						; size = 4
?spin_acquire_lock@@YAHPAH@Z PROC			; spin_acquire_lock

; 1864 : static int spin_acquire_lock(int *sl) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1865 :   int spins = 0;

	mov	DWORD PTR _spins$[ebp], 0
$LN4@spin_acqui:

; 1866 :   while (*(volatile int *)sl != 0 || CAS_LOCK(sl)) {

	mov	eax, DWORD PTR _sl$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@spin_acqui
	mov	ecx, 1
	mov	edx, DWORD PTR _sl$[ebp]
	xchg	DWORD PTR [edx], ecx
	test	ecx, ecx
	je	SHORT $LN3@spin_acqui
$LN2@spin_acqui:

; 1867 :     if ((++spins & SPINS_PER_YIELD) == 0) {

	mov	eax, DWORD PTR _spins$[ebp]
	add	eax, 1
	mov	DWORD PTR _spins$[ebp], eax
	mov	ecx, DWORD PTR _spins$[ebp]
	and	ecx, 63					; 0000003fH
	jne	SHORT $LN1@spin_acqui

; 1868 :       SPIN_LOCK_YIELD;

	push	0
	push	50					; 00000032H
	call	DWORD PTR __imp__SleepEx@8
$LN1@spin_acqui:

; 1869 :     }
; 1870 :   }

	jmp	SHORT $LN4@spin_acqui
$LN3@spin_acqui:

; 1871 :   return 0;

	xor	eax, eax

; 1872 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?spin_acquire_lock@@YAHPAH@Z ENDP			; spin_acquire_lock
_TEXT	ENDS
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv74 = -56						; size = 4
tv70 = -52						; size = 4
_system_info$30860 = -48				; size = 36
_psize$30858 = -12					; size = 4
_gsize$30859 = -8					; size = 4
_magic$30857 = -4					; size = 4
?init_mparams@@YAHXZ PROC				; init_mparams

; 3085 : static int init_mparams(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 3086 : #ifdef NEED_GLOBAL_LOCK_INIT
; 3087 :   if (malloc_global_mutex_status <= 0)
; 3088 :     init_malloc_global_mutex();
; 3089 : #endif
; 3090 : 
; 3091 :   ACQUIRE_MALLOC_GLOBAL_LOCK();

	mov	eax, 1
	mov	ecx, OFFSET _malloc_global_mutex
	xchg	DWORD PTR [ecx], eax
	test	eax, eax
	je	SHORT $LN6@init_mpara
	push	OFFSET _malloc_global_mutex
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN7@init_mpara
$LN6@init_mpara:
	mov	DWORD PTR tv70[ebp], 0
$LN7@init_mpara:

; 3092 :   if (mparams.magic == 0) {

	cmp	DWORD PTR _mparams, 0
	jne	$LN3@init_mpara

; 3093 :     size_t magic;
; 3094 :     size_t psize;
; 3095 :     size_t gsize;
; 3096 : 
; 3097 : #ifndef WIN32
; 3098 :     psize = malloc_getpagesize;
; 3099 :     gsize = ((DEFAULT_GRANULARITY != 0)? DEFAULT_GRANULARITY : psize);
; 3100 : #else /* WIN32 */
; 3101 :     {
; 3102 :       SYSTEM_INFO system_info;
; 3103 :       GetSystemInfo(&system_info);

	lea	edx, DWORD PTR _system_info$30860[ebp]
	push	edx
	call	DWORD PTR __imp__GetSystemInfo@4

; 3104 :       psize = system_info.dwPageSize;

	mov	eax, DWORD PTR _system_info$30860[ebp+4]
	mov	DWORD PTR _psize$30858[ebp], eax

; 3105 :       gsize = ((DEFAULT_GRANULARITY != 0)?
; 3106 :                DEFAULT_GRANULARITY : system_info.dwAllocationGranularity);

	xor	ecx, ecx
	je	SHORT $LN8@init_mpara
	mov	DWORD PTR tv74[ebp], 0
	jmp	SHORT $LN9@init_mpara
$LN8@init_mpara:
	mov	edx, DWORD PTR _system_info$30860[ebp+28]
	mov	DWORD PTR tv74[ebp], edx
$LN9@init_mpara:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR _gsize$30859[ebp], eax

; 3107 :     }
; 3108 : #endif /* WIN32 */
; 3109 : 
; 3110 :     /* Sanity-check configuration:
; 3111 :        size_t must be unsigned and as wide as pointer type.
; 3112 :        ints must be at least 4 bytes.
; 3113 :        alignment must be at least 8.
; 3114 :        Alignment, min chunk size, and page size must all be powers of 2.
; 3115 :     */
; 3116 :     if ((sizeof(size_t) != sizeof(char*)) ||
; 3117 :         (MAX_SIZE_T < MIN_CHUNK_SIZE)  ||
; 3118 :         (sizeof(int) < 4)  ||
; 3119 :         (MALLOC_ALIGNMENT < (size_t)8U) ||
; 3120 :         ((MALLOC_ALIGNMENT & (MALLOC_ALIGNMENT-SIZE_T_ONE)) != 0) ||
; 3121 :         ((MCHUNK_SIZE      & (MCHUNK_SIZE-SIZE_T_ONE))      != 0) ||
; 3122 :         ((gsize            & (gsize-SIZE_T_ONE))            != 0) ||
; 3123 :         ((psize            & (psize-SIZE_T_ONE))            != 0))

	xor	ecx, ecx
	jne	SHORT $LN1@init_mpara
	mov	edx, DWORD PTR _gsize$30859[ebp]
	sub	edx, 1
	and	edx, DWORD PTR _gsize$30859[ebp]
	jne	SHORT $LN1@init_mpara
	mov	eax, DWORD PTR _psize$30858[ebp]
	sub	eax, 1
	and	eax, DWORD PTR _psize$30858[ebp]
	je	SHORT $LN2@init_mpara
$LN1@init_mpara:

; 3124 :       ABORT;

	call	DWORD PTR __imp__abort
$LN2@init_mpara:

; 3125 :     mparams.granularity = gsize;

	mov	ecx, DWORD PTR _gsize$30859[ebp]
	mov	DWORD PTR _mparams+8, ecx

; 3126 :     mparams.page_size = psize;

	mov	edx, DWORD PTR _psize$30858[ebp]
	mov	DWORD PTR _mparams+4, edx

; 3127 :     mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;

	mov	DWORD PTR _mparams+12, 262144		; 00040000H

; 3128 :     mparams.trim_threshold = DEFAULT_TRIM_THRESHOLD;

	mov	DWORD PTR _mparams+16, 2097152		; 00200000H

; 3129 : #if MORECORE_CONTIGUOUS
; 3130 :     mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT;
; 3131 : #else  /* MORECORE_CONTIGUOUS */
; 3132 :     mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT|USE_NONCONTIGUOUS_BIT;

	mov	DWORD PTR _mparams+20, 7

; 3133 : #endif /* MORECORE_CONTIGUOUS */
; 3134 : 
; 3135 : #if !ONLY_MSPACES
; 3136 :     /* Set up lock for main malloc area */
; 3137 :     gm->mflags = mparams.default_mflags;

	mov	eax, DWORD PTR _mparams+20
	mov	DWORD PTR __gm_+444, eax

; 3138 :     (void)INITIAL_LOCK(&gm->mutex);

	mov	DWORD PTR __gm_+448, 0

; 3139 : #endif
; 3140 : #if LOCK_AT_FORK
; 3141 :     pthread_atfork(&pre_fork, &post_fork_parent, &post_fork_child);
; 3142 : #endif
; 3143 : 
; 3144 :     {
; 3145 : #if USE_DEV_RANDOM
; 3146 :       int fd;
; 3147 :       unsigned char buf[sizeof(size_t)];
; 3148 :       /* Try to use /dev/urandom, else fall back on using time */
; 3149 :       if ((fd = open("/dev/urandom", O_RDONLY)) >= 0 &&
; 3150 :           read(fd, buf, sizeof(buf)) == sizeof(buf)) {
; 3151 :         magic = *((size_t *) buf);
; 3152 :         close(fd);
; 3153 :       }
; 3154 :       else
; 3155 : #endif /* USE_DEV_RANDOM */
; 3156 : #ifdef WIN32
; 3157 :       magic = (size_t)(GetTickCount() ^ (size_t)0x55555555U);

	call	DWORD PTR __imp__GetTickCount@0
	xor	eax, 1431655765				; 55555555H
	mov	DWORD PTR _magic$30857[ebp], eax

; 3158 : #elif defined(LACKS_TIME_H)
; 3159 :       magic = (size_t)&magic ^ (size_t)0x55555555U;
; 3160 : #else
; 3161 :       magic = (size_t)(time(0) ^ (size_t)0x55555555U);
; 3162 : #endif
; 3163 :       magic |= (size_t)8U;    /* ensure nonzero */

	mov	ecx, DWORD PTR _magic$30857[ebp]
	or	ecx, 8
	mov	DWORD PTR _magic$30857[ebp], ecx

; 3164 :       magic &= ~(size_t)7U;   /* improve chances of fault for bad values */

	mov	edx, DWORD PTR _magic$30857[ebp]
	and	edx, -8					; fffffff8H
	mov	DWORD PTR _magic$30857[ebp], edx

; 3165 :       /* Until memory modes commonly available, use volatile-write */
; 3166 :       (*(volatile size_t *)(&(mparams.magic))) = magic;

	mov	eax, DWORD PTR _magic$30857[ebp]
	mov	DWORD PTR _mparams, eax
$LN3@init_mpara:

; 3167 :     }
; 3168 :   }
; 3169 : 
; 3170 :   RELEASE_MALLOC_GLOBAL_LOCK();

	xor	ecx, ecx
	mov	edx, OFFSET _malloc_global_mutex
	xchg	DWORD PTR [edx], ecx

; 3171 :   return 1;

	mov	eax, 1

; 3172 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?init_mparams@@YAHXZ ENDP				; init_mparams
; Function compile flags: /Odtp
tv357 = -140						; size = 4
tv325 = -136						; size = 4
tv311 = -132						; size = 4
tv292 = -128						; size = 4
tv256 = -124						; size = 4
tv244 = -120						; size = 4
tv211 = -116						; size = 4
tv200 = -112						; size = 4
tv178 = -108						; size = 4
tv147 = -104						; size = 4
tv140 = -100						; size = 4
tv82 = -96						; size = 4
_r$32105 = -92						; size = 4
_rsize$32103 = -88					; size = 4
_p$32104 = -84						; size = 4
_oldbase$32100 = -80					; size = 4
_sp$32085 = -76						; size = 4
_mn$32036 = -72						; size = 4
_ssize$31955 = -68					; size = 4
_end$31934 = -64					; size = 4
_br$31930 = -60						; size = 4
_mp$31917 = -56						; size = 4
_end$31891 = -52					; size = 4
_esize$31850 = -48					; size = 4
_fp$31746 = -44						; size = 4
_base$31738 = -40					; size = 4
_ss$31733 = -36						; size = 4
_ssize$31732 = -32					; size = 4
_br$31728 = -28						; size = 4
_fp$31724 = -24						; size = 4
_mem$31682 = -20					; size = 4
_asize$ = -16						; size = 4
_tbase$ = -12						; size = 4
_tsize$ = -8						; size = 4
_mmap_flag$ = -4					; size = 4
_m$ = 8							; size = 4
_nb$ = 12						; size = 4
?sys_alloc@@YAPAXPAUmalloc_state@@I@Z PROC		; sys_alloc

; 4020 : static void* sys_alloc(mstate m, size_t nb) {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH

; 4021 :   char* tbase = CMFAIL;

	mov	DWORD PTR _tbase$[ebp], -1

; 4022 :   size_t tsize = 0;

	mov	DWORD PTR _tsize$[ebp], 0

; 4023 :   flag_t mmap_flag = 0;

	mov	DWORD PTR _mmap_flag$[ebp], 0

; 4024 :   size_t asize; /* allocation size */
; 4025 : 
; 4026 :   ensure_initialization();

	cmp	DWORD PTR _mparams, 0
	jne	SHORT $LN49@sys_alloc
	call	?init_mparams@@YAHXZ			; init_mparams
$LN49@sys_alloc:

; 4027 : 
; 4028 :   /* Directly map large chunks, but only if already initialized */
; 4029 :   if (use_mmap(m) && nb >= mparams.mmap_threshold && m->topsize != 0) {

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 1
	je	SHORT $LN46@sys_alloc
	mov	edx, DWORD PTR _nb$[ebp]
	cmp	edx, DWORD PTR _mparams+12
	jb	SHORT $LN46@sys_alloc
	mov	eax, DWORD PTR _m$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN46@sys_alloc

; 4030 :     void* mem = mmap_alloc(m, nb);

	mov	ecx, DWORD PTR _nb$[ebp]
	push	ecx
	mov	edx, DWORD PTR _m$[ebp]
	push	edx
	call	?mmap_alloc@@YAPAXPAUmalloc_state@@I@Z	; mmap_alloc
	add	esp, 8
	mov	DWORD PTR _mem$31682[ebp], eax

; 4031 :     if (mem != 0)

	cmp	DWORD PTR _mem$31682[ebp], 0
	je	SHORT $LN46@sys_alloc

; 4032 :       return mem;

	mov	eax, DWORD PTR _mem$31682[ebp]
	jmp	$LN47@sys_alloc
$LN46@sys_alloc:

; 4033 :   }
; 4034 : 
; 4035 :   asize = granularity_align(nb + SYS_ALLOC_PADDING);

	mov	eax, 7
	and	eax, 8
	jne	SHORT $LN50@sys_alloc
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $LN51@sys_alloc
$LN50@sys_alloc:
	mov	ecx, 7
	and	ecx, 8
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv82[ebp], edx
$LN51@sys_alloc:
	mov	eax, DWORD PTR tv82[ebp]
	mov	ecx, DWORD PTR _nb$[ebp]
	lea	edx, DWORD PTR [ecx+eax+48]
	mov	eax, DWORD PTR _mparams+8
	lea	ecx, DWORD PTR [edx+eax-1]
	mov	edx, DWORD PTR _mparams+8
	sub	edx, 1
	not	edx
	and	ecx, edx
	mov	DWORD PTR _asize$[ebp], ecx

; 4036 :   if (asize <= nb)

	mov	eax, DWORD PTR _asize$[ebp]
	cmp	eax, DWORD PTR _nb$[ebp]
	ja	SHORT $LN44@sys_alloc

; 4037 :     return 0; /* wraparound */

	xor	eax, eax
	jmp	$LN47@sys_alloc
$LN44@sys_alloc:

; 4038 :   if (m->footprint_limit != 0) {

	mov	ecx, DWORD PTR _m$[ebp]
	cmp	DWORD PTR [ecx+440], 0
	je	SHORT $LN43@sys_alloc

; 4039 :     size_t fp = m->footprint + asize;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+432]
	add	eax, DWORD PTR _asize$[ebp]
	mov	DWORD PTR _fp$31724[ebp], eax

; 4040 :     if (fp <= m->footprint || fp > m->footprint_limit)

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _fp$31724[ebp]
	cmp	edx, DWORD PTR [ecx+432]
	jbe	SHORT $LN41@sys_alloc
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _fp$31724[ebp]
	cmp	ecx, DWORD PTR [eax+440]
	jbe	SHORT $LN43@sys_alloc
$LN41@sys_alloc:

; 4041 :       return 0;

	xor	eax, eax
	jmp	$LN47@sys_alloc
$LN43@sys_alloc:

; 4042 :   }
; 4043 : 
; 4044 :   /*
; 4045 :     Try getting memory in any of three ways (in most-preferred to
; 4046 :     least-preferred order):
; 4047 :     1. A call to MORECORE that can normally contiguously extend memory.
; 4048 :        (disabled if not MORECORE_CONTIGUOUS or not HAVE_MORECORE or
; 4049 :        or main space is mmapped or a previous contiguous call failed)
; 4050 :     2. A call to MMAP new space (disabled if not HAVE_MMAP).
; 4051 :        Note that under the default settings, if MORECORE is unable to
; 4052 :        fulfill a request, and HAVE_MMAP is true, then mmap is
; 4053 :        used as a noncontiguous system allocator. This is a useful backup
; 4054 :        strategy for systems with holes in address spaces -- in this case
; 4055 :        sbrk cannot contiguously expand the heap, but mmap may be able to
; 4056 :        find space.
; 4057 :     3. A call to MORECORE that cannot usually contiguously extend memory.
; 4058 :        (disabled if not HAVE_MORECORE)
; 4059 : 
; 4060 :    In all cases, we need to request enough bytes from system to ensure
; 4061 :    we can malloc nb bytes upon success, so pad with enough space for
; 4062 :    top_foot, plus alignment-pad to make sure we don't lose bytes if
; 4063 :    not on boundary, and round this up to a granularity unit.
; 4064 :   */
; 4065 : 
; 4066 :   if (MORECORE_CONTIGUOUS && !use_noncontiguous(m)) {

	xor	edx, edx
	je	$LN40@sys_alloc

; 4067 :     char* br = CMFAIL;

	mov	DWORD PTR _br$31728[ebp], -1

; 4068 :     size_t ssize = asize; /* sbrk call size */

	mov	eax, DWORD PTR _asize$[ebp]
	mov	DWORD PTR _ssize$31732[ebp], eax

; 4069 :     msegmentptr ss = (m->top == 0)? 0 : segment_holding(m, (char*)m->top);

	mov	ecx, DWORD PTR _m$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN52@sys_alloc
	mov	DWORD PTR tv140[ebp], 0
	jmp	SHORT $LN53@sys_alloc
$LN52@sys_alloc:
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	?segment_holding@@YAPAUmalloc_segment@@PAUmalloc_state@@PAD@Z ; segment_holding
	add	esp, 8
	mov	DWORD PTR tv140[ebp], eax
$LN53@sys_alloc:
	mov	edx, DWORD PTR tv140[ebp]
	mov	DWORD PTR _ss$31733[ebp], edx

; 4070 :     ACQUIRE_MALLOC_GLOBAL_LOCK();

	mov	eax, 1
	mov	ecx, OFFSET _malloc_global_mutex
	xchg	DWORD PTR [ecx], eax
	test	eax, eax
	je	SHORT $LN54@sys_alloc
	push	OFFSET _malloc_global_mutex
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN55@sys_alloc
$LN54@sys_alloc:
	mov	DWORD PTR tv147[ebp], 0
$LN55@sys_alloc:

; 4071 : 
; 4072 :     if (ss == 0) {  /* First time through or recovery */

	cmp	DWORD PTR _ss$31733[ebp], 0
	jne	$LN39@sys_alloc

; 4073 :       char* base = (char*)CALL_MORECORE(0);

	mov	DWORD PTR _base$31738[ebp], -1

; 4074 :       if (base != CMFAIL) {

	cmp	DWORD PTR _base$31738[ebp], -1
	je	$LN38@sys_alloc

; 4075 :         size_t fp;
; 4076 :         /* Adjust to end on a page boundary */
; 4077 :         if (!is_page_aligned(base))

	mov	edx, DWORD PTR _mparams+4
	sub	edx, 1
	and	edx, DWORD PTR _base$31738[ebp]
	je	SHORT $LN37@sys_alloc

; 4078 :           ssize += (page_align((size_t)base) - (size_t)base);

	mov	eax, DWORD PTR _mparams+4
	mov	ecx, DWORD PTR _base$31738[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	eax, DWORD PTR _mparams+4
	sub	eax, 1
	not	eax
	and	edx, eax
	sub	edx, DWORD PTR _base$31738[ebp]
	add	edx, DWORD PTR _ssize$31732[ebp]
	mov	DWORD PTR _ssize$31732[ebp], edx
$LN37@sys_alloc:

; 4079 :         fp = m->footprint + ssize; /* recheck limits */

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+432]
	add	edx, DWORD PTR _ssize$31732[ebp]
	mov	DWORD PTR _fp$31746[ebp], edx

; 4080 :         if (ssize > nb && ssize < HALF_MAX_SIZE_T &&
; 4081 :             (m->footprint_limit == 0 ||
; 4082 :              (fp > m->footprint && fp <= m->footprint_limit)) &&
; 4083 :             (br = (char*)(CALL_MORECORE(ssize))) == base) {

	mov	eax, DWORD PTR _ssize$31732[ebp]
	cmp	eax, DWORD PTR _nb$[ebp]
	jbe	SHORT $LN38@sys_alloc
	cmp	DWORD PTR _ssize$31732[ebp], 2147483647	; 7fffffffH
	jae	SHORT $LN38@sys_alloc
	mov	ecx, DWORD PTR _m$[ebp]
	cmp	DWORD PTR [ecx+440], 0
	je	SHORT $LN35@sys_alloc
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _fp$31746[ebp]
	cmp	eax, DWORD PTR [edx+432]
	jbe	SHORT $LN38@sys_alloc
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _fp$31746[ebp]
	cmp	edx, DWORD PTR [ecx+440]
	ja	SHORT $LN38@sys_alloc
$LN35@sys_alloc:
	mov	DWORD PTR _br$31728[ebp], -1
	mov	eax, DWORD PTR _br$31728[ebp]
	cmp	eax, DWORD PTR _base$31738[ebp]
	jne	SHORT $LN38@sys_alloc

; 4084 :           tbase = base;

	mov	ecx, DWORD PTR _base$31738[ebp]
	mov	DWORD PTR _tbase$[ebp], ecx

; 4085 :           tsize = ssize;

	mov	edx, DWORD PTR _ssize$31732[ebp]
	mov	DWORD PTR _tsize$[ebp], edx
$LN38@sys_alloc:

; 4086 :         }
; 4087 :       }
; 4088 :     }
; 4089 :     else {

	jmp	SHORT $LN34@sys_alloc
$LN39@sys_alloc:

; 4090 :       /* Subtract out existing available top space from MORECORE request. */
; 4091 :       ssize = granularity_align(nb - m->topsize + SYS_ALLOC_PADDING);

	mov	eax, 7
	and	eax, 8
	jne	SHORT $LN56@sys_alloc
	mov	DWORD PTR tv178[ebp], 0
	jmp	SHORT $LN57@sys_alloc
$LN56@sys_alloc:
	mov	ecx, 7
	and	ecx, 8
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv178[ebp], edx
$LN57@sys_alloc:
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _nb$[ebp]
	sub	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR tv178[ebp]
	lea	eax, DWORD PTR [ecx+edx+48]
	mov	ecx, DWORD PTR _mparams+8
	lea	edx, DWORD PTR [eax+ecx-1]
	mov	eax, DWORD PTR _mparams+8
	sub	eax, 1
	not	eax
	and	edx, eax
	mov	DWORD PTR _ssize$31732[ebp], edx

; 4092 :       /* Use mem here only if it did continuously extend old space */
; 4093 :       if (ssize < HALF_MAX_SIZE_T &&
; 4094 :           (br = (char*)(CALL_MORECORE(ssize))) == ss->base+ss->size) {

	cmp	DWORD PTR _ssize$31732[ebp], 2147483647	; 7fffffffH
	jae	SHORT $LN34@sys_alloc
	mov	DWORD PTR _br$31728[ebp], -1
	mov	ecx, DWORD PTR _ss$31733[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ss$31733[ebp]
	add	edx, DWORD PTR [eax+4]
	cmp	DWORD PTR _br$31728[ebp], edx
	jne	SHORT $LN34@sys_alloc

; 4095 :         tbase = br;

	mov	ecx, DWORD PTR _br$31728[ebp]
	mov	DWORD PTR _tbase$[ebp], ecx

; 4096 :         tsize = ssize;

	mov	edx, DWORD PTR _ssize$31732[ebp]
	mov	DWORD PTR _tsize$[ebp], edx
$LN34@sys_alloc:

; 4097 :       }
; 4098 :     }
; 4099 : 
; 4100 :     if (tbase == CMFAIL) {    /* Cope with partial failure */

	cmp	DWORD PTR _tbase$[ebp], -1
	jne	$LN32@sys_alloc

; 4101 :       if (br != CMFAIL) {    /* Try to use/extend the space we did get */

	cmp	DWORD PTR _br$31728[ebp], -1
	je	$LN31@sys_alloc

; 4102 :         if (ssize < HALF_MAX_SIZE_T &&
; 4103 :             ssize < nb + SYS_ALLOC_PADDING) {

	cmp	DWORD PTR _ssize$31732[ebp], 2147483647	; 7fffffffH
	jae	$LN31@sys_alloc
	mov	eax, 7
	and	eax, 8
	jne	SHORT $LN58@sys_alloc
	mov	DWORD PTR tv200[ebp], 0
	jmp	SHORT $LN59@sys_alloc
$LN58@sys_alloc:
	mov	ecx, 7
	and	ecx, 8
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv200[ebp], edx
$LN59@sys_alloc:
	mov	eax, DWORD PTR tv200[ebp]
	mov	ecx, DWORD PTR _nb$[ebp]
	lea	edx, DWORD PTR [ecx+eax+48]
	cmp	DWORD PTR _ssize$31732[ebp], edx
	jae	SHORT $LN31@sys_alloc

; 4104 :           size_t esize = granularity_align(nb + SYS_ALLOC_PADDING - ssize);

	mov	eax, 7
	and	eax, 8
	jne	SHORT $LN60@sys_alloc
	mov	DWORD PTR tv211[ebp], 0
	jmp	SHORT $LN61@sys_alloc
$LN60@sys_alloc:
	mov	ecx, 7
	and	ecx, 8
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv211[ebp], edx
$LN61@sys_alloc:
	mov	eax, DWORD PTR tv211[ebp]
	mov	ecx, DWORD PTR _nb$[ebp]
	lea	edx, DWORD PTR [ecx+eax+48]
	sub	edx, DWORD PTR _ssize$31732[ebp]
	mov	eax, DWORD PTR _mparams+8
	lea	ecx, DWORD PTR [edx+eax-1]
	mov	edx, DWORD PTR _mparams+8
	sub	edx, 1
	not	edx
	and	ecx, edx
	mov	DWORD PTR _esize$31850[ebp], ecx

; 4105 :           if (esize < HALF_MAX_SIZE_T) {

	cmp	DWORD PTR _esize$31850[ebp], 2147483647	; 7fffffffH
	jae	SHORT $LN31@sys_alloc

; 4106 :             char* end = (char*)CALL_MORECORE(esize);

	mov	DWORD PTR _end$31891[ebp], -1

; 4107 :             if (end != CMFAIL)

	cmp	DWORD PTR _end$31891[ebp], -1
	je	SHORT $LN28@sys_alloc

; 4108 :               ssize += esize;

	mov	eax, DWORD PTR _ssize$31732[ebp]
	add	eax, DWORD PTR _esize$31850[ebp]
	mov	DWORD PTR _ssize$31732[ebp], eax

; 4109 :             else {            /* Can't use; try to release */

	jmp	SHORT $LN31@sys_alloc
$LN28@sys_alloc:

; 4110 :               (void) CALL_MORECORE(-ssize);
; 4111 :               br = CMFAIL;

	mov	DWORD PTR _br$31728[ebp], -1
$LN31@sys_alloc:

; 4112 :             }
; 4113 :           }
; 4114 :         }
; 4115 :       }
; 4116 :       if (br != CMFAIL) {    /* Use the space we did get */

	cmp	DWORD PTR _br$31728[ebp], -1
	je	SHORT $LN26@sys_alloc

; 4117 :         tbase = br;

	mov	ecx, DWORD PTR _br$31728[ebp]
	mov	DWORD PTR _tbase$[ebp], ecx

; 4118 :         tsize = ssize;

	mov	edx, DWORD PTR _ssize$31732[ebp]
	mov	DWORD PTR _tsize$[ebp], edx

; 4119 :       }
; 4120 :       else

	jmp	SHORT $LN32@sys_alloc
$LN26@sys_alloc:

; 4121 :         disable_contiguous(m); /* Don't try contiguous path in the future */

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	or	ecx, 4
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+444], ecx
$LN32@sys_alloc:

; 4122 :     }
; 4123 : 
; 4124 :     RELEASE_MALLOC_GLOBAL_LOCK();

	xor	eax, eax
	mov	ecx, OFFSET _malloc_global_mutex
	xchg	DWORD PTR [ecx], eax
$LN40@sys_alloc:

; 4125 :   }
; 4126 : 
; 4127 :   if (HAVE_MMAP && tbase == CMFAIL) {  /* Try MMAP */

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN24@sys_alloc
	cmp	DWORD PTR _tbase$[ebp], -1
	jne	SHORT $LN24@sys_alloc

; 4128 :     char* mp = (char*)(CALL_MMAP(asize));

	mov	eax, DWORD PTR _asize$[ebp]
	push	eax
	call	?win32mmap@@YAPAXI@Z			; win32mmap
	add	esp, 4
	mov	DWORD PTR _mp$31917[ebp], eax

; 4129 :     if (mp != CMFAIL) {

	cmp	DWORD PTR _mp$31917[ebp], -1
	je	SHORT $LN24@sys_alloc

; 4130 :       tbase = mp;

	mov	ecx, DWORD PTR _mp$31917[ebp]
	mov	DWORD PTR _tbase$[ebp], ecx

; 4131 :       tsize = asize;

	mov	edx, DWORD PTR _asize$[ebp]
	mov	DWORD PTR _tsize$[ebp], edx

; 4132 :       mmap_flag = USE_MMAP_BIT;

	mov	DWORD PTR _mmap_flag$[ebp], 1
$LN24@sys_alloc:

; 4133 :     }
; 4134 :   }
; 4135 : 
; 4136 :   if (HAVE_MORECORE && tbase == CMFAIL) { /* Try noncontiguous MORECORE */

	xor	eax, eax
	je	$LN22@sys_alloc

; 4137 :     if (asize < HALF_MAX_SIZE_T) {

	cmp	DWORD PTR _asize$[ebp], 2147483647	; 7fffffffH
	jae	$LN22@sys_alloc

; 4138 :       char* br = CMFAIL;

	mov	DWORD PTR _br$31930[ebp], -1

; 4139 :       char* end = CMFAIL;

	mov	DWORD PTR _end$31934[ebp], -1

; 4140 :       ACQUIRE_MALLOC_GLOBAL_LOCK();

	mov	ecx, 1
	mov	edx, OFFSET _malloc_global_mutex
	xchg	DWORD PTR [edx], ecx
	test	ecx, ecx
	je	SHORT $LN62@sys_alloc
	push	OFFSET _malloc_global_mutex
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv244[ebp], eax
	jmp	SHORT $LN63@sys_alloc
$LN62@sys_alloc:
	mov	DWORD PTR tv244[ebp], 0
$LN63@sys_alloc:

; 4141 :       br = (char*)(CALL_MORECORE(asize));

	mov	DWORD PTR _br$31930[ebp], -1

; 4142 :       end = (char*)(CALL_MORECORE(0));

	mov	DWORD PTR _end$31934[ebp], -1

; 4143 :       RELEASE_MALLOC_GLOBAL_LOCK();

	xor	eax, eax
	mov	ecx, OFFSET _malloc_global_mutex
	xchg	DWORD PTR [ecx], eax

; 4144 :       if (br != CMFAIL && end != CMFAIL && br < end) {

	cmp	DWORD PTR _br$31930[ebp], -1
	je	SHORT $LN22@sys_alloc
	cmp	DWORD PTR _end$31934[ebp], -1
	je	SHORT $LN22@sys_alloc
	mov	edx, DWORD PTR _br$31930[ebp]
	cmp	edx, DWORD PTR _end$31934[ebp]
	jae	SHORT $LN22@sys_alloc

; 4145 :         size_t ssize = end - br;

	mov	eax, DWORD PTR _end$31934[ebp]
	sub	eax, DWORD PTR _br$31930[ebp]
	mov	DWORD PTR _ssize$31955[ebp], eax

; 4146 :         if (ssize > nb + TOP_FOOT_SIZE) {

	mov	ecx, 7
	and	ecx, 8
	jne	SHORT $LN64@sys_alloc
	mov	DWORD PTR tv256[ebp], 0
	jmp	SHORT $LN65@sys_alloc
$LN64@sys_alloc:
	mov	edx, 7
	and	edx, 8
	mov	eax, 8
	sub	eax, edx
	and	eax, 7
	mov	DWORD PTR tv256[ebp], eax
$LN65@sys_alloc:
	mov	ecx, DWORD PTR tv256[ebp]
	mov	edx, DWORD PTR _nb$[ebp]
	lea	eax, DWORD PTR [edx+ecx+40]
	cmp	DWORD PTR _ssize$31955[ebp], eax
	jbe	SHORT $LN22@sys_alloc

; 4147 :           tbase = br;

	mov	ecx, DWORD PTR _br$31930[ebp]
	mov	DWORD PTR _tbase$[ebp], ecx

; 4148 :           tsize = ssize;

	mov	edx, DWORD PTR _ssize$31955[ebp]
	mov	DWORD PTR _tsize$[ebp], edx
$LN22@sys_alloc:

; 4149 :         }
; 4150 :       }
; 4151 :     }
; 4152 :   }
; 4153 : 
; 4154 :   if (tbase != CMFAIL) {

	cmp	DWORD PTR _tbase$[ebp], -1
	je	$LN18@sys_alloc

; 4155 : 
; 4156 :     if ((m->footprint += tsize) > m->max_footprint)

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+432]
	add	ecx, DWORD PTR _tsize$[ebp]
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+432], ecx
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [eax+432]
	cmp	edx, DWORD PTR [ecx+436]
	jbe	SHORT $LN17@sys_alloc

; 4157 :       m->max_footprint = m->footprint;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+432]
	mov	DWORD PTR [eax+436], edx
$LN17@sys_alloc:

; 4158 : 
; 4159 :     if (!is_initialized(m)) { /* first-time initialization */

	mov	eax, DWORD PTR _m$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	$LN16@sys_alloc

; 4160 :       if (m->least_addr == 0 || tbase < m->least_addr)

	mov	ecx, DWORD PTR _m$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN14@sys_alloc
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _tbase$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jae	SHORT $LN15@sys_alloc
$LN14@sys_alloc:

; 4161 :         m->least_addr = tbase;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _tbase$[ebp]
	mov	DWORD PTR [ecx+16], edx
$LN15@sys_alloc:

; 4162 :       m->seg.base = tbase;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _tbase$[ebp]
	mov	DWORD PTR [eax+452], ecx

; 4163 :       m->seg.size = tsize;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _tsize$[ebp]
	mov	DWORD PTR [edx+456], eax

; 4164 :       m->seg.sflags = mmap_flag;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _mmap_flag$[ebp]
	mov	DWORD PTR [ecx+464], edx

; 4165 :       m->magic = mparams.magic;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _mparams
	mov	DWORD PTR [eax+36], ecx

; 4166 :       m->release_checks = MAX_RELEASE_CHECK_RATE;

	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+32], 4095		; 00000fffH

; 4167 :       init_bins(m);

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	?init_bins@@YAXPAUmalloc_state@@@Z	; init_bins
	add	esp, 4

; 4168 : #if !ONLY_MSPACES
; 4169 :       if (is_global(m))

	cmp	DWORD PTR _m$[ebp], OFFSET __gm_
	jne	SHORT $LN13@sys_alloc

; 4170 :         init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);

	mov	ecx, 7
	and	ecx, 8
	jne	SHORT $LN66@sys_alloc
	mov	DWORD PTR tv292[ebp], 0
	jmp	SHORT $LN67@sys_alloc
$LN66@sys_alloc:
	mov	edx, 7
	and	edx, 8
	mov	eax, 8
	sub	eax, edx
	and	eax, 7
	mov	DWORD PTR tv292[ebp], eax
$LN67@sys_alloc:
	mov	ecx, DWORD PTR tv292[ebp]
	add	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _tsize$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _tbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	?init_top@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z ; init_top
	add	esp, 12					; 0000000cH

; 4171 :       else

	jmp	SHORT $LN12@sys_alloc
$LN13@sys_alloc:

; 4172 : #endif
; 4173 :       {
; 4174 :         /* Offset top by embedded malloc_state */
; 4175 :         mchunkptr mn = next_chunk(mem2chunk(m));

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx-4]
	and	eax, -8					; fffffff8H
	mov	ecx, DWORD PTR _m$[ebp]
	lea	edx, DWORD PTR [ecx+eax-8]
	mov	DWORD PTR _mn$32036[ebp], edx

; 4176 :         init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);

	mov	eax, 7
	and	eax, 8
	jne	SHORT $LN68@sys_alloc
	mov	DWORD PTR tv311[ebp], 0
	jmp	SHORT $LN69@sys_alloc
$LN68@sys_alloc:
	mov	ecx, 7
	and	ecx, 8
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv311[ebp], edx
$LN69@sys_alloc:
	mov	eax, DWORD PTR _tbase$[ebp]
	add	eax, DWORD PTR _tsize$[ebp]
	sub	eax, DWORD PTR _mn$32036[ebp]
	mov	ecx, DWORD PTR tv311[ebp]
	add	ecx, 40					; 00000028H
	sub	eax, ecx
	push	eax
	mov	edx, DWORD PTR _mn$32036[ebp]
	push	edx
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	?init_top@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z ; init_top
	add	esp, 12					; 0000000cH
$LN12@sys_alloc:

; 4177 :       }
; 4178 :     }
; 4179 : 
; 4180 :     else {

	jmp	$LN11@sys_alloc
$LN16@sys_alloc:

; 4181 :       /* Try to merge with an existing segment */
; 4182 :       msegmentptr sp = &m->seg;

	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, 452				; 000001c4H
	mov	DWORD PTR _sp$32085[ebp], ecx
$LN10@sys_alloc:

; 4183 :       /* Only consider most recent segment if traversal suppressed */
; 4184 :       while (sp != 0 && tbase != sp->base + sp->size)

	cmp	DWORD PTR _sp$32085[ebp], 0
	je	SHORT $LN9@sys_alloc
	mov	edx, DWORD PTR _sp$32085[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _sp$32085[ebp]
	add	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR _tbase$[ebp], eax
	je	SHORT $LN9@sys_alloc

; 4185 :         sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;

	xor	edx, edx
	je	SHORT $LN70@sys_alloc
	mov	DWORD PTR tv325[ebp], 0
	jmp	SHORT $LN71@sys_alloc
$LN70@sys_alloc:
	mov	eax, DWORD PTR _sp$32085[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv325[ebp], ecx
$LN71@sys_alloc:
	mov	edx, DWORD PTR tv325[ebp]
	mov	DWORD PTR _sp$32085[ebp], edx
	jmp	SHORT $LN10@sys_alloc
$LN9@sys_alloc:

; 4186 :       if (sp != 0 &&
; 4187 :           !is_extern_segment(sp) &&
; 4188 :           (sp->sflags & USE_MMAP_BIT) == mmap_flag &&
; 4189 :           segment_holds(sp, m->top)) { /* append */

	cmp	DWORD PTR _sp$32085[ebp], 0
	je	SHORT $LN8@sys_alloc
	mov	eax, DWORD PTR _sp$32085[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 8
	jne	SHORT $LN8@sys_alloc
	mov	edx, DWORD PTR _sp$32085[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 1
	cmp	eax, DWORD PTR _mmap_flag$[ebp]
	jne	SHORT $LN8@sys_alloc
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _sp$32085[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx]
	jb	SHORT $LN8@sys_alloc
	mov	ecx, DWORD PTR _sp$32085[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _sp$32085[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _m$[ebp]
	cmp	DWORD PTR [ecx+24], edx
	jae	SHORT $LN8@sys_alloc

; 4190 :         sp->size += tsize;

	mov	edx, DWORD PTR _sp$32085[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR _tsize$[ebp]
	mov	ecx, DWORD PTR _sp$32085[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4191 :         init_top(m, m->top, m->topsize + tsize);

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _tsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	?init_top@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z ; init_top
	add	esp, 12					; 0000000cH

; 4192 :       }
; 4193 :       else {

	jmp	$LN11@sys_alloc
$LN8@sys_alloc:

; 4194 :         if (tbase < m->least_addr)

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _tbase$[ebp]
	cmp	edx, DWORD PTR [ecx+16]
	jae	SHORT $LN6@sys_alloc

; 4195 :           m->least_addr = tbase;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _tbase$[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN6@sys_alloc:

; 4196 :         sp = &m->seg;

	mov	edx, DWORD PTR _m$[ebp]
	add	edx, 452				; 000001c4H
	mov	DWORD PTR _sp$32085[ebp], edx
$LN5@sys_alloc:

; 4197 :         while (sp != 0 && sp->base != tbase + tsize)

	cmp	DWORD PTR _sp$32085[ebp], 0
	je	SHORT $LN4@sys_alloc
	mov	eax, DWORD PTR _tbase$[ebp]
	add	eax, DWORD PTR _tsize$[ebp]
	mov	ecx, DWORD PTR _sp$32085[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $LN4@sys_alloc

; 4198 :           sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;

	xor	edx, edx
	je	SHORT $LN72@sys_alloc
	mov	DWORD PTR tv357[ebp], 0
	jmp	SHORT $LN73@sys_alloc
$LN72@sys_alloc:
	mov	eax, DWORD PTR _sp$32085[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv357[ebp], ecx
$LN73@sys_alloc:
	mov	edx, DWORD PTR tv357[ebp]
	mov	DWORD PTR _sp$32085[ebp], edx
	jmp	SHORT $LN5@sys_alloc
$LN4@sys_alloc:

; 4199 :         if (sp != 0 &&
; 4200 :             !is_extern_segment(sp) &&
; 4201 :             (sp->sflags & USE_MMAP_BIT) == mmap_flag) {

	cmp	DWORD PTR _sp$32085[ebp], 0
	je	SHORT $LN3@sys_alloc
	mov	eax, DWORD PTR _sp$32085[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 8
	jne	SHORT $LN3@sys_alloc
	mov	edx, DWORD PTR _sp$32085[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 1
	cmp	eax, DWORD PTR _mmap_flag$[ebp]
	jne	SHORT $LN3@sys_alloc

; 4202 :           char* oldbase = sp->base;

	mov	ecx, DWORD PTR _sp$32085[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _oldbase$32100[ebp], edx

; 4203 :           sp->base = tbase;

	mov	eax, DWORD PTR _sp$32085[ebp]
	mov	ecx, DWORD PTR _tbase$[ebp]
	mov	DWORD PTR [eax], ecx

; 4204 :           sp->size += tsize;

	mov	edx, DWORD PTR _sp$32085[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR _tsize$[ebp]
	mov	ecx, DWORD PTR _sp$32085[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4205 :           return prepend_alloc(m, tbase, oldbase, nb);

	mov	edx, DWORD PTR _nb$[ebp]
	push	edx
	mov	eax, DWORD PTR _oldbase$32100[ebp]
	push	eax
	mov	ecx, DWORD PTR _tbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR _m$[ebp]
	push	edx
	call	?prepend_alloc@@YAPAXPAUmalloc_state@@PAD1I@Z ; prepend_alloc
	add	esp, 16					; 00000010H
	jmp	$LN47@sys_alloc

; 4206 :         }
; 4207 :         else

	jmp	SHORT $LN11@sys_alloc
$LN3@sys_alloc:

; 4208 :           add_segment(m, tbase, tsize, mmap_flag);

	mov	eax, DWORD PTR _mmap_flag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tbase$[ebp]
	push	edx
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	?add_segment@@YAXPAUmalloc_state@@PADII@Z ; add_segment
	add	esp, 16					; 00000010H
$LN11@sys_alloc:

; 4209 :       }
; 4210 :     }
; 4211 : 
; 4212 :     if (nb < m->topsize) { /* Allocate from new or extended top space */

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _nb$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jae	SHORT $LN18@sys_alloc

; 4213 :       size_t rsize = m->topsize -= nb;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _rsize$32103[ebp], ecx

; 4214 :       mchunkptr p = m->top;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _p$32104[ebp], eax

; 4215 :       mchunkptr r = m->top = chunk_plus_offset(p, nb);

	mov	ecx, DWORD PTR _p$32104[ebp]
	add	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+24], ecx
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _r$32105[ebp], ecx

; 4216 :       r->head = rsize | PINUSE_BIT;

	mov	edx, DWORD PTR _rsize$32103[ebp]
	or	edx, 1
	mov	eax, DWORD PTR _r$32105[ebp]
	mov	DWORD PTR [eax+4], edx

; 4217 :       set_size_and_pinuse_of_inuse_chunk(m, p, nb);

	mov	ecx, DWORD PTR _nb$[ebp]
	or	ecx, 1
	or	ecx, 2
	mov	edx, DWORD PTR _p$32104[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4218 :       check_top_chunk(m, m->top);
; 4219 :       check_malloced_chunk(m, chunk2mem(p), nb);
; 4220 :       return chunk2mem(p);

	mov	eax, DWORD PTR _p$32104[ebp]
	add	eax, 8
	jmp	SHORT $LN47@sys_alloc
$LN18@sys_alloc:

; 4221 :     }
; 4222 :   }
; 4223 : 
; 4224 :   MALLOC_FAILURE_ACTION;
; 4225 :   return 0;

	xor	eax, eax
$LN47@sys_alloc:

; 4226 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?sys_alloc@@YAPAXPAUmalloc_state@@I@Z ENDP		; sys_alloc
_TEXT	ENDS
EXTRN	__imp__VirtualAlloc@16:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv70 = -8						; size = 4
_ptr$ = -4						; size = 4
_size$ = 8						; size = 4
?win32mmap@@YAPAXI@Z PROC				; win32mmap

; 1653 : static FORCEINLINE void* win32mmap(size_t size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1654 :   void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);

	push	4
	push	12288					; 00003000H
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__VirtualAlloc@16
	mov	DWORD PTR _ptr$[ebp], eax

; 1655 :   return (ptr != 0)? ptr: MFAIL;

	cmp	DWORD PTR _ptr$[ebp], 0
	je	SHORT $LN3@win32mmap
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN4@win32mmap
$LN3@win32mmap:
	mov	DWORD PTR tv70[ebp], -1
$LN4@win32mmap:
	mov	eax, DWORD PTR tv70[ebp]

; 1656 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?win32mmap@@YAPAXI@Z ENDP				; win32mmap
; Function compile flags: /Odtp
_sp$ = -4						; size = 4
_m$ = 8							; size = 4
_addr$ = 12						; size = 4
?segment_holding@@YAPAUmalloc_segment@@PAUmalloc_state@@PAD@Z PROC ; segment_holding

; 2684 : static msegmentptr segment_holding(mstate m, char* addr) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2685 :   msegmentptr sp = &m->seg;

	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 452				; 000001c4H
	mov	DWORD PTR _sp$[ebp], eax
$LN4@segment_ho:

; 2686 :   for (;;) {
; 2687 :     if (addr >= sp->base && addr < sp->base + sp->size)

	mov	ecx, DWORD PTR _sp$[ebp]
	mov	edx, DWORD PTR _addr$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jb	SHORT $LN2@segment_ho
	mov	eax, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _sp$[ebp]
	add	ecx, DWORD PTR [edx+4]
	cmp	DWORD PTR _addr$[ebp], ecx
	jae	SHORT $LN2@segment_ho

; 2688 :       return sp;

	mov	eax, DWORD PTR _sp$[ebp]
	jmp	SHORT $LN5@segment_ho
$LN2@segment_ho:

; 2689 :     if ((sp = sp->next) == 0)

	mov	eax, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _sp$[ebp], ecx
	cmp	DWORD PTR _sp$[ebp], 0
	jne	SHORT $LN1@segment_ho

; 2690 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN5@segment_ho
$LN1@segment_ho:

; 2691 :   }

	jmp	SHORT $LN4@segment_ho
$LN5@segment_ho:

; 2692 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?segment_holding@@YAPAUmalloc_segment@@PAUmalloc_state@@PAD@Z ENDP ; segment_holding
; Function compile flags: /Odtp
tv90 = -28						; size = 4
_psize$31157 = -24					; size = 4
_offset$31137 = -20					; size = 4
_p$31159 = -16						; size = 4
_mm$31131 = -12						; size = 4
_fp$31127 = -8						; size = 4
_mmsize$ = -4						; size = 4
_m$ = 8							; size = 4
_nb$ = 12						; size = 4
?mmap_alloc@@YAPAXPAUmalloc_state@@I@Z PROC		; mmap_alloc

; 3809 : static void* mmap_alloc(mstate m, size_t nb) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3810 :   size_t mmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);

	mov	eax, DWORD PTR _mparams+8
	mov	ecx, DWORD PTR _nb$[ebp]
	lea	edx, DWORD PTR [ecx+eax+30]
	mov	eax, DWORD PTR _mparams+8
	sub	eax, 1
	not	eax
	and	edx, eax
	mov	DWORD PTR _mmsize$[ebp], edx

; 3811 :   if (m->footprint_limit != 0) {

	mov	ecx, DWORD PTR _m$[ebp]
	cmp	DWORD PTR [ecx+440], 0
	je	SHORT $LN8@mmap_alloc

; 3812 :     size_t fp = m->footprint + mmsize;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+432]
	add	eax, DWORD PTR _mmsize$[ebp]
	mov	DWORD PTR _fp$31127[ebp], eax

; 3813 :     if (fp <= m->footprint || fp > m->footprint_limit)

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _fp$31127[ebp]
	cmp	edx, DWORD PTR [ecx+432]
	jbe	SHORT $LN6@mmap_alloc
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _fp$31127[ebp]
	cmp	ecx, DWORD PTR [eax+440]
	jbe	SHORT $LN8@mmap_alloc
$LN6@mmap_alloc:

; 3814 :       return 0;

	xor	eax, eax
	jmp	$LN9@mmap_alloc
$LN8@mmap_alloc:

; 3815 :   }
; 3816 :   if (mmsize > nb) {     /* Check for wrap around 0 */

	mov	edx, DWORD PTR _mmsize$[ebp]
	cmp	edx, DWORD PTR _nb$[ebp]
	jbe	$LN5@mmap_alloc

; 3817 :     char* mm = (char*)(CALL_DIRECT_MMAP(mmsize));

	mov	eax, DWORD PTR _mmsize$[ebp]
	push	eax
	call	?win32direct_mmap@@YAPAXI@Z		; win32direct_mmap
	add	esp, 4
	mov	DWORD PTR _mm$31131[ebp], eax

; 3818 :     if (mm != CMFAIL) {

	cmp	DWORD PTR _mm$31131[ebp], -1
	je	$LN5@mmap_alloc

; 3819 :       size_t offset = align_offset(chunk2mem(mm));

	mov	ecx, DWORD PTR _mm$31131[ebp]
	add	ecx, 8
	and	ecx, 7
	jne	SHORT $LN11@mmap_alloc
	mov	DWORD PTR tv90[ebp], 0
	jmp	SHORT $LN12@mmap_alloc
$LN11@mmap_alloc:
	mov	edx, DWORD PTR _mm$31131[ebp]
	add	edx, 8
	and	edx, 7
	mov	eax, 8
	sub	eax, edx
	and	eax, 7
	mov	DWORD PTR tv90[ebp], eax
$LN12@mmap_alloc:
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR _offset$31137[ebp], ecx

; 3820 :       size_t psize = mmsize - offset - MMAP_FOOT_PAD;

	mov	edx, DWORD PTR _mmsize$[ebp]
	sub	edx, DWORD PTR _offset$31137[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR _psize$31157[ebp], edx

; 3821 :       mchunkptr p = (mchunkptr)(mm + offset);

	mov	eax, DWORD PTR _mm$31131[ebp]
	add	eax, DWORD PTR _offset$31137[ebp]
	mov	DWORD PTR _p$31159[ebp], eax

; 3822 :       p->prev_foot = offset;

	mov	ecx, DWORD PTR _p$31159[ebp]
	mov	edx, DWORD PTR _offset$31137[ebp]
	mov	DWORD PTR [ecx], edx

; 3823 :       p->head = psize;

	mov	eax, DWORD PTR _p$31159[ebp]
	mov	ecx, DWORD PTR _psize$31157[ebp]
	mov	DWORD PTR [eax+4], ecx

; 3824 :       mark_inuse_foot(m, p, psize);
; 3825 :       chunk_plus_offset(p, psize)->head = FENCEPOST_HEAD;

	mov	edx, DWORD PTR _p$31159[ebp]
	add	edx, DWORD PTR _psize$31157[ebp]
	mov	DWORD PTR [edx+4], 7

; 3826 :       chunk_plus_offset(p, psize+SIZE_T_SIZE)->head = 0;

	mov	eax, DWORD PTR _p$31159[ebp]
	add	eax, DWORD PTR _psize$31157[ebp]
	mov	DWORD PTR [eax+8], 0

; 3827 : 
; 3828 :       if (m->least_addr == 0 || mm < m->least_addr)

	mov	ecx, DWORD PTR _m$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN2@mmap_alloc
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _mm$31131[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jae	SHORT $LN3@mmap_alloc
$LN2@mmap_alloc:

; 3829 :         m->least_addr = mm;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _mm$31131[ebp]
	mov	DWORD PTR [ecx+16], edx
$LN3@mmap_alloc:

; 3830 :       if ((m->footprint += mmsize) > m->max_footprint)

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+432]
	add	ecx, DWORD PTR _mmsize$[ebp]
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+432], ecx
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [eax+432]
	cmp	edx, DWORD PTR [ecx+436]
	jbe	SHORT $LN1@mmap_alloc

; 3831 :         m->max_footprint = m->footprint;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+432]
	mov	DWORD PTR [eax+436], edx
$LN1@mmap_alloc:

; 3832 :       assert(is_aligned(chunk2mem(p)));
; 3833 :       check_mmapped_chunk(m, p);
; 3834 :       return chunk2mem(p);

	mov	eax, DWORD PTR _p$31159[ebp]
	add	eax, 8
	jmp	SHORT $LN9@mmap_alloc
$LN5@mmap_alloc:

; 3835 :     }
; 3836 :   }
; 3837 :   return 0;

	xor	eax, eax
$LN9@mmap_alloc:

; 3838 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mmap_alloc@@YAPAXPAUmalloc_state@@I@Z ENDP		; mmap_alloc
; Function compile flags: /Odtp
tv70 = -8						; size = 4
_ptr$ = -4						; size = 4
_size$ = 8						; size = 4
?win32direct_mmap@@YAPAXI@Z PROC			; win32direct_mmap

; 1659 : static FORCEINLINE void* win32direct_mmap(size_t size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1660 :   void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,
; 1661 :                            PAGE_READWRITE);

	push	4
	push	1060864					; 00103000H
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__VirtualAlloc@16
	mov	DWORD PTR _ptr$[ebp], eax

; 1662 :   return (ptr != 0)? ptr: MFAIL;

	cmp	DWORD PTR _ptr$[ebp], 0
	je	SHORT $LN3@win32direc
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN4@win32direc
$LN3@win32direc:
	mov	DWORD PTR tv70[ebp], -1
$LN4@win32direc:
	mov	eax, DWORD PTR tv70[ebp]

; 1663 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?win32direct_mmap@@YAPAXI@Z ENDP			; win32direct_mmap
; Function compile flags: /Odtp
tv85 = -12						; size = 4
tv71 = -8						; size = 4
_offset$ = -4						; size = 4
_m$ = 8							; size = 4
_p$ = 12						; size = 4
_psize$ = 16						; size = 4
?init_top@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z PROC ; init_top

; 3879 : static void init_top(mstate m, mchunkptr p, size_t psize) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3880 :   /* Ensure alignment */
; 3881 :   size_t offset = align_offset(chunk2mem(p));

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 8
	and	eax, 7
	jne	SHORT $LN3@init_top
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN4@init_top
$LN3@init_top:
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 8
	and	ecx, 7
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv71[ebp], edx
$LN4@init_top:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR _offset$[ebp], eax

; 3882 :   p = (mchunkptr)((char*)p + offset);

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 3883 :   psize -= offset;

	mov	edx, DWORD PTR _psize$[ebp]
	sub	edx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _psize$[ebp], edx

; 3884 : 
; 3885 :   m->top = p;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 3886 :   m->topsize = psize;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _psize$[ebp]
	mov	DWORD PTR [edx+12], eax

; 3887 :   p->head = psize | PINUSE_BIT;

	mov	ecx, DWORD PTR _psize$[ebp]
	or	ecx, 1
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 3888 :   /* set size of fake trailing chunk holding overhead space only once */
; 3889 :   chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;

	mov	eax, 7
	and	eax, 8
	jne	SHORT $LN5@init_top
	mov	DWORD PTR tv85[ebp], 0
	jmp	SHORT $LN6@init_top
$LN5@init_top:
	mov	ecx, 7
	and	ecx, 8
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv85[ebp], edx
$LN6@init_top:
	mov	eax, DWORD PTR tv85[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _psize$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 3890 :   m->trim_check = mparams.trim_threshold; /* reset on each update */

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _mparams+16
	mov	DWORD PTR [edx+28], eax

; 3891 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?init_top@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z ENDP ; init_top
; Function compile flags: /Odtp
_bin$31294 = -8					; size = 4
_i$ = -4						; size = 4
_m$ = 8							; size = 4
?init_bins@@YAXPAUmalloc_state@@@Z PROC			; init_bins

; 3894 : static void init_bins(mstate m) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3895 :   /* Establish circular links for smallbins */
; 3896 :   bindex_t i;
; 3897 :   for (i = 0; i < NSMALLBINS; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@init_bins
$LN2@init_bins:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@init_bins:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jae	SHORT $LN4@init_bins

; 3898 :     sbinptr bin = smallbin_at(m,i);

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _m$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+40]
	mov	DWORD PTR _bin$31294[ebp], eax

; 3899 :     bin->fd = bin->bk = bin;

	mov	ecx, DWORD PTR _bin$31294[ebp]
	mov	edx, DWORD PTR _bin$31294[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _bin$31294[ebp]
	mov	ecx, DWORD PTR _bin$31294[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN2@init_bins
$LN4@init_bins:

; 3900 :   }
; 3901 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?init_bins@@YAXPAUmalloc_state@@@Z ENDP			; init_bins
; Function compile flags: /Odtp
tv308 = -140						; size = 4
tv80 = -136						; size = 4
tv71 = -132						; size = 4
_F$31482 = -128						; size = 4
_C$31474 = -124						; size = 4
_K$31464 = -120						; size = 4
_T$31463 = -116						; size = 4
_K$31454 = -112						; size = 4
_X$31449 = -108						; size = 4
_I$31448 = -104						; size = 4
_H$31447 = -100						; size = 4
_TP$31445 = -96						; size = 4
_I$31432 = -92						; size = 4
_F$31437 = -88						; size = 4
_B$31434 = -84						; size = 4
_C0$31416 = -80						; size = 4
_C1$31417 = -76						; size = 4
_H$31405 = -72						; size = 4
_CP$31397 = -68						; size = 4
_RP$31394 = -64						; size = 4
_F$31390 = -60						; size = 4
_R$31388 = -56						; size = 4
_XP$31387 = -52						; size = 4
_TP$31385 = -48						; size = 4
_I$31375 = -44						; size = 4
_F$31373 = -40						; size = 4
_B$31374 = -36						; size = 4
_nsize$31368 = -32					; size = 4
_dsize$31359 = -28					; size = 4
_tsize$31355 = -24					; size = 4
_psize$ = -20						; size = 4
_qsize$ = -16						; size = 4
_oldfirst$ = -12					; size = 4
_q$ = -8						; size = 4
_p$ = -4						; size = 4
_m$ = 8							; size = 4
_newbase$ = 12						; size = 4
_oldbase$ = 16						; size = 4
_nb$ = 20						; size = 4
?prepend_alloc@@YAPAXPAUmalloc_state@@PAD1I@Z PROC	; prepend_alloc

; 3924 :                            size_t nb) {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH

; 3925 :   mchunkptr p = align_as_chunk(newbase);

	mov	eax, DWORD PTR _newbase$[ebp]
	add	eax, 8
	and	eax, 7
	jne	SHORT $LN66@prepend_al
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN67@prepend_al
$LN66@prepend_al:
	mov	ecx, DWORD PTR _newbase$[ebp]
	add	ecx, 8
	and	ecx, 7
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv71[ebp], edx
$LN67@prepend_al:
	mov	eax, DWORD PTR _newbase$[ebp]
	add	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 3926 :   mchunkptr oldfirst = align_as_chunk(oldbase);

	mov	ecx, DWORD PTR _oldbase$[ebp]
	add	ecx, 8
	and	ecx, 7
	jne	SHORT $LN68@prepend_al
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN69@prepend_al
$LN68@prepend_al:
	mov	edx, DWORD PTR _oldbase$[ebp]
	add	edx, 8
	and	edx, 7
	mov	eax, 8
	sub	eax, edx
	and	eax, 7
	mov	DWORD PTR tv80[ebp], eax
$LN69@prepend_al:
	mov	ecx, DWORD PTR _oldbase$[ebp]
	add	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _oldfirst$[ebp], ecx

; 3927 :   size_t psize = (char*)oldfirst - (char*)p;

	mov	edx, DWORD PTR _oldfirst$[ebp]
	sub	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _psize$[ebp], edx

; 3928 :   mchunkptr q = chunk_plus_offset(p, nb);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _q$[ebp], eax

; 3929 :   size_t qsize = psize - nb;

	mov	ecx, DWORD PTR _psize$[ebp]
	sub	ecx, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _qsize$[ebp], ecx

; 3930 :   set_size_and_pinuse_of_inuse_chunk(m, p, nb);

	mov	edx, DWORD PTR _nb$[ebp]
	or	edx, 1
	or	edx, 2
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], edx

; 3931 : 
; 3932 :   assert((char*)oldfirst > (char*)q);
; 3933 :   assert(pinuse(oldfirst));
; 3934 :   assert(qsize >= MIN_CHUNK_SIZE);
; 3935 : 
; 3936 :   /* consolidate remainder with first chunk of old base */
; 3937 :   if (oldfirst == m->top) {

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _oldfirst$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jne	SHORT $LN63@prepend_al

; 3938 :     size_t tsize = m->topsize += qsize;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _qsize$[ebp]
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _tsize$31355[ebp], ecx

; 3939 :     m->top = q;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _q$[ebp]
	mov	DWORD PTR [edx+24], eax

; 3940 :     q->head = tsize | PINUSE_BIT;

	mov	ecx, DWORD PTR _tsize$31355[ebp]
	or	ecx, 1
	mov	edx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [edx+4], ecx
	jmp	$LN62@prepend_al
$LN63@prepend_al:

; 3941 :     check_top_chunk(m, q);
; 3942 :   }
; 3943 :   else if (oldfirst == m->dv) {

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _oldfirst$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN61@prepend_al

; 3944 :     size_t dsize = m->dvsize += qsize;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, DWORD PTR _qsize$[ebp]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _dsize$31359[ebp], eax

; 3945 :     m->dv = q;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 3946 :     set_size_and_pinuse_of_free_chunk(q, dsize);

	mov	eax, DWORD PTR _dsize$31359[ebp]
	or	eax, 1
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _q$[ebp]
	add	edx, DWORD PTR _dsize$31359[ebp]
	mov	eax, DWORD PTR _dsize$31359[ebp]
	mov	DWORD PTR [edx], eax

; 3947 :   }
; 3948 :   else {

	jmp	$LN62@prepend_al
$LN61@prepend_al:

; 3949 :     if (!is_inuse(oldfirst)) {

	mov	ecx, DWORD PTR _oldfirst$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 3
	cmp	edx, 1
	jne	$LN59@prepend_al

; 3950 :       size_t nsize = chunksize(oldfirst);

	mov	eax, DWORD PTR _oldfirst$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	mov	DWORD PTR _nsize$31368[ebp], ecx

; 3951 :       unlink_chunk(m, oldfirst, nsize);

	mov	edx, DWORD PTR _nsize$31368[ebp]
	shr	edx, 3
	cmp	edx, 32					; 00000020H
	jae	SHORT $LN58@prepend_al
	mov	eax, DWORD PTR _oldfirst$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$31373[ebp], ecx
	mov	edx, DWORD PTR _oldfirst$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _B$31374[ebp], eax
	mov	ecx, DWORD PTR _nsize$31368[ebp]
	shr	ecx, 3
	mov	DWORD PTR _I$31375[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN57@prepend_al
	mov	eax, DWORD PTR _B$31374[ebp]
	cmp	eax, DWORD PTR _F$31373[ebp]
	jne	SHORT $LN56@prepend_al
	mov	edx, 1
	mov	ecx, DWORD PTR _I$31375[ebp]
	shl	edx, cl
	not	edx
	mov	eax, DWORD PTR _m$[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN55@prepend_al
$LN56@prepend_al:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN54@prepend_al
	mov	eax, DWORD PTR _F$31373[ebp]
	mov	ecx, DWORD PTR _B$31374[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _B$31374[ebp]
	mov	eax, DWORD PTR _F$31373[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN55@prepend_al
$LN54@prepend_al:
	call	DWORD PTR __imp__abort
$LN55@prepend_al:
	jmp	SHORT $LN52@prepend_al
$LN57@prepend_al:
	call	DWORD PTR __imp__abort
$LN52@prepend_al:
	jmp	$LN51@prepend_al
$LN58@prepend_al:
	mov	ecx, DWORD PTR _oldfirst$[ebp]
	mov	DWORD PTR _TP$31385[ebp], ecx
	mov	edx, DWORD PTR _TP$31385[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _XP$31387[ebp], eax
	mov	ecx, DWORD PTR _TP$31385[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _TP$31385[ebp]
	je	SHORT $LN50@prepend_al
	mov	eax, DWORD PTR _TP$31385[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$31390[ebp], ecx
	mov	edx, DWORD PTR _TP$31385[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _R$31388[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN49@prepend_al
	mov	edx, DWORD PTR _F$31390[ebp]
	mov	eax, DWORD PTR _R$31388[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _R$31388[ebp]
	mov	edx, DWORD PTR _F$31390[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN48@prepend_al
$LN49@prepend_al:
	call	DWORD PTR __imp__abort
$LN48@prepend_al:
	jmp	SHORT $LN47@prepend_al
$LN50@prepend_al:
	mov	eax, DWORD PTR _TP$31385[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _RP$31394[ebp], eax
	mov	ecx, DWORD PTR _RP$31394[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _R$31388[ebp], edx
	cmp	DWORD PTR _R$31388[ebp], 0
	jne	SHORT $LN44@prepend_al
	mov	eax, DWORD PTR _TP$31385[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _RP$31394[ebp], eax
	mov	ecx, DWORD PTR _RP$31394[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _R$31388[ebp], edx
	cmp	DWORD PTR _R$31388[ebp], 0
	je	SHORT $LN47@prepend_al
$LN44@prepend_al:
	mov	eax, DWORD PTR _R$31388[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _CP$31397[ebp], eax
	mov	ecx, DWORD PTR _CP$31397[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN42@prepend_al
	mov	edx, DWORD PTR _R$31388[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _CP$31397[ebp], edx
	mov	eax, DWORD PTR _CP$31397[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN43@prepend_al
$LN42@prepend_al:
	mov	ecx, DWORD PTR _CP$31397[ebp]
	mov	DWORD PTR _RP$31394[ebp], ecx
	mov	edx, DWORD PTR _RP$31394[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _R$31388[ebp], eax
	jmp	SHORT $LN44@prepend_al
$LN43@prepend_al:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN41@prepend_al
	mov	edx, DWORD PTR _RP$31394[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN47@prepend_al
$LN41@prepend_al:
	call	DWORD PTR __imp__abort
$LN47@prepend_al:
	cmp	DWORD PTR _XP$31387[ebp], 0
	je	$LN51@prepend_al
	mov	eax, DWORD PTR _TP$31385[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _m$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+304]
	mov	DWORD PTR _H$31405[ebp], eax
	mov	ecx, DWORD PTR _H$31405[ebp]
	mov	edx, DWORD PTR _TP$31385[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN38@prepend_al
	mov	eax, DWORD PTR _H$31405[ebp]
	mov	ecx, DWORD PTR _R$31388[ebp]
	mov	DWORD PTR [eax], ecx
	cmp	DWORD PTR _R$31388[ebp], 0
	jne	SHORT $LN37@prepend_al
	mov	edx, DWORD PTR _TP$31385[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+28]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _m$[ebp]
	and	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN37@prepend_al:
	jmp	SHORT $LN36@prepend_al
$LN38@prepend_al:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN35@prepend_al
	mov	ecx, DWORD PTR _XP$31387[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _TP$31385[ebp]
	jne	SHORT $LN34@prepend_al
	mov	eax, DWORD PTR _XP$31387[ebp]
	mov	ecx, DWORD PTR _R$31388[ebp]
	mov	DWORD PTR [eax+16], ecx
	jmp	SHORT $LN33@prepend_al
$LN34@prepend_al:
	mov	edx, DWORD PTR _XP$31387[ebp]
	mov	eax, DWORD PTR _R$31388[ebp]
	mov	DWORD PTR [edx+20], eax
$LN33@prepend_al:
	jmp	SHORT $LN36@prepend_al
$LN35@prepend_al:
	call	DWORD PTR __imp__abort
$LN36@prepend_al:
	cmp	DWORD PTR _R$31388[ebp], 0
	je	SHORT $LN51@prepend_al
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN30@prepend_al
	mov	edx, DWORD PTR _R$31388[ebp]
	mov	eax, DWORD PTR _XP$31387[ebp]
	mov	DWORD PTR [edx+24], eax
	mov	ecx, DWORD PTR _TP$31385[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _C0$31416[ebp], edx
	cmp	DWORD PTR _C0$31416[ebp], 0
	je	SHORT $LN29@prepend_al
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN28@prepend_al
	mov	ecx, DWORD PTR _R$31388[ebp]
	mov	edx, DWORD PTR _C0$31416[ebp]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR _C0$31416[ebp]
	mov	ecx, DWORD PTR _R$31388[ebp]
	mov	DWORD PTR [eax+24], ecx
	jmp	SHORT $LN29@prepend_al
$LN28@prepend_al:
	call	DWORD PTR __imp__abort
$LN29@prepend_al:
	mov	edx, DWORD PTR _TP$31385[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _C1$31417[ebp], eax
	cmp	DWORD PTR _C1$31417[ebp], 0
	je	SHORT $LN26@prepend_al
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN25@prepend_al
	mov	edx, DWORD PTR _R$31388[ebp]
	mov	eax, DWORD PTR _C1$31417[ebp]
	mov	DWORD PTR [edx+20], eax
	mov	ecx, DWORD PTR _C1$31417[ebp]
	mov	edx, DWORD PTR _R$31388[ebp]
	mov	DWORD PTR [ecx+24], edx
	jmp	SHORT $LN26@prepend_al
$LN25@prepend_al:
	call	DWORD PTR __imp__abort
$LN26@prepend_al:
	jmp	SHORT $LN51@prepend_al
$LN30@prepend_al:
	call	DWORD PTR __imp__abort
$LN51@prepend_al:

; 3952 :       oldfirst = chunk_plus_offset(oldfirst, nsize);

	mov	eax, DWORD PTR _oldfirst$[ebp]
	add	eax, DWORD PTR _nsize$31368[ebp]
	mov	DWORD PTR _oldfirst$[ebp], eax

; 3953 :       qsize += nsize;

	mov	ecx, DWORD PTR _qsize$[ebp]
	add	ecx, DWORD PTR _nsize$31368[ebp]
	mov	DWORD PTR _qsize$[ebp], ecx
$LN59@prepend_al:

; 3954 :     }
; 3955 :     set_free_with_pinuse(q, qsize, oldfirst);

	mov	edx, DWORD PTR _oldfirst$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _oldfirst$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _qsize$[ebp]
	or	edx, 1
	mov	eax, DWORD PTR _q$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _q$[ebp]
	add	ecx, DWORD PTR _qsize$[ebp]
	mov	edx, DWORD PTR _qsize$[ebp]
	mov	DWORD PTR [ecx], edx

; 3956 :     insert_chunk(m, q, qsize);

	mov	eax, DWORD PTR _qsize$[ebp]
	shr	eax, 3
	cmp	eax, 32					; 00000020H
	jae	$LN22@prepend_al
	mov	ecx, DWORD PTR _qsize$[ebp]
	shr	ecx, 3
	mov	DWORD PTR _I$31432[ebp], ecx
	mov	edx, DWORD PTR _I$31432[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _m$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+40]
	mov	DWORD PTR _B$31434[ebp], ecx
	mov	edx, DWORD PTR _B$31434[ebp]
	mov	DWORD PTR _F$31437[ebp], edx
	mov	eax, 1
	mov	ecx, DWORD PTR _I$31432[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _m$[ebp]
	and	eax, DWORD PTR [ecx]
	jne	SHORT $LN21@prepend_al
	mov	edx, 1
	mov	ecx, DWORD PTR _I$31432[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _m$[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN20@prepend_al
$LN21@prepend_al:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN19@prepend_al
	mov	eax, DWORD PTR _B$31434[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$31437[ebp], ecx
	jmp	SHORT $LN20@prepend_al
$LN19@prepend_al:
	call	DWORD PTR __imp__abort
$LN20@prepend_al:
	mov	edx, DWORD PTR _B$31434[ebp]
	mov	eax, DWORD PTR _q$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _F$31437[ebp]
	mov	edx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR _F$31437[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR _B$31434[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN62@prepend_al
$LN22@prepend_al:
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR _TP$31445[ebp], ecx
	mov	edx, DWORD PTR _qsize$[ebp]
	shr	edx, 8
	mov	DWORD PTR _X$31449[ebp], edx
	cmp	DWORD PTR _X$31449[ebp], 0
	jne	SHORT $LN16@prepend_al
	mov	DWORD PTR _I$31448[ebp], 0
	jmp	SHORT $LN15@prepend_al
$LN16@prepend_al:
	cmp	DWORD PTR _X$31449[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN14@prepend_al
	mov	DWORD PTR _I$31448[ebp], 31		; 0000001fH
	jmp	SHORT $LN15@prepend_al
$LN14@prepend_al:
	mov	eax, DWORD PTR _X$31449[ebp]
	bsr	ecx, eax
	mov	DWORD PTR _K$31454[ebp], ecx
	mov	ecx, DWORD PTR _K$31454[ebp]
	add	ecx, 7
	mov	edx, DWORD PTR _qsize$[ebp]
	shr	edx, cl
	and	edx, 1
	mov	eax, DWORD PTR _K$31454[ebp]
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _I$31448[ebp], ecx
$LN15@prepend_al:
	mov	edx, DWORD PTR _I$31448[ebp]
	mov	eax, DWORD PTR _m$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+304]
	mov	DWORD PTR _H$31447[ebp], ecx
	mov	edx, DWORD PTR _TP$31445[ebp]
	mov	eax, DWORD PTR _I$31448[ebp]
	mov	DWORD PTR [edx+28], eax
	mov	ecx, DWORD PTR _TP$31445[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _TP$31445[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, 1
	mov	ecx, DWORD PTR _I$31448[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _m$[ebp]
	and	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN12@prepend_al
	mov	edx, 1
	mov	ecx, DWORD PTR _I$31448[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _m$[ebp]
	or	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _H$31447[ebp]
	mov	eax, DWORD PTR _TP$31445[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _TP$31445[ebp]
	mov	edx, DWORD PTR _H$31447[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _TP$31445[ebp]
	mov	ecx, DWORD PTR _TP$31445[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _TP$31445[ebp]
	mov	eax, DWORD PTR _TP$31445[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	$LN62@prepend_al
$LN12@prepend_al:
	mov	ecx, DWORD PTR _H$31447[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _T$31463[ebp], edx
	cmp	DWORD PTR _I$31448[ebp], 31		; 0000001fH
	jne	SHORT $LN70@prepend_al
	mov	DWORD PTR tv308[ebp], 0
	jmp	SHORT $LN71@prepend_al
$LN70@prepend_al:
	mov	eax, DWORD PTR _I$31448[ebp]
	shr	eax, 1
	add	eax, 6
	mov	ecx, 31					; 0000001fH
	sub	ecx, eax
	mov	DWORD PTR tv308[ebp], ecx
$LN71@prepend_al:
	mov	edx, DWORD PTR _qsize$[ebp]
	mov	ecx, DWORD PTR tv308[ebp]
	shl	edx, cl
	mov	DWORD PTR _K$31464[ebp], edx
$LN10@prepend_al:
	mov	eax, DWORD PTR _T$31463[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	cmp	ecx, DWORD PTR _qsize$[ebp]
	je	SHORT $LN8@prepend_al
	mov	edx, DWORD PTR _K$31464[ebp]
	shr	edx, 31					; 0000001fH
	and	edx, 1
	mov	eax, DWORD PTR _T$31463[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+16]
	mov	DWORD PTR _C$31474[ebp], ecx
	mov	edx, DWORD PTR _K$31464[ebp]
	shl	edx, 1
	mov	DWORD PTR _K$31464[ebp], edx
	mov	eax, DWORD PTR _C$31474[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@prepend_al
	mov	ecx, DWORD PTR _C$31474[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _T$31463[ebp], edx
	jmp	SHORT $LN6@prepend_al
$LN7@prepend_al:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@prepend_al
	mov	ecx, DWORD PTR _C$31474[ebp]
	mov	edx, DWORD PTR _TP$31445[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _TP$31445[ebp]
	mov	ecx, DWORD PTR _T$31463[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _TP$31445[ebp]
	mov	eax, DWORD PTR _TP$31445[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _TP$31445[ebp]
	mov	edx, DWORD PTR _TP$31445[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN62@prepend_al
	jmp	SHORT $LN6@prepend_al
$LN5@prepend_al:
	call	DWORD PTR __imp__abort
	jmp	SHORT $LN62@prepend_al
$LN6@prepend_al:
	jmp	SHORT $LN3@prepend_al
$LN8@prepend_al:
	mov	eax, DWORD PTR _T$31463[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$31482[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN2@prepend_al
	mov	eax, DWORD PTR _F$31482[ebp]
	mov	ecx, DWORD PTR _TP$31445[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _T$31463[ebp]
	mov	eax, DWORD PTR _TP$31445[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _TP$31445[ebp]
	mov	edx, DWORD PTR _F$31482[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _TP$31445[ebp]
	mov	ecx, DWORD PTR _T$31463[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _TP$31445[ebp]
	mov	DWORD PTR [edx+24], 0
	jmp	SHORT $LN62@prepend_al
	jmp	SHORT $LN3@prepend_al
$LN2@prepend_al:
	call	DWORD PTR __imp__abort
	jmp	SHORT $LN62@prepend_al
$LN3@prepend_al:
	jmp	$LN10@prepend_al
$LN62@prepend_al:

; 3957 :     check_free_chunk(m, q);
; 3958 :   }
; 3959 : 
; 3960 :   check_malloced_chunk(m, chunk2mem(p), nb);
; 3961 :   return chunk2mem(p);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 8

; 3962 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?prepend_alloc@@YAPAXPAUmalloc_state@@PAD1I@Z ENDP	; prepend_alloc
; Function compile flags: /Odtp
tv210 = -132						; size = 4
tv92 = -128						; size = 4
tv84 = -124						; size = 4
tv80 = -120						; size = 4
_F$31665 = -116						; size = 4
_C$31657 = -112						; size = 4
_K$31647 = -108						; size = 4
_T$31646 = -104						; size = 4
_K$31637 = -100						; size = 4
_X$31632 = -96						; size = 4
_I$31631 = -92						; size = 4
_H$31630 = -88						; size = 4
_TP$31628 = -84						; size = 4
_I$31615 = -80						; size = 4
_F$31620 = -76						; size = 4
_B$31617 = -72						; size = 4
_psize$31606 = -68					; size = 4
_q$31604 = -64						; size = 4
_tn$31607 = -60						; size = 4
_nextp$31593 = -56					; size = 4
_oldsp$ = -52						; size = 4
_ss$ = -48						; size = 4
_ssize$ = -44						; size = 4
_nfences$ = -40						; size = 4
_offset$ = -36						; size = 4
_tnext$ = -32						; size = 4
_csp$ = -28						; size = 4
_old_end$ = -24						; size = 4
_sp$ = -20						; size = 4
_rawsp$ = -16						; size = 4
_asp$ = -12						; size = 4
_old_top$ = -8						; size = 4
_p$ = -4						; size = 4
_m$ = 8							; size = 4
_tbase$ = 12						; size = 4
_tsize$ = 16						; size = 4
_mmapped$ = 20						; size = 4
?add_segment@@YAXPAUmalloc_state@@PADII@Z PROC		; add_segment

; 3965 : static void add_segment(mstate m, char* tbase, size_t tsize, flag_t mmapped) {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H

; 3966 :   /* Determine locations and sizes of segment, fenceposts, old top */
; 3967 :   char* old_top = (char*)m->top;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _old_top$[ebp], ecx

; 3968 :   msegmentptr oldsp = segment_holding(m, old_top);

	mov	edx, DWORD PTR _old_top$[ebp]
	push	edx
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	?segment_holding@@YAPAUmalloc_segment@@PAUmalloc_state@@PAD@Z ; segment_holding
	add	esp, 8
	mov	DWORD PTR _oldsp$[ebp], eax

; 3969 :   char* old_end = oldsp->base + oldsp->size;

	mov	ecx, DWORD PTR _oldsp$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _oldsp$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _old_end$[ebp], edx

; 3970 :   size_t ssize = pad_request(sizeof(struct malloc_segment));

	mov	DWORD PTR _ssize$[ebp], 24		; 00000018H

; 3971 :   char* rawsp = old_end - (ssize + FOUR_SIZE_T_SIZES + CHUNK_ALIGN_MASK);

	mov	ecx, DWORD PTR _ssize$[ebp]
	add	ecx, 23					; 00000017H
	mov	edx, DWORD PTR _old_end$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _rawsp$[ebp], edx

; 3972 :   size_t offset = align_offset(chunk2mem(rawsp));

	mov	eax, DWORD PTR _rawsp$[ebp]
	add	eax, 8
	and	eax, 7
	jne	SHORT $LN30@add_segmen
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN31@add_segmen
$LN30@add_segmen:
	mov	ecx, DWORD PTR _rawsp$[ebp]
	add	ecx, 8
	and	ecx, 7
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv80[ebp], edx
$LN31@add_segmen:
	mov	eax, DWORD PTR tv80[ebp]
	mov	DWORD PTR _offset$[ebp], eax

; 3973 :   char* asp = rawsp + offset;

	mov	ecx, DWORD PTR _rawsp$[ebp]
	add	ecx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _asp$[ebp], ecx

; 3974 :   char* csp = (asp < (old_top + MIN_CHUNK_SIZE))? old_top : asp;

	mov	edx, DWORD PTR _old_top$[ebp]
	add	edx, 16					; 00000010H
	cmp	DWORD PTR _asp$[ebp], edx
	jae	SHORT $LN32@add_segmen
	mov	eax, DWORD PTR _old_top$[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN33@add_segmen
$LN32@add_segmen:
	mov	ecx, DWORD PTR _asp$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN33@add_segmen:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR _csp$[ebp], edx

; 3975 :   mchunkptr sp = (mchunkptr)csp;

	mov	eax, DWORD PTR _csp$[ebp]
	mov	DWORD PTR _sp$[ebp], eax

; 3976 :   msegmentptr ss = (msegmentptr)(chunk2mem(sp));

	mov	ecx, DWORD PTR _sp$[ebp]
	add	ecx, 8
	mov	DWORD PTR _ss$[ebp], ecx

; 3977 :   mchunkptr tnext = chunk_plus_offset(sp, ssize);

	mov	edx, DWORD PTR _sp$[ebp]
	add	edx, DWORD PTR _ssize$[ebp]
	mov	DWORD PTR _tnext$[ebp], edx

; 3978 :   mchunkptr p = tnext;

	mov	eax, DWORD PTR _tnext$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 3979 :   int nfences = 0;

	mov	DWORD PTR _nfences$[ebp], 0

; 3980 : 
; 3981 :   /* reset top to new space */
; 3982 :   init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);

	mov	ecx, 7
	and	ecx, 8
	jne	SHORT $LN34@add_segmen
	mov	DWORD PTR tv92[ebp], 0
	jmp	SHORT $LN35@add_segmen
$LN34@add_segmen:
	mov	edx, 7
	and	edx, 8
	mov	eax, 8
	sub	eax, edx
	and	eax, 7
	mov	DWORD PTR tv92[ebp], eax
$LN35@add_segmen:
	mov	ecx, DWORD PTR tv92[ebp]
	add	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _tsize$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _tbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	?init_top@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z ; init_top
	add	esp, 12					; 0000000cH

; 3983 : 
; 3984 :   /* Set up segment record */
; 3985 :   assert(is_aligned(ss));
; 3986 :   set_size_and_pinuse_of_inuse_chunk(m, sp, ssize);

	mov	edx, DWORD PTR _ssize$[ebp]
	or	edx, 1
	or	edx, 2
	mov	eax, DWORD PTR _sp$[ebp]
	mov	DWORD PTR [eax+4], edx

; 3987 :   *ss = m->seg; /* Push current record */

	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, 452				; 000001c4H
	mov	edx, DWORD PTR _ss$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 3988 :   m->seg.base = tbase;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _tbase$[ebp]
	mov	DWORD PTR [edx+452], eax

; 3989 :   m->seg.size = tsize;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _tsize$[ebp]
	mov	DWORD PTR [ecx+456], edx

; 3990 :   m->seg.sflags = mmapped;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _mmapped$[ebp]
	mov	DWORD PTR [eax+464], ecx

; 3991 :   m->seg.next = ss;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _ss$[ebp]
	mov	DWORD PTR [edx+460], eax
$LN27@add_segmen:

; 3992 : 
; 3993 :   /* Insert trailing fenceposts */
; 3994 :   for (;;) {
; 3995 :     mchunkptr nextp = chunk_plus_offset(p, SIZE_T_SIZE);

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 4
	mov	DWORD PTR _nextp$31593[ebp], ecx

; 3996 :     p->head = FENCEPOST_HEAD;

	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx+4], 7

; 3997 :     ++nfences;

	mov	eax, DWORD PTR _nfences$[ebp]
	add	eax, 1
	mov	DWORD PTR _nfences$[ebp], eax

; 3998 :     if ((char*)(&(nextp->head)) < old_end)

	mov	ecx, DWORD PTR _nextp$31593[ebp]
	add	ecx, 4
	cmp	ecx, DWORD PTR _old_end$[ebp]
	jae	SHORT $LN25@add_segmen

; 3999 :       p = nextp;

	mov	edx, DWORD PTR _nextp$31593[ebp]
	mov	DWORD PTR _p$[ebp], edx

; 4000 :     else

	jmp	SHORT $LN24@add_segmen
$LN25@add_segmen:

; 4001 :       break;

	jmp	SHORT $LN26@add_segmen
$LN24@add_segmen:

; 4002 :   }

	jmp	SHORT $LN27@add_segmen
$LN26@add_segmen:

; 4003 :   assert(nfences >= 2);
; 4004 : 
; 4005 :   /* Insert the rest of old top into a bin as an ordinary free chunk */
; 4006 :   if (csp != old_top) {

	mov	eax, DWORD PTR _csp$[ebp]
	cmp	eax, DWORD PTR _old_top$[ebp]
	je	$LN28@add_segmen

; 4007 :     mchunkptr q = (mchunkptr)old_top;

	mov	ecx, DWORD PTR _old_top$[ebp]
	mov	DWORD PTR _q$31604[ebp], ecx

; 4008 :     size_t psize = csp - old_top;

	mov	edx, DWORD PTR _csp$[ebp]
	sub	edx, DWORD PTR _old_top$[ebp]
	mov	DWORD PTR _psize$31606[ebp], edx

; 4009 :     mchunkptr tn = chunk_plus_offset(q, psize);

	mov	eax, DWORD PTR _q$31604[ebp]
	add	eax, DWORD PTR _psize$31606[ebp]
	mov	DWORD PTR _tn$31607[ebp], eax

; 4010 :     set_free_with_pinuse(q, psize, tn);

	mov	ecx, DWORD PTR _tn$31607[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _tn$31607[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _psize$31606[ebp]
	or	ecx, 1
	mov	edx, DWORD PTR _q$31604[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _q$31604[ebp]
	add	eax, DWORD PTR _psize$31606[ebp]
	mov	ecx, DWORD PTR _psize$31606[ebp]
	mov	DWORD PTR [eax], ecx

; 4011 :     insert_chunk(m, q, psize);

	mov	edx, DWORD PTR _psize$31606[ebp]
	shr	edx, 3
	cmp	edx, 32					; 00000020H
	jae	$LN22@add_segmen
	mov	eax, DWORD PTR _psize$31606[ebp]
	shr	eax, 3
	mov	DWORD PTR _I$31615[ebp], eax
	mov	ecx, DWORD PTR _I$31615[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _m$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+40]
	mov	DWORD PTR _B$31617[ebp], eax
	mov	ecx, DWORD PTR _B$31617[ebp]
	mov	DWORD PTR _F$31620[ebp], ecx
	mov	edx, 1
	mov	ecx, DWORD PTR _I$31615[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _m$[ebp]
	and	edx, DWORD PTR [eax]
	jne	SHORT $LN21@add_segmen
	mov	edx, 1
	mov	ecx, DWORD PTR _I$31615[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _m$[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN20@add_segmen
$LN21@add_segmen:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN19@add_segmen
	mov	eax, DWORD PTR _B$31617[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$31620[ebp], ecx
	jmp	SHORT $LN20@add_segmen
$LN19@add_segmen:
	call	DWORD PTR __imp__abort
$LN20@add_segmen:
	mov	edx, DWORD PTR _B$31617[ebp]
	mov	eax, DWORD PTR _q$31604[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _F$31620[ebp]
	mov	edx, DWORD PTR _q$31604[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _q$31604[ebp]
	mov	ecx, DWORD PTR _F$31620[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _q$31604[ebp]
	mov	eax, DWORD PTR _B$31617[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN28@add_segmen
$LN22@add_segmen:
	mov	ecx, DWORD PTR _q$31604[ebp]
	mov	DWORD PTR _TP$31628[ebp], ecx
	mov	edx, DWORD PTR _psize$31606[ebp]
	shr	edx, 8
	mov	DWORD PTR _X$31632[ebp], edx
	cmp	DWORD PTR _X$31632[ebp], 0
	jne	SHORT $LN16@add_segmen
	mov	DWORD PTR _I$31631[ebp], 0
	jmp	SHORT $LN15@add_segmen
$LN16@add_segmen:
	cmp	DWORD PTR _X$31632[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN14@add_segmen
	mov	DWORD PTR _I$31631[ebp], 31		; 0000001fH
	jmp	SHORT $LN15@add_segmen
$LN14@add_segmen:
	mov	eax, DWORD PTR _X$31632[ebp]
	bsr	ecx, eax
	mov	DWORD PTR _K$31637[ebp], ecx
	mov	ecx, DWORD PTR _K$31637[ebp]
	add	ecx, 7
	mov	edx, DWORD PTR _psize$31606[ebp]
	shr	edx, cl
	and	edx, 1
	mov	eax, DWORD PTR _K$31637[ebp]
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _I$31631[ebp], ecx
$LN15@add_segmen:
	mov	edx, DWORD PTR _I$31631[ebp]
	mov	eax, DWORD PTR _m$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+304]
	mov	DWORD PTR _H$31630[ebp], ecx
	mov	edx, DWORD PTR _TP$31628[ebp]
	mov	eax, DWORD PTR _I$31631[ebp]
	mov	DWORD PTR [edx+28], eax
	mov	ecx, DWORD PTR _TP$31628[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _TP$31628[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, 1
	mov	ecx, DWORD PTR _I$31631[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _m$[ebp]
	and	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN12@add_segmen
	mov	edx, 1
	mov	ecx, DWORD PTR _I$31631[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _m$[ebp]
	or	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _H$31630[ebp]
	mov	eax, DWORD PTR _TP$31628[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _TP$31628[ebp]
	mov	edx, DWORD PTR _H$31630[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _TP$31628[ebp]
	mov	ecx, DWORD PTR _TP$31628[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _TP$31628[ebp]
	mov	eax, DWORD PTR _TP$31628[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	$LN28@add_segmen
$LN12@add_segmen:
	mov	ecx, DWORD PTR _H$31630[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _T$31646[ebp], edx
	cmp	DWORD PTR _I$31631[ebp], 31		; 0000001fH
	jne	SHORT $LN36@add_segmen
	mov	DWORD PTR tv210[ebp], 0
	jmp	SHORT $LN37@add_segmen
$LN36@add_segmen:
	mov	eax, DWORD PTR _I$31631[ebp]
	shr	eax, 1
	add	eax, 6
	mov	ecx, 31					; 0000001fH
	sub	ecx, eax
	mov	DWORD PTR tv210[ebp], ecx
$LN37@add_segmen:
	mov	edx, DWORD PTR _psize$31606[ebp]
	mov	ecx, DWORD PTR tv210[ebp]
	shl	edx, cl
	mov	DWORD PTR _K$31647[ebp], edx
$LN10@add_segmen:
	mov	eax, DWORD PTR _T$31646[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	cmp	ecx, DWORD PTR _psize$31606[ebp]
	je	SHORT $LN8@add_segmen
	mov	edx, DWORD PTR _K$31647[ebp]
	shr	edx, 31					; 0000001fH
	and	edx, 1
	mov	eax, DWORD PTR _T$31646[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+16]
	mov	DWORD PTR _C$31657[ebp], ecx
	mov	edx, DWORD PTR _K$31647[ebp]
	shl	edx, 1
	mov	DWORD PTR _K$31647[ebp], edx
	mov	eax, DWORD PTR _C$31657[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@add_segmen
	mov	ecx, DWORD PTR _C$31657[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _T$31646[ebp], edx
	jmp	SHORT $LN6@add_segmen
$LN7@add_segmen:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@add_segmen
	mov	ecx, DWORD PTR _C$31657[ebp]
	mov	edx, DWORD PTR _TP$31628[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _TP$31628[ebp]
	mov	ecx, DWORD PTR _T$31646[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _TP$31628[ebp]
	mov	eax, DWORD PTR _TP$31628[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _TP$31628[ebp]
	mov	edx, DWORD PTR _TP$31628[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN28@add_segmen
	jmp	SHORT $LN6@add_segmen
$LN5@add_segmen:
	call	DWORD PTR __imp__abort
	jmp	SHORT $LN28@add_segmen
$LN6@add_segmen:
	jmp	SHORT $LN3@add_segmen
$LN8@add_segmen:
	mov	eax, DWORD PTR _T$31646[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$31665[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN2@add_segmen
	mov	eax, DWORD PTR _F$31665[ebp]
	mov	ecx, DWORD PTR _TP$31628[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _T$31646[ebp]
	mov	eax, DWORD PTR _TP$31628[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _TP$31628[ebp]
	mov	edx, DWORD PTR _F$31665[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _TP$31628[ebp]
	mov	ecx, DWORD PTR _T$31646[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _TP$31628[ebp]
	mov	DWORD PTR [edx+24], 0
	jmp	SHORT $LN28@add_segmen
	jmp	SHORT $LN3@add_segmen
$LN2@add_segmen:
	call	DWORD PTR __imp__abort
	jmp	SHORT $LN28@add_segmen
$LN3@add_segmen:
	jmp	$LN10@add_segmen
$LN28@add_segmen:

; 4012 :   }
; 4013 : 
; 4014 :   check_top_chunk(m, m->top);
; 4015 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?add_segment@@YAXPAUmalloc_state@@PADII@Z ENDP		; add_segment
; Function compile flags: /Odtp
tv333 = -156						; size = 4
tv164 = -152						; size = 4
tv84 = -148						; size = 4
_F$32768 = -144						; size = 4
_C$32760 = -140						; size = 4
_K$32750 = -136						; size = 4
_T$32749 = -132						; size = 4
_K$32740 = -128						; size = 4
_X$32735 = -124						; size = 4
_I$32734 = -120						; size = 4
_H$32733 = -116						; size = 4
_TP$32731 = -112					; size = 4
_I$32718 = -108						; size = 4
_F$32723 = -104						; size = 4
_B$32720 = -100						; size = 4
_C0$32689 = -96						; size = 4
_C1$32690 = -92						; size = 4
_H$32678 = -88						; size = 4
_CP$32670 = -84						; size = 4
_RP$32667 = -80						; size = 4
_F$32663 = -76						; size = 4
_R$32661 = -72						; size = 4
_XP$32660 = -68						; size = 4
_r$32656 = -64						; size = 4
_trem$32648 = -60					; size = 4
_J$32642 = -56						; size = 4
_leastbit$32641 = -52					; size = 4
_i$32640 = -48						; size = 4
_leftbits$32636 = -44					; size = 4
_trem$32625 = -40					; size = 4
_rt$32624 = -36						; size = 4
_sizebits$32617 = -32					; size = 4
_rst$32620 = -28					; size = 4
_K$32612 = -24						; size = 4
_X$32607 = -20						; size = 4
_t$ = -16						; size = 4
_idx$ = -12						; size = 4
_rsize$ = -8						; size = 4
_v$ = -4						; size = 4
_m$ = 8							; size = 4
_nb$ = 12						; size = 4
?tmalloc_large@@YAPAXPAUmalloc_state@@I@Z PROC		; tmalloc_large

; 4417 : static void* tmalloc_large(mstate m, size_t nb) {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH

; 4418 :   tchunkptr v = 0;

	mov	DWORD PTR _v$[ebp], 0

; 4419 :   size_t rsize = -nb; /* Unsigned negation */

	mov	eax, DWORD PTR _nb$[ebp]
	neg	eax
	mov	DWORD PTR _rsize$[ebp], eax

; 4420 :   tchunkptr t;
; 4421 :   bindex_t idx;
; 4422 :   compute_tree_index(nb, idx);

	mov	ecx, DWORD PTR _nb$[ebp]
	shr	ecx, 8
	mov	DWORD PTR _X$32607[ebp], ecx
	cmp	DWORD PTR _X$32607[ebp], 0
	jne	SHORT $LN71@tmalloc_la
	mov	DWORD PTR _idx$[ebp], 0
	jmp	SHORT $LN70@tmalloc_la
$LN71@tmalloc_la:
	cmp	DWORD PTR _X$32607[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN69@tmalloc_la
	mov	DWORD PTR _idx$[ebp], 31		; 0000001fH
	jmp	SHORT $LN70@tmalloc_la
$LN69@tmalloc_la:
	mov	edx, DWORD PTR _X$32607[ebp]
	bsr	eax, edx
	mov	DWORD PTR _K$32612[ebp], eax
	mov	ecx, DWORD PTR _K$32612[ebp]
	add	ecx, 7
	mov	edx, DWORD PTR _nb$[ebp]
	shr	edx, cl
	and	edx, 1
	mov	eax, DWORD PTR _K$32612[ebp]
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _idx$[ebp], ecx
$LN70@tmalloc_la:

; 4423 :   if ((t = *treebin_at(m, idx)) != 0) {

	mov	edx, DWORD PTR _idx$[ebp]
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+304]
	mov	DWORD PTR _t$[ebp], ecx
	cmp	DWORD PTR _t$[ebp], 0
	je	$LN67@tmalloc_la

; 4424 :     /* Traverse tree for this bin looking for node with size == nb */
; 4425 :     size_t sizebits = nb << leftshift_for_tree_index(idx);

	cmp	DWORD PTR _idx$[ebp], 31		; 0000001fH
	jne	SHORT $LN74@tmalloc_la
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN75@tmalloc_la
$LN74@tmalloc_la:
	mov	edx, DWORD PTR _idx$[ebp]
	shr	edx, 1
	add	edx, 6
	mov	eax, 31					; 0000001fH
	sub	eax, edx
	mov	DWORD PTR tv84[ebp], eax
$LN75@tmalloc_la:
	mov	edx, DWORD PTR _nb$[ebp]
	mov	ecx, DWORD PTR tv84[ebp]
	shl	edx, cl
	mov	DWORD PTR _sizebits$32617[ebp], edx

; 4426 :     tchunkptr rst = 0;  /* The deepest untaken right subtree */

	mov	DWORD PTR _rst$32620[ebp], 0
$LN66@tmalloc_la:

; 4427 :     for (;;) {
; 4428 :       tchunkptr rt;
; 4429 :       size_t trem = chunksize(t) - nb;

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	sub	ecx, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _trem$32625[ebp], ecx

; 4430 :       if (trem < rsize) {

	mov	edx, DWORD PTR _trem$32625[ebp]
	cmp	edx, DWORD PTR _rsize$[ebp]
	jae	SHORT $LN64@tmalloc_la

; 4431 :         v = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _v$[ebp], eax

; 4432 :         if ((rsize = trem) == 0)

	mov	ecx, DWORD PTR _trem$32625[ebp]
	mov	DWORD PTR _rsize$[ebp], ecx
	cmp	DWORD PTR _rsize$[ebp], 0
	jne	SHORT $LN64@tmalloc_la

; 4433 :           break;

	jmp	SHORT $LN67@tmalloc_la
$LN64@tmalloc_la:

; 4434 :       }
; 4435 :       rt = t->child[1];

	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _rt$32624[ebp], eax

; 4436 :       t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];

	mov	ecx, DWORD PTR _sizebits$32617[ebp]
	shr	ecx, 31					; 0000001fH
	and	ecx, 1
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+16]
	mov	DWORD PTR _t$[ebp], eax

; 4437 :       if (rt != 0 && rt != t)

	cmp	DWORD PTR _rt$32624[ebp], 0
	je	SHORT $LN62@tmalloc_la
	mov	ecx, DWORD PTR _rt$32624[ebp]
	cmp	ecx, DWORD PTR _t$[ebp]
	je	SHORT $LN62@tmalloc_la

; 4438 :         rst = rt;

	mov	edx, DWORD PTR _rt$32624[ebp]
	mov	DWORD PTR _rst$32620[ebp], edx
$LN62@tmalloc_la:

; 4439 :       if (t == 0) {

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN61@tmalloc_la

; 4440 :         t = rst; /* set t to least subtree holding sizes > nb */

	mov	eax, DWORD PTR _rst$32620[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 4441 :         break;

	jmp	SHORT $LN67@tmalloc_la
$LN61@tmalloc_la:

; 4442 :       }
; 4443 :       sizebits <<= 1;

	mov	ecx, DWORD PTR _sizebits$32617[ebp]
	shl	ecx, 1
	mov	DWORD PTR _sizebits$32617[ebp], ecx

; 4444 :     }

	jmp	SHORT $LN66@tmalloc_la
$LN67@tmalloc_la:

; 4445 :   }
; 4446 :   if (t == 0 && v == 0) { /* set t to root of next non-empty treebin */

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN58@tmalloc_la
	cmp	DWORD PTR _v$[ebp], 0
	jne	SHORT $LN58@tmalloc_la

; 4447 :     binmap_t leftbits = left_bits(idx2bit(idx)) & m->treemap;

	mov	edx, 1
	mov	ecx, DWORD PTR _idx$[ebp]
	shl	edx, cl
	shl	edx, 1
	mov	eax, 1
	mov	ecx, DWORD PTR _idx$[ebp]
	shl	eax, cl
	shl	eax, 1
	neg	eax
	or	edx, eax
	mov	ecx, DWORD PTR _m$[ebp]
	and	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _leftbits$32636[ebp], edx

; 4448 :     if (leftbits != 0) {

	je	SHORT $LN58@tmalloc_la

; 4449 :       bindex_t i;
; 4450 :       binmap_t leastbit = least_bit(leftbits);

	mov	edx, DWORD PTR _leftbits$32636[ebp]
	neg	edx
	and	edx, DWORD PTR _leftbits$32636[ebp]
	mov	DWORD PTR _leastbit$32641[ebp], edx

; 4451 :       compute_bit2idx(leastbit, i);

	mov	eax, DWORD PTR _leastbit$32641[ebp]
	bsf	ecx, eax
	mov	DWORD PTR _J$32642[ebp], ecx
	mov	edx, DWORD PTR _J$32642[ebp]
	mov	DWORD PTR _i$32640[ebp], edx

; 4452 :       t = *treebin_at(m, i);

	mov	eax, DWORD PTR _i$32640[ebp]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+304]
	mov	DWORD PTR _t$[ebp], edx
$LN58@tmalloc_la:

; 4453 :     }
; 4454 :   }
; 4455 : 
; 4456 :   while (t != 0) { /* find smallest of tree or subtree */

	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN57@tmalloc_la

; 4457 :     size_t trem = chunksize(t) - nb;

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	sub	ecx, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _trem$32648[ebp], ecx

; 4458 :     if (trem < rsize) {

	mov	edx, DWORD PTR _trem$32648[ebp]
	cmp	edx, DWORD PTR _rsize$[ebp]
	jae	SHORT $LN56@tmalloc_la

; 4459 :       rsize = trem;

	mov	eax, DWORD PTR _trem$32648[ebp]
	mov	DWORD PTR _rsize$[ebp], eax

; 4460 :       v = t;

	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR _v$[ebp], ecx
$LN56@tmalloc_la:

; 4461 :     }
; 4462 :     t = leftmost_child(t);

	mov	edx, DWORD PTR _t$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN76@tmalloc_la
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv164[ebp], ecx
	jmp	SHORT $LN77@tmalloc_la
$LN76@tmalloc_la:
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv164[ebp], eax
$LN77@tmalloc_la:
	mov	ecx, DWORD PTR tv164[ebp]
	mov	DWORD PTR _t$[ebp], ecx

; 4463 :   }

	jmp	SHORT $LN58@tmalloc_la
$LN57@tmalloc_la:

; 4464 : 
; 4465 :   /*  If dv is a better fit, return 0 so malloc will use it */
; 4466 :   if (v != 0 && rsize < (size_t)(m->dvsize - nb)) {

	cmp	DWORD PTR _v$[ebp], 0
	je	$LN55@tmalloc_la
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR _nb$[ebp]
	cmp	DWORD PTR _rsize$[ebp], eax
	jae	$LN55@tmalloc_la

; 4467 :     if (RTCHECK(ok_address(m, v))) { /* split */

	mov	ecx, 1
	test	ecx, ecx
	je	$LN54@tmalloc_la

; 4468 :       mchunkptr r = chunk_plus_offset(v, nb);

	mov	edx, DWORD PTR _v$[ebp]
	add	edx, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _r$32656[ebp], edx

; 4469 :       assert(chunksize(v) == rsize + nb);
; 4470 :       if (RTCHECK(ok_next(v, r))) {

	mov	eax, 1
	test	eax, eax
	je	$LN54@tmalloc_la

; 4471 :         unlink_large_chunk(m, v);

	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _XP$32660[ebp], edx
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _v$[ebp]
	je	SHORT $LN52@tmalloc_la
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _F$32663[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _R$32661[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN51@tmalloc_la
	mov	ecx, DWORD PTR _F$32663[ebp]
	mov	edx, DWORD PTR _R$32661[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _R$32661[ebp]
	mov	ecx, DWORD PTR _F$32663[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN50@tmalloc_la
$LN51@tmalloc_la:
	call	DWORD PTR __imp__abort
$LN50@tmalloc_la:
	jmp	SHORT $LN49@tmalloc_la
$LN52@tmalloc_la:
	mov	edx, DWORD PTR _v$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR _RP$32667[ebp], edx
	mov	eax, DWORD PTR _RP$32667[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _R$32661[ebp], ecx
	cmp	DWORD PTR _R$32661[ebp], 0
	jne	SHORT $LN46@tmalloc_la
	mov	edx, DWORD PTR _v$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _RP$32667[ebp], edx
	mov	eax, DWORD PTR _RP$32667[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _R$32661[ebp], ecx
	cmp	DWORD PTR _R$32661[ebp], 0
	je	SHORT $LN49@tmalloc_la
$LN46@tmalloc_la:
	mov	edx, DWORD PTR _R$32661[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR _CP$32670[ebp], edx
	mov	eax, DWORD PTR _CP$32670[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN44@tmalloc_la
	mov	ecx, DWORD PTR _R$32661[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _CP$32670[ebp], ecx
	mov	edx, DWORD PTR _CP$32670[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN45@tmalloc_la
$LN44@tmalloc_la:
	mov	eax, DWORD PTR _CP$32670[ebp]
	mov	DWORD PTR _RP$32667[ebp], eax
	mov	ecx, DWORD PTR _RP$32667[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _R$32661[ebp], edx
	jmp	SHORT $LN46@tmalloc_la
$LN45@tmalloc_la:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN43@tmalloc_la
	mov	ecx, DWORD PTR _RP$32667[ebp]
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN49@tmalloc_la
$LN43@tmalloc_la:
	call	DWORD PTR __imp__abort
$LN49@tmalloc_la:
	cmp	DWORD PTR _XP$32660[ebp], 0
	je	$LN41@tmalloc_la
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _m$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+304]
	mov	DWORD PTR _H$32678[ebp], edx
	mov	eax, DWORD PTR _H$32678[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN40@tmalloc_la
	mov	edx, DWORD PTR _H$32678[ebp]
	mov	eax, DWORD PTR _R$32661[ebp]
	mov	DWORD PTR [edx], eax
	cmp	DWORD PTR _R$32661[ebp], 0
	jne	SHORT $LN39@tmalloc_la
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+28]
	shl	edx, cl
	not	edx
	mov	eax, DWORD PTR _m$[ebp]
	and	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN39@tmalloc_la:
	jmp	SHORT $LN38@tmalloc_la
$LN40@tmalloc_la:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN37@tmalloc_la
	mov	eax, DWORD PTR _XP$32660[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _v$[ebp]
	jne	SHORT $LN36@tmalloc_la
	mov	edx, DWORD PTR _XP$32660[ebp]
	mov	eax, DWORD PTR _R$32661[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	SHORT $LN35@tmalloc_la
$LN36@tmalloc_la:
	mov	ecx, DWORD PTR _XP$32660[ebp]
	mov	edx, DWORD PTR _R$32661[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN35@tmalloc_la:
	jmp	SHORT $LN38@tmalloc_la
$LN37@tmalloc_la:
	call	DWORD PTR __imp__abort
$LN38@tmalloc_la:
	cmp	DWORD PTR _R$32661[ebp], 0
	je	SHORT $LN41@tmalloc_la
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN32@tmalloc_la
	mov	ecx, DWORD PTR _R$32661[ebp]
	mov	edx, DWORD PTR _XP$32660[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _C0$32689[ebp], ecx
	cmp	DWORD PTR _C0$32689[ebp], 0
	je	SHORT $LN31@tmalloc_la
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN30@tmalloc_la
	mov	eax, DWORD PTR _R$32661[ebp]
	mov	ecx, DWORD PTR _C0$32689[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _C0$32689[ebp]
	mov	eax, DWORD PTR _R$32661[ebp]
	mov	DWORD PTR [edx+24], eax
	jmp	SHORT $LN31@tmalloc_la
$LN30@tmalloc_la:
	call	DWORD PTR __imp__abort
$LN31@tmalloc_la:
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _C1$32690[ebp], edx
	cmp	DWORD PTR _C1$32690[ebp], 0
	je	SHORT $LN28@tmalloc_la
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN27@tmalloc_la
	mov	ecx, DWORD PTR _R$32661[ebp]
	mov	edx, DWORD PTR _C1$32690[ebp]
	mov	DWORD PTR [ecx+20], edx
	mov	eax, DWORD PTR _C1$32690[ebp]
	mov	ecx, DWORD PTR _R$32661[ebp]
	mov	DWORD PTR [eax+24], ecx
	jmp	SHORT $LN28@tmalloc_la
$LN27@tmalloc_la:
	call	DWORD PTR __imp__abort
$LN28@tmalloc_la:
	jmp	SHORT $LN41@tmalloc_la
$LN32@tmalloc_la:
	call	DWORD PTR __imp__abort
$LN41@tmalloc_la:

; 4472 :         if (rsize < MIN_CHUNK_SIZE)

	cmp	DWORD PTR _rsize$[ebp], 16		; 00000010H
	jae	SHORT $LN24@tmalloc_la

; 4473 :           set_inuse_and_pinuse(m, v, (rsize + nb));

	mov	edx, DWORD PTR _rsize$[ebp]
	add	edx, DWORD PTR _nb$[ebp]
	or	edx, 1
	or	edx, 2
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _rsize$[ebp]
	add	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	or	eax, 1
	mov	ecx, DWORD PTR _rsize$[ebp]
	add	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+ecx+4], eax

; 4474 :         else {

	jmp	$LN23@tmalloc_la
$LN24@tmalloc_la:

; 4475 :           set_size_and_pinuse_of_inuse_chunk(m, v, nb);

	mov	eax, DWORD PTR _nb$[ebp]
	or	eax, 1
	or	eax, 2
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4476 :           set_size_and_pinuse_of_free_chunk(r, rsize);

	mov	edx, DWORD PTR _rsize$[ebp]
	or	edx, 1
	mov	eax, DWORD PTR _r$32656[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _r$32656[ebp]
	add	ecx, DWORD PTR _rsize$[ebp]
	mov	edx, DWORD PTR _rsize$[ebp]
	mov	DWORD PTR [ecx], edx

; 4477 :           insert_chunk(m, r, rsize);

	mov	eax, DWORD PTR _rsize$[ebp]
	shr	eax, 3
	cmp	eax, 32					; 00000020H
	jae	$LN22@tmalloc_la
	mov	ecx, DWORD PTR _rsize$[ebp]
	shr	ecx, 3
	mov	DWORD PTR _I$32718[ebp], ecx
	mov	edx, DWORD PTR _I$32718[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _m$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+40]
	mov	DWORD PTR _B$32720[ebp], ecx
	mov	edx, DWORD PTR _B$32720[ebp]
	mov	DWORD PTR _F$32723[ebp], edx
	mov	eax, 1
	mov	ecx, DWORD PTR _I$32718[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _m$[ebp]
	and	eax, DWORD PTR [ecx]
	jne	SHORT $LN21@tmalloc_la
	mov	edx, 1
	mov	ecx, DWORD PTR _I$32718[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _m$[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN20@tmalloc_la
$LN21@tmalloc_la:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN19@tmalloc_la
	mov	eax, DWORD PTR _B$32720[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$32723[ebp], ecx
	jmp	SHORT $LN20@tmalloc_la
$LN19@tmalloc_la:
	call	DWORD PTR __imp__abort
$LN20@tmalloc_la:
	mov	edx, DWORD PTR _B$32720[ebp]
	mov	eax, DWORD PTR _r$32656[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _F$32723[ebp]
	mov	edx, DWORD PTR _r$32656[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _r$32656[ebp]
	mov	ecx, DWORD PTR _F$32723[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _r$32656[ebp]
	mov	eax, DWORD PTR _B$32720[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN23@tmalloc_la
$LN22@tmalloc_la:
	mov	ecx, DWORD PTR _r$32656[ebp]
	mov	DWORD PTR _TP$32731[ebp], ecx
	mov	edx, DWORD PTR _rsize$[ebp]
	shr	edx, 8
	mov	DWORD PTR _X$32735[ebp], edx
	cmp	DWORD PTR _X$32735[ebp], 0
	jne	SHORT $LN16@tmalloc_la
	mov	DWORD PTR _I$32734[ebp], 0
	jmp	SHORT $LN15@tmalloc_la
$LN16@tmalloc_la:
	cmp	DWORD PTR _X$32735[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN14@tmalloc_la
	mov	DWORD PTR _I$32734[ebp], 31		; 0000001fH
	jmp	SHORT $LN15@tmalloc_la
$LN14@tmalloc_la:
	mov	eax, DWORD PTR _X$32735[ebp]
	bsr	ecx, eax
	mov	DWORD PTR _K$32740[ebp], ecx
	mov	ecx, DWORD PTR _K$32740[ebp]
	add	ecx, 7
	mov	edx, DWORD PTR _rsize$[ebp]
	shr	edx, cl
	and	edx, 1
	mov	eax, DWORD PTR _K$32740[ebp]
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _I$32734[ebp], ecx
$LN15@tmalloc_la:
	mov	edx, DWORD PTR _I$32734[ebp]
	mov	eax, DWORD PTR _m$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+304]
	mov	DWORD PTR _H$32733[ebp], ecx
	mov	edx, DWORD PTR _TP$32731[ebp]
	mov	eax, DWORD PTR _I$32734[ebp]
	mov	DWORD PTR [edx+28], eax
	mov	ecx, DWORD PTR _TP$32731[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _TP$32731[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, 1
	mov	ecx, DWORD PTR _I$32734[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _m$[ebp]
	and	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN12@tmalloc_la
	mov	edx, 1
	mov	ecx, DWORD PTR _I$32734[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _m$[ebp]
	or	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _H$32733[ebp]
	mov	eax, DWORD PTR _TP$32731[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _TP$32731[ebp]
	mov	edx, DWORD PTR _H$32733[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _TP$32731[ebp]
	mov	ecx, DWORD PTR _TP$32731[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _TP$32731[ebp]
	mov	eax, DWORD PTR _TP$32731[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	$LN23@tmalloc_la
$LN12@tmalloc_la:
	mov	ecx, DWORD PTR _H$32733[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _T$32749[ebp], edx
	cmp	DWORD PTR _I$32734[ebp], 31		; 0000001fH
	jne	SHORT $LN78@tmalloc_la
	mov	DWORD PTR tv333[ebp], 0
	jmp	SHORT $LN79@tmalloc_la
$LN78@tmalloc_la:
	mov	eax, DWORD PTR _I$32734[ebp]
	shr	eax, 1
	add	eax, 6
	mov	ecx, 31					; 0000001fH
	sub	ecx, eax
	mov	DWORD PTR tv333[ebp], ecx
$LN79@tmalloc_la:
	mov	edx, DWORD PTR _rsize$[ebp]
	mov	ecx, DWORD PTR tv333[ebp]
	shl	edx, cl
	mov	DWORD PTR _K$32750[ebp], edx
$LN10@tmalloc_la:
	mov	eax, DWORD PTR _T$32749[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	cmp	ecx, DWORD PTR _rsize$[ebp]
	je	$LN8@tmalloc_la
	mov	edx, DWORD PTR _K$32750[ebp]
	shr	edx, 31					; 0000001fH
	and	edx, 1
	mov	eax, DWORD PTR _T$32749[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+16]
	mov	DWORD PTR _C$32760[ebp], ecx
	mov	edx, DWORD PTR _K$32750[ebp]
	shl	edx, 1
	mov	DWORD PTR _K$32750[ebp], edx
	mov	eax, DWORD PTR _C$32760[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@tmalloc_la
	mov	ecx, DWORD PTR _C$32760[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _T$32749[ebp], edx
	jmp	SHORT $LN6@tmalloc_la
$LN7@tmalloc_la:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@tmalloc_la
	mov	ecx, DWORD PTR _C$32760[ebp]
	mov	edx, DWORD PTR _TP$32731[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _TP$32731[ebp]
	mov	ecx, DWORD PTR _T$32749[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _TP$32731[ebp]
	mov	eax, DWORD PTR _TP$32731[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _TP$32731[ebp]
	mov	edx, DWORD PTR _TP$32731[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN23@tmalloc_la
	jmp	SHORT $LN6@tmalloc_la
$LN5@tmalloc_la:
	call	DWORD PTR __imp__abort
	jmp	SHORT $LN23@tmalloc_la
$LN6@tmalloc_la:
	jmp	SHORT $LN3@tmalloc_la
$LN8@tmalloc_la:
	mov	eax, DWORD PTR _T$32749[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$32768[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN2@tmalloc_la
	mov	eax, DWORD PTR _F$32768[ebp]
	mov	ecx, DWORD PTR _TP$32731[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _T$32749[ebp]
	mov	eax, DWORD PTR _TP$32731[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _TP$32731[ebp]
	mov	edx, DWORD PTR _F$32768[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _TP$32731[ebp]
	mov	ecx, DWORD PTR _T$32749[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _TP$32731[ebp]
	mov	DWORD PTR [edx+24], 0
	jmp	SHORT $LN23@tmalloc_la
	jmp	SHORT $LN3@tmalloc_la
$LN2@tmalloc_la:
	call	DWORD PTR __imp__abort
	jmp	SHORT $LN23@tmalloc_la
$LN3@tmalloc_la:
	jmp	$LN10@tmalloc_la
$LN23@tmalloc_la:

; 4478 :         }
; 4479 :         return chunk2mem(v);

	mov	eax, DWORD PTR _v$[ebp]
	add	eax, 8
	jmp	SHORT $LN72@tmalloc_la
$LN54@tmalloc_la:

; 4480 :       }
; 4481 :     }
; 4482 :     CORRUPTION_ERROR_ACTION(m);

	call	DWORD PTR __imp__abort
$LN55@tmalloc_la:

; 4483 :   }
; 4484 :   return 0;

	xor	eax, eax
$LN72@tmalloc_la:

; 4485 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?tmalloc_large@@YAPAXPAUmalloc_state@@I@Z ENDP		; tmalloc_large
; Function compile flags: /Odtp
tv83 = -88						; size = 4
_I$32862 = -84						; size = 4
_F$32867 = -80						; size = 4
_B$32864 = -76						; size = 4
_DV$32861 = -72						; size = 4
_DVS$32859 = -68					; size = 4
_C0$32831 = -64						; size = 4
_C1$32832 = -60						; size = 4
_H$32820 = -56						; size = 4
_CP$32812 = -52						; size = 4
_RP$32809 = -48						; size = 4
_F$32805 = -44						; size = 4
_R$32803 = -40						; size = 4
_XP$32802 = -36						; size = 4
_r$32798 = -32						; size = 4
_trem$32792 = -28					; size = 4
_J$32783 = -24						; size = 4
_t$ = -20						; size = 4
_leastbit$ = -16					; size = 4
_rsize$ = -12						; size = 4
_i$ = -8						; size = 4
_v$ = -4						; size = 4
_m$ = 8							; size = 4
_nb$ = 12						; size = 4
?tmalloc_small@@YAPAXPAUmalloc_state@@I@Z PROC		; tmalloc_small

; 4488 : static void* tmalloc_small(mstate m, size_t nb) {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 4489 :   tchunkptr t, v;
; 4490 :   size_t rsize;
; 4491 :   bindex_t i;
; 4492 :   binmap_t leastbit = least_bit(m->treemap);

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	neg	ecx
	mov	edx, DWORD PTR _m$[ebp]
	and	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _leastbit$[ebp], ecx

; 4493 :   compute_bit2idx(leastbit, i);

	mov	eax, DWORD PTR _leastbit$[ebp]
	bsf	ecx, eax
	mov	DWORD PTR _J$32783[ebp], ecx
	mov	edx, DWORD PTR _J$32783[ebp]
	mov	DWORD PTR _i$[ebp], edx

; 4494 :   v = t = *treebin_at(m, i);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+304]
	mov	DWORD PTR _t$[ebp], edx
	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR _v$[ebp], eax

; 4495 :   rsize = chunksize(t) - nb;

	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -8					; fffffff8H
	sub	edx, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _rsize$[ebp], edx
$LN40@tmalloc_sm:

; 4496 : 
; 4497 :   while ((t = leftmost_child(t)) != 0) {

	mov	eax, DWORD PTR _t$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN43@tmalloc_sm
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN44@tmalloc_sm
$LN43@tmalloc_sm:
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv83[ebp], ecx
$LN44@tmalloc_sm:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _t$[ebp], edx
	cmp	DWORD PTR _t$[ebp], 0
	je	SHORT $LN39@tmalloc_sm

; 4498 :     size_t trem = chunksize(t) - nb;

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	sub	ecx, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _trem$32792[ebp], ecx

; 4499 :     if (trem < rsize) {

	mov	edx, DWORD PTR _trem$32792[ebp]
	cmp	edx, DWORD PTR _rsize$[ebp]
	jae	SHORT $LN38@tmalloc_sm

; 4500 :       rsize = trem;

	mov	eax, DWORD PTR _trem$32792[ebp]
	mov	DWORD PTR _rsize$[ebp], eax

; 4501 :       v = t;

	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR _v$[ebp], ecx
$LN38@tmalloc_sm:

; 4502 :     }
; 4503 :   }

	jmp	SHORT $LN40@tmalloc_sm
$LN39@tmalloc_sm:

; 4504 : 
; 4505 :   if (RTCHECK(ok_address(m, v))) {

	mov	edx, 1
	test	edx, edx
	je	$LN37@tmalloc_sm

; 4506 :     mchunkptr r = chunk_plus_offset(v, nb);

	mov	eax, DWORD PTR _v$[ebp]
	add	eax, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _r$32798[ebp], eax

; 4507 :     assert(chunksize(v) == rsize + nb);
; 4508 :     if (RTCHECK(ok_next(v, r))) {

	mov	ecx, 1
	test	ecx, ecx
	je	$LN37@tmalloc_sm

; 4509 :       unlink_large_chunk(m, v);

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _XP$32802[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _v$[ebp]
	je	SHORT $LN35@tmalloc_sm
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$32805[ebp], ecx
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _R$32803[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN34@tmalloc_sm
	mov	edx, DWORD PTR _F$32805[ebp]
	mov	eax, DWORD PTR _R$32803[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _R$32803[ebp]
	mov	edx, DWORD PTR _F$32805[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN33@tmalloc_sm
$LN34@tmalloc_sm:
	call	DWORD PTR __imp__abort
$LN33@tmalloc_sm:
	jmp	SHORT $LN32@tmalloc_sm
$LN35@tmalloc_sm:
	mov	eax, DWORD PTR _v$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _RP$32809[ebp], eax
	mov	ecx, DWORD PTR _RP$32809[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _R$32803[ebp], edx
	cmp	DWORD PTR _R$32803[ebp], 0
	jne	SHORT $LN29@tmalloc_sm
	mov	eax, DWORD PTR _v$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _RP$32809[ebp], eax
	mov	ecx, DWORD PTR _RP$32809[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _R$32803[ebp], edx
	cmp	DWORD PTR _R$32803[ebp], 0
	je	SHORT $LN32@tmalloc_sm
$LN29@tmalloc_sm:
	mov	eax, DWORD PTR _R$32803[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _CP$32812[ebp], eax
	mov	ecx, DWORD PTR _CP$32812[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN27@tmalloc_sm
	mov	edx, DWORD PTR _R$32803[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _CP$32812[ebp], edx
	mov	eax, DWORD PTR _CP$32812[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN28@tmalloc_sm
$LN27@tmalloc_sm:
	mov	ecx, DWORD PTR _CP$32812[ebp]
	mov	DWORD PTR _RP$32809[ebp], ecx
	mov	edx, DWORD PTR _RP$32809[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _R$32803[ebp], eax
	jmp	SHORT $LN29@tmalloc_sm
$LN28@tmalloc_sm:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN26@tmalloc_sm
	mov	edx, DWORD PTR _RP$32809[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN32@tmalloc_sm
$LN26@tmalloc_sm:
	call	DWORD PTR __imp__abort
$LN32@tmalloc_sm:
	cmp	DWORD PTR _XP$32802[ebp], 0
	je	$LN24@tmalloc_sm
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _m$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+304]
	mov	DWORD PTR _H$32820[ebp], eax
	mov	ecx, DWORD PTR _H$32820[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN23@tmalloc_sm
	mov	eax, DWORD PTR _H$32820[ebp]
	mov	ecx, DWORD PTR _R$32803[ebp]
	mov	DWORD PTR [eax], ecx
	cmp	DWORD PTR _R$32803[ebp], 0
	jne	SHORT $LN22@tmalloc_sm
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+28]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _m$[ebp]
	and	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN22@tmalloc_sm:
	jmp	SHORT $LN21@tmalloc_sm
$LN23@tmalloc_sm:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN20@tmalloc_sm
	mov	ecx, DWORD PTR _XP$32802[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _v$[ebp]
	jne	SHORT $LN19@tmalloc_sm
	mov	eax, DWORD PTR _XP$32802[ebp]
	mov	ecx, DWORD PTR _R$32803[ebp]
	mov	DWORD PTR [eax+16], ecx
	jmp	SHORT $LN18@tmalloc_sm
$LN19@tmalloc_sm:
	mov	edx, DWORD PTR _XP$32802[ebp]
	mov	eax, DWORD PTR _R$32803[ebp]
	mov	DWORD PTR [edx+20], eax
$LN18@tmalloc_sm:
	jmp	SHORT $LN21@tmalloc_sm
$LN20@tmalloc_sm:
	call	DWORD PTR __imp__abort
$LN21@tmalloc_sm:
	cmp	DWORD PTR _R$32803[ebp], 0
	je	SHORT $LN24@tmalloc_sm
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN15@tmalloc_sm
	mov	edx, DWORD PTR _R$32803[ebp]
	mov	eax, DWORD PTR _XP$32802[ebp]
	mov	DWORD PTR [edx+24], eax
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _C0$32831[ebp], edx
	cmp	DWORD PTR _C0$32831[ebp], 0
	je	SHORT $LN14@tmalloc_sm
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN13@tmalloc_sm
	mov	ecx, DWORD PTR _R$32803[ebp]
	mov	edx, DWORD PTR _C0$32831[ebp]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR _C0$32831[ebp]
	mov	ecx, DWORD PTR _R$32803[ebp]
	mov	DWORD PTR [eax+24], ecx
	jmp	SHORT $LN14@tmalloc_sm
$LN13@tmalloc_sm:
	call	DWORD PTR __imp__abort
$LN14@tmalloc_sm:
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _C1$32832[ebp], eax
	cmp	DWORD PTR _C1$32832[ebp], 0
	je	SHORT $LN11@tmalloc_sm
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN10@tmalloc_sm
	mov	edx, DWORD PTR _R$32803[ebp]
	mov	eax, DWORD PTR _C1$32832[ebp]
	mov	DWORD PTR [edx+20], eax
	mov	ecx, DWORD PTR _C1$32832[ebp]
	mov	edx, DWORD PTR _R$32803[ebp]
	mov	DWORD PTR [ecx+24], edx
	jmp	SHORT $LN11@tmalloc_sm
$LN10@tmalloc_sm:
	call	DWORD PTR __imp__abort
$LN11@tmalloc_sm:
	jmp	SHORT $LN24@tmalloc_sm
$LN15@tmalloc_sm:
	call	DWORD PTR __imp__abort
$LN24@tmalloc_sm:

; 4510 :       if (rsize < MIN_CHUNK_SIZE)

	cmp	DWORD PTR _rsize$[ebp], 16		; 00000010H
	jae	SHORT $LN7@tmalloc_sm

; 4511 :         set_inuse_and_pinuse(m, v, (rsize + nb));

	mov	eax, DWORD PTR _rsize$[ebp]
	add	eax, DWORD PTR _nb$[ebp]
	or	eax, 1
	or	eax, 2
	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _rsize$[ebp]
	add	edx, DWORD PTR _nb$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4]
	or	ecx, 1
	mov	edx, DWORD PTR _rsize$[ebp]
	add	edx, DWORD PTR _nb$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+edx+4], ecx

; 4512 :       else {

	jmp	$LN6@tmalloc_sm
$LN7@tmalloc_sm:

; 4513 :         set_size_and_pinuse_of_inuse_chunk(m, v, nb);

	mov	ecx, DWORD PTR _nb$[ebp]
	or	ecx, 1
	or	ecx, 2
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4514 :         set_size_and_pinuse_of_free_chunk(r, rsize);

	mov	eax, DWORD PTR _rsize$[ebp]
	or	eax, 1
	mov	ecx, DWORD PTR _r$32798[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _r$32798[ebp]
	add	edx, DWORD PTR _rsize$[ebp]
	mov	eax, DWORD PTR _rsize$[ebp]
	mov	DWORD PTR [edx], eax

; 4515 :         replace_dv(m, r, rsize);

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _DVS$32859[ebp], edx
	cmp	DWORD PTR _DVS$32859[ebp], 0
	je	$LN5@tmalloc_sm
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _DV$32861[ebp], ecx
	mov	edx, DWORD PTR _DVS$32859[ebp]
	shr	edx, 3
	mov	DWORD PTR _I$32862[ebp], edx
	mov	eax, DWORD PTR _I$32862[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _m$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+40]
	mov	DWORD PTR _B$32864[ebp], edx
	mov	eax, DWORD PTR _B$32864[ebp]
	mov	DWORD PTR _F$32867[ebp], eax
	mov	edx, 1
	mov	ecx, DWORD PTR _I$32862[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _m$[ebp]
	and	edx, DWORD PTR [eax]
	jne	SHORT $LN4@tmalloc_sm
	mov	edx, 1
	mov	ecx, DWORD PTR _I$32862[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _m$[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN3@tmalloc_sm
$LN4@tmalloc_sm:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN2@tmalloc_sm
	mov	eax, DWORD PTR _B$32864[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$32867[ebp], ecx
	jmp	SHORT $LN3@tmalloc_sm
$LN2@tmalloc_sm:
	call	DWORD PTR __imp__abort
$LN3@tmalloc_sm:
	mov	edx, DWORD PTR _B$32864[ebp]
	mov	eax, DWORD PTR _DV$32861[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _F$32867[ebp]
	mov	edx, DWORD PTR _DV$32861[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _DV$32861[ebp]
	mov	ecx, DWORD PTR _F$32867[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _DV$32861[ebp]
	mov	eax, DWORD PTR _B$32864[ebp]
	mov	DWORD PTR [edx+12], eax
$LN5@tmalloc_sm:
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _rsize$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _r$32798[ebp]
	mov	DWORD PTR [eax+20], ecx
$LN6@tmalloc_sm:

; 4516 :       }
; 4517 :       return chunk2mem(v);

	mov	eax, DWORD PTR _v$[ebp]
	add	eax, 8
	jmp	SHORT $LN41@tmalloc_sm
$LN37@tmalloc_sm:

; 4518 :     }
; 4519 :   }
; 4520 : 
; 4521 :   CORRUPTION_ERROR_ACTION(m);

	call	DWORD PTR __imp__abort

; 4522 :   return 0;

	xor	eax, eax
$LN41@tmalloc_sm:

; 4523 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?tmalloc_small@@YAPAXPAUmalloc_state@@I@Z ENDP		; tmalloc_small
_TEXT	ENDS
PUBLIC	?dlfree@@YAXPAX@Z				; dlfree
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv387 = -188						; size = 4
tv75 = -184						; size = 4
tv73 = -180						; size = 4
_F$33312 = -176						; size = 4
_C$33304 = -172						; size = 4
_K$33294 = -168						; size = 4
_T$33293 = -164						; size = 4
_K$33284 = -160						; size = 4
_X$33279 = -156						; size = 4
_I$33278 = -152						; size = 4
_H$33277 = -148						; size = 4
_tp$33275 = -144					; size = 4
_I$33262 = -140						; size = 4
_F$33267 = -136						; size = 4
_B$33264 = -132						; size = 4
_C0$33242 = -128					; size = 4
_C1$33243 = -124					; size = 4
_H$33231 = -120						; size = 4
_CP$33223 = -116					; size = 4
_RP$33220 = -112					; size = 4
_F$33216 = -108						; size = 4
_R$33214 = -104						; size = 4
_XP$33213 = -100					; size = 4
_TP$33211 = -96						; size = 4
_I$33201 = -92						; size = 4
_F$33199 = -88						; size = 4
_B$33200 = -84						; size = 4
_nsize$33194 = -80					; size = 4
_dsize$33188 = -76					; size = 4
_tsize$33181 = -72					; size = 4
_C0$33154 = -68						; size = 4
_C1$33155 = -64						; size = 4
_H$33143 = -60						; size = 4
_CP$33135 = -56						; size = 4
_RP$33132 = -52						; size = 4
_F$33128 = -48						; size = 4
_R$33126 = -44						; size = 4
_XP$33125 = -40						; size = 4
_TP$33123 = -36						; size = 4
_I$33113 = -32						; size = 4
_F$33111 = -28						; size = 4
_B$33112 = -24						; size = 4
_prev$33105 = -20					; size = 4
_prevsize$33095 = -16					; size = 4
_psize$33086 = -12					; size = 4
_next$33090 = -8					; size = 4
_p$33078 = -4						; size = 4
_mem$ = 8						; size = 4
?dlfree@@YAXPAX@Z PROC					; dlfree

; 4665 : void dlfree(void* mem) {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH

; 4666 :   /*
; 4667 :      Consolidate freed chunks with preceeding or succeeding bordering
; 4668 :      free chunks, if they exist, and then place in a bin.  Intermixed
; 4669 :      with special cases for top, dv, mmapped chunks, and usage errors.
; 4670 :   */
; 4671 : 
; 4672 :   if (mem != 0) {

	cmp	DWORD PTR _mem$[ebp], 0
	je	$LN126@dlfree

; 4673 :     mchunkptr p  = mem2chunk(mem);

	mov	eax, DWORD PTR _mem$[ebp]
	sub	eax, 8
	mov	DWORD PTR _p$33078[ebp], eax

; 4674 : #if FOOTERS
; 4675 :     mstate fm = get_mstate_for(p);
; 4676 :     if (!ok_magic(fm)) {
; 4677 :       USAGE_ERROR_ACTION(fm, p);
; 4678 :       return;
; 4679 :     }
; 4680 : #else /* FOOTERS */
; 4681 : #define fm gm
; 4682 : #endif /* FOOTERS */
; 4683 :     if (!PREACTION(fm)) {

	mov	ecx, DWORD PTR __gm_+444
	and	ecx, 2
	je	SHORT $LN130@dlfree
	mov	edx, 1
	mov	eax, OFFSET __gm_+448
	xchg	DWORD PTR [eax], edx
	test	edx, edx
	je	SHORT $LN128@dlfree
	push	OFFSET __gm_+448
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN129@dlfree
$LN128@dlfree:
	mov	DWORD PTR tv73[ebp], 0
$LN129@dlfree:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN131@dlfree
$LN130@dlfree:
	mov	DWORD PTR tv75[ebp], 0
$LN131@dlfree:
	cmp	DWORD PTR tv75[ebp], 0
	jne	$LN126@dlfree

; 4684 :       check_inuse_chunk(fm, p);
; 4685 :       if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {

	mov	edx, 1
	test	edx, edx
	je	$erroraction$33175

; 4686 :         size_t psize = chunksize(p);

	mov	eax, DWORD PTR _p$33078[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	mov	DWORD PTR _psize$33086[ebp], ecx

; 4687 :         mchunkptr next = chunk_plus_offset(p, psize);

	mov	edx, DWORD PTR _p$33078[ebp]
	add	edx, DWORD PTR _psize$33086[ebp]
	mov	DWORD PTR _next$33090[ebp], edx

; 4688 :         if (!pinuse(p)) {

	mov	eax, DWORD PTR _p$33078[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 1
	jne	$LN122@dlfree

; 4689 :           size_t prevsize = p->prev_foot;

	mov	edx, DWORD PTR _p$33078[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _prevsize$33095[ebp], eax

; 4690 :           if (is_mmapped(p)) {

	mov	ecx, DWORD PTR _p$33078[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 3
	jne	SHORT $LN121@dlfree

; 4691 :             psize += prevsize + MMAP_FOOT_PAD;

	mov	eax, DWORD PTR _prevsize$33095[ebp]
	mov	ecx, DWORD PTR _psize$33086[ebp]
	lea	edx, DWORD PTR [ecx+eax+16]
	mov	DWORD PTR _psize$33086[ebp], edx

; 4692 :             if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)

	mov	eax, DWORD PTR _psize$33086[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$33078[ebp]
	sub	ecx, DWORD PTR _prevsize$33095[ebp]
	push	ecx
	call	?win32munmap@@YAHPAXI@Z			; win32munmap
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN120@dlfree

; 4693 :               fm->footprint -= psize;

	mov	edx, DWORD PTR __gm_+432
	sub	edx, DWORD PTR _psize$33086[ebp]
	mov	DWORD PTR __gm_+432, edx
$LN120@dlfree:

; 4694 :             goto postaction;

	jmp	$postaction$33102
	jmp	$postaction$33102

; 4695 :           }
; 4696 :           else {

	jmp	$LN122@dlfree
$LN121@dlfree:

; 4697 :             mchunkptr prev = chunk_minus_offset(p, prevsize);

	mov	eax, DWORD PTR _p$33078[ebp]
	sub	eax, DWORD PTR _prevsize$33095[ebp]
	mov	DWORD PTR _prev$33105[ebp], eax

; 4698 :             psize += prevsize;

	mov	ecx, DWORD PTR _psize$33086[ebp]
	add	ecx, DWORD PTR _prevsize$33095[ebp]
	mov	DWORD PTR _psize$33086[ebp], ecx

; 4699 :             p = prev;

	mov	edx, DWORD PTR _prev$33105[ebp]
	mov	DWORD PTR _p$33078[ebp], edx

; 4700 :             if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */

	mov	eax, 1
	test	eax, eax
	je	$LN117@dlfree

; 4701 :               if (p != fm->dv) {

	mov	ecx, DWORD PTR _p$33078[ebp]
	cmp	ecx, DWORD PTR __gm_+20
	je	$LN116@dlfree

; 4702 :                 unlink_chunk(fm, p, prevsize);

	mov	edx, DWORD PTR _prevsize$33095[ebp]
	shr	edx, 3
	cmp	edx, 32					; 00000020H
	jae	SHORT $LN115@dlfree
	mov	eax, DWORD PTR _p$33078[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$33111[ebp], ecx
	mov	edx, DWORD PTR _p$33078[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _B$33112[ebp], eax
	mov	ecx, DWORD PTR _prevsize$33095[ebp]
	shr	ecx, 3
	mov	DWORD PTR _I$33113[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN114@dlfree
	mov	eax, DWORD PTR _B$33112[ebp]
	cmp	eax, DWORD PTR _F$33111[ebp]
	jne	SHORT $LN113@dlfree
	mov	edx, 1
	mov	ecx, DWORD PTR _I$33113[ebp]
	shl	edx, cl
	not	edx
	and	edx, DWORD PTR __gm_
	mov	DWORD PTR __gm_, edx
	jmp	SHORT $LN112@dlfree
$LN113@dlfree:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN111@dlfree
	mov	ecx, DWORD PTR _F$33111[ebp]
	mov	edx, DWORD PTR _B$33112[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _B$33112[ebp]
	mov	ecx, DWORD PTR _F$33111[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN112@dlfree
$LN111@dlfree:
	call	DWORD PTR __imp__abort
$LN112@dlfree:
	jmp	SHORT $LN109@dlfree
$LN114@dlfree:
	call	DWORD PTR __imp__abort
$LN109@dlfree:
	jmp	$LN108@dlfree
$LN115@dlfree:
	mov	edx, DWORD PTR _p$33078[ebp]
	mov	DWORD PTR _TP$33123[ebp], edx
	mov	eax, DWORD PTR _TP$33123[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _XP$33125[ebp], ecx
	mov	edx, DWORD PTR _TP$33123[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _TP$33123[ebp]
	je	SHORT $LN107@dlfree
	mov	ecx, DWORD PTR _TP$33123[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _F$33128[ebp], edx
	mov	eax, DWORD PTR _TP$33123[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _R$33126[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN106@dlfree
	mov	eax, DWORD PTR _F$33128[ebp]
	mov	ecx, DWORD PTR _R$33126[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _R$33126[ebp]
	mov	eax, DWORD PTR _F$33128[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN105@dlfree
$LN106@dlfree:
	call	DWORD PTR __imp__abort
$LN105@dlfree:
	jmp	SHORT $LN104@dlfree
$LN107@dlfree:
	mov	ecx, DWORD PTR _TP$33123[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _RP$33132[ebp], ecx
	mov	edx, DWORD PTR _RP$33132[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _R$33126[ebp], eax
	cmp	DWORD PTR _R$33126[ebp], 0
	jne	SHORT $LN101@dlfree
	mov	ecx, DWORD PTR _TP$33123[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _RP$33132[ebp], ecx
	mov	edx, DWORD PTR _RP$33132[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _R$33126[ebp], eax
	cmp	DWORD PTR _R$33126[ebp], 0
	je	SHORT $LN104@dlfree
$LN101@dlfree:
	mov	ecx, DWORD PTR _R$33126[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _CP$33135[ebp], ecx
	mov	edx, DWORD PTR _CP$33135[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN99@dlfree
	mov	eax, DWORD PTR _R$33126[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _CP$33135[ebp], eax
	mov	ecx, DWORD PTR _CP$33135[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN100@dlfree
$LN99@dlfree:
	mov	edx, DWORD PTR _CP$33135[ebp]
	mov	DWORD PTR _RP$33132[ebp], edx
	mov	eax, DWORD PTR _RP$33132[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _R$33126[ebp], ecx
	jmp	SHORT $LN101@dlfree
$LN100@dlfree:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN98@dlfree
	mov	eax, DWORD PTR _RP$33132[ebp]
	mov	DWORD PTR [eax], 0
	jmp	SHORT $LN104@dlfree
$LN98@dlfree:
	call	DWORD PTR __imp__abort
$LN104@dlfree:
	cmp	DWORD PTR _XP$33125[ebp], 0
	je	$LN108@dlfree
	mov	ecx, DWORD PTR _TP$33123[ebp]
	mov	edx, DWORD PTR [ecx+28]
	lea	eax, DWORD PTR __gm_[edx*4+304]
	mov	DWORD PTR _H$33143[ebp], eax
	mov	ecx, DWORD PTR _H$33143[ebp]
	mov	edx, DWORD PTR _TP$33123[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN95@dlfree
	mov	eax, DWORD PTR _H$33143[ebp]
	mov	ecx, DWORD PTR _R$33126[ebp]
	mov	DWORD PTR [eax], ecx
	cmp	DWORD PTR _R$33126[ebp], 0
	jne	SHORT $LN94@dlfree
	mov	edx, DWORD PTR _TP$33123[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+28]
	shl	eax, cl
	not	eax
	and	eax, DWORD PTR __gm_+4
	mov	DWORD PTR __gm_+4, eax
$LN94@dlfree:
	jmp	SHORT $LN93@dlfree
$LN95@dlfree:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN92@dlfree
	mov	edx, DWORD PTR _XP$33125[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _TP$33123[ebp]
	jne	SHORT $LN91@dlfree
	mov	ecx, DWORD PTR _XP$33125[ebp]
	mov	edx, DWORD PTR _R$33126[ebp]
	mov	DWORD PTR [ecx+16], edx
	jmp	SHORT $LN90@dlfree
$LN91@dlfree:
	mov	eax, DWORD PTR _XP$33125[ebp]
	mov	ecx, DWORD PTR _R$33126[ebp]
	mov	DWORD PTR [eax+20], ecx
$LN90@dlfree:
	jmp	SHORT $LN93@dlfree
$LN92@dlfree:
	call	DWORD PTR __imp__abort
$LN93@dlfree:
	cmp	DWORD PTR _R$33126[ebp], 0
	je	SHORT $LN108@dlfree
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN87@dlfree
	mov	eax, DWORD PTR _R$33126[ebp]
	mov	ecx, DWORD PTR _XP$33125[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _TP$33123[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _C0$33154[ebp], eax
	cmp	DWORD PTR _C0$33154[ebp], 0
	je	SHORT $LN86@dlfree
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN85@dlfree
	mov	edx, DWORD PTR _R$33126[ebp]
	mov	eax, DWORD PTR _C0$33154[ebp]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR _C0$33154[ebp]
	mov	edx, DWORD PTR _R$33126[ebp]
	mov	DWORD PTR [ecx+24], edx
	jmp	SHORT $LN86@dlfree
$LN85@dlfree:
	call	DWORD PTR __imp__abort
$LN86@dlfree:
	mov	eax, DWORD PTR _TP$33123[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _C1$33155[ebp], ecx
	cmp	DWORD PTR _C1$33155[ebp], 0
	je	SHORT $LN83@dlfree
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN82@dlfree
	mov	eax, DWORD PTR _R$33126[ebp]
	mov	ecx, DWORD PTR _C1$33155[ebp]
	mov	DWORD PTR [eax+20], ecx
	mov	edx, DWORD PTR _C1$33155[ebp]
	mov	eax, DWORD PTR _R$33126[ebp]
	mov	DWORD PTR [edx+24], eax
	jmp	SHORT $LN83@dlfree
$LN82@dlfree:
	call	DWORD PTR __imp__abort
$LN83@dlfree:
	jmp	SHORT $LN108@dlfree
$LN87@dlfree:
	call	DWORD PTR __imp__abort
$LN108@dlfree:
	jmp	SHORT $LN79@dlfree
$LN116@dlfree:

; 4703 :               }
; 4704 :               else if ((next->head & INUSE_BITS) == INUSE_BITS) {

	mov	ecx, DWORD PTR _next$33090[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 3
	cmp	edx, 3
	jne	SHORT $LN79@dlfree

; 4705 :                 fm->dvsize = psize;

	mov	eax, DWORD PTR _psize$33086[ebp]
	mov	DWORD PTR __gm_+8, eax

; 4706 :                 set_free_with_pinuse(p, psize, next);

	mov	ecx, DWORD PTR _next$33090[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _next$33090[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _psize$33086[ebp]
	or	ecx, 1
	mov	edx, DWORD PTR _p$33078[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _p$33078[ebp]
	add	eax, DWORD PTR _psize$33086[ebp]
	mov	ecx, DWORD PTR _psize$33086[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	$postaction$33102

; 4707 :                 goto postaction;

	jmp	$postaction$33102
$LN79@dlfree:

; 4708 :               }
; 4709 :             }
; 4710 :             else

	jmp	SHORT $LN122@dlfree
$LN117@dlfree:

; 4711 :               goto erroraction;

	jmp	$erroraction$33175
	jmp	$erroraction$33175
$LN122@dlfree:

; 4712 :           }
; 4713 :         }
; 4714 : 
; 4715 :         if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {

	mov	edx, 1
	test	edx, edx
	je	$erroraction$33175

; 4716 :           if (!cinuse(next)) {  /* consolidate forward */

	mov	eax, DWORD PTR _next$33090[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 2
	jne	$LN73@dlfree

; 4717 :             if (next == fm->top) {

	mov	edx, DWORD PTR _next$33090[ebp]
	cmp	edx, DWORD PTR __gm_+24
	jne	SHORT $LN72@dlfree

; 4718 :               size_t tsize = fm->topsize += psize;

	mov	eax, DWORD PTR __gm_+12
	add	eax, DWORD PTR _psize$33086[ebp]
	mov	DWORD PTR __gm_+12, eax
	mov	ecx, DWORD PTR __gm_+12
	mov	DWORD PTR _tsize$33181[ebp], ecx

; 4719 :               fm->top = p;

	mov	edx, DWORD PTR _p$33078[ebp]
	mov	DWORD PTR __gm_+24, edx

; 4720 :               p->head = tsize | PINUSE_BIT;

	mov	eax, DWORD PTR _tsize$33181[ebp]
	or	eax, 1
	mov	ecx, DWORD PTR _p$33078[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4721 :               if (p == fm->dv) {

	mov	edx, DWORD PTR _p$33078[ebp]
	cmp	edx, DWORD PTR __gm_+20
	jne	SHORT $LN71@dlfree

; 4722 :                 fm->dv = 0;

	mov	DWORD PTR __gm_+20, 0

; 4723 :                 fm->dvsize = 0;

	mov	DWORD PTR __gm_+8, 0
$LN71@dlfree:

; 4724 :               }
; 4725 :               if (should_trim(fm, tsize))

	mov	eax, DWORD PTR _tsize$33181[ebp]
	cmp	eax, DWORD PTR __gm_+28
	jbe	SHORT $LN70@dlfree

; 4726 :                 sys_trim(fm, 0);

	push	0
	push	OFFSET __gm_
	call	?sys_trim@@YAHPAUmalloc_state@@I@Z	; sys_trim
	add	esp, 8
$LN70@dlfree:

; 4727 :               goto postaction;

	jmp	$postaction$33102
	jmp	$postaction$33102
	jmp	$LN68@dlfree
$LN72@dlfree:

; 4728 :             }
; 4729 :             else if (next == fm->dv) {

	mov	ecx, DWORD PTR _next$33090[ebp]
	cmp	ecx, DWORD PTR __gm_+20
	jne	SHORT $LN67@dlfree

; 4730 :               size_t dsize = fm->dvsize += psize;

	mov	edx, DWORD PTR __gm_+8
	add	edx, DWORD PTR _psize$33086[ebp]
	mov	DWORD PTR __gm_+8, edx
	mov	eax, DWORD PTR __gm_+8
	mov	DWORD PTR _dsize$33188[ebp], eax

; 4731 :               fm->dv = p;

	mov	ecx, DWORD PTR _p$33078[ebp]
	mov	DWORD PTR __gm_+20, ecx

; 4732 :               set_size_and_pinuse_of_free_chunk(p, dsize);

	mov	edx, DWORD PTR _dsize$33188[ebp]
	or	edx, 1
	mov	eax, DWORD PTR _p$33078[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _p$33078[ebp]
	add	ecx, DWORD PTR _dsize$33188[ebp]
	mov	edx, DWORD PTR _dsize$33188[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	$postaction$33102

; 4733 :               goto postaction;

	jmp	$postaction$33102

; 4734 :             }
; 4735 :             else {

	jmp	$LN68@dlfree
$LN67@dlfree:

; 4736 :               size_t nsize = chunksize(next);

	mov	eax, DWORD PTR _next$33090[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	mov	DWORD PTR _nsize$33194[ebp], ecx

; 4737 :               psize += nsize;

	mov	edx, DWORD PTR _psize$33086[ebp]
	add	edx, DWORD PTR _nsize$33194[ebp]
	mov	DWORD PTR _psize$33086[ebp], edx

; 4738 :               unlink_chunk(fm, next, nsize);

	mov	eax, DWORD PTR _nsize$33194[ebp]
	shr	eax, 3
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN64@dlfree
	mov	ecx, DWORD PTR _next$33090[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _F$33199[ebp], edx
	mov	eax, DWORD PTR _next$33090[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _B$33200[ebp], ecx
	mov	edx, DWORD PTR _nsize$33194[ebp]
	shr	edx, 3
	mov	DWORD PTR _I$33201[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN63@dlfree
	mov	ecx, DWORD PTR _B$33200[ebp]
	cmp	ecx, DWORD PTR _F$33199[ebp]
	jne	SHORT $LN62@dlfree
	mov	edx, 1
	mov	ecx, DWORD PTR _I$33201[ebp]
	shl	edx, cl
	not	edx
	and	edx, DWORD PTR __gm_
	mov	DWORD PTR __gm_, edx
	jmp	SHORT $LN61@dlfree
$LN62@dlfree:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN60@dlfree
	mov	ecx, DWORD PTR _F$33199[ebp]
	mov	edx, DWORD PTR _B$33200[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _B$33200[ebp]
	mov	ecx, DWORD PTR _F$33199[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN61@dlfree
$LN60@dlfree:
	call	DWORD PTR __imp__abort
$LN61@dlfree:
	jmp	SHORT $LN58@dlfree
$LN63@dlfree:
	call	DWORD PTR __imp__abort
$LN58@dlfree:
	jmp	$LN57@dlfree
$LN64@dlfree:
	mov	edx, DWORD PTR _next$33090[ebp]
	mov	DWORD PTR _TP$33211[ebp], edx
	mov	eax, DWORD PTR _TP$33211[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _XP$33213[ebp], ecx
	mov	edx, DWORD PTR _TP$33211[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _TP$33211[ebp]
	je	SHORT $LN56@dlfree
	mov	ecx, DWORD PTR _TP$33211[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _F$33216[ebp], edx
	mov	eax, DWORD PTR _TP$33211[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _R$33214[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN55@dlfree
	mov	eax, DWORD PTR _F$33216[ebp]
	mov	ecx, DWORD PTR _R$33214[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _R$33214[ebp]
	mov	eax, DWORD PTR _F$33216[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN54@dlfree
$LN55@dlfree:
	call	DWORD PTR __imp__abort
$LN54@dlfree:
	jmp	SHORT $LN53@dlfree
$LN56@dlfree:
	mov	ecx, DWORD PTR _TP$33211[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _RP$33220[ebp], ecx
	mov	edx, DWORD PTR _RP$33220[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _R$33214[ebp], eax
	cmp	DWORD PTR _R$33214[ebp], 0
	jne	SHORT $LN50@dlfree
	mov	ecx, DWORD PTR _TP$33211[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _RP$33220[ebp], ecx
	mov	edx, DWORD PTR _RP$33220[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _R$33214[ebp], eax
	cmp	DWORD PTR _R$33214[ebp], 0
	je	SHORT $LN53@dlfree
$LN50@dlfree:
	mov	ecx, DWORD PTR _R$33214[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _CP$33223[ebp], ecx
	mov	edx, DWORD PTR _CP$33223[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN48@dlfree
	mov	eax, DWORD PTR _R$33214[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _CP$33223[ebp], eax
	mov	ecx, DWORD PTR _CP$33223[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN49@dlfree
$LN48@dlfree:
	mov	edx, DWORD PTR _CP$33223[ebp]
	mov	DWORD PTR _RP$33220[ebp], edx
	mov	eax, DWORD PTR _RP$33220[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _R$33214[ebp], ecx
	jmp	SHORT $LN50@dlfree
$LN49@dlfree:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN47@dlfree
	mov	eax, DWORD PTR _RP$33220[ebp]
	mov	DWORD PTR [eax], 0
	jmp	SHORT $LN53@dlfree
$LN47@dlfree:
	call	DWORD PTR __imp__abort
$LN53@dlfree:
	cmp	DWORD PTR _XP$33213[ebp], 0
	je	$LN57@dlfree
	mov	ecx, DWORD PTR _TP$33211[ebp]
	mov	edx, DWORD PTR [ecx+28]
	lea	eax, DWORD PTR __gm_[edx*4+304]
	mov	DWORD PTR _H$33231[ebp], eax
	mov	ecx, DWORD PTR _H$33231[ebp]
	mov	edx, DWORD PTR _TP$33211[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@dlfree
	mov	eax, DWORD PTR _H$33231[ebp]
	mov	ecx, DWORD PTR _R$33214[ebp]
	mov	DWORD PTR [eax], ecx
	cmp	DWORD PTR _R$33214[ebp], 0
	jne	SHORT $LN43@dlfree
	mov	edx, DWORD PTR _TP$33211[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+28]
	shl	eax, cl
	not	eax
	and	eax, DWORD PTR __gm_+4
	mov	DWORD PTR __gm_+4, eax
$LN43@dlfree:
	jmp	SHORT $LN42@dlfree
$LN44@dlfree:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN41@dlfree
	mov	edx, DWORD PTR _XP$33213[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _TP$33211[ebp]
	jne	SHORT $LN40@dlfree
	mov	ecx, DWORD PTR _XP$33213[ebp]
	mov	edx, DWORD PTR _R$33214[ebp]
	mov	DWORD PTR [ecx+16], edx
	jmp	SHORT $LN39@dlfree
$LN40@dlfree:
	mov	eax, DWORD PTR _XP$33213[ebp]
	mov	ecx, DWORD PTR _R$33214[ebp]
	mov	DWORD PTR [eax+20], ecx
$LN39@dlfree:
	jmp	SHORT $LN42@dlfree
$LN41@dlfree:
	call	DWORD PTR __imp__abort
$LN42@dlfree:
	cmp	DWORD PTR _R$33214[ebp], 0
	je	SHORT $LN57@dlfree
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN36@dlfree
	mov	eax, DWORD PTR _R$33214[ebp]
	mov	ecx, DWORD PTR _XP$33213[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _TP$33211[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _C0$33242[ebp], eax
	cmp	DWORD PTR _C0$33242[ebp], 0
	je	SHORT $LN35@dlfree
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN34@dlfree
	mov	edx, DWORD PTR _R$33214[ebp]
	mov	eax, DWORD PTR _C0$33242[ebp]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR _C0$33242[ebp]
	mov	edx, DWORD PTR _R$33214[ebp]
	mov	DWORD PTR [ecx+24], edx
	jmp	SHORT $LN35@dlfree
$LN34@dlfree:
	call	DWORD PTR __imp__abort
$LN35@dlfree:
	mov	eax, DWORD PTR _TP$33211[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _C1$33243[ebp], ecx
	cmp	DWORD PTR _C1$33243[ebp], 0
	je	SHORT $LN32@dlfree
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN31@dlfree
	mov	eax, DWORD PTR _R$33214[ebp]
	mov	ecx, DWORD PTR _C1$33243[ebp]
	mov	DWORD PTR [eax+20], ecx
	mov	edx, DWORD PTR _C1$33243[ebp]
	mov	eax, DWORD PTR _R$33214[ebp]
	mov	DWORD PTR [edx+24], eax
	jmp	SHORT $LN32@dlfree
$LN31@dlfree:
	call	DWORD PTR __imp__abort
$LN32@dlfree:
	jmp	SHORT $LN57@dlfree
$LN36@dlfree:
	call	DWORD PTR __imp__abort
$LN57@dlfree:

; 4739 :               set_size_and_pinuse_of_free_chunk(p, psize);

	mov	ecx, DWORD PTR _psize$33086[ebp]
	or	ecx, 1
	mov	edx, DWORD PTR _p$33078[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _p$33078[ebp]
	add	eax, DWORD PTR _psize$33086[ebp]
	mov	ecx, DWORD PTR _psize$33086[ebp]
	mov	DWORD PTR [eax], ecx

; 4740 :               if (p == fm->dv) {

	mov	edx, DWORD PTR _p$33078[ebp]
	cmp	edx, DWORD PTR __gm_+20
	jne	SHORT $LN68@dlfree

; 4741 :                 fm->dvsize = psize;

	mov	eax, DWORD PTR _psize$33086[ebp]
	mov	DWORD PTR __gm_+8, eax
	jmp	$postaction$33102

; 4742 :                 goto postaction;

	jmp	$postaction$33102
$LN68@dlfree:

; 4743 :               }
; 4744 :             }
; 4745 :           }
; 4746 :           else

	jmp	SHORT $LN26@dlfree
$LN73@dlfree:

; 4747 :             set_free_with_pinuse(p, psize, next);

	mov	ecx, DWORD PTR _next$33090[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _next$33090[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _psize$33086[ebp]
	or	ecx, 1
	mov	edx, DWORD PTR _p$33078[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _p$33078[ebp]
	add	eax, DWORD PTR _psize$33086[ebp]
	mov	ecx, DWORD PTR _psize$33086[ebp]
	mov	DWORD PTR [eax], ecx
$LN26@dlfree:

; 4748 : 
; 4749 :           if (is_small(psize)) {

	mov	edx, DWORD PTR _psize$33086[ebp]
	shr	edx, 3
	cmp	edx, 32					; 00000020H
	jae	$LN25@dlfree

; 4750 :             insert_small_chunk(fm, p, psize);

	mov	eax, DWORD PTR _psize$33086[ebp]
	shr	eax, 3
	mov	DWORD PTR _I$33262[ebp], eax
	mov	ecx, DWORD PTR _I$33262[ebp]
	shl	ecx, 1
	lea	edx, DWORD PTR __gm_[ecx*4+40]
	mov	DWORD PTR _B$33264[ebp], edx
	mov	eax, DWORD PTR _B$33264[ebp]
	mov	DWORD PTR _F$33267[ebp], eax
	mov	edx, 1
	mov	ecx, DWORD PTR _I$33262[ebp]
	shl	edx, cl
	and	edx, DWORD PTR __gm_
	jne	SHORT $LN24@dlfree
	mov	eax, 1
	mov	ecx, DWORD PTR _I$33262[ebp]
	shl	eax, cl
	or	eax, DWORD PTR __gm_
	mov	DWORD PTR __gm_, eax
	jmp	SHORT $LN23@dlfree
$LN24@dlfree:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN22@dlfree
	mov	edx, DWORD PTR _B$33264[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _F$33267[ebp], eax
	jmp	SHORT $LN23@dlfree
$LN22@dlfree:
	call	DWORD PTR __imp__abort
$LN23@dlfree:
	mov	ecx, DWORD PTR _B$33264[ebp]
	mov	edx, DWORD PTR _p$33078[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _F$33267[ebp]
	mov	ecx, DWORD PTR _p$33078[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _p$33078[ebp]
	mov	eax, DWORD PTR _F$33267[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _p$33078[ebp]
	mov	edx, DWORD PTR _B$33264[ebp]
	mov	DWORD PTR [ecx+12], edx

; 4751 :             check_free_chunk(fm, p);
; 4752 :           }
; 4753 :           else {

	jmp	$LN20@dlfree
$LN25@dlfree:

; 4754 :             tchunkptr tp = (tchunkptr)p;

	mov	eax, DWORD PTR _p$33078[ebp]
	mov	DWORD PTR _tp$33275[ebp], eax

; 4755 :             insert_large_chunk(fm, tp, psize);

	mov	ecx, DWORD PTR _psize$33086[ebp]
	shr	ecx, 8
	mov	DWORD PTR _X$33279[ebp], ecx
	cmp	DWORD PTR _X$33279[ebp], 0
	jne	SHORT $LN19@dlfree
	mov	DWORD PTR _I$33278[ebp], 0
	jmp	SHORT $LN18@dlfree
$LN19@dlfree:
	cmp	DWORD PTR _X$33279[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN17@dlfree
	mov	DWORD PTR _I$33278[ebp], 31		; 0000001fH
	jmp	SHORT $LN18@dlfree
$LN17@dlfree:
	mov	edx, DWORD PTR _X$33279[ebp]
	bsr	eax, edx
	mov	DWORD PTR _K$33284[ebp], eax
	mov	ecx, DWORD PTR _K$33284[ebp]
	add	ecx, 7
	mov	edx, DWORD PTR _psize$33086[ebp]
	shr	edx, cl
	and	edx, 1
	mov	eax, DWORD PTR _K$33284[ebp]
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _I$33278[ebp], ecx
$LN18@dlfree:
	mov	edx, DWORD PTR _I$33278[ebp]
	lea	eax, DWORD PTR __gm_[edx*4+304]
	mov	DWORD PTR _H$33277[ebp], eax
	mov	ecx, DWORD PTR _tp$33275[ebp]
	mov	edx, DWORD PTR _I$33278[ebp]
	mov	DWORD PTR [ecx+28], edx
	mov	eax, DWORD PTR _tp$33275[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _tp$33275[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, 1
	mov	ecx, DWORD PTR _I$33278[ebp]
	shl	edx, cl
	and	edx, DWORD PTR __gm_+4
	jne	SHORT $LN15@dlfree
	mov	eax, 1
	mov	ecx, DWORD PTR _I$33278[ebp]
	shl	eax, cl
	or	eax, DWORD PTR __gm_+4
	mov	DWORD PTR __gm_+4, eax
	mov	ecx, DWORD PTR _H$33277[ebp]
	mov	edx, DWORD PTR _tp$33275[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _tp$33275[ebp]
	mov	ecx, DWORD PTR _H$33277[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _tp$33275[ebp]
	mov	eax, DWORD PTR _tp$33275[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _tp$33275[ebp]
	mov	edx, DWORD PTR _tp$33275[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	$LN14@dlfree
$LN15@dlfree:
	mov	eax, DWORD PTR _H$33277[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _T$33293[ebp], ecx
	cmp	DWORD PTR _I$33278[ebp], 31		; 0000001fH
	jne	SHORT $LN132@dlfree
	mov	DWORD PTR tv387[ebp], 0
	jmp	SHORT $LN133@dlfree
$LN132@dlfree:
	mov	edx, DWORD PTR _I$33278[ebp]
	shr	edx, 1
	add	edx, 6
	mov	eax, 31					; 0000001fH
	sub	eax, edx
	mov	DWORD PTR tv387[ebp], eax
$LN133@dlfree:
	mov	edx, DWORD PTR _psize$33086[ebp]
	mov	ecx, DWORD PTR tv387[ebp]
	shl	edx, cl
	mov	DWORD PTR _K$33294[ebp], edx
$LN13@dlfree:
	mov	eax, DWORD PTR _T$33293[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	cmp	ecx, DWORD PTR _psize$33086[ebp]
	je	$LN11@dlfree
	mov	edx, DWORD PTR _K$33294[ebp]
	shr	edx, 31					; 0000001fH
	and	edx, 1
	mov	eax, DWORD PTR _T$33293[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+16]
	mov	DWORD PTR _C$33304[ebp], ecx
	mov	edx, DWORD PTR _K$33294[ebp]
	shl	edx, 1
	mov	DWORD PTR _K$33294[ebp], edx
	mov	eax, DWORD PTR _C$33304[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN10@dlfree
	mov	ecx, DWORD PTR _C$33304[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _T$33293[ebp], edx
	jmp	SHORT $LN9@dlfree
$LN10@dlfree:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN8@dlfree
	mov	ecx, DWORD PTR _C$33304[ebp]
	mov	edx, DWORD PTR _tp$33275[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _tp$33275[ebp]
	mov	ecx, DWORD PTR _T$33293[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _tp$33275[ebp]
	mov	eax, DWORD PTR _tp$33275[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _tp$33275[ebp]
	mov	edx, DWORD PTR _tp$33275[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN14@dlfree
	jmp	SHORT $LN9@dlfree
$LN8@dlfree:
	call	DWORD PTR __imp__abort
	jmp	SHORT $LN14@dlfree
$LN9@dlfree:
	jmp	SHORT $LN6@dlfree
$LN11@dlfree:
	mov	eax, DWORD PTR _T$33293[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$33312[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@dlfree
	mov	eax, DWORD PTR _F$33312[ebp]
	mov	ecx, DWORD PTR _tp$33275[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _T$33293[ebp]
	mov	eax, DWORD PTR _tp$33275[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _tp$33275[ebp]
	mov	edx, DWORD PTR _F$33312[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _tp$33275[ebp]
	mov	ecx, DWORD PTR _T$33293[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _tp$33275[ebp]
	mov	DWORD PTR [edx+24], 0
	jmp	SHORT $LN14@dlfree
	jmp	SHORT $LN6@dlfree
$LN5@dlfree:
	call	DWORD PTR __imp__abort
	jmp	SHORT $LN14@dlfree
$LN6@dlfree:
	jmp	$LN13@dlfree
$LN14@dlfree:

; 4756 :             check_free_chunk(fm, p);
; 4757 :             if (--fm->release_checks == 0)

	mov	eax, DWORD PTR __gm_+32
	sub	eax, 1
	mov	DWORD PTR __gm_+32, eax
	jne	SHORT $LN20@dlfree

; 4758 :               release_unused_segments(fm);

	push	OFFSET __gm_
	call	?release_unused_segments@@YAIPAUmalloc_state@@@Z ; release_unused_segments
	add	esp, 4
$LN20@dlfree:

; 4759 :           }

	jmp	SHORT $postaction$33102

; 4760 :           goto postaction;

	jmp	SHORT $postaction$33102
$erroraction$33175:

; 4761 :         }
; 4762 :       }
; 4763 :     erroraction:
; 4764 :       USAGE_ERROR_ACTION(fm, p);

	call	DWORD PTR __imp__abort
$postaction$33102:

; 4765 :     postaction:
; 4766 :       POSTACTION(fm);

	mov	ecx, DWORD PTR __gm_+444
	and	ecx, 2
	je	SHORT $LN126@dlfree
	xor	edx, edx
	mov	eax, OFFSET __gm_+448
	xchg	DWORD PTR [eax], edx
$LN126@dlfree:

; 4767 :     }
; 4768 :   }
; 4769 : #if !FOOTERS
; 4770 : #undef fm
; 4771 : #endif /* FOOTERS */
; 4772 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dlfree@@YAXPAX@Z ENDP					; dlfree
_TEXT	ENDS
EXTRN	__imp__VirtualFree@12:PROC
EXTRN	__imp__VirtualQuery@12:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_cptr$ = -32						; size = 4
_minfo$ = -28						; size = 28
_ptr$ = 8						; size = 4
_size$ = 12						; size = 4
?win32munmap@@YAHPAXI@Z PROC				; win32munmap

; 1666 : static FORCEINLINE int win32munmap(void* ptr, size_t size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1667 :   MEMORY_BASIC_INFORMATION minfo;
; 1668 :   char* cptr = (char*)ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _cptr$[ebp], eax
$LN6@win32munma:

; 1669 :   while (size) {

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN5@win32munma

; 1670 :     if (VirtualQuery(cptr, &minfo, sizeof(minfo)) == 0)

	push	28					; 0000001cH
	lea	ecx, DWORD PTR _minfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cptr$[ebp]
	push	edx
	call	DWORD PTR __imp__VirtualQuery@12
	test	eax, eax
	jne	SHORT $LN4@win32munma

; 1671 :       return -1;

	or	eax, -1
	jmp	SHORT $LN7@win32munma
$LN4@win32munma:

; 1672 :     if (minfo.BaseAddress != cptr || minfo.AllocationBase != cptr ||
; 1673 :         minfo.State != MEM_COMMIT || minfo.RegionSize > size)

	mov	eax, DWORD PTR _minfo$[ebp]
	cmp	eax, DWORD PTR _cptr$[ebp]
	jne	SHORT $LN2@win32munma
	mov	ecx, DWORD PTR _minfo$[ebp+4]
	cmp	ecx, DWORD PTR _cptr$[ebp]
	jne	SHORT $LN2@win32munma
	cmp	DWORD PTR _minfo$[ebp+16], 4096		; 00001000H
	jne	SHORT $LN2@win32munma
	mov	edx, DWORD PTR _minfo$[ebp+12]
	cmp	edx, DWORD PTR _size$[ebp]
	jbe	SHORT $LN3@win32munma
$LN2@win32munma:

; 1674 :       return -1;

	or	eax, -1
	jmp	SHORT $LN7@win32munma
$LN3@win32munma:

; 1675 :     if (VirtualFree(cptr, 0, MEM_RELEASE) == 0)

	push	32768					; 00008000H
	push	0
	mov	eax, DWORD PTR _cptr$[ebp]
	push	eax
	call	DWORD PTR __imp__VirtualFree@12
	test	eax, eax
	jne	SHORT $LN1@win32munma

; 1676 :       return -1;

	or	eax, -1
	jmp	SHORT $LN7@win32munma
$LN1@win32munma:

; 1677 :     cptr += minfo.RegionSize;

	mov	ecx, DWORD PTR _cptr$[ebp]
	add	ecx, DWORD PTR _minfo$[ebp+12]
	mov	DWORD PTR _cptr$[ebp], ecx

; 1678 :     size -= minfo.RegionSize;

	mov	edx, DWORD PTR _size$[ebp]
	sub	edx, DWORD PTR _minfo$[ebp+12]
	mov	DWORD PTR _size$[ebp], edx

; 1679 :   }

	jmp	SHORT $LN6@win32munma
$LN5@win32munma:

; 1680 :   return 0;

	xor	eax, eax
$LN7@win32munma:

; 1681 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?win32munmap@@YAHPAXI@Z ENDP				; win32munmap
; Function compile flags: /Odtp
tv266 = -120						; size = 4
tv240 = -116						; size = 4
tv129 = -112						; size = 4
tv83 = -108						; size = 4
_F$32272 = -104						; size = 4
_C$32264 = -100						; size = 4
_K$32254 = -96						; size = 4
_T$32253 = -92						; size = 4
_K$32244 = -88						; size = 4
_X$32239 = -84						; size = 4
_I$32238 = -80						; size = 4
_H$32237 = -76						; size = 4
_C0$32226 = -72						; size = 4
_C1$32227 = -68						; size = 4
_H$32215 = -64						; size = 4
_CP$32207 = -60						; size = 4
_RP$32204 = -56						; size = 4
_F$32200 = -52						; size = 4
_R$32198 = -48						; size = 4
_XP$32197 = -44						; size = 4
_tp$32193 = -40						; size = 4
_psize$32150 = -36					; size = 4
_p$32129 = -32						; size = 4
_size$32125 = -28					; size = 4
_next$32126 = -24					; size = 4
_base$32124 = -20					; size = 4
_pred$ = -16						; size = 4
_nsegs$ = -12						; size = 4
_released$ = -8						; size = 4
_sp$ = -4						; size = 4
_m$ = 8							; size = 4
?release_unused_segments@@YAIPAUmalloc_state@@@Z PROC	; release_unused_segments

; 4231 : static size_t release_unused_segments(mstate m) {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H

; 4232 :   size_t released = 0;

	mov	DWORD PTR _released$[ebp], 0

; 4233 :   int nsegs = 0;

	mov	DWORD PTR _nsegs$[ebp], 0

; 4234 :   msegmentptr pred = &m->seg;

	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 452				; 000001c4H
	mov	DWORD PTR _pred$[ebp], eax

; 4235 :   msegmentptr sp = pred->next;

	mov	ecx, DWORD PTR _pred$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _sp$[ebp], edx
$LN53@release_un:

; 4236 :   while (sp != 0) {

	cmp	DWORD PTR _sp$[ebp], 0
	je	$LN52@release_un

; 4237 :     char* base = sp->base;

	mov	eax, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _base$32124[ebp], ecx

; 4238 :     size_t size = sp->size;

	mov	edx, DWORD PTR _sp$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _size$32125[ebp], eax

; 4239 :     msegmentptr next = sp->next;

	mov	ecx, DWORD PTR _sp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _next$32126[ebp], edx

; 4240 :     ++nsegs;

	mov	eax, DWORD PTR _nsegs$[ebp]
	add	eax, 1
	mov	DWORD PTR _nsegs$[ebp], eax

; 4241 :     if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {

	mov	ecx, DWORD PTR _sp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 1
	je	$LN51@release_un
	mov	eax, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 8
	jne	$LN51@release_un

; 4242 :       mchunkptr p = align_as_chunk(base);

	mov	edx, DWORD PTR _base$32124[ebp]
	add	edx, 8
	and	edx, 7
	jne	SHORT $LN56@release_un
	mov	DWORD PTR tv83[ebp], 0
	jmp	SHORT $LN57@release_un
$LN56@release_un:
	mov	eax, DWORD PTR _base$32124[ebp]
	add	eax, 8
	and	eax, 7
	mov	ecx, 8
	sub	ecx, eax
	and	ecx, 7
	mov	DWORD PTR tv83[ebp], ecx
$LN57@release_un:
	mov	edx, DWORD PTR _base$32124[ebp]
	add	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _p$32129[ebp], edx

; 4243 :       size_t psize = chunksize(p);

	mov	eax, DWORD PTR _p$32129[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	mov	DWORD PTR _psize$32150[ebp], ecx

; 4244 :       /* Can unmap if first chunk holds entire segment and not pinned */
; 4245 :       if (!is_inuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {

	mov	edx, DWORD PTR _p$32129[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 3
	cmp	eax, 1
	jne	$LN51@release_un
	mov	ecx, 7
	and	ecx, 8
	jne	SHORT $LN58@release_un
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN59@release_un
$LN58@release_un:
	mov	edx, 7
	and	edx, 8
	mov	eax, 8
	sub	eax, edx
	and	eax, 7
	mov	DWORD PTR tv129[ebp], eax
$LN59@release_un:
	mov	ecx, DWORD PTR _p$32129[ebp]
	add	ecx, DWORD PTR _psize$32150[ebp]
	mov	edx, DWORD PTR _base$32124[ebp]
	add	edx, DWORD PTR _size$32125[ebp]
	mov	eax, DWORD PTR tv129[ebp]
	add	eax, 40					; 00000028H
	sub	edx, eax
	cmp	ecx, edx
	jb	$LN51@release_un

; 4246 :         tchunkptr tp = (tchunkptr)p;

	mov	ecx, DWORD PTR _p$32129[ebp]
	mov	DWORD PTR _tp$32193[ebp], ecx

; 4247 :         assert(segment_holds(sp, (char*)sp));
; 4248 :         if (p == m->dv) {

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _p$32129[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jne	SHORT $LN49@release_un

; 4249 :           m->dv = 0;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 4250 :           m->dvsize = 0;

	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+8], 0

; 4251 :         }
; 4252 :         else {

	jmp	$LN48@release_un
$LN49@release_un:

; 4253 :           unlink_large_chunk(m, tp);

	mov	eax, DWORD PTR _tp$32193[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _XP$32197[ebp], ecx
	mov	edx, DWORD PTR _tp$32193[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _tp$32193[ebp]
	je	SHORT $LN47@release_un
	mov	ecx, DWORD PTR _tp$32193[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _F$32200[ebp], edx
	mov	eax, DWORD PTR _tp$32193[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _R$32198[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN46@release_un
	mov	eax, DWORD PTR _F$32200[ebp]
	mov	ecx, DWORD PTR _R$32198[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _R$32198[ebp]
	mov	eax, DWORD PTR _F$32200[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN45@release_un
$LN46@release_un:
	call	DWORD PTR __imp__abort
$LN45@release_un:
	jmp	SHORT $LN44@release_un
$LN47@release_un:
	mov	ecx, DWORD PTR _tp$32193[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _RP$32204[ebp], ecx
	mov	edx, DWORD PTR _RP$32204[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _R$32198[ebp], eax
	cmp	DWORD PTR _R$32198[ebp], 0
	jne	SHORT $LN41@release_un
	mov	ecx, DWORD PTR _tp$32193[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _RP$32204[ebp], ecx
	mov	edx, DWORD PTR _RP$32204[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _R$32198[ebp], eax
	cmp	DWORD PTR _R$32198[ebp], 0
	je	SHORT $LN44@release_un
$LN41@release_un:
	mov	ecx, DWORD PTR _R$32198[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _CP$32207[ebp], ecx
	mov	edx, DWORD PTR _CP$32207[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN39@release_un
	mov	eax, DWORD PTR _R$32198[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _CP$32207[ebp], eax
	mov	ecx, DWORD PTR _CP$32207[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN40@release_un
$LN39@release_un:
	mov	edx, DWORD PTR _CP$32207[ebp]
	mov	DWORD PTR _RP$32204[ebp], edx
	mov	eax, DWORD PTR _RP$32204[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _R$32198[ebp], ecx
	jmp	SHORT $LN41@release_un
$LN40@release_un:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN38@release_un
	mov	eax, DWORD PTR _RP$32204[ebp]
	mov	DWORD PTR [eax], 0
	jmp	SHORT $LN44@release_un
$LN38@release_un:
	call	DWORD PTR __imp__abort
$LN44@release_un:
	cmp	DWORD PTR _XP$32197[ebp], 0
	je	$LN48@release_un
	mov	ecx, DWORD PTR _tp$32193[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _m$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+304]
	mov	DWORD PTR _H$32215[ebp], ecx
	mov	edx, DWORD PTR _H$32215[ebp]
	mov	eax, DWORD PTR _tp$32193[ebp]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN35@release_un
	mov	ecx, DWORD PTR _H$32215[ebp]
	mov	edx, DWORD PTR _R$32198[ebp]
	mov	DWORD PTR [ecx], edx
	cmp	DWORD PTR _R$32198[ebp], 0
	jne	SHORT $LN34@release_un
	mov	eax, DWORD PTR _tp$32193[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+28]
	shl	edx, cl
	not	edx
	mov	eax, DWORD PTR _m$[ebp]
	and	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN34@release_un:
	jmp	SHORT $LN33@release_un
$LN35@release_un:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN32@release_un
	mov	eax, DWORD PTR _XP$32197[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _tp$32193[ebp]
	jne	SHORT $LN31@release_un
	mov	edx, DWORD PTR _XP$32197[ebp]
	mov	eax, DWORD PTR _R$32198[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	SHORT $LN30@release_un
$LN31@release_un:
	mov	ecx, DWORD PTR _XP$32197[ebp]
	mov	edx, DWORD PTR _R$32198[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN30@release_un:
	jmp	SHORT $LN33@release_un
$LN32@release_un:
	call	DWORD PTR __imp__abort
$LN33@release_un:
	cmp	DWORD PTR _R$32198[ebp], 0
	je	SHORT $LN48@release_un
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN27@release_un
	mov	ecx, DWORD PTR _R$32198[ebp]
	mov	edx, DWORD PTR _XP$32197[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _tp$32193[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _C0$32226[ebp], ecx
	cmp	DWORD PTR _C0$32226[ebp], 0
	je	SHORT $LN26@release_un
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN25@release_un
	mov	eax, DWORD PTR _R$32198[ebp]
	mov	ecx, DWORD PTR _C0$32226[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _C0$32226[ebp]
	mov	eax, DWORD PTR _R$32198[ebp]
	mov	DWORD PTR [edx+24], eax
	jmp	SHORT $LN26@release_un
$LN25@release_un:
	call	DWORD PTR __imp__abort
$LN26@release_un:
	mov	ecx, DWORD PTR _tp$32193[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _C1$32227[ebp], edx
	cmp	DWORD PTR _C1$32227[ebp], 0
	je	SHORT $LN23@release_un
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN22@release_un
	mov	ecx, DWORD PTR _R$32198[ebp]
	mov	edx, DWORD PTR _C1$32227[ebp]
	mov	DWORD PTR [ecx+20], edx
	mov	eax, DWORD PTR _C1$32227[ebp]
	mov	ecx, DWORD PTR _R$32198[ebp]
	mov	DWORD PTR [eax+24], ecx
	jmp	SHORT $LN23@release_un
$LN22@release_un:
	call	DWORD PTR __imp__abort
$LN23@release_un:
	jmp	SHORT $LN48@release_un
$LN27@release_un:
	call	DWORD PTR __imp__abort
$LN48@release_un:

; 4254 :         }
; 4255 :         if (CALL_MUNMAP(base, size) == 0) {

	mov	edx, DWORD PTR _size$32125[ebp]
	push	edx
	mov	eax, DWORD PTR _base$32124[ebp]
	push	eax
	call	?win32munmap@@YAHPAXI@Z			; win32munmap
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@release_un

; 4256 :           released += size;

	mov	ecx, DWORD PTR _released$[ebp]
	add	ecx, DWORD PTR _size$32125[ebp]
	mov	DWORD PTR _released$[ebp], ecx

; 4257 :           m->footprint -= size;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+432]
	sub	eax, DWORD PTR _size$32125[ebp]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+432], eax

; 4258 :           /* unlink obsoleted record */
; 4259 :           sp = pred;

	mov	edx, DWORD PTR _pred$[ebp]
	mov	DWORD PTR _sp$[ebp], edx

; 4260 :           sp->next = next;

	mov	eax, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR _next$32126[ebp]
	mov	DWORD PTR [eax+8], ecx

; 4261 :         }
; 4262 :         else { /* back out if cannot unmap */

	jmp	$LN51@release_un
$LN19@release_un:

; 4263 :           insert_large_chunk(m, tp, psize);

	mov	edx, DWORD PTR _psize$32150[ebp]
	shr	edx, 8
	mov	DWORD PTR _X$32239[ebp], edx
	cmp	DWORD PTR _X$32239[ebp], 0
	jne	SHORT $LN17@release_un
	mov	DWORD PTR _I$32238[ebp], 0
	jmp	SHORT $LN16@release_un
$LN17@release_un:
	cmp	DWORD PTR _X$32239[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN15@release_un
	mov	DWORD PTR _I$32238[ebp], 31		; 0000001fH
	jmp	SHORT $LN16@release_un
$LN15@release_un:
	mov	eax, DWORD PTR _X$32239[ebp]
	bsr	ecx, eax
	mov	DWORD PTR _K$32244[ebp], ecx
	mov	ecx, DWORD PTR _K$32244[ebp]
	add	ecx, 7
	mov	edx, DWORD PTR _psize$32150[ebp]
	shr	edx, cl
	and	edx, 1
	mov	eax, DWORD PTR _K$32244[ebp]
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _I$32238[ebp], ecx
$LN16@release_un:
	mov	edx, DWORD PTR _I$32238[ebp]
	mov	eax, DWORD PTR _m$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+304]
	mov	DWORD PTR _H$32237[ebp], ecx
	mov	edx, DWORD PTR _tp$32193[ebp]
	mov	eax, DWORD PTR _I$32238[ebp]
	mov	DWORD PTR [edx+28], eax
	mov	ecx, DWORD PTR _tp$32193[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _tp$32193[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, 1
	mov	ecx, DWORD PTR _I$32238[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _m$[ebp]
	and	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN13@release_un
	mov	edx, 1
	mov	ecx, DWORD PTR _I$32238[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _m$[ebp]
	or	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _H$32237[ebp]
	mov	eax, DWORD PTR _tp$32193[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _tp$32193[ebp]
	mov	edx, DWORD PTR _H$32237[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _tp$32193[ebp]
	mov	ecx, DWORD PTR _tp$32193[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _tp$32193[ebp]
	mov	eax, DWORD PTR _tp$32193[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	$LN51@release_un
$LN13@release_un:
	mov	ecx, DWORD PTR _H$32237[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _T$32253[ebp], edx
	cmp	DWORD PTR _I$32238[ebp], 31		; 0000001fH
	jne	SHORT $LN60@release_un
	mov	DWORD PTR tv240[ebp], 0
	jmp	SHORT $LN61@release_un
$LN60@release_un:
	mov	eax, DWORD PTR _I$32238[ebp]
	shr	eax, 1
	add	eax, 6
	mov	ecx, 31					; 0000001fH
	sub	ecx, eax
	mov	DWORD PTR tv240[ebp], ecx
$LN61@release_un:
	mov	edx, DWORD PTR _psize$32150[ebp]
	mov	ecx, DWORD PTR tv240[ebp]
	shl	edx, cl
	mov	DWORD PTR _K$32254[ebp], edx
$LN11@release_un:
	mov	eax, DWORD PTR _T$32253[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	cmp	ecx, DWORD PTR _psize$32150[ebp]
	je	SHORT $LN9@release_un
	mov	edx, DWORD PTR _K$32254[ebp]
	shr	edx, 31					; 0000001fH
	and	edx, 1
	mov	eax, DWORD PTR _T$32253[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+16]
	mov	DWORD PTR _C$32264[ebp], ecx
	mov	edx, DWORD PTR _K$32254[ebp]
	shl	edx, 1
	mov	DWORD PTR _K$32254[ebp], edx
	mov	eax, DWORD PTR _C$32264[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@release_un
	mov	ecx, DWORD PTR _C$32264[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _T$32253[ebp], edx
	jmp	SHORT $LN7@release_un
$LN8@release_un:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN6@release_un
	mov	ecx, DWORD PTR _C$32264[ebp]
	mov	edx, DWORD PTR _tp$32193[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _tp$32193[ebp]
	mov	ecx, DWORD PTR _T$32253[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _tp$32193[ebp]
	mov	eax, DWORD PTR _tp$32193[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _tp$32193[ebp]
	mov	edx, DWORD PTR _tp$32193[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN51@release_un
	jmp	SHORT $LN7@release_un
$LN6@release_un:
	call	DWORD PTR __imp__abort
	jmp	SHORT $LN51@release_un
$LN7@release_un:
	jmp	SHORT $LN4@release_un
$LN9@release_un:
	mov	eax, DWORD PTR _T$32253[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$32272[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@release_un
	mov	eax, DWORD PTR _F$32272[ebp]
	mov	ecx, DWORD PTR _tp$32193[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _T$32253[ebp]
	mov	eax, DWORD PTR _tp$32193[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _tp$32193[ebp]
	mov	edx, DWORD PTR _F$32272[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _tp$32193[ebp]
	mov	ecx, DWORD PTR _T$32253[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _tp$32193[ebp]
	mov	DWORD PTR [edx+24], 0
	jmp	SHORT $LN51@release_un
	jmp	SHORT $LN4@release_un
$LN3@release_un:
	call	DWORD PTR __imp__abort
	jmp	SHORT $LN51@release_un
$LN4@release_un:
	jmp	$LN11@release_un
$LN51@release_un:

; 4264 :         }
; 4265 :       }
; 4266 :     }
; 4267 :     if (NO_SEGMENT_TRAVERSAL) /* scan only first segment */

	xor	eax, eax
	je	SHORT $LN1@release_un

; 4268 :       break;

	jmp	SHORT $LN52@release_un
$LN1@release_un:

; 4269 :     pred = sp;

	mov	ecx, DWORD PTR _sp$[ebp]
	mov	DWORD PTR _pred$[ebp], ecx

; 4270 :     sp = next;

	mov	edx, DWORD PTR _next$32126[ebp]
	mov	DWORD PTR _sp$[ebp], edx

; 4271 :   }

	jmp	$LN53@release_un
$LN52@release_un:

; 4272 :   /* Reset check counter */
; 4273 :   m->release_checks = (((size_t) nsegs > (size_t) MAX_RELEASE_CHECK_RATE)?
; 4274 :                        (size_t) nsegs : (size_t) MAX_RELEASE_CHECK_RATE);

	cmp	DWORD PTR _nsegs$[ebp], 4095		; 00000fffH
	jbe	SHORT $LN62@release_un
	mov	eax, DWORD PTR _nsegs$[ebp]
	mov	DWORD PTR tv266[ebp], eax
	jmp	SHORT $LN63@release_un
$LN62@release_un:
	mov	DWORD PTR tv266[ebp], 4095		; 00000fffH
$LN63@release_un:
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR tv266[ebp]
	mov	DWORD PTR [ecx+32], edx

; 4275 :   return released;

	mov	eax, DWORD PTR _released$[ebp]

; 4276 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?release_unused_segments@@YAIPAUmalloc_state@@@Z ENDP	; release_unused_segments
; Function compile flags: /Odtp
tv154 = -40						; size = 4
tv75 = -36						; size = 4
_new_br$32364 = -32					; size = 4
_rel_br$32360 = -28					; size = 4
_old_br$32355 = -24					; size = 4
_newsize$32339 = -20					; size = 4
_unit$32329 = -16					; size = 4
_extra$32330 = -12					; size = 4
_sp$32333 = -8						; size = 4
_released$ = -4						; size = 4
_m$ = 8							; size = 4
_pad$ = 12						; size = 4
?sys_trim@@YAHPAUmalloc_state@@I@Z PROC			; sys_trim

; 4278 : static int sys_trim(mstate m, size_t pad) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 4279 :   size_t released = 0;

	mov	DWORD PTR _released$[ebp], 0

; 4280 :   ensure_initialization();

	cmp	DWORD PTR _mparams, 0
	jne	SHORT $LN18@sys_trim
	call	?init_mparams@@YAHXZ			; init_mparams
$LN18@sys_trim:

; 4281 :   if (pad < MAX_REQUEST && is_initialized(m)) {

	cmp	DWORD PTR _pad$[ebp], -64		; ffffffc0H
	jae	$LN15@sys_trim
	mov	eax, DWORD PTR _m$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	$LN15@sys_trim

; 4282 :     pad += TOP_FOOT_SIZE; /* ensure enough room for segment overhead */

	mov	ecx, 7
	and	ecx, 8
	jne	SHORT $LN19@sys_trim
	mov	DWORD PTR tv75[ebp], 0
	jmp	SHORT $LN20@sys_trim
$LN19@sys_trim:
	mov	edx, 7
	and	edx, 8
	mov	eax, 8
	sub	eax, edx
	and	eax, 7
	mov	DWORD PTR tv75[ebp], eax
$LN20@sys_trim:
	mov	ecx, DWORD PTR tv75[ebp]
	mov	edx, DWORD PTR _pad$[ebp]
	lea	eax, DWORD PTR [edx+ecx+40]
	mov	DWORD PTR _pad$[ebp], eax

; 4283 : 
; 4284 :     if (m->topsize > pad) {

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _pad$[ebp]
	jbe	$LN14@sys_trim

; 4285 :       /* Shrink top space in granularity-size units, keeping at least one */
; 4286 :       size_t unit = mparams.granularity;

	mov	eax, DWORD PTR _mparams+8
	mov	DWORD PTR _unit$32329[ebp], eax

; 4287 :       size_t extra = ((m->topsize - pad + (unit - SIZE_T_ONE)) / unit -
; 4288 :                       SIZE_T_ONE) * unit;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, DWORD PTR _pad$[ebp]
	mov	eax, DWORD PTR _unit$32329[ebp]
	lea	eax, DWORD PTR [edx+eax-1]
	xor	edx, edx
	div	DWORD PTR _unit$32329[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _unit$32329[ebp]
	mov	DWORD PTR _extra$32330[ebp], eax

; 4289 :       msegmentptr sp = segment_holding(m, (char*)m->top);

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	?segment_holding@@YAPAUmalloc_segment@@PAUmalloc_state@@PAD@Z ; segment_holding
	add	esp, 8
	mov	DWORD PTR _sp$32333[ebp], eax

; 4290 : 
; 4291 :       if (!is_extern_segment(sp)) {

	mov	ecx, DWORD PTR _sp$32333[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 8
	jne	$LN13@sys_trim

; 4292 :         if (is_mmapped_segment(sp)) {

	mov	eax, DWORD PTR _sp$32333[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 1
	je	SHORT $LN12@sys_trim

; 4293 :           if (HAVE_MMAP &&
; 4294 :               sp->size >= extra &&
; 4295 :               !has_segment_link(m, sp)) { /* can't shrink if pinned */

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN11@sys_trim
	mov	eax, DWORD PTR _sp$32333[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _extra$32330[ebp]
	jb	SHORT $LN11@sys_trim
	mov	edx, DWORD PTR _sp$32333[ebp]
	push	edx
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	?has_segment_link@@YAHPAUmalloc_state@@PAUmalloc_segment@@@Z ; has_segment_link
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@sys_trim

; 4296 :             size_t newsize = sp->size - extra;

	mov	ecx, DWORD PTR _sp$32333[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, DWORD PTR _extra$32330[ebp]
	mov	DWORD PTR _newsize$32339[ebp], edx

; 4297 :             (void)newsize; /* placate people compiling -Wunused-variable */
; 4298 :             /* Prefer mremap, fall back to munmap */
; 4299 :             if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
; 4300 :                 (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {

	xor	eax, eax
	jne	SHORT $LN9@sys_trim
	mov	ecx, DWORD PTR _extra$32330[ebp]
	push	ecx
	mov	edx, DWORD PTR _sp$32333[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _newsize$32339[ebp]
	push	eax
	call	?win32munmap@@YAHPAXI@Z			; win32munmap
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@sys_trim
$LN9@sys_trim:

; 4301 :               released = extra;

	mov	ecx, DWORD PTR _extra$32330[ebp]
	mov	DWORD PTR _released$[ebp], ecx
$LN11@sys_trim:

; 4302 :             }
; 4303 :           }
; 4304 :         }

	jmp	$LN13@sys_trim
$LN12@sys_trim:

; 4305 :         else if (HAVE_MORECORE) {

	xor	edx, edx
	je	$LN13@sys_trim

; 4306 :           if (extra >= HALF_MAX_SIZE_T) /* Avoid wrapping negative */

	cmp	DWORD PTR _extra$32330[ebp], 2147483647	; 7fffffffH
	jb	SHORT $LN6@sys_trim

; 4307 :             extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;

	mov	eax, -2147483648			; 80000000H
	sub	eax, DWORD PTR _unit$32329[ebp]
	mov	DWORD PTR _extra$32330[ebp], eax
$LN6@sys_trim:

; 4308 :           ACQUIRE_MALLOC_GLOBAL_LOCK();

	mov	ecx, 1
	mov	edx, OFFSET _malloc_global_mutex
	xchg	DWORD PTR [edx], ecx
	test	ecx, ecx
	je	SHORT $LN21@sys_trim
	push	OFFSET _malloc_global_mutex
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv154[ebp], eax
	jmp	SHORT $LN22@sys_trim
$LN21@sys_trim:
	mov	DWORD PTR tv154[ebp], 0
$LN22@sys_trim:

; 4309 :           {
; 4310 :             /* Make sure end of memory is where we last set it. */
; 4311 :             char* old_br = (char*)(CALL_MORECORE(0));

	mov	DWORD PTR _old_br$32355[ebp], -1

; 4312 :             if (old_br == sp->base + sp->size) {

	mov	eax, DWORD PTR _sp$32333[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _sp$32333[ebp]
	add	ecx, DWORD PTR [edx+4]
	cmp	DWORD PTR _old_br$32355[ebp], ecx
	jne	SHORT $LN5@sys_trim

; 4313 :               char* rel_br = (char*)(CALL_MORECORE(-extra));

	mov	DWORD PTR _rel_br$32360[ebp], -1

; 4314 :               char* new_br = (char*)(CALL_MORECORE(0));

	mov	DWORD PTR _new_br$32364[ebp], -1

; 4315 :               if (rel_br != CMFAIL && new_br < old_br)

	cmp	DWORD PTR _rel_br$32360[ebp], -1
	je	SHORT $LN5@sys_trim
	mov	eax, DWORD PTR _new_br$32364[ebp]
	cmp	eax, DWORD PTR _old_br$32355[ebp]
	jae	SHORT $LN5@sys_trim

; 4316 :                 released = old_br - new_br;

	mov	ecx, DWORD PTR _old_br$32355[ebp]
	sub	ecx, DWORD PTR _new_br$32364[ebp]
	mov	DWORD PTR _released$[ebp], ecx
$LN5@sys_trim:

; 4317 :             }
; 4318 :           }
; 4319 :           RELEASE_MALLOC_GLOBAL_LOCK();

	xor	edx, edx
	mov	eax, OFFSET _malloc_global_mutex
	xchg	DWORD PTR [eax], edx
$LN13@sys_trim:

; 4320 :         }
; 4321 :       }
; 4322 : 
; 4323 :       if (released != 0) {

	cmp	DWORD PTR _released$[ebp], 0
	je	SHORT $LN14@sys_trim

; 4324 :         sp->size -= released;

	mov	ecx, DWORD PTR _sp$32333[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, DWORD PTR _released$[ebp]
	mov	eax, DWORD PTR _sp$32333[ebp]
	mov	DWORD PTR [eax+4], edx

; 4325 :         m->footprint -= released;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+432]
	sub	edx, DWORD PTR _released$[ebp]
	mov	eax, DWORD PTR _m$[ebp]
	mov	DWORD PTR [eax+432], edx

; 4326 :         init_top(m, m->top, m->topsize - released);

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, DWORD PTR _released$[ebp]
	push	edx
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _m$[ebp]
	push	edx
	call	?init_top@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z ; init_top
	add	esp, 12					; 0000000cH
$LN14@sys_trim:

; 4327 :         check_top_chunk(m, m->top);
; 4328 :       }
; 4329 :     }
; 4330 : 
; 4331 :     /* Unmap any unused mmapped segments */
; 4332 :     if (HAVE_MMAP)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@sys_trim

; 4333 :       released += release_unused_segments(m);

	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	?release_unused_segments@@YAIPAUmalloc_state@@@Z ; release_unused_segments
	add	esp, 4
	add	eax, DWORD PTR _released$[ebp]
	mov	DWORD PTR _released$[ebp], eax
$LN2@sys_trim:

; 4334 : 
; 4335 :     /* On failure, disable autotrim to avoid repeated failed future calls */
; 4336 :     if (released == 0 && m->topsize > m->trim_check)

	cmp	DWORD PTR _released$[ebp], 0
	jne	SHORT $LN15@sys_trim
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+28]
	jbe	SHORT $LN15@sys_trim

; 4337 :       m->trim_check = MAX_SIZE_T;

	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+28], -1
$LN15@sys_trim:

; 4338 :   }
; 4339 : 
; 4340 :   return (released != 0)? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR _released$[ebp], 0
	setne	al

; 4341 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?sys_trim@@YAHPAUmalloc_state@@I@Z ENDP			; sys_trim
; Function compile flags: /Odtp
_sp$ = -4						; size = 4
_m$ = 8							; size = 4
_ss$ = 12						; size = 4
?has_segment_link@@YAHPAUmalloc_state@@PAUmalloc_segment@@@Z PROC ; has_segment_link

; 2695 : static int has_segment_link(mstate m, msegmentptr ss) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2696 :   msegmentptr sp = &m->seg;

	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 452				; 000001c4H
	mov	DWORD PTR _sp$[ebp], eax
$LN4@has_segmen:

; 2697 :   for (;;) {
; 2698 :     if ((char*)sp >= ss->base && (char*)sp < ss->base + ss->size)

	mov	ecx, DWORD PTR _ss$[ebp]
	mov	edx, DWORD PTR _sp$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jb	SHORT $LN2@has_segmen
	mov	eax, DWORD PTR _ss$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ss$[ebp]
	add	ecx, DWORD PTR [edx+4]
	cmp	DWORD PTR _sp$[ebp], ecx
	jae	SHORT $LN2@has_segmen

; 2699 :       return 1;

	mov	eax, 1
	jmp	SHORT $LN5@has_segmen
$LN2@has_segmen:

; 2700 :     if ((sp = sp->next) == 0)

	mov	eax, DWORD PTR _sp$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _sp$[ebp], ecx
	cmp	DWORD PTR _sp$[ebp], 0
	jne	SHORT $LN1@has_segmen

; 2701 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN5@has_segmen
$LN1@has_segmen:

; 2702 :   }

	jmp	SHORT $LN4@has_segmen
$LN5@has_segmen:

; 2703 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?has_segment_link@@YAHPAUmalloc_state@@PAUmalloc_segment@@@Z ENDP ; has_segment_link
_TEXT	ENDS
PUBLIC	?dlcalloc@@YAPAXII@Z				; dlcalloc
EXTRN	_memset:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_mem$ = -8						; size = 4
_req$ = -4						; size = 4
_n_elements$ = 8					; size = 4
_elem_size$ = 12					; size = 4
?dlcalloc@@YAPAXII@Z PROC				; dlcalloc

; 4774 : void* dlcalloc(size_t n_elements, size_t elem_size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4775 :   void* mem;
; 4776 :   size_t req = 0;

	mov	DWORD PTR _req$[ebp], 0

; 4777 :   if (n_elements != 0) {

	cmp	DWORD PTR _n_elements$[ebp], 0
	je	SHORT $LN3@dlcalloc

; 4778 :     req = n_elements * elem_size;

	mov	eax, DWORD PTR _n_elements$[ebp]
	imul	eax, DWORD PTR _elem_size$[ebp]
	mov	DWORD PTR _req$[ebp], eax

; 4779 :     if (((n_elements | elem_size) & ~(size_t)0xffff) &&
; 4780 :         (req / n_elements != elem_size))

	mov	ecx, DWORD PTR _n_elements$[ebp]
	or	ecx, DWORD PTR _elem_size$[ebp]
	and	ecx, -65536				; ffff0000H
	je	SHORT $LN3@dlcalloc
	mov	eax, DWORD PTR _req$[ebp]
	xor	edx, edx
	div	DWORD PTR _n_elements$[ebp]
	cmp	eax, DWORD PTR _elem_size$[ebp]
	je	SHORT $LN3@dlcalloc

; 4781 :       req = MAX_SIZE_T; /* force downstream failure on overflow */

	mov	DWORD PTR _req$[ebp], -1
$LN3@dlcalloc:

; 4782 :   }
; 4783 :   mem = dlmalloc(req);

	mov	edx, DWORD PTR _req$[ebp]
	push	edx
	call	?dlmalloc@@YAPAXI@Z			; dlmalloc
	add	esp, 4
	mov	DWORD PTR _mem$[ebp], eax

; 4784 :   if (mem != 0 && calloc_must_clear(mem2chunk(mem)))

	cmp	DWORD PTR _mem$[ebp], 0
	je	SHORT $LN1@dlcalloc
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	and	ecx, 3
	je	SHORT $LN1@dlcalloc

; 4785 :     memset(mem, 0, req);

	mov	edx, DWORD PTR _req$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _mem$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@dlcalloc:

; 4786 :   return mem;

	mov	eax, DWORD PTR _mem$[ebp]

; 4787 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dlcalloc@@YAPAXII@Z ENDP				; dlcalloc
_TEXT	ENDS
PUBLIC	?mspace_free@@YAXPAX0@Z				; mspace_free
PUBLIC	?mspace_malloc@@YAPAXPAXI@Z			; mspace_malloc
PUBLIC	?dlrealloc@@YAPAXPAXI@Z				; dlrealloc
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv150 = -44						; size = 4
tv139 = -40						; size = 4
tv86 = -36						; size = 4
tv84 = -32						; size = 4
tv72 = -28						; size = 4
_oc$33959 = -24						; size = 4
_newp$33949 = -20					; size = 4
_nb$33917 = -16						; size = 4
_m$33945 = -12						; size = 4
_oldp$33941 = -8					; size = 4
_mem$ = -4						; size = 4
_oldmem$ = 8						; size = 4
_bytes$ = 12						; size = 4
?dlrealloc@@YAPAXPAXI@Z PROC				; dlrealloc

; 5168 : void* dlrealloc(void* oldmem, size_t bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 5169 :   void* mem = 0;

	mov	DWORD PTR _mem$[ebp], 0

; 5170 :   if (oldmem == 0) {

	cmp	DWORD PTR _oldmem$[ebp], 0
	jne	SHORT $LN11@dlrealloc

; 5171 :     mem = dlmalloc(bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	call	?dlmalloc@@YAPAXI@Z			; dlmalloc
	add	esp, 4
	mov	DWORD PTR _mem$[ebp], eax
	jmp	$LN10@dlrealloc
$LN11@dlrealloc:

; 5172 :   }
; 5173 :   else if (bytes >= MAX_REQUEST) {

	cmp	DWORD PTR _bytes$[ebp], -64		; ffffffc0H
	jb	SHORT $LN9@dlrealloc

; 5174 :     MALLOC_FAILURE_ACTION;
; 5175 :   }
; 5176 : #ifdef REALLOC_ZERO_BYTES_FREES
; 5177 :   else if (bytes == 0) {
; 5178 :     dlfree(oldmem);
; 5179 :   }
; 5180 : #endif /* REALLOC_ZERO_BYTES_FREES */
; 5181 :   else {

	jmp	$LN10@dlrealloc
$LN9@dlrealloc:

; 5182 :     size_t nb = request2size(bytes);

	cmp	DWORD PTR _bytes$[ebp], 11		; 0000000bH
	jae	SHORT $LN14@dlrealloc
	mov	DWORD PTR tv72[ebp], 16			; 00000010H
	jmp	SHORT $LN15@dlrealloc
$LN14@dlrealloc:
	mov	ecx, DWORD PTR _bytes$[ebp]
	add	ecx, 11					; 0000000bH
	and	ecx, -8					; fffffff8H
	mov	DWORD PTR tv72[ebp], ecx
$LN15@dlrealloc:
	mov	edx, DWORD PTR tv72[ebp]
	mov	DWORD PTR _nb$33917[ebp], edx

; 5183 :     mchunkptr oldp = mem2chunk(oldmem);

	mov	eax, DWORD PTR _oldmem$[ebp]
	sub	eax, 8
	mov	DWORD PTR _oldp$33941[ebp], eax

; 5184 : #if ! FOOTERS
; 5185 :     mstate m = gm;

	mov	DWORD PTR _m$33945[ebp], OFFSET __gm_

; 5186 : #else /* FOOTERS */
; 5187 :     mstate m = get_mstate_for(oldp);
; 5188 :     if (!ok_magic(m)) {
; 5189 :       USAGE_ERROR_ACTION(m, oldmem);
; 5190 :       return 0;
; 5191 :     }
; 5192 : #endif /* FOOTERS */
; 5193 :     if (!PREACTION(m)) {

	mov	ecx, DWORD PTR _m$33945[ebp]
	mov	edx, DWORD PTR [ecx+444]
	and	edx, 2
	je	SHORT $LN18@dlrealloc
	mov	eax, 1
	mov	ecx, DWORD PTR _m$33945[ebp]
	add	ecx, 448				; 000001c0H
	xchg	DWORD PTR [ecx], eax
	test	eax, eax
	je	SHORT $LN16@dlrealloc
	mov	edx, DWORD PTR _m$33945[ebp]
	add	edx, 448				; 000001c0H
	push	edx
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN17@dlrealloc
$LN16@dlrealloc:
	mov	DWORD PTR tv84[ebp], 0
$LN17@dlrealloc:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN19@dlrealloc
$LN18@dlrealloc:
	mov	DWORD PTR tv86[ebp], 0
$LN19@dlrealloc:
	cmp	DWORD PTR tv86[ebp], 0
	jne	$LN10@dlrealloc

; 5194 :       mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);

	push	1
	mov	ecx, DWORD PTR _nb$33917[ebp]
	push	ecx
	mov	edx, DWORD PTR _oldp$33941[ebp]
	push	edx
	mov	eax, DWORD PTR _m$33945[ebp]
	push	eax
	call	?try_realloc_chunk@@YAPAUmalloc_chunk@@PAUmalloc_state@@PAU1@IH@Z ; try_realloc_chunk
	add	esp, 16					; 00000010H
	mov	DWORD PTR _newp$33949[ebp], eax

; 5195 :       POSTACTION(m);

	mov	ecx, DWORD PTR _m$33945[ebp]
	mov	edx, DWORD PTR [ecx+444]
	and	edx, 2
	je	SHORT $LN6@dlrealloc
	xor	eax, eax
	mov	ecx, DWORD PTR _m$33945[ebp]
	add	ecx, 448				; 000001c0H
	xchg	DWORD PTR [ecx], eax
$LN6@dlrealloc:

; 5196 :       if (newp != 0) {

	cmp	DWORD PTR _newp$33949[ebp], 0
	je	SHORT $LN5@dlrealloc

; 5197 :         check_inuse_chunk(m, newp);
; 5198 :         mem = chunk2mem(newp);

	mov	edx, DWORD PTR _newp$33949[ebp]
	add	edx, 8
	mov	DWORD PTR _mem$[ebp], edx

; 5199 :       }
; 5200 :       else {

	jmp	$LN10@dlrealloc
$LN5@dlrealloc:

; 5201 :         mem = internal_malloc(m, bytes);

	cmp	DWORD PTR _m$33945[ebp], OFFSET __gm_
	jne	SHORT $LN20@dlrealloc
	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	call	?dlmalloc@@YAPAXI@Z			; dlmalloc
	add	esp, 4
	mov	DWORD PTR tv139[ebp], eax
	jmp	SHORT $LN21@dlrealloc
$LN20@dlrealloc:
	mov	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _m$33945[ebp]
	push	edx
	call	?mspace_malloc@@YAPAXPAXI@Z		; mspace_malloc
	add	esp, 8
	mov	DWORD PTR tv139[ebp], eax
$LN21@dlrealloc:
	mov	eax, DWORD PTR tv139[ebp]
	mov	DWORD PTR _mem$[ebp], eax

; 5202 :         if (mem != 0) {

	cmp	DWORD PTR _mem$[ebp], 0
	je	SHORT $LN10@dlrealloc

; 5203 :           size_t oc = chunksize(oldp) - overhead_for(oldp);

	mov	ecx, DWORD PTR _oldp$33941[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -8					; fffffff8H
	mov	eax, DWORD PTR _oldp$33941[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 3
	neg	ecx
	sbb	ecx, ecx
	and	ecx, -4					; fffffffcH
	add	ecx, 8
	sub	edx, ecx
	mov	DWORD PTR _oc$33959[ebp], edx

; 5204 :           memcpy(mem, oldmem, (oc < bytes)? oc : bytes);

	mov	edx, DWORD PTR _oc$33959[ebp]
	cmp	edx, DWORD PTR _bytes$[ebp]
	jae	SHORT $LN22@dlrealloc
	mov	eax, DWORD PTR _oc$33959[ebp]
	mov	DWORD PTR tv150[ebp], eax
	jmp	SHORT $LN23@dlrealloc
$LN22@dlrealloc:
	mov	ecx, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR tv150[ebp], ecx
$LN23@dlrealloc:
	mov	edx, DWORD PTR tv150[ebp]
	push	edx
	mov	eax, DWORD PTR _oldmem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5205 :           internal_free(m, oldmem);

	cmp	DWORD PTR _m$33945[ebp], OFFSET __gm_
	jne	SHORT $LN2@dlrealloc
	mov	edx, DWORD PTR _oldmem$[ebp]
	push	edx
	call	?dlfree@@YAXPAX@Z			; dlfree
	add	esp, 4
	jmp	SHORT $LN10@dlrealloc
$LN2@dlrealloc:
	mov	eax, DWORD PTR _oldmem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _m$33945[ebp]
	push	ecx
	call	?mspace_free@@YAXPAX0@Z			; mspace_free
	add	esp, 8
$LN10@dlrealloc:

; 5206 :         }
; 5207 :       }
; 5208 :     }
; 5209 :   }
; 5210 :   return mem;

	mov	eax, DWORD PTR _mem$[ebp]

; 5211 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dlrealloc@@YAPAXPAXI@Z ENDP				; dlrealloc
; Function compile flags: /Odtp
_r$33504 = -116					; size = 4
_newsize$33497 = -112					; size = 4
_C0$33480 = -108					; size = 4
_C1$33481 = -104					; size = 4
_H$33469 = -100						; size = 4
_CP$33461 = -96						; size = 4
_RP$33458 = -92						; size = 4
_F$33454 = -88						; size = 4
_R$33452 = -84						; size = 4
_XP$33451 = -80						; size = 4
_TP$33449 = -76						; size = 4
_I$33439 = -72						; size = 4
_F$33437 = -68						; size = 4
_B$33438 = -64						; size = 4
_rsize$33435 = -60					; size = 4
_nextsize$33430 = -56					; size = 4
_newsize$33421 = -52					; size = 4
_r$33405 = -48						; size = 4
_n$33408 = -44						; size = 4
_dsize$33396 = -40					; size = 4
_dvs$33394 = -36					; size = 4
_newtop$33383 = -32					; size = 4
_newsize$33381 = -28					; size = 4
_newtopsize$33382 = -24					; size = 4
_r$33365 = -20						; size = 4
_rsize$33356 = -16					; size = 4
_next$ = -12						; size = 4
_newp$ = -8						; size = 4
_oldsize$ = -4						; size = 4
_m$ = 8							; size = 4
_p$ = 12						; size = 4
_nb$ = 16						; size = 4
_can_move$ = 20						; size = 4
?try_realloc_chunk@@YAPAUmalloc_chunk@@PAUmalloc_state@@PAU1@IH@Z PROC ; try_realloc_chunk

; 4795 :                                    int can_move) {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H

; 4796 :   mchunkptr newp = 0;

	mov	DWORD PTR _newp$[ebp], 0

; 4797 :   size_t oldsize = chunksize(p);

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	mov	DWORD PTR _oldsize$[ebp], ecx

; 4798 :   mchunkptr next = chunk_plus_offset(p, oldsize);

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, DWORD PTR _oldsize$[ebp]
	mov	DWORD PTR _next$[ebp], edx

; 4799 :   if (RTCHECK(ok_address(m, p) && ok_inuse(p) &&
; 4800 :               ok_next(p, next) && ok_pinuse(next))) {

	mov	eax, 1
	test	eax, eax
	je	$LN55@try_reallo

; 4801 :     if (is_mmapped(p)) {

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 3
	jne	SHORT $LN54@try_reallo

; 4802 :       newp = mmap_resize(m, p, nb, can_move);

	mov	eax, DWORD PTR _can_move$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nb$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	?mmap_resize@@YAPAUmalloc_chunk@@PAUmalloc_state@@PAU1@IH@Z ; mmap_resize
	add	esp, 16					; 00000010H
	mov	DWORD PTR _newp$[ebp], eax
	jmp	$LN53@try_reallo
$LN54@try_reallo:

; 4803 :     }
; 4804 :     else if (oldsize >= nb) {             /* already big enough */

	mov	ecx, DWORD PTR _oldsize$[ebp]
	cmp	ecx, DWORD PTR _nb$[ebp]
	jb	$LN52@try_reallo

; 4805 :       size_t rsize = oldsize - nb;

	mov	edx, DWORD PTR _oldsize$[ebp]
	sub	edx, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _rsize$33356[ebp], edx

; 4806 :       if (rsize >= MIN_CHUNK_SIZE) {      /* split off remainder */

	cmp	DWORD PTR _rsize$33356[ebp], 16		; 00000010H
	jb	SHORT $LN51@try_reallo

; 4807 :         mchunkptr r = chunk_plus_offset(p, nb);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _r$33365[ebp], eax

; 4808 :         set_inuse(m, p, nb);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 1
	or	edx, DWORD PTR _nb$[ebp]
	or	edx, 2
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	or	edx, 1
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _nb$[ebp]
	mov	DWORD PTR [eax+4], edx

; 4809 :         set_inuse(m, r, rsize);

	mov	ecx, DWORD PTR _r$33365[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 1
	or	edx, DWORD PTR _rsize$33356[ebp]
	or	edx, 2
	mov	eax, DWORD PTR _r$33365[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _r$33365[ebp]
	add	ecx, DWORD PTR _rsize$33356[ebp]
	mov	edx, DWORD PTR [ecx+4]
	or	edx, 1
	mov	eax, DWORD PTR _r$33365[ebp]
	add	eax, DWORD PTR _rsize$33356[ebp]
	mov	DWORD PTR [eax+4], edx

; 4810 :         dispose_chunk(m, r, rsize);

	mov	ecx, DWORD PTR _rsize$33356[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$33365[ebp]
	push	edx
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	?dispose_chunk@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z ; dispose_chunk
	add	esp, 12					; 0000000cH
$LN51@try_reallo:

; 4811 :       }
; 4812 :       newp = p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _newp$[ebp], ecx
	jmp	$LN53@try_reallo
$LN52@try_reallo:

; 4813 :     }
; 4814 :     else if (next == m->top) {  /* extend into top */

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _next$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jne	SHORT $LN49@try_reallo

; 4815 :       if (oldsize + m->topsize > nb) {

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _oldsize$[ebp]
	add	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _nb$[ebp]
	jbe	SHORT $LN48@try_reallo

; 4816 :         size_t newsize = oldsize + m->topsize;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _oldsize$[ebp]
	add	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _newsize$33381[ebp], ecx

; 4817 :         size_t newtopsize = newsize - nb;

	mov	edx, DWORD PTR _newsize$33381[ebp]
	sub	edx, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _newtopsize$33382[ebp], edx

; 4818 :         mchunkptr newtop = chunk_plus_offset(p, nb);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _newtop$33383[ebp], eax

; 4819 :         set_inuse(m, p, nb);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 1
	or	edx, DWORD PTR _nb$[ebp]
	or	edx, 2
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	or	edx, 1
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _nb$[ebp]
	mov	DWORD PTR [eax+4], edx

; 4820 :         newtop->head = newtopsize |PINUSE_BIT;

	mov	ecx, DWORD PTR _newtopsize$33382[ebp]
	or	ecx, 1
	mov	edx, DWORD PTR _newtop$33383[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4821 :         m->top = newtop;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _newtop$33383[ebp]
	mov	DWORD PTR [eax+24], ecx

; 4822 :         m->topsize = newtopsize;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _newtopsize$33382[ebp]
	mov	DWORD PTR [edx+12], eax

; 4823 :         newp = p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _newp$[ebp], ecx
$LN48@try_reallo:

; 4824 :       }
; 4825 :     }

	jmp	$LN53@try_reallo
$LN49@try_reallo:

; 4826 :     else if (next == m->dv) { /* extend into dv */

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _next$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jne	$LN46@try_reallo

; 4827 :       size_t dvs = m->dvsize;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _dvs$33394[ebp], edx

; 4828 :       if (oldsize + dvs >= nb) {

	mov	eax, DWORD PTR _oldsize$[ebp]
	add	eax, DWORD PTR _dvs$33394[ebp]
	cmp	eax, DWORD PTR _nb$[ebp]
	jb	$LN45@try_reallo

; 4829 :         size_t dsize = oldsize + dvs - nb;

	mov	ecx, DWORD PTR _oldsize$[ebp]
	add	ecx, DWORD PTR _dvs$33394[ebp]
	sub	ecx, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _dsize$33396[ebp], ecx

; 4830 :         if (dsize >= MIN_CHUNK_SIZE) {

	cmp	DWORD PTR _dsize$33396[ebp], 16		; 00000010H
	jb	SHORT $LN44@try_reallo

; 4831 :           mchunkptr r = chunk_plus_offset(p, nb);

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _r$33405[ebp], edx

; 4832 :           mchunkptr n = chunk_plus_offset(r, dsize);

	mov	eax, DWORD PTR _r$33405[ebp]
	add	eax, DWORD PTR _dsize$33396[ebp]
	mov	DWORD PTR _n$33408[ebp], eax

; 4833 :           set_inuse(m, p, nb);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 1
	or	edx, DWORD PTR _nb$[ebp]
	or	edx, 2
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	or	edx, 1
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _nb$[ebp]
	mov	DWORD PTR [eax+4], edx

; 4834 :           set_size_and_pinuse_of_free_chunk(r, dsize);

	mov	ecx, DWORD PTR _dsize$33396[ebp]
	or	ecx, 1
	mov	edx, DWORD PTR _r$33405[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _r$33405[ebp]
	add	eax, DWORD PTR _dsize$33396[ebp]
	mov	ecx, DWORD PTR _dsize$33396[ebp]
	mov	DWORD PTR [eax], ecx

; 4835 :           clear_pinuse(n);

	mov	edx, DWORD PTR _n$33408[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _n$33408[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4836 :           m->dvsize = dsize;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _dsize$33396[ebp]
	mov	DWORD PTR [edx+8], eax

; 4837 :           m->dv = r;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _r$33405[ebp]
	mov	DWORD PTR [ecx+20], edx

; 4838 :         }
; 4839 :         else { /* exhaust dv */

	jmp	SHORT $LN43@try_reallo
$LN44@try_reallo:

; 4840 :           size_t newsize = oldsize + dvs;

	mov	eax, DWORD PTR _oldsize$[ebp]
	add	eax, DWORD PTR _dvs$33394[ebp]
	mov	DWORD PTR _newsize$33421[ebp], eax

; 4841 :           set_inuse(m, p, newsize);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 1
	or	edx, DWORD PTR _newsize$33421[ebp]
	or	edx, 2
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _newsize$33421[ebp]
	mov	edx, DWORD PTR [ecx+4]
	or	edx, 1
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _newsize$33421[ebp]
	mov	DWORD PTR [eax+4], edx

; 4842 :           m->dvsize = 0;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 4843 :           m->dv = 0;

	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+20], 0
$LN43@try_reallo:

; 4844 :         }
; 4845 :         newp = p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _newp$[ebp], eax
$LN45@try_reallo:

; 4846 :       }
; 4847 :     }

	jmp	$LN53@try_reallo
$LN46@try_reallo:

; 4848 :     else if (!cinuse(next)) { /* extend into next free chunk */

	mov	ecx, DWORD PTR _next$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 2
	jne	$LN53@try_reallo

; 4849 :       size_t nextsize = chunksize(next);

	mov	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	mov	DWORD PTR _nextsize$33430[ebp], ecx

; 4850 :       if (oldsize + nextsize >= nb) {

	mov	edx, DWORD PTR _oldsize$[ebp]
	add	edx, DWORD PTR _nextsize$33430[ebp]
	cmp	edx, DWORD PTR _nb$[ebp]
	jb	$LN53@try_reallo

; 4851 :         size_t rsize = oldsize + nextsize - nb;

	mov	eax, DWORD PTR _oldsize$[ebp]
	add	eax, DWORD PTR _nextsize$33430[ebp]
	sub	eax, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _rsize$33435[ebp], eax

; 4852 :         unlink_chunk(m, next, nextsize);

	mov	ecx, DWORD PTR _nextsize$33430[ebp]
	shr	ecx, 3
	cmp	ecx, 32					; 00000020H
	jae	SHORT $LN39@try_reallo
	mov	edx, DWORD PTR _next$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _F$33437[ebp], eax
	mov	ecx, DWORD PTR _next$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _B$33438[ebp], edx
	mov	eax, DWORD PTR _nextsize$33430[ebp]
	shr	eax, 3
	mov	DWORD PTR _I$33439[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN38@try_reallo
	mov	edx, DWORD PTR _B$33438[ebp]
	cmp	edx, DWORD PTR _F$33437[ebp]
	jne	SHORT $LN37@try_reallo
	mov	eax, 1
	mov	ecx, DWORD PTR _I$33439[ebp]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _m$[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN36@try_reallo
$LN37@try_reallo:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN35@try_reallo
	mov	ecx, DWORD PTR _F$33437[ebp]
	mov	edx, DWORD PTR _B$33438[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _B$33438[ebp]
	mov	ecx, DWORD PTR _F$33437[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN36@try_reallo
$LN35@try_reallo:
	call	DWORD PTR __imp__abort
$LN36@try_reallo:
	jmp	SHORT $LN33@try_reallo
$LN38@try_reallo:
	call	DWORD PTR __imp__abort
$LN33@try_reallo:
	jmp	$LN32@try_reallo
$LN39@try_reallo:
	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _TP$33449[ebp], edx
	mov	eax, DWORD PTR _TP$33449[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _XP$33451[ebp], ecx
	mov	edx, DWORD PTR _TP$33449[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _TP$33449[ebp]
	je	SHORT $LN31@try_reallo
	mov	ecx, DWORD PTR _TP$33449[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _F$33454[ebp], edx
	mov	eax, DWORD PTR _TP$33449[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _R$33452[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN30@try_reallo
	mov	eax, DWORD PTR _F$33454[ebp]
	mov	ecx, DWORD PTR _R$33452[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _R$33452[ebp]
	mov	eax, DWORD PTR _F$33454[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN29@try_reallo
$LN30@try_reallo:
	call	DWORD PTR __imp__abort
$LN29@try_reallo:
	jmp	SHORT $LN28@try_reallo
$LN31@try_reallo:
	mov	ecx, DWORD PTR _TP$33449[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _RP$33458[ebp], ecx
	mov	edx, DWORD PTR _RP$33458[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _R$33452[ebp], eax
	cmp	DWORD PTR _R$33452[ebp], 0
	jne	SHORT $LN25@try_reallo
	mov	ecx, DWORD PTR _TP$33449[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _RP$33458[ebp], ecx
	mov	edx, DWORD PTR _RP$33458[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _R$33452[ebp], eax
	cmp	DWORD PTR _R$33452[ebp], 0
	je	SHORT $LN28@try_reallo
$LN25@try_reallo:
	mov	ecx, DWORD PTR _R$33452[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _CP$33461[ebp], ecx
	mov	edx, DWORD PTR _CP$33461[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN23@try_reallo
	mov	eax, DWORD PTR _R$33452[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _CP$33461[ebp], eax
	mov	ecx, DWORD PTR _CP$33461[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN24@try_reallo
$LN23@try_reallo:
	mov	edx, DWORD PTR _CP$33461[ebp]
	mov	DWORD PTR _RP$33458[ebp], edx
	mov	eax, DWORD PTR _RP$33458[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _R$33452[ebp], ecx
	jmp	SHORT $LN25@try_reallo
$LN24@try_reallo:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN22@try_reallo
	mov	eax, DWORD PTR _RP$33458[ebp]
	mov	DWORD PTR [eax], 0
	jmp	SHORT $LN28@try_reallo
$LN22@try_reallo:
	call	DWORD PTR __imp__abort
$LN28@try_reallo:
	cmp	DWORD PTR _XP$33451[ebp], 0
	je	$LN32@try_reallo
	mov	ecx, DWORD PTR _TP$33449[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _m$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+304]
	mov	DWORD PTR _H$33469[ebp], ecx
	mov	edx, DWORD PTR _H$33469[ebp]
	mov	eax, DWORD PTR _TP$33449[ebp]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN19@try_reallo
	mov	ecx, DWORD PTR _H$33469[ebp]
	mov	edx, DWORD PTR _R$33452[ebp]
	mov	DWORD PTR [ecx], edx
	cmp	DWORD PTR _R$33452[ebp], 0
	jne	SHORT $LN18@try_reallo
	mov	eax, DWORD PTR _TP$33449[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+28]
	shl	edx, cl
	not	edx
	mov	eax, DWORD PTR _m$[ebp]
	and	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN18@try_reallo:
	jmp	SHORT $LN17@try_reallo
$LN19@try_reallo:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN16@try_reallo
	mov	eax, DWORD PTR _XP$33451[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _TP$33449[ebp]
	jne	SHORT $LN15@try_reallo
	mov	edx, DWORD PTR _XP$33451[ebp]
	mov	eax, DWORD PTR _R$33452[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	SHORT $LN14@try_reallo
$LN15@try_reallo:
	mov	ecx, DWORD PTR _XP$33451[ebp]
	mov	edx, DWORD PTR _R$33452[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN14@try_reallo:
	jmp	SHORT $LN17@try_reallo
$LN16@try_reallo:
	call	DWORD PTR __imp__abort
$LN17@try_reallo:
	cmp	DWORD PTR _R$33452[ebp], 0
	je	SHORT $LN32@try_reallo
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN11@try_reallo
	mov	ecx, DWORD PTR _R$33452[ebp]
	mov	edx, DWORD PTR _XP$33451[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _TP$33449[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _C0$33480[ebp], ecx
	cmp	DWORD PTR _C0$33480[ebp], 0
	je	SHORT $LN10@try_reallo
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN9@try_reallo
	mov	eax, DWORD PTR _R$33452[ebp]
	mov	ecx, DWORD PTR _C0$33480[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _C0$33480[ebp]
	mov	eax, DWORD PTR _R$33452[ebp]
	mov	DWORD PTR [edx+24], eax
	jmp	SHORT $LN10@try_reallo
$LN9@try_reallo:
	call	DWORD PTR __imp__abort
$LN10@try_reallo:
	mov	ecx, DWORD PTR _TP$33449[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _C1$33481[ebp], edx
	cmp	DWORD PTR _C1$33481[ebp], 0
	je	SHORT $LN7@try_reallo
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN6@try_reallo
	mov	ecx, DWORD PTR _R$33452[ebp]
	mov	edx, DWORD PTR _C1$33481[ebp]
	mov	DWORD PTR [ecx+20], edx
	mov	eax, DWORD PTR _C1$33481[ebp]
	mov	ecx, DWORD PTR _R$33452[ebp]
	mov	DWORD PTR [eax+24], ecx
	jmp	SHORT $LN7@try_reallo
$LN6@try_reallo:
	call	DWORD PTR __imp__abort
$LN7@try_reallo:
	jmp	SHORT $LN32@try_reallo
$LN11@try_reallo:
	call	DWORD PTR __imp__abort
$LN32@try_reallo:

; 4853 :         if (rsize < MIN_CHUNK_SIZE) {

	cmp	DWORD PTR _rsize$33435[ebp], 16		; 00000010H
	jae	SHORT $LN3@try_reallo

; 4854 :           size_t newsize = oldsize + nextsize;

	mov	edx, DWORD PTR _oldsize$[ebp]
	add	edx, DWORD PTR _nextsize$33430[ebp]
	mov	DWORD PTR _newsize$33497[ebp], edx

; 4855 :           set_inuse(m, p, newsize);

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 1
	or	ecx, DWORD PTR _newsize$33497[ebp]
	or	ecx, 2
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _newsize$33497[ebp]
	mov	ecx, DWORD PTR [eax+4]
	or	ecx, 1
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, DWORD PTR _newsize$33497[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4856 :         }
; 4857 :         else {

	jmp	SHORT $LN2@try_reallo
$LN3@try_reallo:

; 4858 :           mchunkptr r = chunk_plus_offset(p, nb);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _r$33504[ebp], eax

; 4859 :           set_inuse(m, p, nb);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 1
	or	edx, DWORD PTR _nb$[ebp]
	or	edx, 2
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	or	edx, 1
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _nb$[ebp]
	mov	DWORD PTR [eax+4], edx

; 4860 :           set_inuse(m, r, rsize);

	mov	ecx, DWORD PTR _r$33504[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 1
	or	edx, DWORD PTR _rsize$33435[ebp]
	or	edx, 2
	mov	eax, DWORD PTR _r$33504[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _r$33504[ebp]
	add	ecx, DWORD PTR _rsize$33435[ebp]
	mov	edx, DWORD PTR [ecx+4]
	or	edx, 1
	mov	eax, DWORD PTR _r$33504[ebp]
	add	eax, DWORD PTR _rsize$33435[ebp]
	mov	DWORD PTR [eax+4], edx

; 4861 :           dispose_chunk(m, r, rsize);

	mov	ecx, DWORD PTR _rsize$33435[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$33504[ebp]
	push	edx
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	?dispose_chunk@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z ; dispose_chunk
	add	esp, 12					; 0000000cH
$LN2@try_reallo:

; 4862 :         }
; 4863 :         newp = p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _newp$[ebp], ecx
$LN53@try_reallo:

; 4864 :       }
; 4865 :     }
; 4866 :   }
; 4867 :   else {

	jmp	SHORT $LN1@try_reallo
$LN55@try_reallo:

; 4868 :     USAGE_ERROR_ACTION(m, chunk2mem(p));

	call	DWORD PTR __imp__abort
$LN1@try_reallo:

; 4869 :   }
; 4870 :   return newp;

	mov	eax, DWORD PTR _newp$[ebp]

; 4871 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?try_realloc_chunk@@YAPAUmalloc_chunk@@PAUmalloc_state@@PAU1@IH@Z ENDP ; try_realloc_chunk
; Function compile flags: /Odtp
_psize$31211 = -28					; size = 4
_newp$31209 = -24					; size = 4
_oldmmsize$31191 = -20					; size = 4
_offset$31190 = -16					; size = 4
_newmmsize$31193 = -12					; size = 4
_cp$31201 = -8						; size = 4
_oldsize$ = -4						; size = 4
_m$ = 8							; size = 4
_oldp$ = 12						; size = 4
_nb$ = 16						; size = 4
_flags$ = 20						; size = 4
?mmap_resize@@YAPAUmalloc_chunk@@PAUmalloc_state@@PAU1@IH@Z PROC ; mmap_resize

; 3841 : static mchunkptr mmap_resize(mstate m, mchunkptr oldp, size_t nb, int flags) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3842 :   size_t oldsize = chunksize(oldp);

	mov	eax, DWORD PTR _oldp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	mov	DWORD PTR _oldsize$[ebp], ecx

; 3843 :   (void)flags; /* placate people compiling -Wunused */
; 3844 :   if (is_small(nb)) /* Can't shrink mmap regions below small size */

	mov	edx, DWORD PTR _nb$[ebp]
	shr	edx, 3
	cmp	edx, 32					; 00000020H
	jae	SHORT $LN6@mmap_resiz

; 3845 :     return 0;

	xor	eax, eax
	jmp	$LN7@mmap_resiz
$LN6@mmap_resiz:

; 3846 :   /* Keep old chunk if big enough but not too big */
; 3847 :   if (oldsize >= nb + SIZE_T_SIZE &&
; 3848 :       (oldsize - nb) <= (mparams.granularity << 1))

	mov	eax, DWORD PTR _nb$[ebp]
	add	eax, 4
	cmp	DWORD PTR _oldsize$[ebp], eax
	jb	SHORT $LN5@mmap_resiz
	mov	ecx, DWORD PTR _oldsize$[ebp]
	sub	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR _mparams+8
	shl	edx, 1
	cmp	ecx, edx
	ja	SHORT $LN5@mmap_resiz

; 3849 :     return oldp;

	mov	eax, DWORD PTR _oldp$[ebp]
	jmp	$LN7@mmap_resiz

; 3850 :   else {

	jmp	$LN4@mmap_resiz
$LN5@mmap_resiz:

; 3851 :     size_t offset = oldp->prev_foot;

	mov	eax, DWORD PTR _oldp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _offset$31190[ebp], ecx

; 3852 :     size_t oldmmsize = oldsize + offset + MMAP_FOOT_PAD;

	mov	edx, DWORD PTR _offset$31190[ebp]
	mov	eax, DWORD PTR _oldsize$[ebp]
	lea	ecx, DWORD PTR [eax+edx+16]
	mov	DWORD PTR _oldmmsize$31191[ebp], ecx

; 3853 :     size_t newmmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);

	mov	edx, DWORD PTR _mparams+8
	mov	eax, DWORD PTR _nb$[ebp]
	lea	ecx, DWORD PTR [eax+edx+30]
	mov	edx, DWORD PTR _mparams+8
	sub	edx, 1
	not	edx
	and	ecx, edx
	mov	DWORD PTR _newmmsize$31193[ebp], ecx

; 3854 :     char* cp = (char*)CALL_MREMAP((char*)oldp - offset,
; 3855 :                                   oldmmsize, newmmsize, flags);

	mov	DWORD PTR _cp$31201[ebp], -1

; 3856 :     if (cp != CMFAIL) {

	cmp	DWORD PTR _cp$31201[ebp], -1
	je	$LN4@mmap_resiz

; 3857 :       mchunkptr newp = (mchunkptr)(cp + offset);

	mov	eax, DWORD PTR _cp$31201[ebp]
	add	eax, DWORD PTR _offset$31190[ebp]
	mov	DWORD PTR _newp$31209[ebp], eax

; 3858 :       size_t psize = newmmsize - offset - MMAP_FOOT_PAD;

	mov	ecx, DWORD PTR _newmmsize$31193[ebp]
	sub	ecx, DWORD PTR _offset$31190[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR _psize$31211[ebp], ecx

; 3859 :       newp->head = psize;

	mov	edx, DWORD PTR _newp$31209[ebp]
	mov	eax, DWORD PTR _psize$31211[ebp]
	mov	DWORD PTR [edx+4], eax

; 3860 :       mark_inuse_foot(m, newp, psize);
; 3861 :       chunk_plus_offset(newp, psize)->head = FENCEPOST_HEAD;

	mov	ecx, DWORD PTR _newp$31209[ebp]
	add	ecx, DWORD PTR _psize$31211[ebp]
	mov	DWORD PTR [ecx+4], 7

; 3862 :       chunk_plus_offset(newp, psize+SIZE_T_SIZE)->head = 0;

	mov	edx, DWORD PTR _newp$31209[ebp]
	add	edx, DWORD PTR _psize$31211[ebp]
	mov	DWORD PTR [edx+8], 0

; 3863 : 
; 3864 :       if (cp < m->least_addr)

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _cp$31201[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN2@mmap_resiz

; 3865 :         m->least_addr = cp;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _cp$31201[ebp]
	mov	DWORD PTR [edx+16], eax
$LN2@mmap_resiz:

; 3866 :       if ((m->footprint += newmmsize - oldmmsize) > m->max_footprint)

	mov	ecx, DWORD PTR _newmmsize$31193[ebp]
	sub	ecx, DWORD PTR _oldmmsize$31191[ebp]
	mov	edx, DWORD PTR _m$[ebp]
	add	ecx, DWORD PTR [edx+432]
	mov	eax, DWORD PTR _m$[ebp]
	mov	DWORD PTR [eax+432], ecx
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [ecx+432]
	cmp	eax, DWORD PTR [edx+436]
	jbe	SHORT $LN1@mmap_resiz

; 3867 :         m->max_footprint = m->footprint;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+432]
	mov	DWORD PTR [ecx+436], eax
$LN1@mmap_resiz:

; 3868 :       check_mmapped_chunk(m, newp);
; 3869 :       return newp;

	mov	eax, DWORD PTR _newp$31209[ebp]
	jmp	SHORT $LN7@mmap_resiz
$LN4@mmap_resiz:

; 3870 :     }
; 3871 :   }
; 3872 :   return 0;

	xor	eax, eax
$LN7@mmap_resiz:

; 3873 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mmap_resize@@YAPAUmalloc_chunk@@PAUmalloc_state@@PAU1@IH@Z ENDP ; mmap_resize
; Function compile flags: /Odtp
tv398 = -172						; size = 4
_F$32595 = -168						; size = 4
_C$32587 = -164						; size = 4
_K$32577 = -160						; size = 4
_T$32576 = -156						; size = 4
_K$32567 = -152						; size = 4
_X$32562 = -148						; size = 4
_I$32561 = -144						; size = 4
_H$32560 = -140						; size = 4
_TP$32558 = -136					; size = 4
_I$32545 = -132						; size = 4
_F$32550 = -128						; size = 4
_B$32547 = -124						; size = 4
_C0$32526 = -120					; size = 4
_C1$32527 = -116					; size = 4
_H$32515 = -112						; size = 4
_CP$32507 = -108					; size = 4
_RP$32504 = -104					; size = 4
_F$32500 = -100						; size = 4
_R$32498 = -96						; size = 4
_XP$32497 = -92						; size = 4
_TP$32495 = -88						; size = 4
_I$32485 = -84						; size = 4
_F$32483 = -80						; size = 4
_B$32484 = -76						; size = 4
_nsize$32478 = -72					; size = 4
_dsize$32473 = -68					; size = 4
_tsize$32468 = -64					; size = 4
_C0$32444 = -60						; size = 4
_C1$32445 = -56						; size = 4
_H$32433 = -52						; size = 4
_CP$32425 = -48						; size = 4
_RP$32422 = -44						; size = 4
_F$32418 = -40						; size = 4
_R$32416 = -36						; size = 4
_XP$32415 = -32						; size = 4
_TP$32413 = -28						; size = 4
_I$32403 = -24						; size = 4
_F$32401 = -20						; size = 4
_B$32402 = -16						; size = 4
_prevsize$32389 = -12					; size = 4
_prev$32388 = -8					; size = 4
_next$ = -4						; size = 4
_m$ = 8							; size = 4
_p$ = 12						; size = 4
_psize$ = 16						; size = 4
?dispose_chunk@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z PROC ; dispose_chunk

; 4346 : static void dispose_chunk(mstate m, mchunkptr p, size_t psize) {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH

; 4347 :   mchunkptr next = chunk_plus_offset(p, psize);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _psize$[ebp]
	mov	DWORD PTR _next$[ebp], eax

; 4348 :   if (!pinuse(p)) {

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 1
	jne	$LN112@dispose_ch

; 4349 :     mchunkptr prev;
; 4350 :     size_t prevsize = p->prev_foot;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _prevsize$32389[ebp], ecx

; 4351 :     if (is_mmapped(p)) {

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 3
	jne	SHORT $LN111@dispose_ch

; 4352 :       psize += prevsize + MMAP_FOOT_PAD;

	mov	ecx, DWORD PTR _prevsize$32389[ebp]
	mov	edx, DWORD PTR _psize$[ebp]
	lea	eax, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _psize$[ebp], eax

; 4353 :       if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)

	mov	ecx, DWORD PTR _psize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	sub	edx, DWORD PTR _prevsize$32389[ebp]
	push	edx
	call	?win32munmap@@YAHPAXI@Z			; win32munmap
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN110@dispose_ch

; 4354 :         m->footprint -= psize;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+432]
	sub	ecx, DWORD PTR _psize$[ebp]
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+432], ecx
$LN110@dispose_ch:

; 4355 :       return;

	jmp	$LN113@dispose_ch
$LN111@dispose_ch:

; 4356 :     }
; 4357 :     prev = chunk_minus_offset(p, prevsize);

	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, DWORD PTR _prevsize$32389[ebp]
	mov	DWORD PTR _prev$32388[ebp], eax

; 4358 :     psize += prevsize;

	mov	ecx, DWORD PTR _psize$[ebp]
	add	ecx, DWORD PTR _prevsize$32389[ebp]
	mov	DWORD PTR _psize$[ebp], ecx

; 4359 :     p = prev;

	mov	edx, DWORD PTR _prev$32388[ebp]
	mov	DWORD PTR _p$[ebp], edx

; 4360 :     if (RTCHECK(ok_address(m, prev))) { /* consolidate backward */

	mov	eax, 1
	test	eax, eax
	je	$LN109@dispose_ch

; 4361 :       if (p != m->dv) {

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	je	$LN108@dispose_ch

; 4362 :         unlink_chunk(m, p, prevsize);

	mov	eax, DWORD PTR _prevsize$32389[ebp]
	shr	eax, 3
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN107@dispose_ch
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _F$32401[ebp], edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _B$32402[ebp], ecx
	mov	edx, DWORD PTR _prevsize$32389[ebp]
	shr	edx, 3
	mov	DWORD PTR _I$32403[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN106@dispose_ch
	mov	ecx, DWORD PTR _B$32402[ebp]
	cmp	ecx, DWORD PTR _F$32401[ebp]
	jne	SHORT $LN105@dispose_ch
	mov	edx, 1
	mov	ecx, DWORD PTR _I$32403[ebp]
	shl	edx, cl
	not	edx
	mov	eax, DWORD PTR _m$[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN104@dispose_ch
$LN105@dispose_ch:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN103@dispose_ch
	mov	eax, DWORD PTR _F$32401[ebp]
	mov	ecx, DWORD PTR _B$32402[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _B$32402[ebp]
	mov	eax, DWORD PTR _F$32401[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN104@dispose_ch
$LN103@dispose_ch:
	call	DWORD PTR __imp__abort
$LN104@dispose_ch:
	jmp	SHORT $LN101@dispose_ch
$LN106@dispose_ch:
	call	DWORD PTR __imp__abort
$LN101@dispose_ch:
	jmp	$LN100@dispose_ch
$LN107@dispose_ch:
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _TP$32413[ebp], ecx
	mov	edx, DWORD PTR _TP$32413[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _XP$32415[ebp], eax
	mov	ecx, DWORD PTR _TP$32413[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _TP$32413[ebp]
	je	SHORT $LN99@dispose_ch
	mov	eax, DWORD PTR _TP$32413[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$32418[ebp], ecx
	mov	edx, DWORD PTR _TP$32413[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _R$32416[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN98@dispose_ch
	mov	edx, DWORD PTR _F$32418[ebp]
	mov	eax, DWORD PTR _R$32416[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _R$32416[ebp]
	mov	edx, DWORD PTR _F$32418[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN97@dispose_ch
$LN98@dispose_ch:
	call	DWORD PTR __imp__abort
$LN97@dispose_ch:
	jmp	SHORT $LN96@dispose_ch
$LN99@dispose_ch:
	mov	eax, DWORD PTR _TP$32413[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _RP$32422[ebp], eax
	mov	ecx, DWORD PTR _RP$32422[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _R$32416[ebp], edx
	cmp	DWORD PTR _R$32416[ebp], 0
	jne	SHORT $LN93@dispose_ch
	mov	eax, DWORD PTR _TP$32413[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _RP$32422[ebp], eax
	mov	ecx, DWORD PTR _RP$32422[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _R$32416[ebp], edx
	cmp	DWORD PTR _R$32416[ebp], 0
	je	SHORT $LN96@dispose_ch
$LN93@dispose_ch:
	mov	eax, DWORD PTR _R$32416[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _CP$32425[ebp], eax
	mov	ecx, DWORD PTR _CP$32425[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN91@dispose_ch
	mov	edx, DWORD PTR _R$32416[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _CP$32425[ebp], edx
	mov	eax, DWORD PTR _CP$32425[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN92@dispose_ch
$LN91@dispose_ch:
	mov	ecx, DWORD PTR _CP$32425[ebp]
	mov	DWORD PTR _RP$32422[ebp], ecx
	mov	edx, DWORD PTR _RP$32422[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _R$32416[ebp], eax
	jmp	SHORT $LN93@dispose_ch
$LN92@dispose_ch:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN90@dispose_ch
	mov	edx, DWORD PTR _RP$32422[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN96@dispose_ch
$LN90@dispose_ch:
	call	DWORD PTR __imp__abort
$LN96@dispose_ch:
	cmp	DWORD PTR _XP$32415[ebp], 0
	je	$LN100@dispose_ch
	mov	eax, DWORD PTR _TP$32413[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _m$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+304]
	mov	DWORD PTR _H$32433[ebp], eax
	mov	ecx, DWORD PTR _H$32433[ebp]
	mov	edx, DWORD PTR _TP$32413[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN87@dispose_ch
	mov	eax, DWORD PTR _H$32433[ebp]
	mov	ecx, DWORD PTR _R$32416[ebp]
	mov	DWORD PTR [eax], ecx
	cmp	DWORD PTR _R$32416[ebp], 0
	jne	SHORT $LN86@dispose_ch
	mov	edx, DWORD PTR _TP$32413[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+28]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _m$[ebp]
	and	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN86@dispose_ch:
	jmp	SHORT $LN85@dispose_ch
$LN87@dispose_ch:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN84@dispose_ch
	mov	ecx, DWORD PTR _XP$32415[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _TP$32413[ebp]
	jne	SHORT $LN83@dispose_ch
	mov	eax, DWORD PTR _XP$32415[ebp]
	mov	ecx, DWORD PTR _R$32416[ebp]
	mov	DWORD PTR [eax+16], ecx
	jmp	SHORT $LN82@dispose_ch
$LN83@dispose_ch:
	mov	edx, DWORD PTR _XP$32415[ebp]
	mov	eax, DWORD PTR _R$32416[ebp]
	mov	DWORD PTR [edx+20], eax
$LN82@dispose_ch:
	jmp	SHORT $LN85@dispose_ch
$LN84@dispose_ch:
	call	DWORD PTR __imp__abort
$LN85@dispose_ch:
	cmp	DWORD PTR _R$32416[ebp], 0
	je	SHORT $LN100@dispose_ch
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN79@dispose_ch
	mov	edx, DWORD PTR _R$32416[ebp]
	mov	eax, DWORD PTR _XP$32415[ebp]
	mov	DWORD PTR [edx+24], eax
	mov	ecx, DWORD PTR _TP$32413[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _C0$32444[ebp], edx
	cmp	DWORD PTR _C0$32444[ebp], 0
	je	SHORT $LN78@dispose_ch
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN77@dispose_ch
	mov	ecx, DWORD PTR _R$32416[ebp]
	mov	edx, DWORD PTR _C0$32444[ebp]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR _C0$32444[ebp]
	mov	ecx, DWORD PTR _R$32416[ebp]
	mov	DWORD PTR [eax+24], ecx
	jmp	SHORT $LN78@dispose_ch
$LN77@dispose_ch:
	call	DWORD PTR __imp__abort
$LN78@dispose_ch:
	mov	edx, DWORD PTR _TP$32413[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _C1$32445[ebp], eax
	cmp	DWORD PTR _C1$32445[ebp], 0
	je	SHORT $LN75@dispose_ch
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN74@dispose_ch
	mov	edx, DWORD PTR _R$32416[ebp]
	mov	eax, DWORD PTR _C1$32445[ebp]
	mov	DWORD PTR [edx+20], eax
	mov	ecx, DWORD PTR _C1$32445[ebp]
	mov	edx, DWORD PTR _R$32416[ebp]
	mov	DWORD PTR [ecx+24], edx
	jmp	SHORT $LN75@dispose_ch
$LN74@dispose_ch:
	call	DWORD PTR __imp__abort
$LN75@dispose_ch:
	jmp	SHORT $LN100@dispose_ch
$LN79@dispose_ch:
	call	DWORD PTR __imp__abort
$LN100@dispose_ch:
	jmp	SHORT $LN71@dispose_ch
$LN108@dispose_ch:

; 4363 :       }
; 4364 :       else if ((next->head & INUSE_BITS) == INUSE_BITS) {

	mov	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 3
	cmp	ecx, 3
	jne	SHORT $LN71@dispose_ch

; 4365 :         m->dvsize = psize;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _psize$[ebp]
	mov	DWORD PTR [edx+8], eax

; 4366 :         set_free_with_pinuse(p, psize, next);

	mov	ecx, DWORD PTR _next$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _psize$[ebp]
	or	ecx, 1
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _psize$[ebp]
	mov	ecx, DWORD PTR _psize$[ebp]
	mov	DWORD PTR [eax], ecx

; 4367 :         return;

	jmp	$LN113@dispose_ch
$LN71@dispose_ch:

; 4368 :       }
; 4369 :     }
; 4370 :     else {

	jmp	SHORT $LN112@dispose_ch
$LN109@dispose_ch:

; 4371 :       CORRUPTION_ERROR_ACTION(m);

	call	DWORD PTR __imp__abort

; 4372 :       return;

	jmp	$LN113@dispose_ch
$LN112@dispose_ch:

; 4373 :     }
; 4374 :   }
; 4375 :   if (RTCHECK(ok_address(m, next))) {

	mov	edx, 1
	test	edx, edx
	je	$LN68@dispose_ch

; 4376 :     if (!cinuse(next)) {  /* consolidate forward */

	mov	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 2
	jne	$LN67@dispose_ch

; 4377 :       if (next == m->top) {

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _next$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jne	SHORT $LN66@dispose_ch

; 4378 :         size_t tsize = m->topsize += psize;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _psize$[ebp]
	mov	eax, DWORD PTR _m$[ebp]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _tsize$32468[ebp], edx

; 4379 :         m->top = p;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 4380 :         p->head = tsize | PINUSE_BIT;

	mov	edx, DWORD PTR _tsize$32468[ebp]
	or	edx, 1
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], edx

; 4381 :         if (p == m->dv) {

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN65@dispose_ch

; 4382 :           m->dv = 0;

	mov	eax, DWORD PTR _m$[ebp]
	mov	DWORD PTR [eax+20], 0

; 4383 :           m->dvsize = 0;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN65@dispose_ch:

; 4384 :         }

	jmp	$LN113@dispose_ch

; 4385 :         return;

	jmp	$LN64@dispose_ch
$LN66@dispose_ch:

; 4386 :       }
; 4387 :       else if (next == m->dv) {

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _next$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jne	SHORT $LN63@dispose_ch

; 4388 :         size_t dsize = m->dvsize += psize;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _psize$[ebp]
	mov	eax, DWORD PTR _m$[ebp]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _dsize$32473[ebp], edx

; 4389 :         m->dv = p;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 4390 :         set_size_and_pinuse_of_free_chunk(p, dsize);

	mov	edx, DWORD PTR _dsize$32473[ebp]
	or	edx, 1
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _dsize$32473[ebp]
	mov	edx, DWORD PTR _dsize$32473[ebp]
	mov	DWORD PTR [ecx], edx

; 4391 :         return;

	jmp	$LN113@dispose_ch

; 4392 :       }
; 4393 :       else {

	jmp	$LN64@dispose_ch
$LN63@dispose_ch:

; 4394 :         size_t nsize = chunksize(next);

	mov	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	mov	DWORD PTR _nsize$32478[ebp], ecx

; 4395 :         psize += nsize;

	mov	edx, DWORD PTR _psize$[ebp]
	add	edx, DWORD PTR _nsize$32478[ebp]
	mov	DWORD PTR _psize$[ebp], edx

; 4396 :         unlink_chunk(m, next, nsize);

	mov	eax, DWORD PTR _nsize$32478[ebp]
	shr	eax, 3
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN61@dispose_ch
	mov	ecx, DWORD PTR _next$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _F$32483[ebp], edx
	mov	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _B$32484[ebp], ecx
	mov	edx, DWORD PTR _nsize$32478[ebp]
	shr	edx, 3
	mov	DWORD PTR _I$32485[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN60@dispose_ch
	mov	ecx, DWORD PTR _B$32484[ebp]
	cmp	ecx, DWORD PTR _F$32483[ebp]
	jne	SHORT $LN59@dispose_ch
	mov	edx, 1
	mov	ecx, DWORD PTR _I$32485[ebp]
	shl	edx, cl
	not	edx
	mov	eax, DWORD PTR _m$[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN58@dispose_ch
$LN59@dispose_ch:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN57@dispose_ch
	mov	eax, DWORD PTR _F$32483[ebp]
	mov	ecx, DWORD PTR _B$32484[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _B$32484[ebp]
	mov	eax, DWORD PTR _F$32483[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN58@dispose_ch
$LN57@dispose_ch:
	call	DWORD PTR __imp__abort
$LN58@dispose_ch:
	jmp	SHORT $LN55@dispose_ch
$LN60@dispose_ch:
	call	DWORD PTR __imp__abort
$LN55@dispose_ch:
	jmp	$LN54@dispose_ch
$LN61@dispose_ch:
	mov	ecx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _TP$32495[ebp], ecx
	mov	edx, DWORD PTR _TP$32495[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _XP$32497[ebp], eax
	mov	ecx, DWORD PTR _TP$32495[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _TP$32495[ebp]
	je	SHORT $LN53@dispose_ch
	mov	eax, DWORD PTR _TP$32495[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$32500[ebp], ecx
	mov	edx, DWORD PTR _TP$32495[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _R$32498[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN52@dispose_ch
	mov	edx, DWORD PTR _F$32500[ebp]
	mov	eax, DWORD PTR _R$32498[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _R$32498[ebp]
	mov	edx, DWORD PTR _F$32500[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN51@dispose_ch
$LN52@dispose_ch:
	call	DWORD PTR __imp__abort
$LN51@dispose_ch:
	jmp	SHORT $LN50@dispose_ch
$LN53@dispose_ch:
	mov	eax, DWORD PTR _TP$32495[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _RP$32504[ebp], eax
	mov	ecx, DWORD PTR _RP$32504[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _R$32498[ebp], edx
	cmp	DWORD PTR _R$32498[ebp], 0
	jne	SHORT $LN47@dispose_ch
	mov	eax, DWORD PTR _TP$32495[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _RP$32504[ebp], eax
	mov	ecx, DWORD PTR _RP$32504[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _R$32498[ebp], edx
	cmp	DWORD PTR _R$32498[ebp], 0
	je	SHORT $LN50@dispose_ch
$LN47@dispose_ch:
	mov	eax, DWORD PTR _R$32498[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _CP$32507[ebp], eax
	mov	ecx, DWORD PTR _CP$32507[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN45@dispose_ch
	mov	edx, DWORD PTR _R$32498[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _CP$32507[ebp], edx
	mov	eax, DWORD PTR _CP$32507[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN46@dispose_ch
$LN45@dispose_ch:
	mov	ecx, DWORD PTR _CP$32507[ebp]
	mov	DWORD PTR _RP$32504[ebp], ecx
	mov	edx, DWORD PTR _RP$32504[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _R$32498[ebp], eax
	jmp	SHORT $LN47@dispose_ch
$LN46@dispose_ch:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN44@dispose_ch
	mov	edx, DWORD PTR _RP$32504[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN50@dispose_ch
$LN44@dispose_ch:
	call	DWORD PTR __imp__abort
$LN50@dispose_ch:
	cmp	DWORD PTR _XP$32497[ebp], 0
	je	$LN54@dispose_ch
	mov	eax, DWORD PTR _TP$32495[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _m$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+304]
	mov	DWORD PTR _H$32515[ebp], eax
	mov	ecx, DWORD PTR _H$32515[ebp]
	mov	edx, DWORD PTR _TP$32495[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN41@dispose_ch
	mov	eax, DWORD PTR _H$32515[ebp]
	mov	ecx, DWORD PTR _R$32498[ebp]
	mov	DWORD PTR [eax], ecx
	cmp	DWORD PTR _R$32498[ebp], 0
	jne	SHORT $LN40@dispose_ch
	mov	edx, DWORD PTR _TP$32495[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+28]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _m$[ebp]
	and	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN40@dispose_ch:
	jmp	SHORT $LN39@dispose_ch
$LN41@dispose_ch:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN38@dispose_ch
	mov	ecx, DWORD PTR _XP$32497[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _TP$32495[ebp]
	jne	SHORT $LN37@dispose_ch
	mov	eax, DWORD PTR _XP$32497[ebp]
	mov	ecx, DWORD PTR _R$32498[ebp]
	mov	DWORD PTR [eax+16], ecx
	jmp	SHORT $LN36@dispose_ch
$LN37@dispose_ch:
	mov	edx, DWORD PTR _XP$32497[ebp]
	mov	eax, DWORD PTR _R$32498[ebp]
	mov	DWORD PTR [edx+20], eax
$LN36@dispose_ch:
	jmp	SHORT $LN39@dispose_ch
$LN38@dispose_ch:
	call	DWORD PTR __imp__abort
$LN39@dispose_ch:
	cmp	DWORD PTR _R$32498[ebp], 0
	je	SHORT $LN54@dispose_ch
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN33@dispose_ch
	mov	edx, DWORD PTR _R$32498[ebp]
	mov	eax, DWORD PTR _XP$32497[ebp]
	mov	DWORD PTR [edx+24], eax
	mov	ecx, DWORD PTR _TP$32495[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _C0$32526[ebp], edx
	cmp	DWORD PTR _C0$32526[ebp], 0
	je	SHORT $LN32@dispose_ch
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN31@dispose_ch
	mov	ecx, DWORD PTR _R$32498[ebp]
	mov	edx, DWORD PTR _C0$32526[ebp]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR _C0$32526[ebp]
	mov	ecx, DWORD PTR _R$32498[ebp]
	mov	DWORD PTR [eax+24], ecx
	jmp	SHORT $LN32@dispose_ch
$LN31@dispose_ch:
	call	DWORD PTR __imp__abort
$LN32@dispose_ch:
	mov	edx, DWORD PTR _TP$32495[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _C1$32527[ebp], eax
	cmp	DWORD PTR _C1$32527[ebp], 0
	je	SHORT $LN29@dispose_ch
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN28@dispose_ch
	mov	edx, DWORD PTR _R$32498[ebp]
	mov	eax, DWORD PTR _C1$32527[ebp]
	mov	DWORD PTR [edx+20], eax
	mov	ecx, DWORD PTR _C1$32527[ebp]
	mov	edx, DWORD PTR _R$32498[ebp]
	mov	DWORD PTR [ecx+24], edx
	jmp	SHORT $LN29@dispose_ch
$LN28@dispose_ch:
	call	DWORD PTR __imp__abort
$LN29@dispose_ch:
	jmp	SHORT $LN54@dispose_ch
$LN33@dispose_ch:
	call	DWORD PTR __imp__abort
$LN54@dispose_ch:

; 4397 :         set_size_and_pinuse_of_free_chunk(p, psize);

	mov	eax, DWORD PTR _psize$[ebp]
	or	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, DWORD PTR _psize$[ebp]
	mov	eax, DWORD PTR _psize$[ebp]
	mov	DWORD PTR [edx], eax

; 4398 :         if (p == m->dv) {

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN64@dispose_ch

; 4399 :           m->dvsize = psize;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _psize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 4400 :           return;

	jmp	$LN113@dispose_ch
$LN64@dispose_ch:

; 4401 :         }
; 4402 :       }
; 4403 :     }
; 4404 :     else {

	jmp	SHORT $LN24@dispose_ch
$LN67@dispose_ch:

; 4405 :       set_free_with_pinuse(p, psize, next);

	mov	edx, DWORD PTR _next$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _next$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _psize$[ebp]
	or	edx, 1
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _psize$[ebp]
	mov	edx, DWORD PTR _psize$[ebp]
	mov	DWORD PTR [ecx], edx
$LN24@dispose_ch:

; 4406 :     }
; 4407 :     insert_chunk(m, p, psize);

	mov	eax, DWORD PTR _psize$[ebp]
	shr	eax, 3
	cmp	eax, 32					; 00000020H
	jae	$LN23@dispose_ch
	mov	ecx, DWORD PTR _psize$[ebp]
	shr	ecx, 3
	mov	DWORD PTR _I$32545[ebp], ecx
	mov	edx, DWORD PTR _I$32545[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _m$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+40]
	mov	DWORD PTR _B$32547[ebp], ecx
	mov	edx, DWORD PTR _B$32547[ebp]
	mov	DWORD PTR _F$32550[ebp], edx
	mov	eax, 1
	mov	ecx, DWORD PTR _I$32545[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _m$[ebp]
	and	eax, DWORD PTR [ecx]
	jne	SHORT $LN22@dispose_ch
	mov	edx, 1
	mov	ecx, DWORD PTR _I$32545[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _m$[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN21@dispose_ch
$LN22@dispose_ch:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN20@dispose_ch
	mov	eax, DWORD PTR _B$32547[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$32550[ebp], ecx
	jmp	SHORT $LN21@dispose_ch
$LN20@dispose_ch:
	call	DWORD PTR __imp__abort
$LN21@dispose_ch:
	mov	edx, DWORD PTR _B$32547[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _F$32550[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _F$32550[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _B$32547[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN18@dispose_ch
$LN23@dispose_ch:
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _TP$32558[ebp], ecx
	mov	edx, DWORD PTR _psize$[ebp]
	shr	edx, 8
	mov	DWORD PTR _X$32562[ebp], edx
	cmp	DWORD PTR _X$32562[ebp], 0
	jne	SHORT $LN17@dispose_ch
	mov	DWORD PTR _I$32561[ebp], 0
	jmp	SHORT $LN16@dispose_ch
$LN17@dispose_ch:
	cmp	DWORD PTR _X$32562[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN15@dispose_ch
	mov	DWORD PTR _I$32561[ebp], 31		; 0000001fH
	jmp	SHORT $LN16@dispose_ch
$LN15@dispose_ch:
	mov	eax, DWORD PTR _X$32562[ebp]
	bsr	ecx, eax
	mov	DWORD PTR _K$32567[ebp], ecx
	mov	ecx, DWORD PTR _K$32567[ebp]
	add	ecx, 7
	mov	edx, DWORD PTR _psize$[ebp]
	shr	edx, cl
	and	edx, 1
	mov	eax, DWORD PTR _K$32567[ebp]
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _I$32561[ebp], ecx
$LN16@dispose_ch:
	mov	edx, DWORD PTR _I$32561[ebp]
	mov	eax, DWORD PTR _m$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+304]
	mov	DWORD PTR _H$32560[ebp], ecx
	mov	edx, DWORD PTR _TP$32558[ebp]
	mov	eax, DWORD PTR _I$32561[ebp]
	mov	DWORD PTR [edx+28], eax
	mov	ecx, DWORD PTR _TP$32558[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _TP$32558[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, 1
	mov	ecx, DWORD PTR _I$32561[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _m$[ebp]
	and	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN13@dispose_ch
	mov	edx, 1
	mov	ecx, DWORD PTR _I$32561[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _m$[ebp]
	or	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _H$32560[ebp]
	mov	eax, DWORD PTR _TP$32558[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _TP$32558[ebp]
	mov	edx, DWORD PTR _H$32560[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _TP$32558[ebp]
	mov	ecx, DWORD PTR _TP$32558[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _TP$32558[ebp]
	mov	eax, DWORD PTR _TP$32558[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	$LN18@dispose_ch
$LN13@dispose_ch:
	mov	ecx, DWORD PTR _H$32560[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _T$32576[ebp], edx
	cmp	DWORD PTR _I$32561[ebp], 31		; 0000001fH
	jne	SHORT $LN115@dispose_ch
	mov	DWORD PTR tv398[ebp], 0
	jmp	SHORT $LN116@dispose_ch
$LN115@dispose_ch:
	mov	eax, DWORD PTR _I$32561[ebp]
	shr	eax, 1
	add	eax, 6
	mov	ecx, 31					; 0000001fH
	sub	ecx, eax
	mov	DWORD PTR tv398[ebp], ecx
$LN116@dispose_ch:
	mov	edx, DWORD PTR _psize$[ebp]
	mov	ecx, DWORD PTR tv398[ebp]
	shl	edx, cl
	mov	DWORD PTR _K$32577[ebp], edx
$LN11@dispose_ch:
	mov	eax, DWORD PTR _T$32576[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	cmp	ecx, DWORD PTR _psize$[ebp]
	je	$LN9@dispose_ch
	mov	edx, DWORD PTR _K$32577[ebp]
	shr	edx, 31					; 0000001fH
	and	edx, 1
	mov	eax, DWORD PTR _T$32576[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+16]
	mov	DWORD PTR _C$32587[ebp], ecx
	mov	edx, DWORD PTR _K$32577[ebp]
	shl	edx, 1
	mov	DWORD PTR _K$32577[ebp], edx
	mov	eax, DWORD PTR _C$32587[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@dispose_ch
	mov	ecx, DWORD PTR _C$32587[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _T$32576[ebp], edx
	jmp	SHORT $LN7@dispose_ch
$LN8@dispose_ch:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN6@dispose_ch
	mov	ecx, DWORD PTR _C$32587[ebp]
	mov	edx, DWORD PTR _TP$32558[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _TP$32558[ebp]
	mov	ecx, DWORD PTR _T$32576[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _TP$32558[ebp]
	mov	eax, DWORD PTR _TP$32558[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _TP$32558[ebp]
	mov	edx, DWORD PTR _TP$32558[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN18@dispose_ch
	jmp	SHORT $LN7@dispose_ch
$LN6@dispose_ch:
	call	DWORD PTR __imp__abort
	jmp	SHORT $LN18@dispose_ch
$LN7@dispose_ch:
	jmp	SHORT $LN4@dispose_ch
$LN9@dispose_ch:
	mov	eax, DWORD PTR _T$32576[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$32595[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@dispose_ch
	mov	eax, DWORD PTR _F$32595[ebp]
	mov	ecx, DWORD PTR _TP$32558[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _T$32576[ebp]
	mov	eax, DWORD PTR _TP$32558[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _TP$32558[ebp]
	mov	edx, DWORD PTR _F$32595[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _TP$32558[ebp]
	mov	ecx, DWORD PTR _T$32576[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _TP$32558[ebp]
	mov	DWORD PTR [edx+24], 0
	jmp	SHORT $LN18@dispose_ch
	jmp	SHORT $LN4@dispose_ch
$LN3@dispose_ch:
	call	DWORD PTR __imp__abort
	jmp	SHORT $LN18@dispose_ch
$LN4@dispose_ch:
	jmp	$LN11@dispose_ch
$LN18@dispose_ch:

; 4408 :   }
; 4409 :   else {

	jmp	SHORT $LN113@dispose_ch
$LN68@dispose_ch:

; 4410 :     CORRUPTION_ERROR_ACTION(m);

	call	DWORD PTR __imp__abort
$LN113@dispose_ch:

; 4411 :   }
; 4412 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dispose_chunk@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z ENDP ; dispose_chunk
_TEXT	ENDS
PUBLIC	?dlrealloc_in_place@@YAPAXPAXI@Z		; dlrealloc_in_place
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv84 = -32						; size = 4
tv82 = -28						; size = 4
tv70 = -24						; size = 4
_newp$34016 = -20					; size = 4
_nb$33984 = -16						; size = 4
_m$34012 = -12						; size = 4
_oldp$34008 = -8					; size = 4
_mem$ = -4						; size = 4
_oldmem$ = 8						; size = 4
_bytes$ = 12						; size = 4
?dlrealloc_in_place@@YAPAXPAXI@Z PROC			; dlrealloc_in_place

; 5213 : void* dlrealloc_in_place(void* oldmem, size_t bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 5214 :   void* mem = 0;

	mov	DWORD PTR _mem$[ebp], 0

; 5215 :   if (oldmem != 0) {

	cmp	DWORD PTR _oldmem$[ebp], 0
	je	$LN6@dlrealloc_

; 5216 :     if (bytes >= MAX_REQUEST) {

	cmp	DWORD PTR _bytes$[ebp], -64		; ffffffc0H
	jb	SHORT $LN5@dlrealloc_

; 5217 :       MALLOC_FAILURE_ACTION;
; 5218 :     }
; 5219 :     else {

	jmp	$LN6@dlrealloc_
$LN5@dlrealloc_:

; 5220 :       size_t nb = request2size(bytes);

	cmp	DWORD PTR _bytes$[ebp], 11		; 0000000bH
	jae	SHORT $LN9@dlrealloc_
	mov	DWORD PTR tv70[ebp], 16			; 00000010H
	jmp	SHORT $LN10@dlrealloc_
$LN9@dlrealloc_:
	mov	eax, DWORD PTR _bytes$[ebp]
	add	eax, 11					; 0000000bH
	and	eax, -8					; fffffff8H
	mov	DWORD PTR tv70[ebp], eax
$LN10@dlrealloc_:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _nb$33984[ebp], ecx

; 5221 :       mchunkptr oldp = mem2chunk(oldmem);

	mov	edx, DWORD PTR _oldmem$[ebp]
	sub	edx, 8
	mov	DWORD PTR _oldp$34008[ebp], edx

; 5222 : #if ! FOOTERS
; 5223 :       mstate m = gm;

	mov	DWORD PTR _m$34012[ebp], OFFSET __gm_

; 5224 : #else /* FOOTERS */
; 5225 :       mstate m = get_mstate_for(oldp);
; 5226 :       if (!ok_magic(m)) {
; 5227 :         USAGE_ERROR_ACTION(m, oldmem);
; 5228 :         return 0;
; 5229 :       }
; 5230 : #endif /* FOOTERS */
; 5231 :       if (!PREACTION(m)) {

	mov	eax, DWORD PTR _m$34012[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 2
	je	SHORT $LN13@dlrealloc_
	mov	edx, 1
	mov	eax, DWORD PTR _m$34012[ebp]
	add	eax, 448				; 000001c0H
	xchg	DWORD PTR [eax], edx
	test	edx, edx
	je	SHORT $LN11@dlrealloc_
	mov	ecx, DWORD PTR _m$34012[ebp]
	add	ecx, 448				; 000001c0H
	push	ecx
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN12@dlrealloc_
$LN11@dlrealloc_:
	mov	DWORD PTR tv82[ebp], 0
$LN12@dlrealloc_:
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv84[ebp], edx
	jmp	SHORT $LN14@dlrealloc_
$LN13@dlrealloc_:
	mov	DWORD PTR tv84[ebp], 0
$LN14@dlrealloc_:
	cmp	DWORD PTR tv84[ebp], 0
	jne	SHORT $LN6@dlrealloc_

; 5232 :         mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);

	push	0
	mov	eax, DWORD PTR _nb$33984[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldp$34008[ebp]
	push	ecx
	mov	edx, DWORD PTR _m$34012[ebp]
	push	edx
	call	?try_realloc_chunk@@YAPAUmalloc_chunk@@PAUmalloc_state@@PAU1@IH@Z ; try_realloc_chunk
	add	esp, 16					; 00000010H
	mov	DWORD PTR _newp$34016[ebp], eax

; 5233 :         POSTACTION(m);

	mov	eax, DWORD PTR _m$34012[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 2
	je	SHORT $LN2@dlrealloc_
	xor	edx, edx
	mov	eax, DWORD PTR _m$34012[ebp]
	add	eax, 448				; 000001c0H
	xchg	DWORD PTR [eax], edx
$LN2@dlrealloc_:

; 5234 :         if (newp == oldp) {

	mov	ecx, DWORD PTR _newp$34016[ebp]
	cmp	ecx, DWORD PTR _oldp$34008[ebp]
	jne	SHORT $LN6@dlrealloc_

; 5235 :           check_inuse_chunk(m, newp);
; 5236 :           mem = oldmem;

	mov	edx, DWORD PTR _oldmem$[ebp]
	mov	DWORD PTR _mem$[ebp], edx
$LN6@dlrealloc_:

; 5237 :         }
; 5238 :       }
; 5239 :     }
; 5240 :   }
; 5241 :   return mem;

	mov	eax, DWORD PTR _mem$[ebp]

; 5242 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dlrealloc_in_place@@YAPAXPAXI@Z ENDP			; dlrealloc_in_place
_TEXT	ENDS
PUBLIC	?dlmemalign@@YAPAXII@Z				; dlmemalign
; Function compile flags: /Odtp
_TEXT	SEGMENT
_alignment$ = 8						; size = 4
_bytes$ = 12						; size = 4
?dlmemalign@@YAPAXII@Z PROC				; dlmemalign

; 5244 : void* dlmemalign(size_t alignment, size_t bytes) {

	push	ebp
	mov	ebp, esp

; 5245 :   if (alignment <= MALLOC_ALIGNMENT) {

	cmp	DWORD PTR _alignment$[ebp], 8
	ja	SHORT $LN1@dlmemalign

; 5246 :     return dlmalloc(bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	call	?dlmalloc@@YAPAXI@Z			; dlmalloc
	add	esp, 4
	jmp	SHORT $LN2@dlmemalign
$LN1@dlmemalign:

; 5247 :   }
; 5248 :   return internal_memalign(gm, alignment, bytes);

	mov	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _alignment$[ebp]
	push	edx
	push	OFFSET __gm_
	call	?internal_memalign@@YAPAXPAUmalloc_state@@II@Z ; internal_memalign
	add	esp, 12					; 0000000cH
$LN2@dlmemalign:

; 5249 : }

	pop	ebp
	ret	0
?dlmemalign@@YAPAXII@Z ENDP				; dlmemalign
; Function compile flags: /Odtp
tv147 = -72						; size = 4
tv134 = -68						; size = 4
tv132 = -64						; size = 4
tv87 = -60						; size = 4
tv77 = -56						; size = 4
_remainder_size$33656 = -52				; size = 4
_remainder$33657 = -48					; size = 4
_size$33644 = -44					; size = 4
_pos$33609 = -40					; size = 4
_newsize$33623 = -36					; size = 4
_br$33600 = -32						; size = 4
_newp$33619 = -28					; size = 4
_leadsize$33621 = -24					; size = 4
_p$33591 = -20						; size = 4
_nb$33557 = -16						; size = 4
_req$33581 = -12					; size = 4
_a$33541 = -8						; size = 4
_mem$ = -4						; size = 4
_m$ = 8							; size = 4
_alignment$ = 12					; size = 4
_bytes$ = 16						; size = 4
?internal_memalign@@YAPAXPAUmalloc_state@@II@Z PROC	; internal_memalign

; 4873 : static void* internal_memalign(mstate m, size_t alignment, size_t bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 4874 :   void* mem = 0;

	mov	DWORD PTR _mem$[ebp], 0

; 4875 :   if (alignment <  MIN_CHUNK_SIZE) /* must be at least a minimum chunk size */

	cmp	DWORD PTR _alignment$[ebp], 16		; 00000010H
	jae	SHORT $LN15@internal_m

; 4876 :     alignment = MIN_CHUNK_SIZE;

	mov	DWORD PTR _alignment$[ebp], 16		; 00000010H
$LN15@internal_m:

; 4877 :   if ((alignment & (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */

	mov	eax, DWORD PTR _alignment$[ebp]
	sub	eax, 1
	and	eax, DWORD PTR _alignment$[ebp]
	je	SHORT $LN14@internal_m

; 4878 :     size_t a = MALLOC_ALIGNMENT << 1;

	mov	DWORD PTR _a$33541[ebp], 16		; 00000010H
$LN13@internal_m:

; 4879 :     while (a < alignment) a <<= 1;

	mov	ecx, DWORD PTR _a$33541[ebp]
	cmp	ecx, DWORD PTR _alignment$[ebp]
	jae	SHORT $LN12@internal_m
	mov	edx, DWORD PTR _a$33541[ebp]
	shl	edx, 1
	mov	DWORD PTR _a$33541[ebp], edx
	jmp	SHORT $LN13@internal_m
$LN12@internal_m:

; 4880 :     alignment = a;

	mov	eax, DWORD PTR _a$33541[ebp]
	mov	DWORD PTR _alignment$[ebp], eax
$LN14@internal_m:

; 4881 :   }
; 4882 :   if (bytes >= MAX_REQUEST - alignment) {

	mov	ecx, -64				; ffffffc0H
	sub	ecx, DWORD PTR _alignment$[ebp]
	cmp	DWORD PTR _bytes$[ebp], ecx
	jb	SHORT $LN11@internal_m

; 4883 :     if (m != 0)  { /* Test isn't needed but avoids compiler warning */
; 4884 :       MALLOC_FAILURE_ACTION;
; 4885 :     }
; 4886 :   }
; 4887 :   else {

	jmp	$LN9@internal_m
$LN11@internal_m:

; 4888 :     size_t nb = request2size(bytes);

	cmp	DWORD PTR _bytes$[ebp], 11		; 0000000bH
	jae	SHORT $LN18@internal_m
	mov	DWORD PTR tv77[ebp], 16			; 00000010H
	jmp	SHORT $LN19@internal_m
$LN18@internal_m:
	mov	edx, DWORD PTR _bytes$[ebp]
	add	edx, 11					; 0000000bH
	and	edx, -8					; fffffff8H
	mov	DWORD PTR tv77[ebp], edx
$LN19@internal_m:
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR _nb$33557[ebp], eax

; 4889 :     size_t req = nb + alignment + MIN_CHUNK_SIZE - CHUNK_OVERHEAD;

	mov	ecx, DWORD PTR _alignment$[ebp]
	mov	edx, DWORD PTR _nb$33557[ebp]
	lea	eax, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR _req$33581[ebp], eax

; 4890 :     mem = internal_malloc(m, req);

	cmp	DWORD PTR _m$[ebp], OFFSET __gm_
	jne	SHORT $LN20@internal_m
	mov	ecx, DWORD PTR _req$33581[ebp]
	push	ecx
	call	?dlmalloc@@YAPAXI@Z			; dlmalloc
	add	esp, 4
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN21@internal_m
$LN20@internal_m:
	mov	edx, DWORD PTR _req$33581[ebp]
	push	edx
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	?mspace_malloc@@YAPAXPAXI@Z		; mspace_malloc
	add	esp, 8
	mov	DWORD PTR tv87[ebp], eax
$LN21@internal_m:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR _mem$[ebp], ecx

; 4891 :     if (mem != 0) {

	cmp	DWORD PTR _mem$[ebp], 0
	je	$LN9@internal_m

; 4892 :       mchunkptr p = mem2chunk(mem);

	mov	edx, DWORD PTR _mem$[ebp]
	sub	edx, 8
	mov	DWORD PTR _p$33591[ebp], edx

; 4893 :       if (PREACTION(m))

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 2
	je	SHORT $LN24@internal_m
	mov	edx, 1
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 448				; 000001c0H
	xchg	DWORD PTR [eax], edx
	test	edx, edx
	je	SHORT $LN22@internal_m
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, 448				; 000001c0H
	push	ecx
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN23@internal_m
$LN22@internal_m:
	mov	DWORD PTR tv132[ebp], 0
$LN23@internal_m:
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR tv134[ebp], edx
	jmp	SHORT $LN25@internal_m
$LN24@internal_m:
	mov	DWORD PTR tv134[ebp], 0
$LN25@internal_m:
	cmp	DWORD PTR tv134[ebp], 0
	je	SHORT $LN7@internal_m

; 4894 :         return 0;

	xor	eax, eax
	jmp	$LN16@internal_m
$LN7@internal_m:

; 4895 :       if ((((size_t)(mem)) & (alignment - 1)) != 0) { /* misaligned */

	mov	eax, DWORD PTR _alignment$[ebp]
	sub	eax, 1
	and	eax, DWORD PTR _mem$[ebp]
	je	$LN6@internal_m

; 4896 :         /*
; 4897 :           Find an aligned spot inside chunk.  Since we need to give
; 4898 :           back leading space in a chunk of at least MIN_CHUNK_SIZE, if
; 4899 :           the first calculation places us at a spot with less than
; 4900 :           MIN_CHUNK_SIZE leader, we can move to the next aligned spot.
; 4901 :           We've allocated enough total room so that this is always
; 4902 :           possible.
; 4903 :         */
; 4904 :         char* br = (char*)mem2chunk((size_t)(((size_t)((char*)mem + alignment -
; 4905 :                                                        SIZE_T_ONE)) &
; 4906 :                                              -alignment));

	mov	ecx, DWORD PTR _alignment$[ebp]
	mov	edx, DWORD PTR _mem$[ebp]
	lea	eax, DWORD PTR [edx+ecx-1]
	mov	ecx, DWORD PTR _alignment$[ebp]
	neg	ecx
	and	eax, ecx
	sub	eax, 8
	mov	DWORD PTR _br$33600[ebp], eax

; 4907 :         char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?
; 4908 :           br : br+alignment;

	mov	edx, DWORD PTR _br$33600[ebp]
	sub	edx, DWORD PTR _p$33591[ebp]
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN26@internal_m
	mov	eax, DWORD PTR _br$33600[ebp]
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN27@internal_m
$LN26@internal_m:
	mov	ecx, DWORD PTR _br$33600[ebp]
	add	ecx, DWORD PTR _alignment$[ebp]
	mov	DWORD PTR tv147[ebp], ecx
$LN27@internal_m:
	mov	edx, DWORD PTR tv147[ebp]
	mov	DWORD PTR _pos$33609[ebp], edx

; 4909 :         mchunkptr newp = (mchunkptr)pos;

	mov	eax, DWORD PTR _pos$33609[ebp]
	mov	DWORD PTR _newp$33619[ebp], eax

; 4910 :         size_t leadsize = pos - (char*)(p);

	mov	ecx, DWORD PTR _pos$33609[ebp]
	sub	ecx, DWORD PTR _p$33591[ebp]
	mov	DWORD PTR _leadsize$33621[ebp], ecx

; 4911 :         size_t newsize = chunksize(p) - leadsize;

	mov	edx, DWORD PTR _p$33591[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, -8					; fffffff8H
	sub	eax, DWORD PTR _leadsize$33621[ebp]
	mov	DWORD PTR _newsize$33623[ebp], eax

; 4912 : 
; 4913 :         if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */

	mov	ecx, DWORD PTR _p$33591[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 3
	jne	SHORT $LN5@internal_m

; 4914 :           newp->prev_foot = p->prev_foot + leadsize;

	mov	eax, DWORD PTR _p$33591[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _leadsize$33621[ebp]
	mov	edx, DWORD PTR _newp$33619[ebp]
	mov	DWORD PTR [edx], ecx

; 4915 :           newp->head = newsize;

	mov	eax, DWORD PTR _newp$33619[ebp]
	mov	ecx, DWORD PTR _newsize$33623[ebp]
	mov	DWORD PTR [eax+4], ecx

; 4916 :         }
; 4917 :         else { /* Otherwise, give back leader, use the rest */

	jmp	SHORT $LN4@internal_m
$LN5@internal_m:

; 4918 :           set_inuse(m, newp, newsize);

	mov	edx, DWORD PTR _newp$33619[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 1
	or	eax, DWORD PTR _newsize$33623[ebp]
	or	eax, 2
	mov	ecx, DWORD PTR _newp$33619[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _newp$33619[ebp]
	add	edx, DWORD PTR _newsize$33623[ebp]
	mov	eax, DWORD PTR [edx+4]
	or	eax, 1
	mov	ecx, DWORD PTR _newp$33619[ebp]
	add	ecx, DWORD PTR _newsize$33623[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4919 :           set_inuse(m, p, leadsize);

	mov	edx, DWORD PTR _p$33591[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 1
	or	eax, DWORD PTR _leadsize$33621[ebp]
	or	eax, 2
	mov	ecx, DWORD PTR _p$33591[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _p$33591[ebp]
	add	edx, DWORD PTR _leadsize$33621[ebp]
	mov	eax, DWORD PTR [edx+4]
	or	eax, 1
	mov	ecx, DWORD PTR _p$33591[ebp]
	add	ecx, DWORD PTR _leadsize$33621[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4920 :           dispose_chunk(m, p, leadsize);

	mov	edx, DWORD PTR _leadsize$33621[ebp]
	push	edx
	mov	eax, DWORD PTR _p$33591[ebp]
	push	eax
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	?dispose_chunk@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z ; dispose_chunk
	add	esp, 12					; 0000000cH
$LN4@internal_m:

; 4921 :         }
; 4922 :         p = newp;

	mov	edx, DWORD PTR _newp$33619[ebp]
	mov	DWORD PTR _p$33591[ebp], edx
$LN6@internal_m:

; 4923 :       }
; 4924 : 
; 4925 :       /* Give back spare room at the end */
; 4926 :       if (!is_mmapped(p)) {

	mov	eax, DWORD PTR _p$33591[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 3
	je	$LN3@internal_m

; 4927 :         size_t size = chunksize(p);

	mov	edx, DWORD PTR _p$33591[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, -8					; fffffff8H
	mov	DWORD PTR _size$33644[ebp], eax

; 4928 :         if (size > nb + MIN_CHUNK_SIZE) {

	mov	ecx, DWORD PTR _nb$33557[ebp]
	add	ecx, 16					; 00000010H
	cmp	DWORD PTR _size$33644[ebp], ecx
	jbe	SHORT $LN3@internal_m

; 4929 :           size_t remainder_size = size - nb;

	mov	edx, DWORD PTR _size$33644[ebp]
	sub	edx, DWORD PTR _nb$33557[ebp]
	mov	DWORD PTR _remainder_size$33656[ebp], edx

; 4930 :           mchunkptr remainder = chunk_plus_offset(p, nb);

	mov	eax, DWORD PTR _p$33591[ebp]
	add	eax, DWORD PTR _nb$33557[ebp]
	mov	DWORD PTR _remainder$33657[ebp], eax

; 4931 :           set_inuse(m, p, nb);

	mov	ecx, DWORD PTR _p$33591[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 1
	or	edx, DWORD PTR _nb$33557[ebp]
	or	edx, 2
	mov	eax, DWORD PTR _p$33591[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _p$33591[ebp]
	add	ecx, DWORD PTR _nb$33557[ebp]
	mov	edx, DWORD PTR [ecx+4]
	or	edx, 1
	mov	eax, DWORD PTR _p$33591[ebp]
	add	eax, DWORD PTR _nb$33557[ebp]
	mov	DWORD PTR [eax+4], edx

; 4932 :           set_inuse(m, remainder, remainder_size);

	mov	ecx, DWORD PTR _remainder$33657[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 1
	or	edx, DWORD PTR _remainder_size$33656[ebp]
	or	edx, 2
	mov	eax, DWORD PTR _remainder$33657[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _remainder$33657[ebp]
	add	ecx, DWORD PTR _remainder_size$33656[ebp]
	mov	edx, DWORD PTR [ecx+4]
	or	edx, 1
	mov	eax, DWORD PTR _remainder$33657[ebp]
	add	eax, DWORD PTR _remainder_size$33656[ebp]
	mov	DWORD PTR [eax+4], edx

; 4933 :           dispose_chunk(m, remainder, remainder_size);

	mov	ecx, DWORD PTR _remainder_size$33656[ebp]
	push	ecx
	mov	edx, DWORD PTR _remainder$33657[ebp]
	push	edx
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	?dispose_chunk@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z ; dispose_chunk
	add	esp, 12					; 0000000cH
$LN3@internal_m:

; 4934 :         }
; 4935 :       }
; 4936 : 
; 4937 :       mem = chunk2mem(p);

	mov	ecx, DWORD PTR _p$33591[ebp]
	add	ecx, 8
	mov	DWORD PTR _mem$[ebp], ecx

; 4938 :       assert (chunksize(p) >= nb);
; 4939 :       assert(((size_t)mem & (alignment - 1)) == 0);
; 4940 :       check_inuse_chunk(m, p);
; 4941 :       POSTACTION(m);

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+444]
	and	eax, 2
	je	SHORT $LN9@internal_m
	xor	ecx, ecx
	mov	edx, DWORD PTR _m$[ebp]
	add	edx, 448				; 000001c0H
	xchg	DWORD PTR [edx], ecx
$LN9@internal_m:

; 4942 :     }
; 4943 :   }
; 4944 :   return mem;

	mov	eax, DWORD PTR _mem$[ebp]
$LN16@internal_m:

; 4945 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?internal_memalign@@YAPAXPAUmalloc_state@@II@Z ENDP	; internal_memalign
_TEXT	ENDS
PUBLIC	?dlposix_memalign@@YAHPAPAXII@Z			; dlposix_memalign
; Function compile flags: /Odtp
_TEXT	SEGMENT
_d$34038 = -12						; size = 4
_r$34040 = -8						; size = 4
_mem$ = -4						; size = 4
_pp$ = 8						; size = 4
_alignment$ = 12					; size = 4
_bytes$ = 16						; size = 4
?dlposix_memalign@@YAHPAPAXII@Z PROC			; dlposix_memalign

; 5251 : int dlposix_memalign(void** pp, size_t alignment, size_t bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 5252 :   void* mem = 0;

	mov	DWORD PTR _mem$[ebp], 0

; 5253 :   if (alignment == MALLOC_ALIGNMENT)

	cmp	DWORD PTR _alignment$[ebp], 8
	jne	SHORT $LN9@dlposix_me

; 5254 :     mem = dlmalloc(bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	call	?dlmalloc@@YAPAXI@Z			; dlmalloc
	add	esp, 4
	mov	DWORD PTR _mem$[ebp], eax

; 5255 :   else {

	jmp	SHORT $LN8@dlposix_me
$LN9@dlposix_me:

; 5256 :     size_t d = alignment / sizeof(void*);

	mov	ecx, DWORD PTR _alignment$[ebp]
	shr	ecx, 2
	mov	DWORD PTR _d$34038[ebp], ecx

; 5257 :     size_t r = alignment % sizeof(void*);

	mov	eax, DWORD PTR _alignment$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	DWORD PTR _r$34040[ebp], edx

; 5258 :     if (r != 0 || d == 0 || (d & (d-SIZE_T_ONE)) != 0)

	cmp	DWORD PTR _r$34040[ebp], 0
	jne	SHORT $LN6@dlposix_me
	cmp	DWORD PTR _d$34038[ebp], 0
	je	SHORT $LN6@dlposix_me
	mov	edx, DWORD PTR _d$34038[ebp]
	sub	edx, 1
	and	edx, DWORD PTR _d$34038[ebp]
	je	SHORT $LN7@dlposix_me
$LN6@dlposix_me:

; 5259 :       return EINVAL;

	mov	eax, 22					; 00000016H
	jmp	SHORT $LN10@dlposix_me
	jmp	SHORT $LN8@dlposix_me
$LN7@dlposix_me:

; 5260 :     else if (bytes <= MAX_REQUEST - alignment) {

	mov	eax, -64				; ffffffc0H
	sub	eax, DWORD PTR _alignment$[ebp]
	cmp	DWORD PTR _bytes$[ebp], eax
	ja	SHORT $LN8@dlposix_me

; 5261 :       if (alignment <  MIN_CHUNK_SIZE)

	cmp	DWORD PTR _alignment$[ebp], 16		; 00000010H
	jae	SHORT $LN3@dlposix_me

; 5262 :         alignment = MIN_CHUNK_SIZE;

	mov	DWORD PTR _alignment$[ebp], 16		; 00000010H
$LN3@dlposix_me:

; 5263 :       mem = internal_memalign(gm, alignment, bytes);

	mov	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _alignment$[ebp]
	push	edx
	push	OFFSET __gm_
	call	?internal_memalign@@YAPAXPAUmalloc_state@@II@Z ; internal_memalign
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _mem$[ebp], eax
$LN8@dlposix_me:

; 5264 :     }
; 5265 :   }
; 5266 :   if (mem == 0)

	cmp	DWORD PTR _mem$[ebp], 0
	jne	SHORT $LN2@dlposix_me

; 5267 :     return ENOMEM;

	mov	eax, 12					; 0000000cH
	jmp	SHORT $LN10@dlposix_me

; 5268 :   else {

	jmp	SHORT $LN10@dlposix_me
$LN2@dlposix_me:

; 5269 :     *pp = mem;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [eax], ecx

; 5270 :     return 0;

	xor	eax, eax
$LN10@dlposix_me:

; 5271 :   }
; 5272 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dlposix_memalign@@YAHPAPAXII@Z ENDP			; dlposix_memalign
_TEXT	ENDS
PUBLIC	?dlvalloc@@YAPAXI@Z				; dlvalloc
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pagesz$ = -4						; size = 4
_bytes$ = 8						; size = 4
?dlvalloc@@YAPAXI@Z PROC				; dlvalloc

; 5274 : void* dlvalloc(size_t bytes) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5275 :   size_t pagesz;
; 5276 :   ensure_initialization();

	cmp	DWORD PTR _mparams, 0
	jne	SHORT $LN3@dlvalloc
	call	?init_mparams@@YAHXZ			; init_mparams
$LN3@dlvalloc:

; 5277 :   pagesz = mparams.page_size;

	mov	eax, DWORD PTR _mparams+4
	mov	DWORD PTR _pagesz$[ebp], eax

; 5278 :   return dlmemalign(pagesz, bytes);

	mov	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pagesz$[ebp]
	push	edx
	call	?dlmemalign@@YAPAXII@Z			; dlmemalign
	add	esp, 8

; 5279 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dlvalloc@@YAPAXI@Z ENDP				; dlvalloc
_TEXT	ENDS
PUBLIC	?dlpvalloc@@YAPAXI@Z				; dlpvalloc
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pagesz$ = -4						; size = 4
_bytes$ = 8						; size = 4
?dlpvalloc@@YAPAXI@Z PROC				; dlpvalloc

; 5281 : void* dlpvalloc(size_t bytes) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5282 :   size_t pagesz;
; 5283 :   ensure_initialization();

	cmp	DWORD PTR _mparams, 0
	jne	SHORT $LN3@dlpvalloc
	call	?init_mparams@@YAHXZ			; init_mparams
$LN3@dlpvalloc:

; 5284 :   pagesz = mparams.page_size;

	mov	eax, DWORD PTR _mparams+4
	mov	DWORD PTR _pagesz$[ebp], eax

; 5285 :   return dlmemalign(pagesz, (bytes + pagesz - SIZE_T_ONE) & ~(pagesz - SIZE_T_ONE));

	mov	ecx, DWORD PTR _pagesz$[ebp]
	mov	edx, DWORD PTR _bytes$[ebp]
	lea	eax, DWORD PTR [edx+ecx-1]
	mov	ecx, DWORD PTR _pagesz$[ebp]
	sub	ecx, 1
	not	ecx
	and	eax, ecx
	push	eax
	mov	edx, DWORD PTR _pagesz$[ebp]
	push	edx
	call	?dlmemalign@@YAPAXII@Z			; dlmemalign
	add	esp, 8

; 5286 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dlpvalloc@@YAPAXI@Z ENDP				; dlpvalloc
_TEXT	ENDS
PUBLIC	?dlindependent_calloc@@YAPAPAXIIPAPAX@Z		; dlindependent_calloc
; Function compile flags: /Odtp
_TEXT	SEGMENT
_sz$ = -4						; size = 4
_n_elements$ = 8					; size = 4
_elem_size$ = 12					; size = 4
_chunks$ = 16						; size = 4
?dlindependent_calloc@@YAPAPAXIIPAPAX@Z PROC		; dlindependent_calloc

; 5289 :                             void* chunks[]) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5290 :   size_t sz = elem_size; /* serves as 1-element array */

	mov	eax, DWORD PTR _elem_size$[ebp]
	mov	DWORD PTR _sz$[ebp], eax

; 5291 :   return ialloc(gm, n_elements, &sz, 3, chunks);

	mov	ecx, DWORD PTR _chunks$[ebp]
	push	ecx
	push	3
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _n_elements$[ebp]
	push	eax
	push	OFFSET __gm_
	call	?ialloc@@YAPAPAXPAUmalloc_state@@IPAIHQAPAX@Z ; ialloc
	add	esp, 20					; 00000014H

; 5292 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dlindependent_calloc@@YAPAPAXIIPAPAX@Z ENDP		; dlindependent_calloc
; Function compile flags: /Odtp
tv202 = -80						; size = 4
tv168 = -76						; size = 4
tv166 = -72						; size = 4
tv150 = -68						; size = 4
tv134 = -64						; size = 4
tv90 = -60						; size = 4
tv83 = -56						; size = 4
tv76 = -52						; size = 4
_array_chunk_size$33796 = -48				; size = 4
_element_size$ = -44					; size = 4
_mem$ = -40						; size = 4
_array_size$ = -36					; size = 4
_marray$ = -32						; size = 4
_size$ = -28						; size = 4
_contents_size$ = -24					; size = 4
_remainder_size$ = -20					; size = 4
_was_enabled$ = -16					; size = 4
_i$ = -12						; size = 4
_array_chunk$ = -8					; size = 4
_p$ = -4						; size = 4
_m$ = 8							; size = 4
_n_elements$ = 12					; size = 4
_sizes$ = 16						; size = 4
_opts$ = 20						; size = 4
_chunks$ = 24						; size = 4
?ialloc@@YAPAPAXPAUmalloc_state@@IPAIHQAPAX@Z PROC	; ialloc

; 4958 :                      void* chunks[]) {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 4959 : 
; 4960 :   size_t    element_size;   /* chunksize of each element, if all same */
; 4961 :   size_t    contents_size;  /* total size of elements */
; 4962 :   size_t    array_size;     /* request size of pointer array */
; 4963 :   void*     mem;            /* malloced aggregate space */
; 4964 :   mchunkptr p;              /* corresponding chunk */
; 4965 :   size_t    remainder_size; /* remaining bytes while splitting */
; 4966 :   void**    marray;         /* either "chunks" or malloced ptr array */
; 4967 :   mchunkptr array_chunk;    /* chunk for malloced ptr array */
; 4968 :   flag_t    was_enabled;    /* to disable mmap */
; 4969 :   size_t    size;
; 4970 :   size_t    i;
; 4971 : 
; 4972 :   ensure_initialization();

	cmp	DWORD PTR _mparams, 0
	jne	SHORT $LN25@ialloc
	call	?init_mparams@@YAHXZ			; init_mparams
$LN25@ialloc:

; 4973 :   /* compute array length, if needed */
; 4974 :   if (chunks != 0) {

	cmp	DWORD PTR _chunks$[ebp], 0
	je	SHORT $LN22@ialloc

; 4975 :     if (n_elements == 0)

	cmp	DWORD PTR _n_elements$[ebp], 0
	jne	SHORT $LN21@ialloc

; 4976 :       return chunks; /* nothing to do */

	mov	eax, DWORD PTR _chunks$[ebp]
	jmp	$LN23@ialloc
$LN21@ialloc:

; 4977 :     marray = chunks;

	mov	eax, DWORD PTR _chunks$[ebp]
	mov	DWORD PTR _marray$[ebp], eax

; 4978 :     array_size = 0;

	mov	DWORD PTR _array_size$[ebp], 0

; 4979 :   }
; 4980 :   else {

	jmp	SHORT $LN20@ialloc
$LN22@ialloc:

; 4981 :     /* if empty req, must still return chunk representing empty array */
; 4982 :     if (n_elements == 0)

	cmp	DWORD PTR _n_elements$[ebp], 0
	jne	SHORT $LN19@ialloc

; 4983 :       return (void**)internal_malloc(m, 0);

	cmp	DWORD PTR _m$[ebp], OFFSET __gm_
	jne	SHORT $LN26@ialloc
	push	0
	call	?dlmalloc@@YAPAXI@Z			; dlmalloc
	add	esp, 4
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN27@ialloc
$LN26@ialloc:
	push	0
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	?mspace_malloc@@YAPAXPAXI@Z		; mspace_malloc
	add	esp, 8
	mov	DWORD PTR tv76[ebp], eax
$LN27@ialloc:
	mov	eax, DWORD PTR tv76[ebp]
	jmp	$LN23@ialloc
$LN19@ialloc:

; 4984 :     marray = 0;

	mov	DWORD PTR _marray$[ebp], 0

; 4985 :     array_size = request2size(n_elements * (sizeof(void*)));

	mov	edx, DWORD PTR _n_elements$[ebp]
	shl	edx, 2
	cmp	edx, 11					; 0000000bH
	jae	SHORT $LN28@ialloc
	mov	DWORD PTR tv83[ebp], 16			; 00000010H
	jmp	SHORT $LN29@ialloc
$LN28@ialloc:
	mov	eax, DWORD PTR _n_elements$[ebp]
	lea	ecx, DWORD PTR [eax*4+11]
	and	ecx, -8					; fffffff8H
	mov	DWORD PTR tv83[ebp], ecx
$LN29@ialloc:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _array_size$[ebp], edx
$LN20@ialloc:

; 4986 :   }
; 4987 : 
; 4988 :   /* compute total element size */
; 4989 :   if (opts & 0x1) { /* all-same-size */

	mov	eax, DWORD PTR _opts$[ebp]
	and	eax, 1
	je	SHORT $LN18@ialloc

; 4990 :     element_size = request2size(*sizes);

	mov	ecx, DWORD PTR _sizes$[ebp]
	cmp	DWORD PTR [ecx], 11			; 0000000bH
	jae	SHORT $LN30@ialloc
	mov	DWORD PTR tv90[ebp], 16			; 00000010H
	jmp	SHORT $LN31@ialloc
$LN30@ialloc:
	mov	edx, DWORD PTR _sizes$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 11					; 0000000bH
	and	eax, -8					; fffffff8H
	mov	DWORD PTR tv90[ebp], eax
$LN31@ialloc:
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR _element_size$[ebp], ecx

; 4991 :     contents_size = n_elements * element_size;

	mov	edx, DWORD PTR _n_elements$[ebp]
	imul	edx, DWORD PTR _element_size$[ebp]
	mov	DWORD PTR _contents_size$[ebp], edx

; 4992 :   }
; 4993 :   else { /* add up all the sizes */

	jmp	SHORT $LN17@ialloc
$LN18@ialloc:

; 4994 :     element_size = 0;

	mov	DWORD PTR _element_size$[ebp], 0

; 4995 :     contents_size = 0;

	mov	DWORD PTR _contents_size$[ebp], 0

; 4996 :     for (i = 0; i != n_elements; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@ialloc
$LN15@ialloc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN16@ialloc:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _n_elements$[ebp]
	je	SHORT $LN17@ialloc

; 4997 :       contents_size += request2size(sizes[i]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _sizes$[ebp]
	cmp	DWORD PTR [eax+edx*4], 11		; 0000000bH
	jae	SHORT $LN32@ialloc
	mov	DWORD PTR tv134[ebp], 16		; 00000010H
	jmp	SHORT $LN33@ialloc
$LN32@ialloc:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _sizes$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	add	eax, 11					; 0000000bH
	and	eax, -8					; fffffff8H
	mov	DWORD PTR tv134[ebp], eax
$LN33@ialloc:
	mov	ecx, DWORD PTR _contents_size$[ebp]
	add	ecx, DWORD PTR tv134[ebp]
	mov	DWORD PTR _contents_size$[ebp], ecx
	jmp	SHORT $LN15@ialloc
$LN17@ialloc:

; 4998 :   }
; 4999 : 
; 5000 :   size = contents_size + array_size;

	mov	edx, DWORD PTR _contents_size$[ebp]
	add	edx, DWORD PTR _array_size$[ebp]
	mov	DWORD PTR _size$[ebp], edx

; 5001 : 
; 5002 :   /*
; 5003 :      Allocate the aggregate chunk.  First disable direct-mmapping so
; 5004 :      malloc won't use it, since we would not be able to later
; 5005 :      free/realloc space internal to a segregated mmap region.
; 5006 :   */
; 5007 :   was_enabled = use_mmap(m);

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 1
	mov	DWORD PTR _was_enabled$[ebp], ecx

; 5008 :   disable_mmap(m);

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+444]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+444], eax

; 5009 :   mem = internal_malloc(m, size - CHUNK_OVERHEAD);

	cmp	DWORD PTR _m$[ebp], OFFSET __gm_
	jne	SHORT $LN34@ialloc
	mov	edx, DWORD PTR _size$[ebp]
	sub	edx, 4
	push	edx
	call	?dlmalloc@@YAPAXI@Z			; dlmalloc
	add	esp, 4
	mov	DWORD PTR tv150[ebp], eax
	jmp	SHORT $LN35@ialloc
$LN34@ialloc:
	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 4
	push	eax
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	?mspace_malloc@@YAPAXPAXI@Z		; mspace_malloc
	add	esp, 8
	mov	DWORD PTR tv150[ebp], eax
$LN35@ialloc:
	mov	edx, DWORD PTR tv150[ebp]
	mov	DWORD PTR _mem$[ebp], edx

; 5010 :   if (was_enabled)

	cmp	DWORD PTR _was_enabled$[ebp], 0
	je	SHORT $LN13@ialloc

; 5011 :     enable_mmap(m);

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	or	ecx, 1
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+444], ecx
$LN13@ialloc:

; 5012 :   if (mem == 0)

	cmp	DWORD PTR _mem$[ebp], 0
	jne	SHORT $LN12@ialloc

; 5013 :     return 0;

	xor	eax, eax
	jmp	$LN23@ialloc
$LN12@ialloc:

; 5014 : 
; 5015 :   if (PREACTION(m)) return 0;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 2
	je	SHORT $LN38@ialloc
	mov	edx, 1
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 448				; 000001c0H
	xchg	DWORD PTR [eax], edx
	test	edx, edx
	je	SHORT $LN36@ialloc
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, 448				; 000001c0H
	push	ecx
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv166[ebp], eax
	jmp	SHORT $LN37@ialloc
$LN36@ialloc:
	mov	DWORD PTR tv166[ebp], 0
$LN37@ialloc:
	mov	edx, DWORD PTR tv166[ebp]
	mov	DWORD PTR tv168[ebp], edx
	jmp	SHORT $LN39@ialloc
$LN38@ialloc:
	mov	DWORD PTR tv168[ebp], 0
$LN39@ialloc:
	cmp	DWORD PTR tv168[ebp], 0
	je	SHORT $LN11@ialloc
	xor	eax, eax
	jmp	$LN23@ialloc
$LN11@ialloc:

; 5016 :   p = mem2chunk(mem);

	mov	eax, DWORD PTR _mem$[ebp]
	sub	eax, 8
	mov	DWORD PTR _p$[ebp], eax

; 5017 :   remainder_size = chunksize(p);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -8					; fffffff8H
	mov	DWORD PTR _remainder_size$[ebp], edx

; 5018 : 
; 5019 :   assert(!is_mmapped(p));
; 5020 : 
; 5021 :   if (opts & 0x2) {       /* optionally clear the elements */

	mov	eax, DWORD PTR _opts$[ebp]
	and	eax, 2
	je	SHORT $LN10@ialloc

; 5022 :     memset((size_t*)mem, 0, remainder_size - SIZE_T_SIZE - array_size);

	mov	ecx, DWORD PTR _remainder_size$[ebp]
	sub	ecx, 4
	sub	ecx, DWORD PTR _array_size$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN10@ialloc:

; 5023 :   }
; 5024 : 
; 5025 :   /* If not provided, allocate the pointer array as final part of chunk */
; 5026 :   if (marray == 0) {

	cmp	DWORD PTR _marray$[ebp], 0
	jne	SHORT $LN9@ialloc

; 5027 :     size_t  array_chunk_size;
; 5028 :     array_chunk = chunk_plus_offset(p, contents_size);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _contents_size$[ebp]
	mov	DWORD PTR _array_chunk$[ebp], eax

; 5029 :     array_chunk_size = remainder_size - contents_size;

	mov	ecx, DWORD PTR _remainder_size$[ebp]
	sub	ecx, DWORD PTR _contents_size$[ebp]
	mov	DWORD PTR _array_chunk_size$33796[ebp], ecx

; 5030 :     marray = (void**) (chunk2mem(array_chunk));

	mov	edx, DWORD PTR _array_chunk$[ebp]
	add	edx, 8
	mov	DWORD PTR _marray$[ebp], edx

; 5031 :     set_size_and_pinuse_of_inuse_chunk(m, array_chunk, array_chunk_size);

	mov	eax, DWORD PTR _array_chunk_size$33796[ebp]
	or	eax, 1
	or	eax, 2
	mov	ecx, DWORD PTR _array_chunk$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 5032 :     remainder_size = contents_size;

	mov	edx, DWORD PTR _contents_size$[ebp]
	mov	DWORD PTR _remainder_size$[ebp], edx
$LN9@ialloc:

; 5033 :   }
; 5034 : 
; 5035 :   /* split out elements */
; 5036 :   for (i = 0; ; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@ialloc
$LN7@ialloc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@ialloc:

; 5037 :     marray[i] = chunk2mem(p);

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _marray$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 5038 :     if (i != n_elements-1) {

	mov	ecx, DWORD PTR _n_elements$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	je	SHORT $LN5@ialloc

; 5039 :       if (element_size != 0)

	cmp	DWORD PTR _element_size$[ebp], 0
	je	SHORT $LN4@ialloc

; 5040 :         size = element_size;

	mov	edx, DWORD PTR _element_size$[ebp]
	mov	DWORD PTR _size$[ebp], edx

; 5041 :       else

	jmp	SHORT $LN3@ialloc
$LN4@ialloc:

; 5042 :         size = request2size(sizes[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sizes$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 11		; 0000000bH
	jae	SHORT $LN40@ialloc
	mov	DWORD PTR tv202[ebp], 16		; 00000010H
	jmp	SHORT $LN41@ialloc
$LN40@ialloc:
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _sizes$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, 11					; 0000000bH
	and	ecx, -8					; fffffff8H
	mov	DWORD PTR tv202[ebp], ecx
$LN41@ialloc:
	mov	edx, DWORD PTR tv202[ebp]
	mov	DWORD PTR _size$[ebp], edx
$LN3@ialloc:

; 5043 :       remainder_size -= size;

	mov	eax, DWORD PTR _remainder_size$[ebp]
	sub	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _remainder_size$[ebp], eax

; 5044 :       set_size_and_pinuse_of_inuse_chunk(m, p, size);

	mov	ecx, DWORD PTR _size$[ebp]
	or	ecx, 1
	or	ecx, 2
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 5045 :       p = chunk_plus_offset(p, size);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 5046 :     }
; 5047 :     else { /* the final element absorbs any overallocation slop */

	jmp	SHORT $LN2@ialloc
$LN5@ialloc:

; 5048 :       set_size_and_pinuse_of_inuse_chunk(m, p, remainder_size);

	mov	ecx, DWORD PTR _remainder_size$[ebp]
	or	ecx, 1
	or	ecx, 2
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 5049 :       break;

	jmp	SHORT $LN6@ialloc
$LN2@ialloc:

; 5050 :     }
; 5051 :   }

	jmp	$LN7@ialloc
$LN6@ialloc:

; 5052 : 
; 5053 : #if DEBUG
; 5054 :   if (marray != chunks) {
; 5055 :     /* final element must have exactly exhausted chunk */
; 5056 :     if (element_size != 0) {
; 5057 :       assert(remainder_size == element_size);
; 5058 :     }
; 5059 :     else {
; 5060 :       assert(remainder_size == request2size(sizes[i]));
; 5061 :     }
; 5062 :     check_inuse_chunk(m, mem2chunk(marray));
; 5063 :   }
; 5064 :   for (i = 0; i != n_elements; ++i)
; 5065 :     check_inuse_chunk(m, mem2chunk(marray[i]));
; 5066 : 
; 5067 : #endif /* DEBUG */
; 5068 : 
; 5069 :   POSTACTION(m);

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 2
	je	SHORT $LN1@ialloc
	xor	edx, edx
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 448				; 000001c0H
	xchg	DWORD PTR [eax], edx
$LN1@ialloc:

; 5070 :   return marray;

	mov	eax, DWORD PTR _marray$[ebp]
$LN23@ialloc:

; 5071 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ialloc@@YAPAPAXPAUmalloc_state@@IPAIHQAPAX@Z ENDP	; ialloc
_TEXT	ENDS
PUBLIC	?dlindependent_comalloc@@YAPAPAXIPAIPAPAX@Z	; dlindependent_comalloc
; Function compile flags: /Odtp
_TEXT	SEGMENT
_n_elements$ = 8					; size = 4
_sizes$ = 12						; size = 4
_chunks$ = 16						; size = 4
?dlindependent_comalloc@@YAPAPAXIPAIPAPAX@Z PROC	; dlindependent_comalloc

; 5295 :                               void* chunks[]) {

	push	ebp
	mov	ebp, esp

; 5296 :   return ialloc(gm, n_elements, sizes, 0, chunks);

	mov	eax, DWORD PTR _chunks$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _sizes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n_elements$[ebp]
	push	edx
	push	OFFSET __gm_
	call	?ialloc@@YAPAPAXPAUmalloc_state@@IPAIHQAPAX@Z ; ialloc
	add	esp, 20					; 00000014H

; 5297 : }

	pop	ebp
	ret	0
?dlindependent_comalloc@@YAPAPAXIPAIPAPAX@Z ENDP	; dlindependent_comalloc
_TEXT	ENDS
PUBLIC	?dlbulk_free@@YAIPAPAXI@Z			; dlbulk_free
; Function compile flags: /Odtp
_TEXT	SEGMENT
_array$ = 8						; size = 4
_nelem$ = 12						; size = 4
?dlbulk_free@@YAIPAPAXI@Z PROC				; dlbulk_free

; 5299 : size_t dlbulk_free(void* array[], size_t nelem) {

	push	ebp
	mov	ebp, esp

; 5300 :   return internal_bulk_free(gm, array, nelem);

	mov	eax, DWORD PTR _nelem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _array$[ebp]
	push	ecx
	push	OFFSET __gm_
	call	?internal_bulk_free@@YAIPAUmalloc_state@@QAPAXI@Z ; internal_bulk_free
	add	esp, 12					; 0000000cH

; 5301 : }

	pop	ebp
	ret	0
?dlbulk_free@@YAIPAPAXI@Z ENDP				; dlbulk_free
; Function compile flags: /Odtp
tv76 = -44						; size = 4
tv74 = -40						; size = 4
_newsize$33883 = -36					; size = 4
_b$33872 = -32						; size = 4
_next$33873 = -28					; size = 4
_psize$33867 = -24					; size = 4
_p$33863 = -20						; size = 4
_mem$33861 = -16					; size = 4
_fence$33857 = -12					; size = 4
_a$33856 = -8						; size = 4
_unfreed$ = -4						; size = 4
_m$ = 8							; size = 4
_array$ = 12						; size = 4
_nelem$ = 16						; size = 4
?internal_bulk_free@@YAIPAUmalloc_state@@QAPAXI@Z PROC	; internal_bulk_free

; 5080 : static size_t internal_bulk_free(mstate m, void* array[], size_t nelem) {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 5081 :   size_t unfreed = 0;

	mov	DWORD PTR _unfreed$[ebp], 0

; 5082 :   if (!PREACTION(m)) {

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 2
	je	SHORT $LN16@internal_b
	mov	edx, 1
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 448				; 000001c0H
	xchg	DWORD PTR [eax], edx
	test	edx, edx
	je	SHORT $LN14@internal_b
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, 448				; 000001c0H
	push	ecx
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN15@internal_b
$LN14@internal_b:
	mov	DWORD PTR tv74[ebp], 0
$LN15@internal_b:
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv76[ebp], edx
	jmp	SHORT $LN17@internal_b
$LN16@internal_b:
	mov	DWORD PTR tv76[ebp], 0
$LN17@internal_b:
	cmp	DWORD PTR tv76[ebp], 0
	jne	$LN11@internal_b

; 5083 :     void** a;
; 5084 :     void** fence = &(array[nelem]);

	mov	eax, DWORD PTR _nelem$[ebp]
	mov	ecx, DWORD PTR _array$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _fence$33857[ebp], edx

; 5085 :     for (a = array; a != fence; ++a) {

	mov	eax, DWORD PTR _array$[ebp]
	mov	DWORD PTR _a$33856[ebp], eax
	jmp	SHORT $LN10@internal_b
$LN9@internal_b:
	mov	ecx, DWORD PTR _a$33856[ebp]
	add	ecx, 4
	mov	DWORD PTR _a$33856[ebp], ecx
$LN10@internal_b:
	mov	edx, DWORD PTR _a$33856[ebp]
	cmp	edx, DWORD PTR _fence$33857[ebp]
	je	$LN8@internal_b

; 5086 :       void* mem = *a;

	mov	eax, DWORD PTR _a$33856[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mem$33861[ebp], ecx

; 5087 :       if (mem != 0) {

	cmp	DWORD PTR _mem$33861[ebp], 0
	je	$LN7@internal_b

; 5088 :         mchunkptr p = mem2chunk(mem);

	mov	edx, DWORD PTR _mem$33861[ebp]
	sub	edx, 8
	mov	DWORD PTR _p$33863[ebp], edx

; 5089 :         size_t psize = chunksize(p);

	mov	eax, DWORD PTR _p$33863[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	mov	DWORD PTR _psize$33867[ebp], ecx

; 5090 : #if FOOTERS
; 5091 :         if (get_mstate_for(p) != m) {
; 5092 :           ++unfreed;
; 5093 :           continue;
; 5094 :         }
; 5095 : #endif
; 5096 :         check_inuse_chunk(m, p);
; 5097 :         *a = 0;

	mov	edx, DWORD PTR _a$33856[ebp]
	mov	DWORD PTR [edx], 0

; 5098 :         if (RTCHECK(ok_address(m, p) && ok_inuse(p))) {

	mov	eax, 1
	test	eax, eax
	je	$LN6@internal_b

; 5099 :           void ** b = a + 1; /* try to merge with next chunk */

	mov	ecx, DWORD PTR _a$33856[ebp]
	add	ecx, 4
	mov	DWORD PTR _b$33872[ebp], ecx

; 5100 :           mchunkptr next = next_chunk(p);

	mov	edx, DWORD PTR _p$33863[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, -8					; fffffff8H
	add	eax, DWORD PTR _p$33863[ebp]
	mov	DWORD PTR _next$33873[ebp], eax

; 5101 :           if (b != fence && *b == chunk2mem(next)) {

	mov	ecx, DWORD PTR _b$33872[ebp]
	cmp	ecx, DWORD PTR _fence$33857[ebp]
	je	SHORT $LN5@internal_b
	mov	edx, DWORD PTR _next$33873[ebp]
	add	edx, 8
	mov	eax, DWORD PTR _b$33872[ebp]
	cmp	DWORD PTR [eax], edx
	jne	SHORT $LN5@internal_b

; 5102 :             size_t newsize = chunksize(next) + psize;

	mov	ecx, DWORD PTR _next$33873[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -8					; fffffff8H
	add	edx, DWORD PTR _psize$33867[ebp]
	mov	DWORD PTR _newsize$33883[ebp], edx

; 5103 :             set_inuse(m, p, newsize);

	mov	eax, DWORD PTR _p$33863[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 1
	or	ecx, DWORD PTR _newsize$33883[ebp]
	or	ecx, 2
	mov	edx, DWORD PTR _p$33863[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _p$33863[ebp]
	add	eax, DWORD PTR _newsize$33883[ebp]
	mov	ecx, DWORD PTR [eax+4]
	or	ecx, 1
	mov	edx, DWORD PTR _p$33863[ebp]
	add	edx, DWORD PTR _newsize$33883[ebp]
	mov	DWORD PTR [edx+4], ecx

; 5104 :             *b = chunk2mem(p);

	mov	eax, DWORD PTR _p$33863[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _b$33872[ebp]
	mov	DWORD PTR [ecx], eax

; 5105 :           }
; 5106 :           else

	jmp	SHORT $LN4@internal_b
$LN5@internal_b:

; 5107 :             dispose_chunk(m, p, psize);

	mov	edx, DWORD PTR _psize$33867[ebp]
	push	edx
	mov	eax, DWORD PTR _p$33863[ebp]
	push	eax
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	?dispose_chunk@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z ; dispose_chunk
	add	esp, 12					; 0000000cH
$LN4@internal_b:

; 5108 :         }
; 5109 :         else {

	jmp	SHORT $LN7@internal_b
$LN6@internal_b:

; 5110 :           CORRUPTION_ERROR_ACTION(m);

	call	DWORD PTR __imp__abort

; 5111 :           break;

	jmp	SHORT $LN8@internal_b
$LN7@internal_b:

; 5112 :         }
; 5113 :       }
; 5114 :     }

	jmp	$LN9@internal_b
$LN8@internal_b:

; 5115 :     if (should_trim(m, m->topsize))

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+28]
	jbe	SHORT $LN2@internal_b

; 5116 :       sys_trim(m, 0);

	push	0
	mov	edx, DWORD PTR _m$[ebp]
	push	edx
	call	?sys_trim@@YAHPAUmalloc_state@@I@Z	; sys_trim
	add	esp, 8
$LN2@internal_b:

; 5117 :     POSTACTION(m);

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 2
	je	SHORT $LN11@internal_b
	xor	edx, edx
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 448				; 000001c0H
	xchg	DWORD PTR [eax], edx
$LN11@internal_b:

; 5118 :   }
; 5119 :   return unfreed;

	mov	eax, DWORD PTR _unfreed$[ebp]

; 5120 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?internal_bulk_free@@YAIPAUmalloc_state@@QAPAXI@Z ENDP	; internal_bulk_free
_TEXT	ENDS
PUBLIC	?dlmalloc_trim@@YAHI@Z				; dlmalloc_trim
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv76 = -12						; size = 4
tv74 = -8						; size = 4
_result$ = -4						; size = 4
_pad$ = 8						; size = 4
?dlmalloc_trim@@YAHI@Z PROC				; dlmalloc_trim

; 5317 : int dlmalloc_trim(size_t pad) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 5318 :   int result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 5319 :   ensure_initialization();

	cmp	DWORD PTR _mparams, 0
	jne	SHORT $LN5@dlmalloc_t
	call	?init_mparams@@YAHXZ			; init_mparams
$LN5@dlmalloc_t:

; 5320 :   if (!PREACTION(gm)) {

	mov	eax, DWORD PTR __gm_+444
	and	eax, 2
	je	SHORT $LN8@dlmalloc_t
	mov	ecx, 1
	mov	edx, OFFSET __gm_+448
	xchg	DWORD PTR [edx], ecx
	test	ecx, ecx
	je	SHORT $LN6@dlmalloc_t
	push	OFFSET __gm_+448
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN7@dlmalloc_t
$LN6@dlmalloc_t:
	mov	DWORD PTR tv74[ebp], 0
$LN7@dlmalloc_t:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN9@dlmalloc_t
$LN8@dlmalloc_t:
	mov	DWORD PTR tv76[ebp], 0
$LN9@dlmalloc_t:
	cmp	DWORD PTR tv76[ebp], 0
	jne	SHORT $LN2@dlmalloc_t

; 5321 :     result = sys_trim(gm, pad);

	mov	ecx, DWORD PTR _pad$[ebp]
	push	ecx
	push	OFFSET __gm_
	call	?sys_trim@@YAHPAUmalloc_state@@I@Z	; sys_trim
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax

; 5322 :     POSTACTION(gm);

	mov	edx, DWORD PTR __gm_+444
	and	edx, 2
	je	SHORT $LN2@dlmalloc_t
	xor	eax, eax
	mov	ecx, OFFSET __gm_+448
	xchg	DWORD PTR [ecx], eax
$LN2@dlmalloc_t:

; 5323 :   }
; 5324 :   return result;

	mov	eax, DWORD PTR _result$[ebp]

; 5325 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dlmalloc_trim@@YAHI@Z ENDP				; dlmalloc_trim
_TEXT	ENDS
PUBLIC	?dlmalloc_footprint@@YAIXZ			; dlmalloc_footprint
; Function compile flags: /Odtp
_TEXT	SEGMENT
?dlmalloc_footprint@@YAIXZ PROC				; dlmalloc_footprint

; 5327 : size_t dlmalloc_footprint(void) {

	push	ebp
	mov	ebp, esp

; 5328 :   return gm->footprint;

	mov	eax, DWORD PTR __gm_+432

; 5329 : }

	pop	ebp
	ret	0
?dlmalloc_footprint@@YAIXZ ENDP				; dlmalloc_footprint
_TEXT	ENDS
PUBLIC	?dlmalloc_max_footprint@@YAIXZ			; dlmalloc_max_footprint
; Function compile flags: /Odtp
_TEXT	SEGMENT
?dlmalloc_max_footprint@@YAIXZ PROC			; dlmalloc_max_footprint

; 5331 : size_t dlmalloc_max_footprint(void) {

	push	ebp
	mov	ebp, esp

; 5332 :   return gm->max_footprint;

	mov	eax, DWORD PTR __gm_+436

; 5333 : }

	pop	ebp
	ret	0
?dlmalloc_max_footprint@@YAIXZ ENDP			; dlmalloc_max_footprint
_TEXT	ENDS
PUBLIC	?dlmalloc_footprint_limit@@YAIXZ		; dlmalloc_footprint_limit
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_maf$ = -4						; size = 4
?dlmalloc_footprint_limit@@YAIXZ PROC			; dlmalloc_footprint_limit

; 5335 : size_t dlmalloc_footprint_limit(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5336 :   size_t maf = gm->footprint_limit;

	mov	eax, DWORD PTR __gm_+440
	mov	DWORD PTR _maf$[ebp], eax

; 5337 :   return maf == 0 ? MAX_SIZE_T : maf;

	cmp	DWORD PTR _maf$[ebp], 0
	jne	SHORT $LN3@dlmalloc_f
	mov	DWORD PTR tv65[ebp], -1
	jmp	SHORT $LN4@dlmalloc_f
$LN3@dlmalloc_f:
	mov	ecx, DWORD PTR _maf$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
$LN4@dlmalloc_f:
	mov	eax, DWORD PTR tv65[ebp]

; 5338 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dlmalloc_footprint_limit@@YAIXZ ENDP			; dlmalloc_footprint_limit
_TEXT	ENDS
PUBLIC	?dlmalloc_set_footprint_limit@@YAII@Z		; dlmalloc_set_footprint_limit
; Function compile flags: /Odtp
_TEXT	SEGMENT
_result$ = -4						; size = 4
_bytes$ = 8						; size = 4
?dlmalloc_set_footprint_limit@@YAII@Z PROC		; dlmalloc_set_footprint_limit

; 5340 : size_t dlmalloc_set_footprint_limit(size_t bytes) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5341 :   size_t result;  /* invert sense of 0 */
; 5342 :   if (bytes == 0)

	cmp	DWORD PTR _bytes$[ebp], 0
	jne	SHORT $LN3@dlmalloc_s

; 5343 :     result = granularity_align(1); /* Use minimal size */

	mov	eax, DWORD PTR _mparams+8
	mov	ecx, DWORD PTR _mparams+8
	sub	ecx, 1
	not	ecx
	and	eax, ecx
	mov	DWORD PTR _result$[ebp], eax
$LN3@dlmalloc_s:

; 5344 :   if (bytes == MAX_SIZE_T)

	cmp	DWORD PTR _bytes$[ebp], -1
	jne	SHORT $LN2@dlmalloc_s

; 5345 :     result = 0;                    /* disable */

	mov	DWORD PTR _result$[ebp], 0

; 5346 :   else

	jmp	SHORT $LN1@dlmalloc_s
$LN2@dlmalloc_s:

; 5347 :     result = granularity_align(bytes);

	mov	edx, DWORD PTR _mparams+8
	mov	eax, DWORD PTR _bytes$[ebp]
	lea	ecx, DWORD PTR [eax+edx-1]
	mov	edx, DWORD PTR _mparams+8
	sub	edx, 1
	not	edx
	and	ecx, edx
	mov	DWORD PTR _result$[ebp], ecx
$LN1@dlmalloc_s:

; 5348 :   return gm->footprint_limit = result;

	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR __gm_+440, eax
	mov	eax, DWORD PTR __gm_+440

; 5349 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dlmalloc_set_footprint_limit@@YAII@Z ENDP		; dlmalloc_set_footprint_limit
_TEXT	ENDS
PUBLIC	?dlmallinfo@@YA?AUmallinfo@@XZ			; dlmallinfo
; Function compile flags: /Odtp
_TEXT	SEGMENT
$T35519 = -80						; size = 40
$T35518 = -40						; size = 40
$T35517 = 8						; size = 4
?dlmallinfo@@YA?AUmallinfo@@XZ PROC			; dlmallinfo

; 5352 : struct mallinfo dlmallinfo(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi
	push	edi

; 5353 :   return internal_mallinfo(gm);

	push	OFFSET __gm_
	lea	eax, DWORD PTR $T35519[ebp]
	push	eax
	call	?internal_mallinfo@@YA?AUmallinfo@@PAUmalloc_state@@@Z ; internal_mallinfo
	add	esp, 8
	mov	ecx, 10					; 0000000aH
	mov	esi, eax
	lea	edi, DWORD PTR $T35518[ebp]
	rep movsd
	mov	ecx, 10					; 0000000aH
	lea	esi, DWORD PTR $T35518[ebp]
	mov	edi, DWORD PTR $T35517[ebp]
	rep movsd
	mov	eax, DWORD PTR $T35517[ebp]

; 5354 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?dlmallinfo@@YA?AUmallinfo@@XZ ENDP			; dlmallinfo
; Function compile flags: /Odtp
tv134 = -80						; size = 4
tv89 = -76						; size = 4
tv79 = -72						; size = 4
tv77 = -68						; size = 4
_sz$30999 = -64						; size = 4
_q$30970 = -60						; size = 4
_sum$30965 = -56					; size = 4
_nfree$30928 = -52					; size = 4
_s$30966 = -48						; size = 4
_mfree$30930 = -44					; size = 4
_nm$ = -40						; size = 40
$T35521 = 8						; size = 4
_m$ = 12						; size = 4
?internal_mallinfo@@YA?AUmallinfo@@PAUmalloc_state@@@Z PROC ; internal_mallinfo

; 3470 : static struct mallinfo internal_mallinfo(mstate m) {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi
	push	edi

; 3471 :   struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

	mov	DWORD PTR _nm$[ebp], 0
	mov	DWORD PTR _nm$[ebp+4], 0
	mov	DWORD PTR _nm$[ebp+8], 0
	mov	DWORD PTR _nm$[ebp+12], 0
	mov	DWORD PTR _nm$[ebp+16], 0
	mov	DWORD PTR _nm$[ebp+20], 0
	mov	DWORD PTR _nm$[ebp+24], 0
	mov	DWORD PTR _nm$[ebp+28], 0
	mov	DWORD PTR _nm$[ebp+32], 0
	mov	DWORD PTR _nm$[ebp+36], 0

; 3472 :   ensure_initialization();

	cmp	DWORD PTR _mparams, 0
	jne	SHORT $LN11@internal_m@2
	call	?init_mparams@@YAHXZ			; init_mparams
$LN11@internal_m@2:

; 3473 :   if (!PREACTION(m)) {

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 2
	je	SHORT $LN14@internal_m@2
	mov	edx, 1
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 448				; 000001c0H
	xchg	DWORD PTR [eax], edx
	test	edx, edx
	je	SHORT $LN12@internal_m@2
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, 448				; 000001c0H
	push	ecx
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN13@internal_m@2
$LN12@internal_m@2:
	mov	DWORD PTR tv77[ebp], 0
$LN13@internal_m@2:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv79[ebp], edx
	jmp	SHORT $LN15@internal_m@2
$LN14@internal_m@2:
	mov	DWORD PTR tv79[ebp], 0
$LN15@internal_m@2:
	cmp	DWORD PTR tv79[ebp], 0
	jne	$LN8@internal_m@2

; 3474 :     check_malloc_state(m);
; 3475 :     if (is_initialized(m)) {

	mov	eax, DWORD PTR _m$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	$LN7@internal_m@2

; 3476 :       size_t nfree = SIZE_T_ONE; /* top always free */

	mov	DWORD PTR _nfree$30928[ebp], 1

; 3477 :       size_t mfree = m->topsize + TOP_FOOT_SIZE;

	mov	ecx, 7
	and	ecx, 8
	jne	SHORT $LN16@internal_m@2
	mov	DWORD PTR tv89[ebp], 0
	jmp	SHORT $LN17@internal_m@2
$LN16@internal_m@2:
	mov	edx, 7
	and	edx, 8
	mov	eax, 8
	sub	eax, edx
	and	eax, 7
	mov	DWORD PTR tv89[ebp], eax
$LN17@internal_m@2:
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR tv89[ebp]
	lea	ecx, DWORD PTR [eax+edx+40]
	mov	DWORD PTR _mfree$30930[ebp], ecx

; 3478 :       size_t sum = mfree;

	mov	edx, DWORD PTR _mfree$30930[ebp]
	mov	DWORD PTR _sum$30965[ebp], edx

; 3479 :       msegmentptr s = &m->seg;

	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 452				; 000001c4H
	mov	DWORD PTR _s$30966[ebp], eax
$LN6@internal_m@2:

; 3480 :       while (s != 0) {

	cmp	DWORD PTR _s$30966[ebp], 0
	je	$LN5@internal_m@2

; 3481 :         mchunkptr q = align_as_chunk(s->base);

	mov	ecx, DWORD PTR _s$30966[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 8
	and	edx, 7
	jne	SHORT $LN18@internal_m@2
	mov	DWORD PTR tv134[ebp], 0
	jmp	SHORT $LN19@internal_m@2
$LN18@internal_m@2:
	mov	eax, DWORD PTR _s$30966[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	and	ecx, 7
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv134[ebp], edx
$LN19@internal_m@2:
	mov	eax, DWORD PTR _s$30966[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR tv134[ebp]
	mov	DWORD PTR _q$30970[ebp], ecx
$LN4@internal_m@2:

; 3482 :         while (segment_holds(s, q) &&
; 3483 :                q != m->top && q->head != FENCEPOST_HEAD) {

	mov	edx, DWORD PTR _s$30966[ebp]
	mov	eax, DWORD PTR _q$30970[ebp]
	cmp	eax, DWORD PTR [edx]
	jb	SHORT $LN3@internal_m@2
	mov	ecx, DWORD PTR _s$30966[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _s$30966[ebp]
	add	edx, DWORD PTR [eax+4]
	cmp	DWORD PTR _q$30970[ebp], edx
	jae	SHORT $LN3@internal_m@2
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _q$30970[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	je	SHORT $LN3@internal_m@2
	mov	eax, DWORD PTR _q$30970[ebp]
	cmp	DWORD PTR [eax+4], 7
	je	SHORT $LN3@internal_m@2

; 3484 :           size_t sz = chunksize(q);

	mov	ecx, DWORD PTR _q$30970[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -8					; fffffff8H
	mov	DWORD PTR _sz$30999[ebp], edx

; 3485 :           sum += sz;

	mov	eax, DWORD PTR _sum$30965[ebp]
	add	eax, DWORD PTR _sz$30999[ebp]
	mov	DWORD PTR _sum$30965[ebp], eax

; 3486 :           if (!is_inuse(q)) {

	mov	ecx, DWORD PTR _q$30970[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 3
	cmp	edx, 1
	jne	SHORT $LN2@internal_m@2

; 3487 :             mfree += sz;

	mov	eax, DWORD PTR _mfree$30930[ebp]
	add	eax, DWORD PTR _sz$30999[ebp]
	mov	DWORD PTR _mfree$30930[ebp], eax

; 3488 :             ++nfree;

	mov	ecx, DWORD PTR _nfree$30928[ebp]
	add	ecx, 1
	mov	DWORD PTR _nfree$30928[ebp], ecx
$LN2@internal_m@2:

; 3489 :           }
; 3490 :           q = next_chunk(q);

	mov	edx, DWORD PTR _q$30970[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, -8					; fffffff8H
	add	eax, DWORD PTR _q$30970[ebp]
	mov	DWORD PTR _q$30970[ebp], eax

; 3491 :         }

	jmp	SHORT $LN4@internal_m@2
$LN3@internal_m@2:

; 3492 :         s = s->next;

	mov	ecx, DWORD PTR _s$30966[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _s$30966[ebp], edx

; 3493 :       }

	jmp	$LN6@internal_m@2
$LN5@internal_m@2:

; 3494 : 
; 3495 :       nm.arena    = sum;

	mov	eax, DWORD PTR _sum$30965[ebp]
	mov	DWORD PTR _nm$[ebp], eax

; 3496 :       nm.ordblks  = nfree;

	mov	ecx, DWORD PTR _nfree$30928[ebp]
	mov	DWORD PTR _nm$[ebp+4], ecx

; 3497 :       nm.hblkhd   = m->footprint - sum;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+432]
	sub	eax, DWORD PTR _sum$30965[ebp]
	mov	DWORD PTR _nm$[ebp+16], eax

; 3498 :       nm.usmblks  = m->max_footprint;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+436]
	mov	DWORD PTR _nm$[ebp+20], edx

; 3499 :       nm.uordblks = m->footprint - mfree;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+432]
	sub	ecx, DWORD PTR _mfree$30930[ebp]
	mov	DWORD PTR _nm$[ebp+28], ecx

; 3500 :       nm.fordblks = mfree;

	mov	edx, DWORD PTR _mfree$30930[ebp]
	mov	DWORD PTR _nm$[ebp+32], edx

; 3501 :       nm.keepcost = m->topsize;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _nm$[ebp+36], ecx
$LN7@internal_m@2:

; 3502 :     }
; 3503 : 
; 3504 :     POSTACTION(m);

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+444]
	and	eax, 2
	je	SHORT $LN8@internal_m@2
	xor	ecx, ecx
	mov	edx, DWORD PTR _m$[ebp]
	add	edx, 448				; 000001c0H
	xchg	DWORD PTR [edx], ecx
$LN8@internal_m@2:

; 3505 :   }
; 3506 :   return nm;

	mov	ecx, 10					; 0000000aH
	lea	esi, DWORD PTR _nm$[ebp]
	mov	edi, DWORD PTR $T35521[ebp]
	rep movsd
	mov	eax, DWORD PTR $T35521[ebp]

; 3507 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?internal_mallinfo@@YA?AUmallinfo@@PAUmalloc_state@@@Z ENDP ; internal_mallinfo
_TEXT	ENDS
PUBLIC	?dlmalloc_stats@@YAXXZ				; dlmalloc_stats
; Function compile flags: /Odtp
_TEXT	SEGMENT
?dlmalloc_stats@@YAXXZ PROC				; dlmalloc_stats

; 5358 : void dlmalloc_stats() {

	push	ebp
	mov	ebp, esp

; 5359 :   internal_malloc_stats(gm);

	push	OFFSET __gm_
	call	?internal_malloc_stats@@YAXPAUmalloc_state@@@Z ; internal_malloc_stats
	add	esp, 4

; 5360 : }

	pop	ebp
	ret	0
?dlmalloc_stats@@YAXXZ ENDP				; dlmalloc_stats
_TEXT	ENDS
EXTRN	__imp__fprintf:PROC
EXTRN	__imp____iob_func:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv137 = -36						; size = 4
tv92 = -32						; size = 4
tv79 = -28						; size = 4
tv77 = -24						; size = 4
_q$31064 = -20						; size = 4
_s$31026 = -16						; size = 4
_used$31024 = -12					; size = 4
_maxfp$31022 = -8					; size = 4
_fp$31023 = -4						; size = 4
_m$ = 8							; size = 4
?internal_malloc_stats@@YAXPAUmalloc_state@@@Z PROC	; internal_malloc_stats

; 3511 : static void internal_malloc_stats(mstate m) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 3512 :   ensure_initialization();

	cmp	DWORD PTR _mparams, 0
	jne	SHORT $LN11@internal_m@3
	call	?init_mparams@@YAHXZ			; init_mparams
$LN11@internal_m@3:

; 3513 :   if (!PREACTION(m)) {

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 2
	je	SHORT $LN14@internal_m@3
	mov	edx, 1
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 448				; 000001c0H
	xchg	DWORD PTR [eax], edx
	test	edx, edx
	je	SHORT $LN12@internal_m@3
	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, 448				; 000001c0H
	push	ecx
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN13@internal_m@3
$LN12@internal_m@3:
	mov	DWORD PTR tv77[ebp], 0
$LN13@internal_m@3:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv79[ebp], edx
	jmp	SHORT $LN15@internal_m@3
$LN14@internal_m@3:
	mov	DWORD PTR tv79[ebp], 0
$LN15@internal_m@3:
	cmp	DWORD PTR tv79[ebp], 0
	jne	$LN9@internal_m@3

; 3514 :     size_t maxfp = 0;

	mov	DWORD PTR _maxfp$31022[ebp], 0

; 3515 :     size_t fp = 0;

	mov	DWORD PTR _fp$31023[ebp], 0

; 3516 :     size_t used = 0;

	mov	DWORD PTR _used$31024[ebp], 0

; 3517 :     check_malloc_state(m);
; 3518 :     if (is_initialized(m)) {

	mov	eax, DWORD PTR _m$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	$LN7@internal_m@3

; 3519 :       msegmentptr s = &m->seg;

	mov	ecx, DWORD PTR _m$[ebp]
	add	ecx, 452				; 000001c4H
	mov	DWORD PTR _s$31026[ebp], ecx

; 3520 :       maxfp = m->max_footprint;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+436]
	mov	DWORD PTR _maxfp$31022[ebp], eax

; 3521 :       fp = m->footprint;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+432]
	mov	DWORD PTR _fp$31023[ebp], edx

; 3522 :       used = fp - (m->topsize + TOP_FOOT_SIZE);

	mov	eax, 7
	and	eax, 8
	jne	SHORT $LN16@internal_m@3
	mov	DWORD PTR tv92[ebp], 0
	jmp	SHORT $LN17@internal_m@3
$LN16@internal_m@3:
	mov	ecx, 7
	and	ecx, 8
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv92[ebp], edx
$LN17@internal_m@3:
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR tv92[ebp]
	lea	eax, DWORD PTR [ecx+edx+40]
	mov	ecx, DWORD PTR _fp$31023[ebp]
	sub	ecx, eax
	mov	DWORD PTR _used$31024[ebp], ecx
$LN6@internal_m@3:

; 3523 : 
; 3524 :       while (s != 0) {

	cmp	DWORD PTR _s$31026[ebp], 0
	je	$LN7@internal_m@3

; 3525 :         mchunkptr q = align_as_chunk(s->base);

	mov	edx, DWORD PTR _s$31026[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	and	eax, 7
	jne	SHORT $LN18@internal_m@3
	mov	DWORD PTR tv137[ebp], 0
	jmp	SHORT $LN19@internal_m@3
$LN18@internal_m@3:
	mov	ecx, DWORD PTR _s$31026[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 8
	and	edx, 7
	mov	eax, 8
	sub	eax, edx
	and	eax, 7
	mov	DWORD PTR tv137[ebp], eax
$LN19@internal_m@3:
	mov	ecx, DWORD PTR _s$31026[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR tv137[ebp]
	mov	DWORD PTR _q$31064[ebp], edx
$LN4@internal_m@3:

; 3526 :         while (segment_holds(s, q) &&
; 3527 :                q != m->top && q->head != FENCEPOST_HEAD) {

	mov	eax, DWORD PTR _s$31026[ebp]
	mov	ecx, DWORD PTR _q$31064[ebp]
	cmp	ecx, DWORD PTR [eax]
	jb	SHORT $LN3@internal_m@3
	mov	edx, DWORD PTR _s$31026[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _s$31026[ebp]
	add	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR _q$31064[ebp], eax
	jae	SHORT $LN3@internal_m@3
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _q$31064[ebp]
	cmp	eax, DWORD PTR [edx+24]
	je	SHORT $LN3@internal_m@3
	mov	ecx, DWORD PTR _q$31064[ebp]
	cmp	DWORD PTR [ecx+4], 7
	je	SHORT $LN3@internal_m@3

; 3528 :           if (!is_inuse(q))

	mov	edx, DWORD PTR _q$31064[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 3
	cmp	eax, 1
	jne	SHORT $LN2@internal_m@3

; 3529 :             used -= chunksize(q);

	mov	ecx, DWORD PTR _q$31064[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -8					; fffffff8H
	mov	eax, DWORD PTR _used$31024[ebp]
	sub	eax, edx
	mov	DWORD PTR _used$31024[ebp], eax
$LN2@internal_m@3:

; 3530 :           q = next_chunk(q);

	mov	ecx, DWORD PTR _q$31064[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -8					; fffffff8H
	add	edx, DWORD PTR _q$31064[ebp]
	mov	DWORD PTR _q$31064[ebp], edx

; 3531 :         }

	jmp	SHORT $LN4@internal_m@3
$LN3@internal_m@3:

; 3532 :         s = s->next;

	mov	eax, DWORD PTR _s$31026[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _s$31026[ebp], ecx

; 3533 :       }

	jmp	$LN6@internal_m@3
$LN7@internal_m@3:

; 3534 :     }
; 3535 :     POSTACTION(m); /* drop lock */

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+444]
	and	eax, 2
	je	SHORT $LN1@internal_m@3
	xor	ecx, ecx
	mov	edx, DWORD PTR _m$[ebp]
	add	edx, 448				; 000001c0H
	xchg	DWORD PTR [edx], ecx
$LN1@internal_m@3:

; 3536 :     fprintf(stderr, "max system bytes = %10lu\n", (unsigned long)(maxfp));

	mov	eax, DWORD PTR _maxfp$31022[ebp]
	push	eax
	push	OFFSET $SG31109
	call	DWORD PTR __imp____iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH

; 3537 :     fprintf(stderr, "system bytes     = %10lu\n", (unsigned long)(fp));

	mov	ecx, DWORD PTR _fp$31023[ebp]
	push	ecx
	push	OFFSET $SG31111
	call	DWORD PTR __imp____iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH

; 3538 :     fprintf(stderr, "in use bytes     = %10lu\n", (unsigned long)(used));

	mov	edx, DWORD PTR _used$31024[ebp]
	push	edx
	push	OFFSET $SG31113
	call	DWORD PTR __imp____iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
$LN9@internal_m@3:

; 3539 :   }
; 3540 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?internal_malloc_stats@@YAXPAUmalloc_state@@@Z ENDP	; internal_malloc_stats
_TEXT	ENDS
PUBLIC	?dlmallopt@@YAHHH@Z				; dlmallopt
; Function compile flags: /Odtp
_TEXT	SEGMENT
_param_number$ = 8					; size = 4
_value$ = 12						; size = 4
?dlmallopt@@YAHHH@Z PROC				; dlmallopt

; 5363 : int dlmallopt(int param_number, int value) {

	push	ebp
	mov	ebp, esp

; 5364 :   return change_mparam(param_number, value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _param_number$[ebp]
	push	ecx
	call	?change_mparam@@YAHHH@Z			; change_mparam
	add	esp, 8

; 5365 : }

	pop	ebp
	ret	0
?dlmallopt@@YAHHH@Z ENDP				; dlmallopt
; Function compile flags: /Odtp
tv69 = -12						; size = 4
tv68 = -8						; size = 4
_val$ = -4						; size = 4
_param_number$ = 8					; size = 4
_value$ = 12						; size = 4
?change_mparam@@YAHHH@Z PROC				; change_mparam

; 3175 : static int change_mparam(int param_number, int value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3176 :   size_t val;
; 3177 :   ensure_initialization();

	cmp	DWORD PTR _mparams, 0
	jne	SHORT $LN11@change_mpa
	call	?init_mparams@@YAHXZ			; init_mparams
$LN11@change_mpa:

; 3178 :   val = (value == -1)? MAX_SIZE_T : (size_t)value;

	cmp	DWORD PTR _value$[ebp], -1
	jne	SHORT $LN12@change_mpa
	mov	DWORD PTR tv68[ebp], -1
	jmp	SHORT $LN13@change_mpa
$LN12@change_mpa:
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR tv68[ebp], eax
$LN13@change_mpa:
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _val$[ebp], ecx

; 3179 :   switch(param_number) {

	mov	edx, DWORD PTR _param_number$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	cmp	DWORD PTR tv69[ebp], -3			; fffffffdH
	je	SHORT $LN2@change_mpa
	cmp	DWORD PTR tv69[ebp], -2			; fffffffeH
	je	SHORT $LN5@change_mpa
	cmp	DWORD PTR tv69[ebp], -1
	je	SHORT $LN6@change_mpa
	jmp	SHORT $LN1@change_mpa
$LN6@change_mpa:

; 3180 :   case M_TRIM_THRESHOLD:
; 3181 :     mparams.trim_threshold = val;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _mparams+16, eax

; 3182 :     return 1;

	mov	eax, 1
	jmp	SHORT $LN9@change_mpa
$LN5@change_mpa:

; 3183 :   case M_GRANULARITY:
; 3184 :     if (val >= mparams.page_size && ((val & (val-1)) == 0)) {

	mov	ecx, DWORD PTR _val$[ebp]
	cmp	ecx, DWORD PTR _mparams+4
	jb	SHORT $LN4@change_mpa
	mov	edx, DWORD PTR _val$[ebp]
	sub	edx, 1
	and	edx, DWORD PTR _val$[ebp]
	jne	SHORT $LN4@change_mpa

; 3185 :       mparams.granularity = val;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _mparams+8, eax

; 3186 :       return 1;

	mov	eax, 1
	jmp	SHORT $LN9@change_mpa

; 3187 :     }
; 3188 :     else

	jmp	SHORT $LN2@change_mpa
$LN4@change_mpa:

; 3189 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN9@change_mpa
$LN2@change_mpa:

; 3190 :   case M_MMAP_THRESHOLD:
; 3191 :     mparams.mmap_threshold = val;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _mparams+12, ecx

; 3192 :     return 1;

	mov	eax, 1
	jmp	SHORT $LN9@change_mpa
$LN1@change_mpa:

; 3193 :   default:
; 3194 :     return 0;

	xor	eax, eax
$LN9@change_mpa:

; 3195 :   }
; 3196 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?change_mparam@@YAHHH@Z ENDP				; change_mparam
_TEXT	ENDS
PUBLIC	?dlmalloc_usable_size@@YAIPAX@Z			; dlmalloc_usable_size
; Function compile flags: /Odtp
_TEXT	SEGMENT
_p$34146 = -4						; size = 4
_mem$ = 8						; size = 4
?dlmalloc_usable_size@@YAIPAX@Z PROC			; dlmalloc_usable_size

; 5367 : size_t dlmalloc_usable_size(void* mem) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5368 :   if (mem != 0) {

	cmp	DWORD PTR _mem$[ebp], 0
	je	SHORT $LN2@dlmalloc_u

; 5369 :     mchunkptr p = mem2chunk(mem);

	mov	eax, DWORD PTR _mem$[ebp]
	sub	eax, 8
	mov	DWORD PTR _p$34146[ebp], eax

; 5370 :     if (is_inuse(p))

	mov	ecx, DWORD PTR _p$34146[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 3
	cmp	edx, 1
	je	SHORT $LN2@dlmalloc_u

; 5371 :       return chunksize(p) - overhead_for(p);

	mov	eax, DWORD PTR _p$34146[ebp]
	mov	eax, DWORD PTR [eax+4]
	and	eax, -8					; fffffff8H
	mov	ecx, DWORD PTR _p$34146[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 3
	neg	edx
	sbb	edx, edx
	and	edx, -4					; fffffffcH
	add	edx, 8
	sub	eax, edx
	jmp	SHORT $LN3@dlmalloc_u
$LN2@dlmalloc_u:

; 5372 :   }
; 5373 :   return 0;

	xor	eax, eax
$LN3@dlmalloc_u:

; 5374 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dlmalloc_usable_size@@YAIPAX@Z ENDP			; dlmalloc_usable_size
_TEXT	ENDS
PUBLIC	?create_mspace@@YAPAXIH@Z			; create_mspace
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv142 = -36						; size = 4
tv85 = -32						; size = 4
tv90 = -28						; size = 4
tv72 = -24						; size = 4
_tsize$34337 = -20					; size = 4
_tbase$34340 = -16					; size = 4
_rs$34302 = -12						; size = 4
_m$ = -8						; size = 4
_msize$ = -4						; size = 4
_capacity$ = 8						; size = 4
_locked$ = 12						; size = 4
?create_mspace@@YAPAXIH@Z PROC				; create_mspace

; 5405 : mspace create_mspace(size_t capacity, int locked) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 5406 :   mstate m = 0;

	mov	DWORD PTR _m$[ebp], 0

; 5407 :   size_t msize;
; 5408 :   ensure_initialization();

	cmp	DWORD PTR _mparams, 0
	jne	SHORT $LN5@create_msp
	call	?init_mparams@@YAHXZ			; init_mparams
$LN5@create_msp:

; 5409 :   msize = pad_request(sizeof(struct malloc_state));

	mov	DWORD PTR _msize$[ebp], 480		; 000001e0H

; 5410 :   if (capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {

	mov	eax, 7
	and	eax, 8
	jne	SHORT $LN6@create_msp
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN7@create_msp
$LN6@create_msp:
	mov	ecx, 7
	and	ecx, 8
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv72[ebp], edx
$LN7@create_msp:
	mov	eax, DWORD PTR tv72[ebp]
	mov	ecx, DWORD PTR _msize$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	add	edx, DWORD PTR _mparams+4
	neg	edx
	cmp	DWORD PTR _capacity$[ebp], edx
	jae	$LN2@create_msp

; 5411 :     size_t rs = ((capacity == 0)? mparams.granularity :
; 5412 :                  (capacity + TOP_FOOT_SIZE + msize));

	cmp	DWORD PTR _capacity$[ebp], 0
	jne	SHORT $LN10@create_msp
	mov	eax, DWORD PTR _mparams+8
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN11@create_msp
$LN10@create_msp:
	mov	ecx, 7
	and	ecx, 8
	jne	SHORT $LN8@create_msp
	mov	DWORD PTR tv85[ebp], 0
	jmp	SHORT $LN9@create_msp
$LN8@create_msp:
	mov	edx, 7
	and	edx, 8
	mov	eax, 8
	sub	eax, edx
	and	eax, 7
	mov	DWORD PTR tv85[ebp], eax
$LN9@create_msp:
	mov	ecx, DWORD PTR tv85[ebp]
	mov	edx, DWORD PTR _capacity$[ebp]
	lea	eax, DWORD PTR [edx+ecx+40]
	add	eax, DWORD PTR _msize$[ebp]
	mov	DWORD PTR tv90[ebp], eax
$LN11@create_msp:
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR _rs$34302[ebp], ecx

; 5413 :     size_t tsize = granularity_align(rs);

	mov	edx, DWORD PTR _mparams+8
	mov	eax, DWORD PTR _rs$34302[ebp]
	lea	ecx, DWORD PTR [eax+edx-1]
	mov	edx, DWORD PTR _mparams+8
	sub	edx, 1
	not	edx
	and	ecx, edx
	mov	DWORD PTR _tsize$34337[ebp], ecx

; 5414 :     char* tbase = (char*)(CALL_MMAP(tsize));

	mov	eax, DWORD PTR _tsize$34337[ebp]
	push	eax
	call	?win32mmap@@YAPAXI@Z			; win32mmap
	add	esp, 4
	mov	DWORD PTR _tbase$34340[ebp], eax

; 5415 :     if (tbase != CMFAIL) {

	cmp	DWORD PTR _tbase$34340[ebp], -1
	je	SHORT $LN2@create_msp

; 5416 :       m = init_user_mstate(tbase, tsize);

	mov	ecx, DWORD PTR _tsize$34337[ebp]
	push	ecx
	mov	edx, DWORD PTR _tbase$34340[ebp]
	push	edx
	call	?init_user_mstate@@YAPAUmalloc_state@@PADI@Z ; init_user_mstate
	add	esp, 8
	mov	DWORD PTR _m$[ebp], eax

; 5417 :       m->seg.sflags = USE_MMAP_BIT;

	mov	eax, DWORD PTR _m$[ebp]
	mov	DWORD PTR [eax+464], 1

; 5418 :       set_lock(m, locked);

	cmp	DWORD PTR _locked$[ebp], 0
	je	SHORT $LN12@create_msp
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+444]
	or	edx, 2
	mov	DWORD PTR tv142[ebp], edx
	jmp	SHORT $LN13@create_msp
$LN12@create_msp:
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, -3					; fffffffdH
	mov	DWORD PTR tv142[ebp], ecx
$LN13@create_msp:
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR [edx+444], eax
$LN2@create_msp:

; 5419 :     }
; 5420 :   }
; 5421 :   return (mspace)m;

	mov	eax, DWORD PTR _m$[ebp]

; 5422 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?create_mspace@@YAPAXIH@Z ENDP				; create_mspace
; Function compile flags: /Odtp
tv140 = -24						; size = 4
tv71 = -20						; size = 4
_m$ = -16						; size = 4
_msp$ = -12						; size = 4
_msize$ = -8						; size = 4
_mn$ = -4						; size = 4
_tbase$ = 8						; size = 4
_tsize$ = 12						; size = 4
?init_user_mstate@@YAPAUmalloc_state@@PADI@Z PROC	; init_user_mstate

; 5382 : static mstate init_user_mstate(char* tbase, size_t tsize) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 5383 :   size_t msize = pad_request(sizeof(struct malloc_state));

	mov	DWORD PTR _msize$[ebp], 480		; 000001e0H

; 5384 :   mchunkptr mn;
; 5385 :   mchunkptr msp = align_as_chunk(tbase);

	mov	eax, DWORD PTR _tbase$[ebp]
	add	eax, 8
	and	eax, 7
	jne	SHORT $LN3@init_user_
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN4@init_user_
$LN3@init_user_:
	mov	ecx, DWORD PTR _tbase$[ebp]
	add	ecx, 8
	and	ecx, 7
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv71[ebp], edx
$LN4@init_user_:
	mov	eax, DWORD PTR _tbase$[ebp]
	add	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR _msp$[ebp], eax

; 5386 :   mstate m = (mstate)(chunk2mem(msp));

	mov	ecx, DWORD PTR _msp$[ebp]
	add	ecx, 8
	mov	DWORD PTR _m$[ebp], ecx

; 5387 :   memset(m, 0, msize);

	mov	edx, DWORD PTR _msize$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 5388 :   (void)INITIAL_LOCK(&m->mutex);

	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+448], 0

; 5389 :   msp->head = (msize|INUSE_BITS);

	mov	edx, DWORD PTR _msize$[ebp]
	or	edx, 3
	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR [eax+4], edx

; 5390 :   m->seg.base = m->least_addr = tbase;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _tbase$[ebp]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _tbase$[ebp]
	mov	DWORD PTR [eax+452], ecx

; 5391 :   m->seg.size = m->footprint = m->max_footprint = tsize;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _tsize$[ebp]
	mov	DWORD PTR [edx+436], eax
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR _tsize$[ebp]
	mov	DWORD PTR [ecx+432], edx
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _tsize$[ebp]
	mov	DWORD PTR [eax+456], ecx

; 5392 :   m->magic = mparams.magic;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _mparams
	mov	DWORD PTR [edx+36], eax

; 5393 :   m->release_checks = MAX_RELEASE_CHECK_RATE;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+32], 4095		; 00000fffH

; 5394 :   m->mflags = mparams.default_mflags;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _mparams+20
	mov	DWORD PTR [edx+444], eax

; 5395 :   m->extp = 0;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+468], 0

; 5396 :   m->exts = 0;

	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+472], 0

; 5397 :   disable_contiguous(m);

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	or	ecx, 4
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+444], ecx

; 5398 :   init_bins(m);

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	?init_bins@@YAXPAUmalloc_state@@@Z	; init_bins
	add	esp, 4

; 5399 :   mn = next_chunk(mem2chunk(m));

	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	and	edx, -8					; fffffff8H
	mov	eax, DWORD PTR _m$[ebp]
	lea	ecx, DWORD PTR [eax+edx-8]
	mov	DWORD PTR _mn$[ebp], ecx

; 5400 :   init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) - TOP_FOOT_SIZE);

	mov	edx, 7
	and	edx, 8
	jne	SHORT $LN5@init_user_
	mov	DWORD PTR tv140[ebp], 0
	jmp	SHORT $LN6@init_user_
$LN5@init_user_:
	mov	eax, 7
	and	eax, 8
	mov	ecx, 8
	sub	ecx, eax
	and	ecx, 7
	mov	DWORD PTR tv140[ebp], ecx
$LN6@init_user_:
	mov	edx, DWORD PTR _tbase$[ebp]
	add	edx, DWORD PTR _tsize$[ebp]
	sub	edx, DWORD PTR _mn$[ebp]
	mov	eax, DWORD PTR tv140[ebp]
	add	eax, 40					; 00000028H
	sub	edx, eax
	push	edx
	mov	ecx, DWORD PTR _mn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _m$[ebp]
	push	edx
	call	?init_top@@YAXPAUmalloc_state@@PAUmalloc_chunk@@I@Z ; init_top
	add	esp, 12					; 0000000cH

; 5401 :   check_top_chunk(m, m->top);
; 5402 :   return m;

	mov	eax, DWORD PTR _m$[ebp]

; 5403 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?init_user_mstate@@YAPAUmalloc_state@@PADI@Z ENDP	; init_user_mstate
_TEXT	ENDS
PUBLIC	?create_mspace_with_base@@YAPAXPAXIH@Z		; create_mspace_with_base
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv132 = -20						; size = 4
tv82 = -16						; size = 4
tv72 = -12						; size = 4
_m$ = -8						; size = 4
_msize$ = -4						; size = 4
_base$ = 8						; size = 4
_capacity$ = 12						; size = 4
_locked$ = 16						; size = 4
?create_mspace_with_base@@YAPAXPAXIH@Z PROC		; create_mspace_with_base

; 5424 : mspace create_mspace_with_base(void* base, size_t capacity, int locked) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 5425 :   mstate m = 0;

	mov	DWORD PTR _m$[ebp], 0

; 5426 :   size_t msize;
; 5427 :   ensure_initialization();

	cmp	DWORD PTR _mparams, 0
	jne	SHORT $LN4@create_msp@2
	call	?init_mparams@@YAHXZ			; init_mparams
$LN4@create_msp@2:

; 5428 :   msize = pad_request(sizeof(struct malloc_state));

	mov	DWORD PTR _msize$[ebp], 480		; 000001e0H

; 5429 :   if (capacity > msize + TOP_FOOT_SIZE &&
; 5430 :       capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {

	mov	eax, 7
	and	eax, 8
	jne	SHORT $LN5@create_msp@2
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN6@create_msp@2
$LN5@create_msp@2:
	mov	ecx, 7
	and	ecx, 8
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv72[ebp], edx
$LN6@create_msp@2:
	mov	eax, DWORD PTR tv72[ebp]
	mov	ecx, DWORD PTR _msize$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	cmp	DWORD PTR _capacity$[ebp], edx
	jbe	$LN1@create_msp@2
	mov	eax, 7
	and	eax, 8
	jne	SHORT $LN7@create_msp@2
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $LN8@create_msp@2
$LN7@create_msp@2:
	mov	ecx, 7
	and	ecx, 8
	mov	edx, 8
	sub	edx, ecx
	and	edx, 7
	mov	DWORD PTR tv82[ebp], edx
$LN8@create_msp@2:
	mov	eax, DWORD PTR tv82[ebp]
	mov	ecx, DWORD PTR _msize$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	add	edx, DWORD PTR _mparams+4
	neg	edx
	cmp	DWORD PTR _capacity$[ebp], edx
	jae	SHORT $LN1@create_msp@2

; 5431 :     m = init_user_mstate((char*)base, capacity);

	mov	eax, DWORD PTR _capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _base$[ebp]
	push	ecx
	call	?init_user_mstate@@YAPAUmalloc_state@@PADI@Z ; init_user_mstate
	add	esp, 8
	mov	DWORD PTR _m$[ebp], eax

; 5432 :     m->seg.sflags = EXTERN_BIT;

	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+464], 8

; 5433 :     set_lock(m, locked);

	cmp	DWORD PTR _locked$[ebp], 0
	je	SHORT $LN9@create_msp@2
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	or	ecx, 2
	mov	DWORD PTR tv132[ebp], ecx
	jmp	SHORT $LN10@create_msp@2
$LN9@create_msp@2:
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+444]
	and	eax, -3					; fffffffdH
	mov	DWORD PTR tv132[ebp], eax
$LN10@create_msp@2:
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR [ecx+444], edx
$LN1@create_msp@2:

; 5434 :   }
; 5435 :   return (mspace)m;

	mov	eax, DWORD PTR _m$[ebp]

; 5436 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?create_mspace_with_base@@YAPAXPAXIH@Z ENDP		; create_mspace_with_base
_TEXT	ENDS
PUBLIC	?mspace_track_large_chunks@@YAHPAXH@Z		; mspace_track_large_chunks
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv76 = -16						; size = 4
tv74 = -12						; size = 4
_ret$ = -8						; size = 4
_ms$ = -4						; size = 4
_msp$ = 8						; size = 4
_enable$ = 12						; size = 4
?mspace_track_large_chunks@@YAHPAXH@Z PROC		; mspace_track_large_chunks

; 5438 : int mspace_track_large_chunks(mspace msp, int enable) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 5439 :   int ret = 0;

	mov	DWORD PTR _ret$[ebp], 0

; 5440 :   mstate ms = (mstate)msp;

	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _ms$[ebp], eax

; 5441 :   if (!PREACTION(ms)) {

	mov	ecx, DWORD PTR _ms$[ebp]
	mov	edx, DWORD PTR [ecx+444]
	and	edx, 2
	je	SHORT $LN10@mspace_tra
	mov	eax, 1
	mov	ecx, DWORD PTR _ms$[ebp]
	add	ecx, 448				; 000001c0H
	xchg	DWORD PTR [ecx], eax
	test	eax, eax
	je	SHORT $LN8@mspace_tra
	mov	edx, DWORD PTR _ms$[ebp]
	add	edx, 448				; 000001c0H
	push	edx
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN9@mspace_tra
$LN8@mspace_tra:
	mov	DWORD PTR tv74[ebp], 0
$LN9@mspace_tra:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN11@mspace_tra
$LN10@mspace_tra:
	mov	DWORD PTR tv76[ebp], 0
$LN11@mspace_tra:
	cmp	DWORD PTR tv76[ebp], 0
	jne	SHORT $LN5@mspace_tra

; 5442 :     if (!use_mmap(ms)) {

	mov	ecx, DWORD PTR _ms$[ebp]
	mov	edx, DWORD PTR [ecx+444]
	and	edx, 1
	jne	SHORT $LN4@mspace_tra

; 5443 :       ret = 1;

	mov	DWORD PTR _ret$[ebp], 1
$LN4@mspace_tra:

; 5444 :     }
; 5445 :     if (!enable) {

	cmp	DWORD PTR _enable$[ebp], 0
	jne	SHORT $LN3@mspace_tra

; 5446 :       enable_mmap(ms);

	mov	eax, DWORD PTR _ms$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	or	ecx, 1
	mov	edx, DWORD PTR _ms$[ebp]
	mov	DWORD PTR [edx+444], ecx

; 5447 :     } else {

	jmp	SHORT $LN2@mspace_tra
$LN3@mspace_tra:

; 5448 :       disable_mmap(ms);

	mov	eax, DWORD PTR _ms$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _ms$[ebp]
	mov	DWORD PTR [edx+444], ecx
$LN2@mspace_tra:

; 5449 :     }
; 5450 :     POSTACTION(ms);

	mov	eax, DWORD PTR _ms$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 2
	je	SHORT $LN5@mspace_tra
	xor	edx, edx
	mov	eax, DWORD PTR _ms$[ebp]
	add	eax, 448				; 000001c0H
	xchg	DWORD PTR [eax], edx
$LN5@mspace_tra:

; 5451 :   }
; 5452 :   return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 5453 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_track_large_chunks@@YAHPAXH@Z ENDP		; mspace_track_large_chunks
_TEXT	ENDS
PUBLIC	?destroy_mspace@@YAIPAX@Z			; destroy_mspace
; Function compile flags: /Odtp
_TEXT	SEGMENT
_flag$34469 = -24					; size = 4
_size$34468 = -20					; size = 4
_base$34467 = -16					; size = 4
_sp$34462 = -12						; size = 4
_ms$ = -8						; size = 4
_freed$ = -4						; size = 4
_msp$ = 8						; size = 4
?destroy_mspace@@YAIPAX@Z PROC				; destroy_mspace

; 5455 : size_t destroy_mspace(mspace msp) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 5456 :   size_t freed = 0;

	mov	DWORD PTR _freed$[ebp], 0

; 5457 :   mstate ms = (mstate)msp;

	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _ms$[ebp], eax

; 5458 :   if (ok_magic(ms)) {

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN5@destroy_ms

; 5459 :     msegmentptr sp = &ms->seg;

	mov	edx, DWORD PTR _ms$[ebp]
	add	edx, 452				; 000001c4H
	mov	DWORD PTR _sp$34462[ebp], edx
$LN4@destroy_ms:

; 5460 :     (void)DESTROY_LOCK(&ms->mutex); /* destroy before unmapped */
; 5461 :     while (sp != 0) {

	cmp	DWORD PTR _sp$34462[ebp], 0
	je	SHORT $LN3@destroy_ms

; 5462 :       char* base = sp->base;

	mov	eax, DWORD PTR _sp$34462[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _base$34467[ebp], ecx

; 5463 :       size_t size = sp->size;

	mov	edx, DWORD PTR _sp$34462[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _size$34468[ebp], eax

; 5464 :       flag_t flag = sp->sflags;

	mov	ecx, DWORD PTR _sp$34462[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _flag$34469[ebp], edx

; 5465 :       (void)base; /* placate people compiling -Wunused-variable */
; 5466 :       sp = sp->next;

	mov	eax, DWORD PTR _sp$34462[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _sp$34462[ebp], ecx

; 5467 :       if ((flag & USE_MMAP_BIT) && !(flag & EXTERN_BIT) &&
; 5468 :           CALL_MUNMAP(base, size) == 0)

	mov	edx, DWORD PTR _flag$34469[ebp]
	and	edx, 1
	je	SHORT $LN2@destroy_ms
	mov	eax, DWORD PTR _flag$34469[ebp]
	and	eax, 8
	jne	SHORT $LN2@destroy_ms
	mov	ecx, DWORD PTR _size$34468[ebp]
	push	ecx
	mov	edx, DWORD PTR _base$34467[ebp]
	push	edx
	call	?win32munmap@@YAHPAXI@Z			; win32munmap
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@destroy_ms

; 5469 :         freed += size;

	mov	eax, DWORD PTR _freed$[ebp]
	add	eax, DWORD PTR _size$34468[ebp]
	mov	DWORD PTR _freed$[ebp], eax
$LN2@destroy_ms:

; 5470 :     }

	jmp	SHORT $LN4@destroy_ms
$LN3@destroy_ms:

; 5471 :   }
; 5472 :   else {

	jmp	SHORT $LN1@destroy_ms
$LN5@destroy_ms:

; 5473 :     USAGE_ERROR_ACTION(ms,ms);

	call	DWORD PTR __imp__abort
$LN1@destroy_ms:

; 5474 :   }
; 5475 :   return freed;

	mov	eax, DWORD PTR _freed$[ebp]

; 5476 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?destroy_mspace@@YAIPAX@Z ENDP				; destroy_mspace
; Function compile flags: /Odtp
tv84 = -128						; size = 4
tv77 = -124						; size = 4
tv75 = -120						; size = 4
_r$34661 = -116						; size = 4
_rsize$34659 = -112					; size = 4
_p$34660 = -108						; size = 4
_dvs$34647 = -104					; size = 4
_r$34638 = -100						; size = 4
_rsize$34628 = -96					; size = 4
_p$34629 = -92						; size = 4
_I$34588 = -88						; size = 4
_F$34593 = -84						; size = 4
_B$34590 = -80						; size = 4
_DV$34587 = -76						; size = 4
_DVS$34585 = -72					; size = 4
_F$34557 = -68						; size = 4
_J$34552 = -64						; size = 4
_r$34545 = -60						; size = 4
_leastbit$34551 = -56					; size = 4
_leftbits$34548 = -52					; size = 4
_b$34543 = -48						; size = 4
_rsize$34546 = -44					; size = 4
_i$34547 = -40						; size = 4
_p$34544 = -36						; size = 4
_F$34524 = -32						; size = 4
_b$34520 = -28						; size = 4
_p$34521 = -24						; size = 4
_smallbits$34494 = -20					; size = 4
_idx$34493 = -16					; size = 4
_nb$34485 = -12						; size = 4
_mem$34484 = -8						; size = 4
_ms$ = -4						; size = 4
_msp$ = 8						; size = 4
_bytes$ = 12						; size = 4
?mspace_malloc@@YAPAXPAXI@Z PROC			; mspace_malloc

; 5483 : void* mspace_malloc(mspace msp, size_t bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	esi

; 5484 :   mstate ms = (mstate)msp;

	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _ms$[ebp], eax

; 5485 :   if (!ok_magic(ms)) {

	xor	ecx, ecx
	je	SHORT $LN40@mspace_mal

; 5486 :     USAGE_ERROR_ACTION(ms,ms);

	call	DWORD PTR __imp__abort

; 5487 :     return 0;

	xor	eax, eax
	jmp	$LN41@mspace_mal
$LN40@mspace_mal:

; 5488 :   }
; 5489 :   if (!PREACTION(ms)) {

	mov	edx, DWORD PTR _ms$[ebp]
	mov	eax, DWORD PTR [edx+444]
	and	eax, 2
	je	SHORT $LN45@mspace_mal
	mov	ecx, 1
	mov	edx, DWORD PTR _ms$[ebp]
	add	edx, 448				; 000001c0H
	xchg	DWORD PTR [edx], ecx
	test	ecx, ecx
	je	SHORT $LN43@mspace_mal
	mov	eax, DWORD PTR _ms$[ebp]
	add	eax, 448				; 000001c0H
	push	eax
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN44@mspace_mal
$LN43@mspace_mal:
	mov	DWORD PTR tv75[ebp], 0
$LN44@mspace_mal:
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR tv77[ebp], ecx
	jmp	SHORT $LN46@mspace_mal
$LN45@mspace_mal:
	mov	DWORD PTR tv77[ebp], 0
$LN46@mspace_mal:
	cmp	DWORD PTR tv77[ebp], 0
	jne	$LN39@mspace_mal

; 5490 :     void* mem;
; 5491 :     size_t nb;
; 5492 :     if (bytes <= MAX_SMALL_REQUEST) {

	cmp	DWORD PTR _bytes$[ebp], 244		; 000000f4H
	ja	$LN38@mspace_mal

; 5493 :       bindex_t idx;
; 5494 :       binmap_t smallbits;
; 5495 :       nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);

	cmp	DWORD PTR _bytes$[ebp], 11		; 0000000bH
	jae	SHORT $LN47@mspace_mal
	mov	DWORD PTR tv84[ebp], 16			; 00000010H
	jmp	SHORT $LN48@mspace_mal
$LN47@mspace_mal:
	mov	edx, DWORD PTR _bytes$[ebp]
	add	edx, 11					; 0000000bH
	and	edx, -8					; fffffff8H
	mov	DWORD PTR tv84[ebp], edx
$LN48@mspace_mal:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR _nb$34485[ebp], eax

; 5496 :       idx = small_index(nb);

	mov	ecx, DWORD PTR _nb$34485[ebp]
	shr	ecx, 3
	mov	DWORD PTR _idx$34493[ebp], ecx

; 5497 :       smallbits = ms->smallmap >> idx;

	mov	edx, DWORD PTR _ms$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _idx$34493[ebp]
	shr	eax, cl
	mov	DWORD PTR _smallbits$34494[ebp], eax

; 5498 : 
; 5499 :       if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */

	mov	ecx, DWORD PTR _smallbits$34494[ebp]
	and	ecx, 3
	je	$LN37@mspace_mal

; 5500 :         mchunkptr b, p;
; 5501 :         idx += ~smallbits & 1;       /* Uses next bin if idx empty */

	mov	edx, DWORD PTR _smallbits$34494[ebp]
	not	edx
	and	edx, 1
	add	edx, DWORD PTR _idx$34493[ebp]
	mov	DWORD PTR _idx$34493[ebp], edx

; 5502 :         b = smallbin_at(ms, idx);

	mov	eax, DWORD PTR _idx$34493[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _ms$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+40]
	mov	DWORD PTR _b$34520[ebp], edx

; 5503 :         p = b->fd;

	mov	eax, DWORD PTR _b$34520[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _p$34521[ebp], ecx

; 5504 :         assert(chunksize(p) == small_index2size(idx));
; 5505 :         unlink_first_small_chunk(ms, b, p, idx);

	mov	edx, DWORD PTR _p$34521[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _F$34524[ebp], eax
	mov	ecx, DWORD PTR _b$34520[ebp]
	cmp	ecx, DWORD PTR _F$34524[ebp]
	jne	SHORT $LN36@mspace_mal
	mov	edx, 1
	mov	ecx, DWORD PTR _idx$34493[ebp]
	shl	edx, cl
	not	edx
	mov	eax, DWORD PTR _ms$[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ms$[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN35@mspace_mal
$LN36@mspace_mal:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN34@mspace_mal
	mov	eax, DWORD PTR _F$34524[ebp]
	mov	ecx, DWORD PTR _b$34520[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _b$34520[ebp]
	mov	eax, DWORD PTR _F$34524[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN35@mspace_mal
$LN34@mspace_mal:
	call	DWORD PTR __imp__abort
$LN35@mspace_mal:

; 5506 :         set_inuse_and_pinuse(ms, p, small_index2size(idx));

	mov	ecx, DWORD PTR _idx$34493[ebp]
	shl	ecx, 3
	or	ecx, 1
	or	ecx, 2
	mov	edx, DWORD PTR _p$34521[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _idx$34493[ebp]
	mov	ecx, DWORD PTR _p$34521[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	or	edx, 1
	mov	eax, DWORD PTR _idx$34493[ebp]
	mov	ecx, DWORD PTR _p$34521[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 5507 :         mem = chunk2mem(p);

	mov	edx, DWORD PTR _p$34521[ebp]
	add	edx, 8
	mov	DWORD PTR _mem$34484[ebp], edx
	jmp	$postaction$34538

; 5508 :         check_malloced_chunk(ms, mem, nb);
; 5509 :         goto postaction;

	jmp	$postaction$34538
	jmp	$LN31@mspace_mal
$LN37@mspace_mal:

; 5510 :       }
; 5511 : 
; 5512 :       else if (nb > ms->dvsize) {

	mov	eax, DWORD PTR _ms$[ebp]
	mov	ecx, DWORD PTR _nb$34485[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jbe	$LN31@mspace_mal

; 5513 :         if (smallbits != 0) { /* Use chunk in next nonempty smallbin */

	cmp	DWORD PTR _smallbits$34494[ebp], 0
	je	$LN29@mspace_mal

; 5514 :           mchunkptr b, p, r;
; 5515 :           size_t rsize;
; 5516 :           bindex_t i;
; 5517 :           binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));

	mov	edx, DWORD PTR _smallbits$34494[ebp]
	mov	ecx, DWORD PTR _idx$34493[ebp]
	shl	edx, cl
	mov	eax, 1
	mov	ecx, DWORD PTR _idx$34493[ebp]
	shl	eax, cl
	shl	eax, 1
	mov	esi, 1
	mov	ecx, DWORD PTR _idx$34493[ebp]
	shl	esi, cl
	shl	esi, 1
	neg	esi
	or	eax, esi
	and	edx, eax
	mov	DWORD PTR _leftbits$34548[ebp], edx

; 5518 :           binmap_t leastbit = least_bit(leftbits);

	mov	ecx, DWORD PTR _leftbits$34548[ebp]
	neg	ecx
	and	ecx, DWORD PTR _leftbits$34548[ebp]
	mov	DWORD PTR _leastbit$34551[ebp], ecx

; 5519 :           compute_bit2idx(leastbit, i);

	mov	edx, DWORD PTR _leastbit$34551[ebp]
	bsf	eax, edx
	mov	DWORD PTR _J$34552[ebp], eax
	mov	ecx, DWORD PTR _J$34552[ebp]
	mov	DWORD PTR _i$34547[ebp], ecx

; 5520 :           b = smallbin_at(ms, i);

	mov	edx, DWORD PTR _i$34547[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _ms$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+40]
	mov	DWORD PTR _b$34543[ebp], ecx

; 5521 :           p = b->fd;

	mov	edx, DWORD PTR _b$34543[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _p$34544[ebp], eax

; 5522 :           assert(chunksize(p) == small_index2size(i));
; 5523 :           unlink_first_small_chunk(ms, b, p, i);

	mov	ecx, DWORD PTR _p$34544[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _F$34557[ebp], edx
	mov	eax, DWORD PTR _b$34543[ebp]
	cmp	eax, DWORD PTR _F$34557[ebp]
	jne	SHORT $LN28@mspace_mal
	mov	edx, 1
	mov	ecx, DWORD PTR _i$34547[ebp]
	shl	edx, cl
	not	edx
	mov	eax, DWORD PTR _ms$[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ms$[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN27@mspace_mal
$LN28@mspace_mal:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN26@mspace_mal
	mov	eax, DWORD PTR _F$34557[ebp]
	mov	ecx, DWORD PTR _b$34543[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _b$34543[ebp]
	mov	eax, DWORD PTR _F$34557[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN27@mspace_mal
$LN26@mspace_mal:
	call	DWORD PTR __imp__abort
$LN27@mspace_mal:

; 5524 :           rsize = small_index2size(i) - nb;

	mov	ecx, DWORD PTR _i$34547[ebp]
	shl	ecx, 3
	sub	ecx, DWORD PTR _nb$34485[ebp]
	mov	DWORD PTR _rsize$34546[ebp], ecx

; 5525 :           /* Fit here cannot be remainderless if 4byte sizes */
; 5526 :           if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)

	xor	edx, edx
	je	SHORT $LN24@mspace_mal

; 5527 :             set_inuse_and_pinuse(ms, p, small_index2size(i));

	mov	eax, DWORD PTR _i$34547[ebp]
	shl	eax, 3
	or	eax, 1
	or	eax, 2
	mov	ecx, DWORD PTR _p$34544[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _i$34547[ebp]
	mov	eax, DWORD PTR _p$34544[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	or	ecx, 1
	mov	edx, DWORD PTR _i$34547[ebp]
	mov	eax, DWORD PTR _p$34544[ebp]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 5528 :           else {

	jmp	$LN23@mspace_mal
$LN24@mspace_mal:

; 5529 :             set_size_and_pinuse_of_inuse_chunk(ms, p, nb);

	mov	ecx, DWORD PTR _nb$34485[ebp]
	or	ecx, 1
	or	ecx, 2
	mov	edx, DWORD PTR _p$34544[ebp]
	mov	DWORD PTR [edx+4], ecx

; 5530 :             r = chunk_plus_offset(p, nb);

	mov	eax, DWORD PTR _p$34544[ebp]
	add	eax, DWORD PTR _nb$34485[ebp]
	mov	DWORD PTR _r$34545[ebp], eax

; 5531 :             set_size_and_pinuse_of_free_chunk(r, rsize);

	mov	ecx, DWORD PTR _rsize$34546[ebp]
	or	ecx, 1
	mov	edx, DWORD PTR _r$34545[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _r$34545[ebp]
	add	eax, DWORD PTR _rsize$34546[ebp]
	mov	ecx, DWORD PTR _rsize$34546[ebp]
	mov	DWORD PTR [eax], ecx

; 5532 :             replace_dv(ms, r, rsize);

	mov	edx, DWORD PTR _ms$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _DVS$34585[ebp], eax
	cmp	DWORD PTR _DVS$34585[ebp], 0
	je	$LN22@mspace_mal
	mov	ecx, DWORD PTR _ms$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _DV$34587[ebp], edx
	mov	eax, DWORD PTR _DVS$34585[ebp]
	shr	eax, 3
	mov	DWORD PTR _I$34588[ebp], eax
	mov	ecx, DWORD PTR _I$34588[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _ms$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+40]
	mov	DWORD PTR _B$34590[ebp], eax
	mov	ecx, DWORD PTR _B$34590[ebp]
	mov	DWORD PTR _F$34593[ebp], ecx
	mov	edx, 1
	mov	ecx, DWORD PTR _I$34588[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _ms$[ebp]
	and	edx, DWORD PTR [eax]
	jne	SHORT $LN21@mspace_mal
	mov	edx, 1
	mov	ecx, DWORD PTR _I$34588[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _ms$[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ms$[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN20@mspace_mal
$LN21@mspace_mal:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN19@mspace_mal
	mov	eax, DWORD PTR _B$34590[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$34593[ebp], ecx
	jmp	SHORT $LN20@mspace_mal
$LN19@mspace_mal:
	call	DWORD PTR __imp__abort
$LN20@mspace_mal:
	mov	edx, DWORD PTR _B$34590[ebp]
	mov	eax, DWORD PTR _DV$34587[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _F$34593[ebp]
	mov	edx, DWORD PTR _DV$34587[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _DV$34587[ebp]
	mov	ecx, DWORD PTR _F$34593[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _DV$34587[ebp]
	mov	eax, DWORD PTR _B$34590[ebp]
	mov	DWORD PTR [edx+12], eax
$LN22@mspace_mal:
	mov	ecx, DWORD PTR _ms$[ebp]
	mov	edx, DWORD PTR _rsize$34546[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _ms$[ebp]
	mov	ecx, DWORD PTR _r$34545[ebp]
	mov	DWORD PTR [eax+20], ecx
$LN23@mspace_mal:

; 5533 :           }
; 5534 :           mem = chunk2mem(p);

	mov	edx, DWORD PTR _p$34544[ebp]
	add	edx, 8
	mov	DWORD PTR _mem$34484[ebp], edx
	jmp	$postaction$34538

; 5535 :           check_malloced_chunk(ms, mem, nb);
; 5536 :           goto postaction;

	jmp	$postaction$34538
	jmp	SHORT $LN31@mspace_mal
$LN29@mspace_mal:

; 5537 :         }
; 5538 : 
; 5539 :         else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {

	mov	eax, DWORD PTR _ms$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN31@mspace_mal
	mov	ecx, DWORD PTR _nb$34485[ebp]
	push	ecx
	mov	edx, DWORD PTR _ms$[ebp]
	push	edx
	call	?tmalloc_small@@YAPAXPAUmalloc_state@@I@Z ; tmalloc_small
	add	esp, 8
	mov	DWORD PTR _mem$34484[ebp], eax
	cmp	DWORD PTR _mem$34484[ebp], 0
	je	SHORT $LN31@mspace_mal
	jmp	$postaction$34538

; 5540 :           check_malloced_chunk(ms, mem, nb);
; 5541 :           goto postaction;

	jmp	$postaction$34538
$LN31@mspace_mal:

; 5542 :         }
; 5543 :       }
; 5544 :     }

	jmp	SHORT $LN13@mspace_mal
$LN38@mspace_mal:

; 5545 :     else if (bytes >= MAX_REQUEST)

	cmp	DWORD PTR _bytes$[ebp], -64		; ffffffc0H
	jb	SHORT $LN12@mspace_mal

; 5546 :       nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */

	mov	DWORD PTR _nb$34485[ebp], -1

; 5547 :     else {

	jmp	SHORT $LN13@mspace_mal
$LN12@mspace_mal:

; 5548 :       nb = pad_request(bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	add	eax, 11					; 0000000bH
	and	eax, -8					; fffffff8H
	mov	DWORD PTR _nb$34485[ebp], eax

; 5549 :       if (ms->treemap != 0 && (mem = tmalloc_large(ms, nb)) != 0) {

	mov	ecx, DWORD PTR _ms$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN13@mspace_mal
	mov	edx, DWORD PTR _nb$34485[ebp]
	push	edx
	mov	eax, DWORD PTR _ms$[ebp]
	push	eax
	call	?tmalloc_large@@YAPAXPAUmalloc_state@@I@Z ; tmalloc_large
	add	esp, 8
	mov	DWORD PTR _mem$34484[ebp], eax
	cmp	DWORD PTR _mem$34484[ebp], 0
	je	SHORT $LN13@mspace_mal
	jmp	$postaction$34538

; 5550 :         check_malloced_chunk(ms, mem, nb);
; 5551 :         goto postaction;

	jmp	$postaction$34538
$LN13@mspace_mal:

; 5552 :       }
; 5553 :     }
; 5554 : 
; 5555 :     if (nb <= ms->dvsize) {

	mov	ecx, DWORD PTR _ms$[ebp]
	mov	edx, DWORD PTR _nb$34485[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	ja	$LN8@mspace_mal

; 5556 :       size_t rsize = ms->dvsize - nb;

	mov	eax, DWORD PTR _ms$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _nb$34485[ebp]
	mov	DWORD PTR _rsize$34628[ebp], ecx

; 5557 :       mchunkptr p = ms->dv;

	mov	edx, DWORD PTR _ms$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _p$34629[ebp], eax

; 5558 :       if (rsize >= MIN_CHUNK_SIZE) { /* split dv */

	cmp	DWORD PTR _rsize$34628[ebp], 16		; 00000010H
	jb	SHORT $LN7@mspace_mal

; 5559 :         mchunkptr r = ms->dv = chunk_plus_offset(p, nb);

	mov	ecx, DWORD PTR _p$34629[ebp]
	add	ecx, DWORD PTR _nb$34485[ebp]
	mov	edx, DWORD PTR _ms$[ebp]
	mov	DWORD PTR [edx+20], ecx
	mov	eax, DWORD PTR _ms$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _r$34638[ebp], ecx

; 5560 :         ms->dvsize = rsize;

	mov	edx, DWORD PTR _ms$[ebp]
	mov	eax, DWORD PTR _rsize$34628[ebp]
	mov	DWORD PTR [edx+8], eax

; 5561 :         set_size_and_pinuse_of_free_chunk(r, rsize);

	mov	ecx, DWORD PTR _rsize$34628[ebp]
	or	ecx, 1
	mov	edx, DWORD PTR _r$34638[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _r$34638[ebp]
	add	eax, DWORD PTR _rsize$34628[ebp]
	mov	ecx, DWORD PTR _rsize$34628[ebp]
	mov	DWORD PTR [eax], ecx

; 5562 :         set_size_and_pinuse_of_inuse_chunk(ms, p, nb);

	mov	edx, DWORD PTR _nb$34485[ebp]
	or	edx, 1
	or	edx, 2
	mov	eax, DWORD PTR _p$34629[ebp]
	mov	DWORD PTR [eax+4], edx

; 5563 :       }
; 5564 :       else { /* exhaust dv */

	jmp	SHORT $LN6@mspace_mal
$LN7@mspace_mal:

; 5565 :         size_t dvs = ms->dvsize;

	mov	ecx, DWORD PTR _ms$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _dvs$34647[ebp], edx

; 5566 :         ms->dvsize = 0;

	mov	eax, DWORD PTR _ms$[ebp]
	mov	DWORD PTR [eax+8], 0

; 5567 :         ms->dv = 0;

	mov	ecx, DWORD PTR _ms$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 5568 :         set_inuse_and_pinuse(ms, p, dvs);

	mov	edx, DWORD PTR _dvs$34647[ebp]
	or	edx, 1
	or	edx, 2
	mov	eax, DWORD PTR _p$34629[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _p$34629[ebp]
	add	ecx, DWORD PTR _dvs$34647[ebp]
	mov	edx, DWORD PTR [ecx+4]
	or	edx, 1
	mov	eax, DWORD PTR _p$34629[ebp]
	add	eax, DWORD PTR _dvs$34647[ebp]
	mov	DWORD PTR [eax+4], edx
$LN6@mspace_mal:

; 5569 :       }
; 5570 :       mem = chunk2mem(p);

	mov	ecx, DWORD PTR _p$34629[ebp]
	add	ecx, 8
	mov	DWORD PTR _mem$34484[ebp], ecx
	jmp	$postaction$34538

; 5571 :       check_malloced_chunk(ms, mem, nb);
; 5572 :       goto postaction;

	jmp	SHORT $postaction$34538
	jmp	SHORT $LN4@mspace_mal
$LN8@mspace_mal:

; 5573 :     }
; 5574 : 
; 5575 :     else if (nb < ms->topsize) { /* Split top */

	mov	edx, DWORD PTR _ms$[ebp]
	mov	eax, DWORD PTR _nb$34485[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jae	SHORT $LN4@mspace_mal

; 5576 :       size_t rsize = ms->topsize -= nb;

	mov	ecx, DWORD PTR _ms$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, DWORD PTR _nb$34485[ebp]
	mov	eax, DWORD PTR _ms$[ebp]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _ms$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _rsize$34659[ebp], edx

; 5577 :       mchunkptr p = ms->top;

	mov	eax, DWORD PTR _ms$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _p$34660[ebp], ecx

; 5578 :       mchunkptr r = ms->top = chunk_plus_offset(p, nb);

	mov	edx, DWORD PTR _p$34660[ebp]
	add	edx, DWORD PTR _nb$34485[ebp]
	mov	eax, DWORD PTR _ms$[ebp]
	mov	DWORD PTR [eax+24], edx
	mov	ecx, DWORD PTR _ms$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _r$34661[ebp], edx

; 5579 :       r->head = rsize | PINUSE_BIT;

	mov	eax, DWORD PTR _rsize$34659[ebp]
	or	eax, 1
	mov	ecx, DWORD PTR _r$34661[ebp]
	mov	DWORD PTR [ecx+4], eax

; 5580 :       set_size_and_pinuse_of_inuse_chunk(ms, p, nb);

	mov	edx, DWORD PTR _nb$34485[ebp]
	or	edx, 1
	or	edx, 2
	mov	eax, DWORD PTR _p$34660[ebp]
	mov	DWORD PTR [eax+4], edx

; 5581 :       mem = chunk2mem(p);

	mov	ecx, DWORD PTR _p$34660[ebp]
	add	ecx, 8
	mov	DWORD PTR _mem$34484[ebp], ecx
	jmp	SHORT $postaction$34538

; 5582 :       check_top_chunk(ms, ms->top);
; 5583 :       check_malloced_chunk(ms, mem, nb);
; 5584 :       goto postaction;

	jmp	SHORT $postaction$34538
$LN4@mspace_mal:

; 5585 :     }
; 5586 : 
; 5587 :     mem = sys_alloc(ms, nb);

	mov	edx, DWORD PTR _nb$34485[ebp]
	push	edx
	mov	eax, DWORD PTR _ms$[ebp]
	push	eax
	call	?sys_alloc@@YAPAXPAUmalloc_state@@I@Z	; sys_alloc
	add	esp, 8
	mov	DWORD PTR _mem$34484[ebp], eax
$postaction$34538:

; 5588 : 
; 5589 :   postaction:
; 5590 :     POSTACTION(ms);

	mov	ecx, DWORD PTR _ms$[ebp]
	mov	edx, DWORD PTR [ecx+444]
	and	edx, 2
	je	SHORT $LN1@mspace_mal
	xor	eax, eax
	mov	ecx, DWORD PTR _ms$[ebp]
	add	ecx, 448				; 000001c0H
	xchg	DWORD PTR [ecx], eax
$LN1@mspace_mal:

; 5591 :     return mem;

	mov	eax, DWORD PTR _mem$34484[ebp]
	jmp	SHORT $LN41@mspace_mal
$LN39@mspace_mal:

; 5592 :   }
; 5593 : 
; 5594 :   return 0;

	xor	eax, eax
$LN41@mspace_mal:

; 5595 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_malloc@@YAPAXPAXI@Z ENDP			; mspace_malloc
; Function compile flags: /Odtp
tv422 = -192						; size = 4
tv79 = -188						; size = 4
tv77 = -184						; size = 4
_F$34916 = -180						; size = 4
_C$34908 = -176						; size = 4
_K$34898 = -172						; size = 4
_T$34897 = -168						; size = 4
_K$34888 = -164						; size = 4
_X$34883 = -160						; size = 4
_I$34882 = -156						; size = 4
_H$34881 = -152						; size = 4
_tp$34879 = -148					; size = 4
_I$34866 = -144						; size = 4
_F$34871 = -140						; size = 4
_B$34868 = -136						; size = 4
_C0$34846 = -132					; size = 4
_C1$34847 = -128					; size = 4
_H$34835 = -124						; size = 4
_CP$34827 = -120					; size = 4
_RP$34824 = -116					; size = 4
_F$34820 = -112						; size = 4
_R$34818 = -108						; size = 4
_XP$34817 = -104					; size = 4
_TP$34815 = -100					; size = 4
_I$34805 = -96						; size = 4
_F$34803 = -92						; size = 4
_B$34804 = -88						; size = 4
_nsize$34798 = -84					; size = 4
_dsize$34792 = -80					; size = 4
_tsize$34785 = -76					; size = 4
_C0$34758 = -72						; size = 4
_C1$34759 = -68						; size = 4
_H$34747 = -64						; size = 4
_CP$34739 = -60						; size = 4
_RP$34736 = -56						; size = 4
_F$34732 = -52						; size = 4
_R$34730 = -48						; size = 4
_XP$34729 = -44						; size = 4
_TP$34727 = -40						; size = 4
_I$34717 = -36						; size = 4
_F$34715 = -32						; size = 4
_B$34716 = -28						; size = 4
_prev$34709 = -24					; size = 4
_prevsize$34699 = -20					; size = 4
_psize$34690 = -16					; size = 4
_next$34694 = -12					; size = 4
_fm$34683 = -8						; size = 4
_p$34679 = -4						; size = 4
_msp$ = 8						; size = 4
_mem$ = 12						; size = 4
?mspace_free@@YAXPAX0@Z PROC				; mspace_free

; 5597 : void mspace_free(mspace msp, void* mem) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H

; 5598 :   if (mem != 0) {

	cmp	DWORD PTR _mem$[ebp], 0
	je	$LN127@mspace_fre

; 5599 :     mchunkptr p  = mem2chunk(mem);

	mov	eax, DWORD PTR _mem$[ebp]
	sub	eax, 8
	mov	DWORD PTR _p$34679[ebp], eax

; 5600 : #if FOOTERS
; 5601 :     mstate fm = get_mstate_for(p);
; 5602 :     (void)msp; /* placate people compiling -Wunused */
; 5603 : #else /* FOOTERS */
; 5604 :     mstate fm = (mstate)msp;

	mov	ecx, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _fm$34683[ebp], ecx

; 5605 : #endif /* FOOTERS */
; 5606 :     if (!ok_magic(fm)) {

	xor	edx, edx
	je	SHORT $LN125@mspace_fre

; 5607 :       USAGE_ERROR_ACTION(fm, p);

	call	DWORD PTR __imp__abort

; 5608 :       return;

	jmp	$LN127@mspace_fre
$LN125@mspace_fre:

; 5609 :     }
; 5610 :     if (!PREACTION(fm)) {

	mov	eax, DWORD PTR _fm$34683[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 2
	je	SHORT $LN131@mspace_fre
	mov	edx, 1
	mov	eax, DWORD PTR _fm$34683[ebp]
	add	eax, 448				; 000001c0H
	xchg	DWORD PTR [eax], edx
	test	edx, edx
	je	SHORT $LN129@mspace_fre
	mov	ecx, DWORD PTR _fm$34683[ebp]
	add	ecx, 448				; 000001c0H
	push	ecx
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN130@mspace_fre
$LN129@mspace_fre:
	mov	DWORD PTR tv77[ebp], 0
$LN130@mspace_fre:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv79[ebp], edx
	jmp	SHORT $LN132@mspace_fre
$LN131@mspace_fre:
	mov	DWORD PTR tv79[ebp], 0
$LN132@mspace_fre:
	cmp	DWORD PTR tv79[ebp], 0
	jne	$LN127@mspace_fre

; 5611 :       check_inuse_chunk(fm, p);
; 5612 :       if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {

	mov	eax, 1
	test	eax, eax
	je	$erroraction$34779

; 5613 :         size_t psize = chunksize(p);

	mov	ecx, DWORD PTR _p$34679[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -8					; fffffff8H
	mov	DWORD PTR _psize$34690[ebp], edx

; 5614 :         mchunkptr next = chunk_plus_offset(p, psize);

	mov	eax, DWORD PTR _p$34679[ebp]
	add	eax, DWORD PTR _psize$34690[ebp]
	mov	DWORD PTR _next$34694[ebp], eax

; 5615 :         if (!pinuse(p)) {

	mov	ecx, DWORD PTR _p$34679[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 1
	jne	$LN122@mspace_fre

; 5616 :           size_t prevsize = p->prev_foot;

	mov	eax, DWORD PTR _p$34679[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _prevsize$34699[ebp], ecx

; 5617 :           if (is_mmapped(p)) {

	mov	edx, DWORD PTR _p$34679[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 3
	jne	SHORT $LN121@mspace_fre

; 5618 :             psize += prevsize + MMAP_FOOT_PAD;

	mov	ecx, DWORD PTR _prevsize$34699[ebp]
	mov	edx, DWORD PTR _psize$34690[ebp]
	lea	eax, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _psize$34690[ebp], eax

; 5619 :             if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)

	mov	ecx, DWORD PTR _psize$34690[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$34679[ebp]
	sub	edx, DWORD PTR _prevsize$34699[ebp]
	push	edx
	call	?win32munmap@@YAHPAXI@Z			; win32munmap
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN120@mspace_fre

; 5620 :               fm->footprint -= psize;

	mov	eax, DWORD PTR _fm$34683[ebp]
	mov	ecx, DWORD PTR [eax+432]
	sub	ecx, DWORD PTR _psize$34690[ebp]
	mov	edx, DWORD PTR _fm$34683[ebp]
	mov	DWORD PTR [edx+432], ecx
$LN120@mspace_fre:

; 5621 :             goto postaction;

	jmp	$postaction$34706
	jmp	$postaction$34706

; 5622 :           }
; 5623 :           else {

	jmp	$LN122@mspace_fre
$LN121@mspace_fre:

; 5624 :             mchunkptr prev = chunk_minus_offset(p, prevsize);

	mov	eax, DWORD PTR _p$34679[ebp]
	sub	eax, DWORD PTR _prevsize$34699[ebp]
	mov	DWORD PTR _prev$34709[ebp], eax

; 5625 :             psize += prevsize;

	mov	ecx, DWORD PTR _psize$34690[ebp]
	add	ecx, DWORD PTR _prevsize$34699[ebp]
	mov	DWORD PTR _psize$34690[ebp], ecx

; 5626 :             p = prev;

	mov	edx, DWORD PTR _prev$34709[ebp]
	mov	DWORD PTR _p$34679[ebp], edx

; 5627 :             if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */

	mov	eax, 1
	test	eax, eax
	je	$LN117@mspace_fre

; 5628 :               if (p != fm->dv) {

	mov	ecx, DWORD PTR _fm$34683[ebp]
	mov	edx, DWORD PTR _p$34679[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	je	$LN116@mspace_fre

; 5629 :                 unlink_chunk(fm, p, prevsize);

	mov	eax, DWORD PTR _prevsize$34699[ebp]
	shr	eax, 3
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN115@mspace_fre
	mov	ecx, DWORD PTR _p$34679[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _F$34715[ebp], edx
	mov	eax, DWORD PTR _p$34679[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _B$34716[ebp], ecx
	mov	edx, DWORD PTR _prevsize$34699[ebp]
	shr	edx, 3
	mov	DWORD PTR _I$34717[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN114@mspace_fre
	mov	ecx, DWORD PTR _B$34716[ebp]
	cmp	ecx, DWORD PTR _F$34715[ebp]
	jne	SHORT $LN113@mspace_fre
	mov	edx, 1
	mov	ecx, DWORD PTR _I$34717[ebp]
	shl	edx, cl
	not	edx
	mov	eax, DWORD PTR _fm$34683[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _fm$34683[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN112@mspace_fre
$LN113@mspace_fre:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN111@mspace_fre
	mov	eax, DWORD PTR _F$34715[ebp]
	mov	ecx, DWORD PTR _B$34716[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _B$34716[ebp]
	mov	eax, DWORD PTR _F$34715[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN112@mspace_fre
$LN111@mspace_fre:
	call	DWORD PTR __imp__abort
$LN112@mspace_fre:
	jmp	SHORT $LN109@mspace_fre
$LN114@mspace_fre:
	call	DWORD PTR __imp__abort
$LN109@mspace_fre:
	jmp	$LN108@mspace_fre
$LN115@mspace_fre:
	mov	ecx, DWORD PTR _p$34679[ebp]
	mov	DWORD PTR _TP$34727[ebp], ecx
	mov	edx, DWORD PTR _TP$34727[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _XP$34729[ebp], eax
	mov	ecx, DWORD PTR _TP$34727[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _TP$34727[ebp]
	je	SHORT $LN107@mspace_fre
	mov	eax, DWORD PTR _TP$34727[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$34732[ebp], ecx
	mov	edx, DWORD PTR _TP$34727[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _R$34730[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN106@mspace_fre
	mov	edx, DWORD PTR _F$34732[ebp]
	mov	eax, DWORD PTR _R$34730[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _R$34730[ebp]
	mov	edx, DWORD PTR _F$34732[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN105@mspace_fre
$LN106@mspace_fre:
	call	DWORD PTR __imp__abort
$LN105@mspace_fre:
	jmp	SHORT $LN104@mspace_fre
$LN107@mspace_fre:
	mov	eax, DWORD PTR _TP$34727[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _RP$34736[ebp], eax
	mov	ecx, DWORD PTR _RP$34736[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _R$34730[ebp], edx
	cmp	DWORD PTR _R$34730[ebp], 0
	jne	SHORT $LN101@mspace_fre
	mov	eax, DWORD PTR _TP$34727[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _RP$34736[ebp], eax
	mov	ecx, DWORD PTR _RP$34736[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _R$34730[ebp], edx
	cmp	DWORD PTR _R$34730[ebp], 0
	je	SHORT $LN104@mspace_fre
$LN101@mspace_fre:
	mov	eax, DWORD PTR _R$34730[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _CP$34739[ebp], eax
	mov	ecx, DWORD PTR _CP$34739[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN99@mspace_fre
	mov	edx, DWORD PTR _R$34730[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _CP$34739[ebp], edx
	mov	eax, DWORD PTR _CP$34739[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN100@mspace_fre
$LN99@mspace_fre:
	mov	ecx, DWORD PTR _CP$34739[ebp]
	mov	DWORD PTR _RP$34736[ebp], ecx
	mov	edx, DWORD PTR _RP$34736[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _R$34730[ebp], eax
	jmp	SHORT $LN101@mspace_fre
$LN100@mspace_fre:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN98@mspace_fre
	mov	edx, DWORD PTR _RP$34736[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN104@mspace_fre
$LN98@mspace_fre:
	call	DWORD PTR __imp__abort
$LN104@mspace_fre:
	cmp	DWORD PTR _XP$34729[ebp], 0
	je	$LN108@mspace_fre
	mov	eax, DWORD PTR _TP$34727[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _fm$34683[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+304]
	mov	DWORD PTR _H$34747[ebp], eax
	mov	ecx, DWORD PTR _H$34747[ebp]
	mov	edx, DWORD PTR _TP$34727[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN95@mspace_fre
	mov	eax, DWORD PTR _H$34747[ebp]
	mov	ecx, DWORD PTR _R$34730[ebp]
	mov	DWORD PTR [eax], ecx
	cmp	DWORD PTR _R$34730[ebp], 0
	jne	SHORT $LN94@mspace_fre
	mov	edx, DWORD PTR _TP$34727[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+28]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _fm$34683[ebp]
	and	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _fm$34683[ebp]
	mov	DWORD PTR [edx+4], eax
$LN94@mspace_fre:
	jmp	SHORT $LN93@mspace_fre
$LN95@mspace_fre:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN92@mspace_fre
	mov	ecx, DWORD PTR _XP$34729[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _TP$34727[ebp]
	jne	SHORT $LN91@mspace_fre
	mov	eax, DWORD PTR _XP$34729[ebp]
	mov	ecx, DWORD PTR _R$34730[ebp]
	mov	DWORD PTR [eax+16], ecx
	jmp	SHORT $LN90@mspace_fre
$LN91@mspace_fre:
	mov	edx, DWORD PTR _XP$34729[ebp]
	mov	eax, DWORD PTR _R$34730[ebp]
	mov	DWORD PTR [edx+20], eax
$LN90@mspace_fre:
	jmp	SHORT $LN93@mspace_fre
$LN92@mspace_fre:
	call	DWORD PTR __imp__abort
$LN93@mspace_fre:
	cmp	DWORD PTR _R$34730[ebp], 0
	je	SHORT $LN108@mspace_fre
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN87@mspace_fre
	mov	edx, DWORD PTR _R$34730[ebp]
	mov	eax, DWORD PTR _XP$34729[ebp]
	mov	DWORD PTR [edx+24], eax
	mov	ecx, DWORD PTR _TP$34727[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _C0$34758[ebp], edx
	cmp	DWORD PTR _C0$34758[ebp], 0
	je	SHORT $LN86@mspace_fre
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN85@mspace_fre
	mov	ecx, DWORD PTR _R$34730[ebp]
	mov	edx, DWORD PTR _C0$34758[ebp]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR _C0$34758[ebp]
	mov	ecx, DWORD PTR _R$34730[ebp]
	mov	DWORD PTR [eax+24], ecx
	jmp	SHORT $LN86@mspace_fre
$LN85@mspace_fre:
	call	DWORD PTR __imp__abort
$LN86@mspace_fre:
	mov	edx, DWORD PTR _TP$34727[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _C1$34759[ebp], eax
	cmp	DWORD PTR _C1$34759[ebp], 0
	je	SHORT $LN83@mspace_fre
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN82@mspace_fre
	mov	edx, DWORD PTR _R$34730[ebp]
	mov	eax, DWORD PTR _C1$34759[ebp]
	mov	DWORD PTR [edx+20], eax
	mov	ecx, DWORD PTR _C1$34759[ebp]
	mov	edx, DWORD PTR _R$34730[ebp]
	mov	DWORD PTR [ecx+24], edx
	jmp	SHORT $LN83@mspace_fre
$LN82@mspace_fre:
	call	DWORD PTR __imp__abort
$LN83@mspace_fre:
	jmp	SHORT $LN108@mspace_fre
$LN87@mspace_fre:
	call	DWORD PTR __imp__abort
$LN108@mspace_fre:
	jmp	SHORT $LN79@mspace_fre
$LN116@mspace_fre:

; 5630 :               }
; 5631 :               else if ((next->head & INUSE_BITS) == INUSE_BITS) {

	mov	eax, DWORD PTR _next$34694[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 3
	cmp	ecx, 3
	jne	SHORT $LN79@mspace_fre

; 5632 :                 fm->dvsize = psize;

	mov	edx, DWORD PTR _fm$34683[ebp]
	mov	eax, DWORD PTR _psize$34690[ebp]
	mov	DWORD PTR [edx+8], eax

; 5633 :                 set_free_with_pinuse(p, psize, next);

	mov	ecx, DWORD PTR _next$34694[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _next$34694[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _psize$34690[ebp]
	or	ecx, 1
	mov	edx, DWORD PTR _p$34679[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _p$34679[ebp]
	add	eax, DWORD PTR _psize$34690[ebp]
	mov	ecx, DWORD PTR _psize$34690[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	$postaction$34706

; 5634 :                 goto postaction;

	jmp	$postaction$34706
$LN79@mspace_fre:

; 5635 :               }
; 5636 :             }
; 5637 :             else

	jmp	SHORT $LN122@mspace_fre
$LN117@mspace_fre:

; 5638 :               goto erroraction;

	jmp	$erroraction$34779
	jmp	$erroraction$34779
$LN122@mspace_fre:

; 5639 :           }
; 5640 :         }
; 5641 : 
; 5642 :         if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {

	mov	edx, 1
	test	edx, edx
	je	$erroraction$34779

; 5643 :           if (!cinuse(next)) {  /* consolidate forward */

	mov	eax, DWORD PTR _next$34694[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 2
	jne	$LN73@mspace_fre

; 5644 :             if (next == fm->top) {

	mov	edx, DWORD PTR _fm$34683[ebp]
	mov	eax, DWORD PTR _next$34694[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jne	SHORT $LN72@mspace_fre

; 5645 :               size_t tsize = fm->topsize += psize;

	mov	ecx, DWORD PTR _fm$34683[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _psize$34690[ebp]
	mov	eax, DWORD PTR _fm$34683[ebp]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _fm$34683[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _tsize$34785[ebp], edx

; 5646 :               fm->top = p;

	mov	eax, DWORD PTR _fm$34683[ebp]
	mov	ecx, DWORD PTR _p$34679[ebp]
	mov	DWORD PTR [eax+24], ecx

; 5647 :               p->head = tsize | PINUSE_BIT;

	mov	edx, DWORD PTR _tsize$34785[ebp]
	or	edx, 1
	mov	eax, DWORD PTR _p$34679[ebp]
	mov	DWORD PTR [eax+4], edx

; 5648 :               if (p == fm->dv) {

	mov	ecx, DWORD PTR _fm$34683[ebp]
	mov	edx, DWORD PTR _p$34679[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN71@mspace_fre

; 5649 :                 fm->dv = 0;

	mov	eax, DWORD PTR _fm$34683[ebp]
	mov	DWORD PTR [eax+20], 0

; 5650 :                 fm->dvsize = 0;

	mov	ecx, DWORD PTR _fm$34683[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN71@mspace_fre:

; 5651 :               }
; 5652 :               if (should_trim(fm, tsize))

	mov	edx, DWORD PTR _fm$34683[ebp]
	mov	eax, DWORD PTR _tsize$34785[ebp]
	cmp	eax, DWORD PTR [edx+28]
	jbe	SHORT $LN70@mspace_fre

; 5653 :                 sys_trim(fm, 0);

	push	0
	mov	ecx, DWORD PTR _fm$34683[ebp]
	push	ecx
	call	?sys_trim@@YAHPAUmalloc_state@@I@Z	; sys_trim
	add	esp, 8
$LN70@mspace_fre:

; 5654 :               goto postaction;

	jmp	$postaction$34706
	jmp	$postaction$34706
	jmp	$LN68@mspace_fre
$LN72@mspace_fre:

; 5655 :             }
; 5656 :             else if (next == fm->dv) {

	mov	edx, DWORD PTR _fm$34683[ebp]
	mov	eax, DWORD PTR _next$34694[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jne	SHORT $LN67@mspace_fre

; 5657 :               size_t dsize = fm->dvsize += psize;

	mov	ecx, DWORD PTR _fm$34683[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _psize$34690[ebp]
	mov	eax, DWORD PTR _fm$34683[ebp]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR _fm$34683[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _dsize$34792[ebp], edx

; 5658 :               fm->dv = p;

	mov	eax, DWORD PTR _fm$34683[ebp]
	mov	ecx, DWORD PTR _p$34679[ebp]
	mov	DWORD PTR [eax+20], ecx

; 5659 :               set_size_and_pinuse_of_free_chunk(p, dsize);

	mov	edx, DWORD PTR _dsize$34792[ebp]
	or	edx, 1
	mov	eax, DWORD PTR _p$34679[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _p$34679[ebp]
	add	ecx, DWORD PTR _dsize$34792[ebp]
	mov	edx, DWORD PTR _dsize$34792[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	$postaction$34706

; 5660 :               goto postaction;

	jmp	$postaction$34706

; 5661 :             }
; 5662 :             else {

	jmp	$LN68@mspace_fre
$LN67@mspace_fre:

; 5663 :               size_t nsize = chunksize(next);

	mov	eax, DWORD PTR _next$34694[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	mov	DWORD PTR _nsize$34798[ebp], ecx

; 5664 :               psize += nsize;

	mov	edx, DWORD PTR _psize$34690[ebp]
	add	edx, DWORD PTR _nsize$34798[ebp]
	mov	DWORD PTR _psize$34690[ebp], edx

; 5665 :               unlink_chunk(fm, next, nsize);

	mov	eax, DWORD PTR _nsize$34798[ebp]
	shr	eax, 3
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN64@mspace_fre
	mov	ecx, DWORD PTR _next$34694[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _F$34803[ebp], edx
	mov	eax, DWORD PTR _next$34694[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _B$34804[ebp], ecx
	mov	edx, DWORD PTR _nsize$34798[ebp]
	shr	edx, 3
	mov	DWORD PTR _I$34805[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN63@mspace_fre
	mov	ecx, DWORD PTR _B$34804[ebp]
	cmp	ecx, DWORD PTR _F$34803[ebp]
	jne	SHORT $LN62@mspace_fre
	mov	edx, 1
	mov	ecx, DWORD PTR _I$34805[ebp]
	shl	edx, cl
	not	edx
	mov	eax, DWORD PTR _fm$34683[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _fm$34683[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN61@mspace_fre
$LN62@mspace_fre:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN60@mspace_fre
	mov	eax, DWORD PTR _F$34803[ebp]
	mov	ecx, DWORD PTR _B$34804[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _B$34804[ebp]
	mov	eax, DWORD PTR _F$34803[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN61@mspace_fre
$LN60@mspace_fre:
	call	DWORD PTR __imp__abort
$LN61@mspace_fre:
	jmp	SHORT $LN58@mspace_fre
$LN63@mspace_fre:
	call	DWORD PTR __imp__abort
$LN58@mspace_fre:
	jmp	$LN57@mspace_fre
$LN64@mspace_fre:
	mov	ecx, DWORD PTR _next$34694[ebp]
	mov	DWORD PTR _TP$34815[ebp], ecx
	mov	edx, DWORD PTR _TP$34815[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _XP$34817[ebp], eax
	mov	ecx, DWORD PTR _TP$34815[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _TP$34815[ebp]
	je	SHORT $LN56@mspace_fre
	mov	eax, DWORD PTR _TP$34815[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$34820[ebp], ecx
	mov	edx, DWORD PTR _TP$34815[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _R$34818[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN55@mspace_fre
	mov	edx, DWORD PTR _F$34820[ebp]
	mov	eax, DWORD PTR _R$34818[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _R$34818[ebp]
	mov	edx, DWORD PTR _F$34820[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN54@mspace_fre
$LN55@mspace_fre:
	call	DWORD PTR __imp__abort
$LN54@mspace_fre:
	jmp	SHORT $LN53@mspace_fre
$LN56@mspace_fre:
	mov	eax, DWORD PTR _TP$34815[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _RP$34824[ebp], eax
	mov	ecx, DWORD PTR _RP$34824[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _R$34818[ebp], edx
	cmp	DWORD PTR _R$34818[ebp], 0
	jne	SHORT $LN50@mspace_fre
	mov	eax, DWORD PTR _TP$34815[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _RP$34824[ebp], eax
	mov	ecx, DWORD PTR _RP$34824[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _R$34818[ebp], edx
	cmp	DWORD PTR _R$34818[ebp], 0
	je	SHORT $LN53@mspace_fre
$LN50@mspace_fre:
	mov	eax, DWORD PTR _R$34818[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _CP$34827[ebp], eax
	mov	ecx, DWORD PTR _CP$34827[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN48@mspace_fre
	mov	edx, DWORD PTR _R$34818[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _CP$34827[ebp], edx
	mov	eax, DWORD PTR _CP$34827[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN49@mspace_fre
$LN48@mspace_fre:
	mov	ecx, DWORD PTR _CP$34827[ebp]
	mov	DWORD PTR _RP$34824[ebp], ecx
	mov	edx, DWORD PTR _RP$34824[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _R$34818[ebp], eax
	jmp	SHORT $LN50@mspace_fre
$LN49@mspace_fre:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN47@mspace_fre
	mov	edx, DWORD PTR _RP$34824[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN53@mspace_fre
$LN47@mspace_fre:
	call	DWORD PTR __imp__abort
$LN53@mspace_fre:
	cmp	DWORD PTR _XP$34817[ebp], 0
	je	$LN57@mspace_fre
	mov	eax, DWORD PTR _TP$34815[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _fm$34683[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+304]
	mov	DWORD PTR _H$34835[ebp], eax
	mov	ecx, DWORD PTR _H$34835[ebp]
	mov	edx, DWORD PTR _TP$34815[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@mspace_fre
	mov	eax, DWORD PTR _H$34835[ebp]
	mov	ecx, DWORD PTR _R$34818[ebp]
	mov	DWORD PTR [eax], ecx
	cmp	DWORD PTR _R$34818[ebp], 0
	jne	SHORT $LN43@mspace_fre
	mov	edx, DWORD PTR _TP$34815[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+28]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _fm$34683[ebp]
	and	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _fm$34683[ebp]
	mov	DWORD PTR [edx+4], eax
$LN43@mspace_fre:
	jmp	SHORT $LN42@mspace_fre
$LN44@mspace_fre:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN41@mspace_fre
	mov	ecx, DWORD PTR _XP$34817[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _TP$34815[ebp]
	jne	SHORT $LN40@mspace_fre
	mov	eax, DWORD PTR _XP$34817[ebp]
	mov	ecx, DWORD PTR _R$34818[ebp]
	mov	DWORD PTR [eax+16], ecx
	jmp	SHORT $LN39@mspace_fre
$LN40@mspace_fre:
	mov	edx, DWORD PTR _XP$34817[ebp]
	mov	eax, DWORD PTR _R$34818[ebp]
	mov	DWORD PTR [edx+20], eax
$LN39@mspace_fre:
	jmp	SHORT $LN42@mspace_fre
$LN41@mspace_fre:
	call	DWORD PTR __imp__abort
$LN42@mspace_fre:
	cmp	DWORD PTR _R$34818[ebp], 0
	je	$LN57@mspace_fre
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN36@mspace_fre
	mov	edx, DWORD PTR _R$34818[ebp]
	mov	eax, DWORD PTR _XP$34817[ebp]
	mov	DWORD PTR [edx+24], eax
	mov	ecx, DWORD PTR _TP$34815[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _C0$34846[ebp], edx
	cmp	DWORD PTR _C0$34846[ebp], 0
	je	SHORT $LN35@mspace_fre
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN34@mspace_fre
	mov	ecx, DWORD PTR _R$34818[ebp]
	mov	edx, DWORD PTR _C0$34846[ebp]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR _C0$34846[ebp]
	mov	ecx, DWORD PTR _R$34818[ebp]
	mov	DWORD PTR [eax+24], ecx
	jmp	SHORT $LN35@mspace_fre
$LN34@mspace_fre:
	call	DWORD PTR __imp__abort
$LN35@mspace_fre:
	mov	edx, DWORD PTR _TP$34815[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _C1$34847[ebp], eax
	cmp	DWORD PTR _C1$34847[ebp], 0
	je	SHORT $LN32@mspace_fre
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN31@mspace_fre
	mov	edx, DWORD PTR _R$34818[ebp]
	mov	eax, DWORD PTR _C1$34847[ebp]
	mov	DWORD PTR [edx+20], eax
	mov	ecx, DWORD PTR _C1$34847[ebp]
	mov	edx, DWORD PTR _R$34818[ebp]
	mov	DWORD PTR [ecx+24], edx
	jmp	SHORT $LN32@mspace_fre
$LN31@mspace_fre:
	call	DWORD PTR __imp__abort
$LN32@mspace_fre:
	jmp	SHORT $LN57@mspace_fre
$LN36@mspace_fre:
	call	DWORD PTR __imp__abort
$LN57@mspace_fre:

; 5666 :               set_size_and_pinuse_of_free_chunk(p, psize);

	mov	eax, DWORD PTR _psize$34690[ebp]
	or	eax, 1
	mov	ecx, DWORD PTR _p$34679[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _p$34679[ebp]
	add	edx, DWORD PTR _psize$34690[ebp]
	mov	eax, DWORD PTR _psize$34690[ebp]
	mov	DWORD PTR [edx], eax

; 5667 :               if (p == fm->dv) {

	mov	ecx, DWORD PTR _fm$34683[ebp]
	mov	edx, DWORD PTR _p$34679[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN68@mspace_fre

; 5668 :                 fm->dvsize = psize;

	mov	eax, DWORD PTR _fm$34683[ebp]
	mov	ecx, DWORD PTR _psize$34690[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	$postaction$34706

; 5669 :                 goto postaction;

	jmp	$postaction$34706
$LN68@mspace_fre:

; 5670 :               }
; 5671 :             }
; 5672 :           }
; 5673 :           else

	jmp	SHORT $LN26@mspace_fre
$LN73@mspace_fre:

; 5674 :             set_free_with_pinuse(p, psize, next);

	mov	edx, DWORD PTR _next$34694[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _next$34694[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _psize$34690[ebp]
	or	edx, 1
	mov	eax, DWORD PTR _p$34679[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _p$34679[ebp]
	add	ecx, DWORD PTR _psize$34690[ebp]
	mov	edx, DWORD PTR _psize$34690[ebp]
	mov	DWORD PTR [ecx], edx
$LN26@mspace_fre:

; 5675 : 
; 5676 :           if (is_small(psize)) {

	mov	eax, DWORD PTR _psize$34690[ebp]
	shr	eax, 3
	cmp	eax, 32					; 00000020H
	jae	$LN25@mspace_fre

; 5677 :             insert_small_chunk(fm, p, psize);

	mov	ecx, DWORD PTR _psize$34690[ebp]
	shr	ecx, 3
	mov	DWORD PTR _I$34866[ebp], ecx
	mov	edx, DWORD PTR _I$34866[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _fm$34683[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+40]
	mov	DWORD PTR _B$34868[ebp], ecx
	mov	edx, DWORD PTR _B$34868[ebp]
	mov	DWORD PTR _F$34871[ebp], edx
	mov	eax, 1
	mov	ecx, DWORD PTR _I$34866[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _fm$34683[ebp]
	and	eax, DWORD PTR [ecx]
	jne	SHORT $LN24@mspace_fre
	mov	edx, 1
	mov	ecx, DWORD PTR _I$34866[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _fm$34683[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _fm$34683[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN23@mspace_fre
$LN24@mspace_fre:
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN22@mspace_fre
	mov	eax, DWORD PTR _B$34868[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$34871[ebp], ecx
	jmp	SHORT $LN23@mspace_fre
$LN22@mspace_fre:
	call	DWORD PTR __imp__abort
$LN23@mspace_fre:
	mov	edx, DWORD PTR _B$34868[ebp]
	mov	eax, DWORD PTR _p$34679[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _F$34871[ebp]
	mov	edx, DWORD PTR _p$34679[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _p$34679[ebp]
	mov	ecx, DWORD PTR _F$34871[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _p$34679[ebp]
	mov	eax, DWORD PTR _B$34868[ebp]
	mov	DWORD PTR [edx+12], eax

; 5678 :             check_free_chunk(fm, p);
; 5679 :           }
; 5680 :           else {

	jmp	$LN20@mspace_fre
$LN25@mspace_fre:

; 5681 :             tchunkptr tp = (tchunkptr)p;

	mov	ecx, DWORD PTR _p$34679[ebp]
	mov	DWORD PTR _tp$34879[ebp], ecx

; 5682 :             insert_large_chunk(fm, tp, psize);

	mov	edx, DWORD PTR _psize$34690[ebp]
	shr	edx, 8
	mov	DWORD PTR _X$34883[ebp], edx
	cmp	DWORD PTR _X$34883[ebp], 0
	jne	SHORT $LN19@mspace_fre
	mov	DWORD PTR _I$34882[ebp], 0
	jmp	SHORT $LN18@mspace_fre
$LN19@mspace_fre:
	cmp	DWORD PTR _X$34883[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN17@mspace_fre
	mov	DWORD PTR _I$34882[ebp], 31		; 0000001fH
	jmp	SHORT $LN18@mspace_fre
$LN17@mspace_fre:
	mov	eax, DWORD PTR _X$34883[ebp]
	bsr	ecx, eax
	mov	DWORD PTR _K$34888[ebp], ecx
	mov	ecx, DWORD PTR _K$34888[ebp]
	add	ecx, 7
	mov	edx, DWORD PTR _psize$34690[ebp]
	shr	edx, cl
	and	edx, 1
	mov	eax, DWORD PTR _K$34888[ebp]
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _I$34882[ebp], ecx
$LN18@mspace_fre:
	mov	edx, DWORD PTR _I$34882[ebp]
	mov	eax, DWORD PTR _fm$34683[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+304]
	mov	DWORD PTR _H$34881[ebp], ecx
	mov	edx, DWORD PTR _tp$34879[ebp]
	mov	eax, DWORD PTR _I$34882[ebp]
	mov	DWORD PTR [edx+28], eax
	mov	ecx, DWORD PTR _tp$34879[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _tp$34879[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, 1
	mov	ecx, DWORD PTR _I$34882[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _fm$34683[ebp]
	and	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN15@mspace_fre
	mov	edx, 1
	mov	ecx, DWORD PTR _I$34882[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _fm$34683[ebp]
	or	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _fm$34683[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _H$34881[ebp]
	mov	eax, DWORD PTR _tp$34879[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _tp$34879[ebp]
	mov	edx, DWORD PTR _H$34881[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _tp$34879[ebp]
	mov	ecx, DWORD PTR _tp$34879[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _tp$34879[ebp]
	mov	eax, DWORD PTR _tp$34879[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	$LN14@mspace_fre
$LN15@mspace_fre:
	mov	ecx, DWORD PTR _H$34881[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _T$34897[ebp], edx
	cmp	DWORD PTR _I$34882[ebp], 31		; 0000001fH
	jne	SHORT $LN133@mspace_fre
	mov	DWORD PTR tv422[ebp], 0
	jmp	SHORT $LN134@mspace_fre
$LN133@mspace_fre:
	mov	eax, DWORD PTR _I$34882[ebp]
	shr	eax, 1
	add	eax, 6
	mov	ecx, 31					; 0000001fH
	sub	ecx, eax
	mov	DWORD PTR tv422[ebp], ecx
$LN134@mspace_fre:
	mov	edx, DWORD PTR _psize$34690[ebp]
	mov	ecx, DWORD PTR tv422[ebp]
	shl	edx, cl
	mov	DWORD PTR _K$34898[ebp], edx
$LN13@mspace_fre:
	mov	eax, DWORD PTR _T$34897[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -8					; fffffff8H
	cmp	ecx, DWORD PTR _psize$34690[ebp]
	je	$LN11@mspace_fre
	mov	edx, DWORD PTR _K$34898[ebp]
	shr	edx, 31					; 0000001fH
	and	edx, 1
	mov	eax, DWORD PTR _T$34897[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+16]
	mov	DWORD PTR _C$34908[ebp], ecx
	mov	edx, DWORD PTR _K$34898[ebp]
	shl	edx, 1
	mov	DWORD PTR _K$34898[ebp], edx
	mov	eax, DWORD PTR _C$34908[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN10@mspace_fre
	mov	ecx, DWORD PTR _C$34908[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _T$34897[ebp], edx
	jmp	SHORT $LN9@mspace_fre
$LN10@mspace_fre:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN8@mspace_fre
	mov	ecx, DWORD PTR _C$34908[ebp]
	mov	edx, DWORD PTR _tp$34879[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _tp$34879[ebp]
	mov	ecx, DWORD PTR _T$34897[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _tp$34879[ebp]
	mov	eax, DWORD PTR _tp$34879[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _tp$34879[ebp]
	mov	edx, DWORD PTR _tp$34879[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN14@mspace_fre
	jmp	SHORT $LN9@mspace_fre
$LN8@mspace_fre:
	call	DWORD PTR __imp__abort
	jmp	SHORT $LN14@mspace_fre
$LN9@mspace_fre:
	jmp	SHORT $LN6@mspace_fre
$LN11@mspace_fre:
	mov	eax, DWORD PTR _T$34897[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _F$34916[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@mspace_fre
	mov	eax, DWORD PTR _F$34916[ebp]
	mov	ecx, DWORD PTR _tp$34879[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _T$34897[ebp]
	mov	eax, DWORD PTR _tp$34879[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _tp$34879[ebp]
	mov	edx, DWORD PTR _F$34916[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _tp$34879[ebp]
	mov	ecx, DWORD PTR _T$34897[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _tp$34879[ebp]
	mov	DWORD PTR [edx+24], 0
	jmp	SHORT $LN14@mspace_fre
	jmp	SHORT $LN6@mspace_fre
$LN5@mspace_fre:
	call	DWORD PTR __imp__abort
	jmp	SHORT $LN14@mspace_fre
$LN6@mspace_fre:
	jmp	$LN13@mspace_fre
$LN14@mspace_fre:

; 5683 :             check_free_chunk(fm, p);
; 5684 :             if (--fm->release_checks == 0)

	mov	eax, DWORD PTR _fm$34683[ebp]
	mov	ecx, DWORD PTR [eax+32]
	sub	ecx, 1
	mov	edx, DWORD PTR _fm$34683[ebp]
	mov	DWORD PTR [edx+32], ecx
	mov	eax, DWORD PTR _fm$34683[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN20@mspace_fre

; 5685 :               release_unused_segments(fm);

	mov	ecx, DWORD PTR _fm$34683[ebp]
	push	ecx
	call	?release_unused_segments@@YAIPAUmalloc_state@@@Z ; release_unused_segments
	add	esp, 4
$LN20@mspace_fre:

; 5686 :           }

	jmp	SHORT $postaction$34706

; 5687 :           goto postaction;

	jmp	SHORT $postaction$34706
$erroraction$34779:

; 5688 :         }
; 5689 :       }
; 5690 :     erroraction:
; 5691 :       USAGE_ERROR_ACTION(fm, p);

	call	DWORD PTR __imp__abort
$postaction$34706:

; 5692 :     postaction:
; 5693 :       POSTACTION(fm);

	mov	edx, DWORD PTR _fm$34683[ebp]
	mov	eax, DWORD PTR [edx+444]
	and	eax, 2
	je	SHORT $LN127@mspace_fre
	xor	ecx, ecx
	mov	edx, DWORD PTR _fm$34683[ebp]
	add	edx, 448				; 000001c0H
	xchg	DWORD PTR [edx], ecx
$LN127@mspace_fre:

; 5694 :     }
; 5695 :   }
; 5696 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_free@@YAXPAX0@Z ENDP				; mspace_free
_TEXT	ENDS
PUBLIC	?mspace_calloc@@YAPAXPAXII@Z			; mspace_calloc
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv78 = -16						; size = 4
_mem$ = -12						; size = 4
_req$ = -8						; size = 4
_ms$ = -4						; size = 4
_msp$ = 8						; size = 4
_n_elements$ = 12					; size = 4
_elem_size$ = 16					; size = 4
?mspace_calloc@@YAPAXPAXII@Z PROC			; mspace_calloc

; 5698 : void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 5699 :   void* mem;
; 5700 :   size_t req = 0;

	mov	DWORD PTR _req$[ebp], 0

; 5701 :   mstate ms = (mstate)msp;

	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _ms$[ebp], eax

; 5702 :   if (!ok_magic(ms)) {

	xor	ecx, ecx
	je	SHORT $LN4@mspace_cal

; 5703 :     USAGE_ERROR_ACTION(ms,ms);

	call	DWORD PTR __imp__abort

; 5704 :     return 0;

	xor	eax, eax
	jmp	$LN5@mspace_cal
$LN4@mspace_cal:

; 5705 :   }
; 5706 :   if (n_elements != 0) {

	cmp	DWORD PTR _n_elements$[ebp], 0
	je	SHORT $LN3@mspace_cal

; 5707 :     req = n_elements * elem_size;

	mov	edx, DWORD PTR _n_elements$[ebp]
	imul	edx, DWORD PTR _elem_size$[ebp]
	mov	DWORD PTR _req$[ebp], edx

; 5708 :     if (((n_elements | elem_size) & ~(size_t)0xffff) &&
; 5709 :         (req / n_elements != elem_size))

	mov	eax, DWORD PTR _n_elements$[ebp]
	or	eax, DWORD PTR _elem_size$[ebp]
	and	eax, -65536				; ffff0000H
	je	SHORT $LN3@mspace_cal
	mov	eax, DWORD PTR _req$[ebp]
	xor	edx, edx
	div	DWORD PTR _n_elements$[ebp]
	cmp	eax, DWORD PTR _elem_size$[ebp]
	je	SHORT $LN3@mspace_cal

; 5710 :       req = MAX_SIZE_T; /* force downstream failure on overflow */

	mov	DWORD PTR _req$[ebp], -1
$LN3@mspace_cal:

; 5711 :   }
; 5712 :   mem = internal_malloc(ms, req);

	cmp	DWORD PTR _ms$[ebp], OFFSET __gm_
	jne	SHORT $LN7@mspace_cal
	mov	ecx, DWORD PTR _req$[ebp]
	push	ecx
	call	?dlmalloc@@YAPAXI@Z			; dlmalloc
	add	esp, 4
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN8@mspace_cal
$LN7@mspace_cal:
	mov	edx, DWORD PTR _req$[ebp]
	push	edx
	mov	eax, DWORD PTR _ms$[ebp]
	push	eax
	call	?mspace_malloc@@YAPAXPAXI@Z		; mspace_malloc
	add	esp, 8
	mov	DWORD PTR tv78[ebp], eax
$LN8@mspace_cal:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _mem$[ebp], ecx

; 5713 :   if (mem != 0 && calloc_must_clear(mem2chunk(mem)))

	cmp	DWORD PTR _mem$[ebp], 0
	je	SHORT $LN1@mspace_cal
	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx-4]
	and	eax, 3
	je	SHORT $LN1@mspace_cal

; 5714 :     memset(mem, 0, req);

	mov	ecx, DWORD PTR _req$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@mspace_cal:

; 5715 :   return mem;

	mov	eax, DWORD PTR _mem$[ebp]
$LN5@mspace_cal:

; 5716 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_calloc@@YAPAXPAXII@Z ENDP			; mspace_calloc
_TEXT	ENDS
PUBLIC	?mspace_realloc@@YAPAXPAX0I@Z			; mspace_realloc
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv147 = -40						; size = 4
tv87 = -36						; size = 4
tv85 = -32						; size = 4
tv73 = -28						; size = 4
_oc$35004 = -24						; size = 4
_newp$34994 = -20					; size = 4
_nb$34961 = -16						; size = 4
_m$34989 = -12						; size = 4
_oldp$34985 = -8					; size = 4
_mem$ = -4						; size = 4
_msp$ = 8						; size = 4
_oldmem$ = 12						; size = 4
_bytes$ = 16						; size = 4
?mspace_realloc@@YAPAXPAX0I@Z PROC			; mspace_realloc

; 5718 : void* mspace_realloc(mspace msp, void* oldmem, size_t bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 5719 :   void* mem = 0;

	mov	DWORD PTR _mem$[ebp], 0

; 5720 :   if (oldmem == 0) {

	cmp	DWORD PTR _oldmem$[ebp], 0
	jne	SHORT $LN9@mspace_rea

; 5721 :     mem = mspace_malloc(msp, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msp$[ebp]
	push	ecx
	call	?mspace_malloc@@YAPAXPAXI@Z		; mspace_malloc
	add	esp, 8
	mov	DWORD PTR _mem$[ebp], eax
	jmp	$LN8@mspace_rea
$LN9@mspace_rea:

; 5722 :   }
; 5723 :   else if (bytes >= MAX_REQUEST) {

	cmp	DWORD PTR _bytes$[ebp], -64		; ffffffc0H
	jb	SHORT $LN7@mspace_rea

; 5724 :     MALLOC_FAILURE_ACTION;
; 5725 :   }
; 5726 : #ifdef REALLOC_ZERO_BYTES_FREES
; 5727 :   else if (bytes == 0) {
; 5728 :     mspace_free(msp, oldmem);
; 5729 :   }
; 5730 : #endif /* REALLOC_ZERO_BYTES_FREES */
; 5731 :   else {

	jmp	$LN8@mspace_rea
$LN7@mspace_rea:

; 5732 :     size_t nb = request2size(bytes);

	cmp	DWORD PTR _bytes$[ebp], 11		; 0000000bH
	jae	SHORT $LN12@mspace_rea
	mov	DWORD PTR tv73[ebp], 16			; 00000010H
	jmp	SHORT $LN13@mspace_rea
$LN12@mspace_rea:
	mov	edx, DWORD PTR _bytes$[ebp]
	add	edx, 11					; 0000000bH
	and	edx, -8					; fffffff8H
	mov	DWORD PTR tv73[ebp], edx
$LN13@mspace_rea:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR _nb$34961[ebp], eax

; 5733 :     mchunkptr oldp = mem2chunk(oldmem);

	mov	ecx, DWORD PTR _oldmem$[ebp]
	sub	ecx, 8
	mov	DWORD PTR _oldp$34985[ebp], ecx

; 5734 : #if ! FOOTERS
; 5735 :     mstate m = (mstate)msp;

	mov	edx, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _m$34989[ebp], edx

; 5736 : #else /* FOOTERS */
; 5737 :     mstate m = get_mstate_for(oldp);
; 5738 :     if (!ok_magic(m)) {
; 5739 :       USAGE_ERROR_ACTION(m, oldmem);
; 5740 :       return 0;
; 5741 :     }
; 5742 : #endif /* FOOTERS */
; 5743 :     if (!PREACTION(m)) {

	mov	eax, DWORD PTR _m$34989[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 2
	je	SHORT $LN16@mspace_rea
	mov	edx, 1
	mov	eax, DWORD PTR _m$34989[ebp]
	add	eax, 448				; 000001c0H
	xchg	DWORD PTR [eax], edx
	test	edx, edx
	je	SHORT $LN14@mspace_rea
	mov	ecx, DWORD PTR _m$34989[ebp]
	add	ecx, 448				; 000001c0H
	push	ecx
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN15@mspace_rea
$LN14@mspace_rea:
	mov	DWORD PTR tv85[ebp], 0
$LN15@mspace_rea:
	mov	edx, DWORD PTR tv85[ebp]
	mov	DWORD PTR tv87[ebp], edx
	jmp	SHORT $LN17@mspace_rea
$LN16@mspace_rea:
	mov	DWORD PTR tv87[ebp], 0
$LN17@mspace_rea:
	cmp	DWORD PTR tv87[ebp], 0
	jne	$LN8@mspace_rea

; 5744 :       mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);

	push	1
	mov	eax, DWORD PTR _nb$34961[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldp$34985[ebp]
	push	ecx
	mov	edx, DWORD PTR _m$34989[ebp]
	push	edx
	call	?try_realloc_chunk@@YAPAUmalloc_chunk@@PAUmalloc_state@@PAU1@IH@Z ; try_realloc_chunk
	add	esp, 16					; 00000010H
	mov	DWORD PTR _newp$34994[ebp], eax

; 5745 :       POSTACTION(m);

	mov	eax, DWORD PTR _m$34989[ebp]
	mov	ecx, DWORD PTR [eax+444]
	and	ecx, 2
	je	SHORT $LN4@mspace_rea
	xor	edx, edx
	mov	eax, DWORD PTR _m$34989[ebp]
	add	eax, 448				; 000001c0H
	xchg	DWORD PTR [eax], edx
$LN4@mspace_rea:

; 5746 :       if (newp != 0) {

	cmp	DWORD PTR _newp$34994[ebp], 0
	je	SHORT $LN3@mspace_rea

; 5747 :         check_inuse_chunk(m, newp);
; 5748 :         mem = chunk2mem(newp);

	mov	ecx, DWORD PTR _newp$34994[ebp]
	add	ecx, 8
	mov	DWORD PTR _mem$[ebp], ecx

; 5749 :       }
; 5750 :       else {

	jmp	SHORT $LN8@mspace_rea
$LN3@mspace_rea:

; 5751 :         mem = mspace_malloc(m, bytes);

	mov	edx, DWORD PTR _bytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _m$34989[ebp]
	push	eax
	call	?mspace_malloc@@YAPAXPAXI@Z		; mspace_malloc
	add	esp, 8
	mov	DWORD PTR _mem$[ebp], eax

; 5752 :         if (mem != 0) {

	cmp	DWORD PTR _mem$[ebp], 0
	je	SHORT $LN8@mspace_rea

; 5753 :           size_t oc = chunksize(oldp) - overhead_for(oldp);

	mov	ecx, DWORD PTR _oldp$34985[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, -8					; fffffff8H
	mov	eax, DWORD PTR _oldp$34985[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 3
	neg	ecx
	sbb	ecx, ecx
	and	ecx, -4					; fffffffcH
	add	ecx, 8
	sub	edx, ecx
	mov	DWORD PTR _oc$35004[ebp], edx

; 5754 :           memcpy(mem, oldmem, (oc < bytes)? oc : bytes);

	mov	edx, DWORD PTR _oc$35004[ebp]
	cmp	edx, DWORD PTR _bytes$[ebp]
	jae	SHORT $LN18@mspace_rea
	mov	eax, DWORD PTR _oc$35004[ebp]
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN19@mspace_rea
$LN18@mspace_rea:
	mov	ecx, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR tv147[ebp], ecx
$LN19@mspace_rea:
	mov	edx, DWORD PTR tv147[ebp]
	push	edx
	mov	eax, DWORD PTR _oldmem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5755 :           mspace_free(m, oldmem);

	mov	edx, DWORD PTR _oldmem$[ebp]
	push	edx
	mov	eax, DWORD PTR _m$34989[ebp]
	push	eax
	call	?mspace_free@@YAXPAX0@Z			; mspace_free
	add	esp, 8
$LN8@mspace_rea:

; 5756 :         }
; 5757 :       }
; 5758 :     }
; 5759 :   }
; 5760 :   return mem;

	mov	eax, DWORD PTR _mem$[ebp]

; 5761 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_realloc@@YAPAXPAX0I@Z ENDP			; mspace_realloc
_TEXT	ENDS
PUBLIC	?mspace_realloc_in_place@@YAPAXPAX0I@Z		; mspace_realloc_in_place
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv84 = -32						; size = 4
tv82 = -28						; size = 4
tv70 = -24						; size = 4
_newp$35061 = -20					; size = 4
_nb$35028 = -16						; size = 4
_m$35056 = -12						; size = 4
_oldp$35052 = -8					; size = 4
_mem$ = -4						; size = 4
_msp$ = 8						; size = 4
_oldmem$ = 12						; size = 4
_bytes$ = 16						; size = 4
?mspace_realloc_in_place@@YAPAXPAX0I@Z PROC		; mspace_realloc_in_place

; 5763 : void* mspace_realloc_in_place(mspace msp, void* oldmem, size_t bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 5764 :   void* mem = 0;

	mov	DWORD PTR _mem$[ebp], 0

; 5765 :   if (oldmem != 0) {

	cmp	DWORD PTR _oldmem$[ebp], 0
	je	$LN6@mspace_rea@2

; 5766 :     if (bytes >= MAX_REQUEST) {

	cmp	DWORD PTR _bytes$[ebp], -64		; ffffffc0H
	jb	SHORT $LN5@mspace_rea@2

; 5767 :       MALLOC_FAILURE_ACTION;
; 5768 :     }
; 5769 :     else {

	jmp	$LN6@mspace_rea@2
$LN5@mspace_rea@2:

; 5770 :       size_t nb = request2size(bytes);

	cmp	DWORD PTR _bytes$[ebp], 11		; 0000000bH
	jae	SHORT $LN9@mspace_rea@2
	mov	DWORD PTR tv70[ebp], 16			; 00000010H
	jmp	SHORT $LN10@mspace_rea@2
$LN9@mspace_rea@2:
	mov	eax, DWORD PTR _bytes$[ebp]
	add	eax, 11					; 0000000bH
	and	eax, -8					; fffffff8H
	mov	DWORD PTR tv70[ebp], eax
$LN10@mspace_rea@2:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _nb$35028[ebp], ecx

; 5771 :       mchunkptr oldp = mem2chunk(oldmem);

	mov	edx, DWORD PTR _oldmem$[ebp]
	sub	edx, 8
	mov	DWORD PTR _oldp$35052[ebp], edx

; 5772 : #if ! FOOTERS
; 5773 :       mstate m = (mstate)msp;

	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _m$35056[ebp], eax

; 5774 : #else /* FOOTERS */
; 5775 :       mstate m = get_mstate_for(oldp);
; 5776 :       (void)msp; /* placate people compiling -Wunused */
; 5777 :       if (!ok_magic(m)) {
; 5778 :         USAGE_ERROR_ACTION(m, oldmem);
; 5779 :         return 0;
; 5780 :       }
; 5781 : #endif /* FOOTERS */
; 5782 :       if (!PREACTION(m)) {

	mov	ecx, DWORD PTR _m$35056[ebp]
	mov	edx, DWORD PTR [ecx+444]
	and	edx, 2
	je	SHORT $LN13@mspace_rea@2
	mov	eax, 1
	mov	ecx, DWORD PTR _m$35056[ebp]
	add	ecx, 448				; 000001c0H
	xchg	DWORD PTR [ecx], eax
	test	eax, eax
	je	SHORT $LN11@mspace_rea@2
	mov	edx, DWORD PTR _m$35056[ebp]
	add	edx, 448				; 000001c0H
	push	edx
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN12@mspace_rea@2
$LN11@mspace_rea@2:
	mov	DWORD PTR tv82[ebp], 0
$LN12@mspace_rea@2:
	mov	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN14@mspace_rea@2
$LN13@mspace_rea@2:
	mov	DWORD PTR tv84[ebp], 0
$LN14@mspace_rea@2:
	cmp	DWORD PTR tv84[ebp], 0
	jne	SHORT $LN6@mspace_rea@2

; 5783 :         mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);

	push	0
	mov	ecx, DWORD PTR _nb$35028[ebp]
	push	ecx
	mov	edx, DWORD PTR _oldp$35052[ebp]
	push	edx
	mov	eax, DWORD PTR _m$35056[ebp]
	push	eax
	call	?try_realloc_chunk@@YAPAUmalloc_chunk@@PAUmalloc_state@@PAU1@IH@Z ; try_realloc_chunk
	add	esp, 16					; 00000010H
	mov	DWORD PTR _newp$35061[ebp], eax

; 5784 :         POSTACTION(m);

	mov	ecx, DWORD PTR _m$35056[ebp]
	mov	edx, DWORD PTR [ecx+444]
	and	edx, 2
	je	SHORT $LN2@mspace_rea@2
	xor	eax, eax
	mov	ecx, DWORD PTR _m$35056[ebp]
	add	ecx, 448				; 000001c0H
	xchg	DWORD PTR [ecx], eax
$LN2@mspace_rea@2:

; 5785 :         if (newp == oldp) {

	mov	edx, DWORD PTR _newp$35061[ebp]
	cmp	edx, DWORD PTR _oldp$35052[ebp]
	jne	SHORT $LN6@mspace_rea@2

; 5786 :           check_inuse_chunk(m, newp);
; 5787 :           mem = oldmem;

	mov	eax, DWORD PTR _oldmem$[ebp]
	mov	DWORD PTR _mem$[ebp], eax
$LN6@mspace_rea@2:

; 5788 :         }
; 5789 :       }
; 5790 :     }
; 5791 :   }
; 5792 :   return mem;

	mov	eax, DWORD PTR _mem$[ebp]

; 5793 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_realloc_in_place@@YAPAXPAX0I@Z ENDP		; mspace_realloc_in_place
_TEXT	ENDS
PUBLIC	?mspace_memalign@@YAPAXPAXII@Z			; mspace_memalign
; Function compile flags: /Odtp
_TEXT	SEGMENT
_ms$ = -4						; size = 4
_msp$ = 8						; size = 4
_alignment$ = 12					; size = 4
_bytes$ = 16						; size = 4
?mspace_memalign@@YAPAXPAXII@Z PROC			; mspace_memalign

; 5795 : void* mspace_memalign(mspace msp, size_t alignment, size_t bytes) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5796 :   mstate ms = (mstate)msp;

	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _ms$[ebp], eax

; 5797 :   if (!ok_magic(ms)) {

	xor	ecx, ecx
	je	SHORT $LN2@mspace_mem

; 5798 :     USAGE_ERROR_ACTION(ms,ms);

	call	DWORD PTR __imp__abort

; 5799 :     return 0;

	xor	eax, eax
	jmp	SHORT $LN3@mspace_mem
$LN2@mspace_mem:

; 5800 :   }
; 5801 :   if (alignment <= MALLOC_ALIGNMENT)

	cmp	DWORD PTR _alignment$[ebp], 8
	ja	SHORT $LN1@mspace_mem

; 5802 :     return mspace_malloc(msp, bytes);

	mov	edx, DWORD PTR _bytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _msp$[ebp]
	push	eax
	call	?mspace_malloc@@YAPAXPAXI@Z		; mspace_malloc
	add	esp, 8
	jmp	SHORT $LN3@mspace_mem
$LN1@mspace_mem:

; 5803 :   return internal_memalign(ms, alignment, bytes);

	mov	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _alignment$[ebp]
	push	edx
	mov	eax, DWORD PTR _ms$[ebp]
	push	eax
	call	?internal_memalign@@YAPAXPAUmalloc_state@@II@Z ; internal_memalign
	add	esp, 12					; 0000000cH
$LN3@mspace_mem:

; 5804 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_memalign@@YAPAXPAXII@Z ENDP			; mspace_memalign
_TEXT	ENDS
PUBLIC	?mspace_independent_calloc@@YAPAPAXPAXIIQAPAX@Z	; mspace_independent_calloc
; Function compile flags: /Odtp
_TEXT	SEGMENT
_sz$ = -8						; size = 4
_ms$ = -4						; size = 4
_msp$ = 8						; size = 4
_n_elements$ = 12					; size = 4
_elem_size$ = 16					; size = 4
_chunks$ = 20						; size = 4
?mspace_independent_calloc@@YAPAPAXPAXIIQAPAX@Z PROC	; mspace_independent_calloc

; 5807 :                                  size_t elem_size, void* chunks[]) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5808 :   size_t sz = elem_size; /* serves as 1-element array */

	mov	eax, DWORD PTR _elem_size$[ebp]
	mov	DWORD PTR _sz$[ebp], eax

; 5809 :   mstate ms = (mstate)msp;

	mov	ecx, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _ms$[ebp], ecx

; 5810 :   if (!ok_magic(ms)) {

	xor	edx, edx
	je	SHORT $LN1@mspace_ind

; 5811 :     USAGE_ERROR_ACTION(ms,ms);

	call	DWORD PTR __imp__abort

; 5812 :     return 0;

	xor	eax, eax
	jmp	SHORT $LN2@mspace_ind
$LN1@mspace_ind:

; 5813 :   }
; 5814 :   return ialloc(ms, n_elements, &sz, 3, chunks);

	mov	eax, DWORD PTR _chunks$[ebp]
	push	eax
	push	3
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n_elements$[ebp]
	push	edx
	mov	eax, DWORD PTR _ms$[ebp]
	push	eax
	call	?ialloc@@YAPAPAXPAUmalloc_state@@IPAIHQAPAX@Z ; ialloc
	add	esp, 20					; 00000014H
$LN2@mspace_ind:

; 5815 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_independent_calloc@@YAPAPAXPAXIIQAPAX@Z ENDP	; mspace_independent_calloc
_TEXT	ENDS
PUBLIC	?mspace_independent_comalloc@@YAPAPAXPAXIQAIQAPAX@Z ; mspace_independent_comalloc
; Function compile flags: /Odtp
_TEXT	SEGMENT
_ms$ = -4						; size = 4
_msp$ = 8						; size = 4
_n_elements$ = 12					; size = 4
_sizes$ = 16						; size = 4
_chunks$ = 20						; size = 4
?mspace_independent_comalloc@@YAPAPAXPAXIQAIQAPAX@Z PROC ; mspace_independent_comalloc

; 5818 :                                    size_t sizes[], void* chunks[]) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5819 :   mstate ms = (mstate)msp;

	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _ms$[ebp], eax

; 5820 :   if (!ok_magic(ms)) {

	xor	ecx, ecx
	je	SHORT $LN1@mspace_ind@2

; 5821 :     USAGE_ERROR_ACTION(ms,ms);

	call	DWORD PTR __imp__abort

; 5822 :     return 0;

	xor	eax, eax
	jmp	SHORT $LN2@mspace_ind@2
$LN1@mspace_ind@2:

; 5823 :   }
; 5824 :   return ialloc(ms, n_elements, sizes, 0, chunks);

	mov	edx, DWORD PTR _chunks$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _sizes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n_elements$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ms$[ebp]
	push	edx
	call	?ialloc@@YAPAPAXPAUmalloc_state@@IPAIHQAPAX@Z ; ialloc
	add	esp, 20					; 00000014H
$LN2@mspace_ind@2:

; 5825 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_independent_comalloc@@YAPAPAXPAXIQAIQAPAX@Z ENDP ; mspace_independent_comalloc
_TEXT	ENDS
PUBLIC	?mspace_bulk_free@@YAIPAXPAPAXI@Z		; mspace_bulk_free
; Function compile flags: /Odtp
_TEXT	SEGMENT
_msp$ = 8						; size = 4
_array$ = 12						; size = 4
_nelem$ = 16						; size = 4
?mspace_bulk_free@@YAIPAXPAPAXI@Z PROC			; mspace_bulk_free

; 5827 : size_t mspace_bulk_free(mspace msp, void* array[], size_t nelem) {

	push	ebp
	mov	ebp, esp

; 5828 :   return internal_bulk_free((mstate)msp, array, nelem);

	mov	eax, DWORD PTR _nelem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _array$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msp$[ebp]
	push	edx
	call	?internal_bulk_free@@YAIPAUmalloc_state@@QAPAXI@Z ; internal_bulk_free
	add	esp, 12					; 0000000cH

; 5829 : }

	pop	ebp
	ret	0
?mspace_bulk_free@@YAIPAXPAPAXI@Z ENDP			; mspace_bulk_free
_TEXT	ENDS
PUBLIC	?mspace_trim@@YAHPAXI@Z				; mspace_trim
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv77 = -16						; size = 4
tv75 = -12						; size = 4
_result$ = -8						; size = 4
_ms$ = -4						; size = 4
_msp$ = 8						; size = 4
_pad$ = 12						; size = 4
?mspace_trim@@YAHPAXI@Z PROC				; mspace_trim

; 5851 : int mspace_trim(mspace msp, size_t pad) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 5852 :   int result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 5853 :   mstate ms = (mstate)msp;

	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _ms$[ebp], eax

; 5854 :   if (ok_magic(ms)) {

	mov	ecx, 1
	test	ecx, ecx
	je	$LN4@mspace_tri

; 5855 :     if (!PREACTION(ms)) {

	mov	edx, DWORD PTR _ms$[ebp]
	mov	eax, DWORD PTR [edx+444]
	and	eax, 2
	je	SHORT $LN9@mspace_tri
	mov	ecx, 1
	mov	edx, DWORD PTR _ms$[ebp]
	add	edx, 448				; 000001c0H
	xchg	DWORD PTR [edx], ecx
	test	ecx, ecx
	je	SHORT $LN7@mspace_tri
	mov	eax, DWORD PTR _ms$[ebp]
	add	eax, 448				; 000001c0H
	push	eax
	call	?spin_acquire_lock@@YAHPAH@Z		; spin_acquire_lock
	add	esp, 4
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN8@mspace_tri
$LN7@mspace_tri:
	mov	DWORD PTR tv75[ebp], 0
$LN8@mspace_tri:
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR tv77[ebp], ecx
	jmp	SHORT $LN10@mspace_tri
$LN9@mspace_tri:
	mov	DWORD PTR tv77[ebp], 0
$LN10@mspace_tri:
	cmp	DWORD PTR tv77[ebp], 0
	jne	SHORT $LN3@mspace_tri

; 5856 :       result = sys_trim(ms, pad);

	mov	edx, DWORD PTR _pad$[ebp]
	push	edx
	mov	eax, DWORD PTR _ms$[ebp]
	push	eax
	call	?sys_trim@@YAHPAUmalloc_state@@I@Z	; sys_trim
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax

; 5857 :       POSTACTION(ms);

	mov	ecx, DWORD PTR _ms$[ebp]
	mov	edx, DWORD PTR [ecx+444]
	and	edx, 2
	je	SHORT $LN3@mspace_tri
	xor	eax, eax
	mov	ecx, DWORD PTR _ms$[ebp]
	add	ecx, 448				; 000001c0H
	xchg	DWORD PTR [ecx], eax
$LN3@mspace_tri:

; 5858 :     }
; 5859 :   }
; 5860 :   else {

	jmp	SHORT $LN1@mspace_tri
$LN4@mspace_tri:

; 5861 :     USAGE_ERROR_ACTION(ms,ms);

	call	DWORD PTR __imp__abort
$LN1@mspace_tri:

; 5862 :   }
; 5863 :   return result;

	mov	eax, DWORD PTR _result$[ebp]

; 5864 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_trim@@YAHPAXI@Z ENDP				; mspace_trim
_TEXT	ENDS
PUBLIC	?mspace_malloc_stats@@YAXPAX@Z			; mspace_malloc_stats
; Function compile flags: /Odtp
_TEXT	SEGMENT
_ms$ = -4						; size = 4
_msp$ = 8						; size = 4
?mspace_malloc_stats@@YAXPAX@Z PROC			; mspace_malloc_stats

; 5867 : void mspace_malloc_stats(mspace msp) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5868 :   mstate ms = (mstate)msp;

	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _ms$[ebp], eax

; 5869 :   if (ok_magic(ms)) {

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@mspace_mal@2

; 5870 :     internal_malloc_stats(ms);

	mov	edx, DWORD PTR _ms$[ebp]
	push	edx
	call	?internal_malloc_stats@@YAXPAUmalloc_state@@@Z ; internal_malloc_stats
	add	esp, 4

; 5871 :   }
; 5872 :   else {

	jmp	SHORT $LN3@mspace_mal@2
$LN2@mspace_mal@2:

; 5873 :     USAGE_ERROR_ACTION(ms,ms);

	call	DWORD PTR __imp__abort
$LN3@mspace_mal@2:

; 5874 :   }
; 5875 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_malloc_stats@@YAXPAX@Z ENDP			; mspace_malloc_stats
_TEXT	ENDS
PUBLIC	?mspace_footprint@@YAIPAX@Z			; mspace_footprint
; Function compile flags: /Odtp
_TEXT	SEGMENT
_result$ = -8						; size = 4
_ms$ = -4						; size = 4
_msp$ = 8						; size = 4
?mspace_footprint@@YAIPAX@Z PROC			; mspace_footprint

; 5878 : size_t mspace_footprint(mspace msp) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5879 :   size_t result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 5880 :   mstate ms = (mstate)msp;

	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _ms$[ebp], eax

; 5881 :   if (ok_magic(ms)) {

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@mspace_foo

; 5882 :     result = ms->footprint;

	mov	edx, DWORD PTR _ms$[ebp]
	mov	eax, DWORD PTR [edx+432]
	mov	DWORD PTR _result$[ebp], eax

; 5883 :   }
; 5884 :   else {

	jmp	SHORT $LN1@mspace_foo
$LN2@mspace_foo:

; 5885 :     USAGE_ERROR_ACTION(ms,ms);

	call	DWORD PTR __imp__abort
$LN1@mspace_foo:

; 5886 :   }
; 5887 :   return result;

	mov	eax, DWORD PTR _result$[ebp]

; 5888 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_footprint@@YAIPAX@Z ENDP			; mspace_footprint
_TEXT	ENDS
PUBLIC	?mspace_max_footprint@@YAIPAX@Z			; mspace_max_footprint
; Function compile flags: /Odtp
_TEXT	SEGMENT
_result$ = -8						; size = 4
_ms$ = -4						; size = 4
_msp$ = 8						; size = 4
?mspace_max_footprint@@YAIPAX@Z PROC			; mspace_max_footprint

; 5890 : size_t mspace_max_footprint(mspace msp) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5891 :   size_t result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 5892 :   mstate ms = (mstate)msp;

	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _ms$[ebp], eax

; 5893 :   if (ok_magic(ms)) {

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@mspace_max

; 5894 :     result = ms->max_footprint;

	mov	edx, DWORD PTR _ms$[ebp]
	mov	eax, DWORD PTR [edx+436]
	mov	DWORD PTR _result$[ebp], eax

; 5895 :   }
; 5896 :   else {

	jmp	SHORT $LN1@mspace_max
$LN2@mspace_max:

; 5897 :     USAGE_ERROR_ACTION(ms,ms);

	call	DWORD PTR __imp__abort
$LN1@mspace_max:

; 5898 :   }
; 5899 :   return result;

	mov	eax, DWORD PTR _result$[ebp]

; 5900 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_max_footprint@@YAIPAX@Z ENDP			; mspace_max_footprint
_TEXT	ENDS
PUBLIC	?mspace_footprint_limit@@YAIPAX@Z		; mspace_footprint_limit
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv67 = -16						; size = 4
_maf$35147 = -12					; size = 4
_result$ = -8						; size = 4
_ms$ = -4						; size = 4
_msp$ = 8						; size = 4
?mspace_footprint_limit@@YAIPAX@Z PROC			; mspace_footprint_limit

; 5902 : size_t mspace_footprint_limit(mspace msp) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 5903 :   size_t result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 5904 :   mstate ms = (mstate)msp;

	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _ms$[ebp], eax

; 5905 :   if (ok_magic(ms)) {

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@mspace_foo@2

; 5906 :     size_t maf = ms->footprint_limit;

	mov	edx, DWORD PTR _ms$[ebp]
	mov	eax, DWORD PTR [edx+440]
	mov	DWORD PTR _maf$35147[ebp], eax

; 5907 :     result = (maf == 0) ? MAX_SIZE_T : maf;

	cmp	DWORD PTR _maf$35147[ebp], 0
	jne	SHORT $LN5@mspace_foo@2
	mov	DWORD PTR tv67[ebp], -1
	jmp	SHORT $LN6@mspace_foo@2
$LN5@mspace_foo@2:
	mov	ecx, DWORD PTR _maf$35147[ebp]
	mov	DWORD PTR tv67[ebp], ecx
$LN6@mspace_foo@2:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _result$[ebp], edx

; 5908 :   }
; 5909 :   else {

	jmp	SHORT $LN1@mspace_foo@2
$LN2@mspace_foo@2:

; 5910 :     USAGE_ERROR_ACTION(ms,ms);

	call	DWORD PTR __imp__abort
$LN1@mspace_foo@2:

; 5911 :   }
; 5912 :   return result;

	mov	eax, DWORD PTR _result$[ebp]

; 5913 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_footprint_limit@@YAIPAX@Z ENDP			; mspace_footprint_limit
_TEXT	ENDS
PUBLIC	?mspace_set_footprint_limit@@YAIPAXI@Z		; mspace_set_footprint_limit
; Function compile flags: /Odtp
_TEXT	SEGMENT
_result$ = -8						; size = 4
_ms$ = -4						; size = 4
_msp$ = 8						; size = 4
_bytes$ = 12						; size = 4
?mspace_set_footprint_limit@@YAIPAXI@Z PROC		; mspace_set_footprint_limit

; 5915 : size_t mspace_set_footprint_limit(mspace msp, size_t bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5916 :   size_t result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 5917 :   mstate ms = (mstate)msp;

	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _ms$[ebp], eax

; 5918 :   if (ok_magic(ms)) {

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN5@mspace_set

; 5919 :     if (bytes == 0)

	cmp	DWORD PTR _bytes$[ebp], 0
	jne	SHORT $LN4@mspace_set

; 5920 :       result = granularity_align(1); /* Use minimal size */

	mov	edx, DWORD PTR _mparams+8
	mov	eax, DWORD PTR _mparams+8
	sub	eax, 1
	not	eax
	and	edx, eax
	mov	DWORD PTR _result$[ebp], edx
$LN4@mspace_set:

; 5921 :     if (bytes == MAX_SIZE_T)

	cmp	DWORD PTR _bytes$[ebp], -1
	jne	SHORT $LN3@mspace_set

; 5922 :       result = 0;                    /* disable */

	mov	DWORD PTR _result$[ebp], 0

; 5923 :     else

	jmp	SHORT $LN2@mspace_set
$LN3@mspace_set:

; 5924 :       result = granularity_align(bytes);

	mov	ecx, DWORD PTR _mparams+8
	mov	edx, DWORD PTR _bytes$[ebp]
	lea	eax, DWORD PTR [edx+ecx-1]
	mov	ecx, DWORD PTR _mparams+8
	sub	ecx, 1
	not	ecx
	and	eax, ecx
	mov	DWORD PTR _result$[ebp], eax
$LN2@mspace_set:

; 5925 :     ms->footprint_limit = result;

	mov	edx, DWORD PTR _ms$[ebp]
	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR [edx+440], eax

; 5926 :   }
; 5927 :   else {

	jmp	SHORT $LN1@mspace_set
$LN5@mspace_set:

; 5928 :     USAGE_ERROR_ACTION(ms,ms);

	call	DWORD PTR __imp__abort
$LN1@mspace_set:

; 5929 :   }
; 5930 :   return result;

	mov	eax, DWORD PTR _result$[ebp]

; 5931 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_set_footprint_limit@@YAIPAXI@Z ENDP		; mspace_set_footprint_limit
_TEXT	ENDS
PUBLIC	?mspace_mallinfo@@YA?AUmallinfo@@PAX@Z		; mspace_mallinfo
; Function compile flags: /Odtp
_TEXT	SEGMENT
$T35629 = -88						; size = 40
$T35628 = -44						; size = 40
_ms$ = -4						; size = 4
$T35627 = 8						; size = 4
_msp$ = 12						; size = 4
?mspace_mallinfo@@YA?AUmallinfo@@PAX@Z PROC		; mspace_mallinfo

; 5934 : struct mallinfo mspace_mallinfo(mspace msp) {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	esi
	push	edi

; 5935 :   mstate ms = (mstate)msp;

	mov	eax, DWORD PTR _msp$[ebp]
	mov	DWORD PTR _ms$[ebp], eax

; 5936 :   if (!ok_magic(ms)) {

	xor	ecx, ecx
	je	SHORT $LN1@mspace_mal@3

; 5937 :     USAGE_ERROR_ACTION(ms,ms);

	call	DWORD PTR __imp__abort
$LN1@mspace_mal@3:

; 5938 :   }
; 5939 :   return internal_mallinfo(ms);

	mov	edx, DWORD PTR _ms$[ebp]
	push	edx
	lea	eax, DWORD PTR $T35629[ebp]
	push	eax
	call	?internal_mallinfo@@YA?AUmallinfo@@PAUmalloc_state@@@Z ; internal_mallinfo
	add	esp, 8
	mov	ecx, 10					; 0000000aH
	mov	esi, eax
	lea	edi, DWORD PTR $T35628[ebp]
	rep movsd
	mov	ecx, 10					; 0000000aH
	lea	esi, DWORD PTR $T35628[ebp]
	mov	edi, DWORD PTR $T35627[ebp]
	rep movsd
	mov	eax, DWORD PTR $T35627[ebp]

; 5940 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_mallinfo@@YA?AUmallinfo@@PAX@Z ENDP		; mspace_mallinfo
_TEXT	ENDS
PUBLIC	?mspace_usable_size@@YAIPBX@Z			; mspace_usable_size
; Function compile flags: /Odtp
_TEXT	SEGMENT
_p$35178 = -4						; size = 4
_mem$ = 8						; size = 4
?mspace_usable_size@@YAIPBX@Z PROC			; mspace_usable_size

; 5943 : size_t mspace_usable_size(const void* mem) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5944 :   if (mem != 0) {

	cmp	DWORD PTR _mem$[ebp], 0
	je	SHORT $LN2@mspace_usa

; 5945 :     mchunkptr p = mem2chunk(mem);

	mov	eax, DWORD PTR _mem$[ebp]
	sub	eax, 8
	mov	DWORD PTR _p$35178[ebp], eax

; 5946 :     if (is_inuse(p))

	mov	ecx, DWORD PTR _p$35178[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 3
	cmp	edx, 1
	je	SHORT $LN2@mspace_usa

; 5947 :       return chunksize(p) - overhead_for(p);

	mov	eax, DWORD PTR _p$35178[ebp]
	mov	eax, DWORD PTR [eax+4]
	and	eax, -8					; fffffff8H
	mov	ecx, DWORD PTR _p$35178[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 3
	neg	edx
	sbb	edx, edx
	and	edx, -4					; fffffffcH
	add	edx, 8
	sub	eax, edx
	jmp	SHORT $LN3@mspace_usa
$LN2@mspace_usa:

; 5948 :   }
; 5949 :   return 0;

	xor	eax, eax
$LN3@mspace_usa:

; 5950 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?mspace_usable_size@@YAIPBX@Z ENDP			; mspace_usable_size
_TEXT	ENDS
PUBLIC	?mspace_mallopt@@YAHHH@Z			; mspace_mallopt
; Function compile flags: /Odtp
_TEXT	SEGMENT
_param_number$ = 8					; size = 4
_value$ = 12						; size = 4
?mspace_mallopt@@YAHHH@Z PROC				; mspace_mallopt

; 5952 : int mspace_mallopt(int param_number, int value) {

	push	ebp
	mov	ebp, esp

; 5953 :   return change_mparam(param_number, value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _param_number$[ebp]
	push	ecx
	call	?change_mparam@@YAHHH@Z			; change_mparam
	add	esp, 8

; 5954 : }

	pop	ebp
	ret	0
?mspace_mallopt@@YAHHH@Z ENDP				; mspace_mallopt
_TEXT	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\sdk\ozcollide\dataio.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG64489 DB	'rb', 00H
	ORG $+1
$SG64609 DB	'wb', 00H
CONST	ENDS
PUBLIC	??_7DataIn@ozcollide@@6B@			; ozcollide::DataIn::`vftable'
PUBLIC	??0DataIn@ozcollide@@QAE@XZ			; ozcollide::DataIn::DataIn
PUBLIC	??_R4DataIn@ozcollide@@6B@			; ozcollide::DataIn::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDataIn@ozcollide@@@8			; ozcollide::DataIn `RTTI Type Descriptor'
PUBLIC	??_R3DataIn@ozcollide@@8			; ozcollide::DataIn::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DataIn@ozcollide@@8			; ozcollide::DataIn::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DataIn@ozcollide@@8		; ozcollide::DataIn::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EDataIn@ozcollide@@UAEPAXI@Z:PROC		; ozcollide::DataIn::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@DataIn@ozcollide@@8
; File i:\svnroot\client\sdk\ozcollide\dataio.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@DataIn@ozcollide@@8 DD FLAT:??_R0?AVDataIn@ozcollide@@@8 ; ozcollide::DataIn::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DataIn@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_R2DataIn@ozcollide@@8
rdata$r	SEGMENT
??_R2DataIn@ozcollide@@8 DD FLAT:??_R1A@?0A@EA@DataIn@ozcollide@@8 ; ozcollide::DataIn::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DataIn@ozcollide@@8
rdata$r	SEGMENT
??_R3DataIn@ozcollide@@8 DD 00H				; ozcollide::DataIn::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DataIn@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDataIn@ozcollide@@@8
_DATA	SEGMENT
??_R0?AVDataIn@ozcollide@@@8 DD FLAT:??_7type_info@@6B@	; ozcollide::DataIn `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDataIn@ozcollide@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DataIn@ozcollide@@6B@
rdata$r	SEGMENT
??_R4DataIn@ozcollide@@6B@ DD 00H			; ozcollide::DataIn::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDataIn@ozcollide@@@8
	DD	FLAT:??_R3DataIn@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_7DataIn@ozcollide@@6B@
CONST	SEGMENT
??_7DataIn@ozcollide@@6B@ DD FLAT:??_R4DataIn@ozcollide@@6B@ ; ozcollide::DataIn::`vftable'
	DD	FLAT:??_EDataIn@ozcollide@@UAEPAXI@Z
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DataIn@ozcollide@@QAE@XZ PROC			; ozcollide::DataIn::DataIn
; _this$ = ecx

; 44   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataIn@ozcollide@@6B@

; 45   : 	fileHandle_ = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 46   : 	mem_ = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 47   : 	memSize_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 48   : 	byteOff_ = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 49   : };

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DataIn@ozcollide@@QAE@XZ ENDP			; ozcollide::DataIn::DataIn
_TEXT	ENDS
PUBLIC	??1DataIn@ozcollide@@UAE@XZ			; ozcollide::DataIn::~DataIn
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GDataIn@ozcollide@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDataIn@ozcollide@@UAEPAXI@Z PROC			; ozcollide::DataIn::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataIn@ozcollide@@UAE@XZ		; ozcollide::DataIn::~DataIn
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDataIn@ozcollide@@UAEPAXI@Z ENDP			; ozcollide::DataIn::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DataIn@ozcollide@@UAE@XZ PROC			; ozcollide::DataIn::~DataIn
; _this$ = ecx

; 52   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataIn@ozcollide@@6B@

; 53   : };

	mov	esp, ebp
	pop	ebp
	ret	0
??1DataIn@ozcollide@@UAE@XZ ENDP			; ozcollide::DataIn::~DataIn
_TEXT	ENDS
PUBLIC	?open@DataIn@ozcollide@@QAE_NPBD@Z		; ozcollide::DataIn::open
EXTRN	__imp__fopen:PROC
EXTRN	__imp__strdup:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_old$ = -4						; size = 4
__fileName$ = 8						; size = 4
?open@DataIn@ozcollide@@QAE_NPBD@Z PROC			; ozcollide::DataIn::open
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 	input_ = SOURCE_DISK;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 58   : 	char *old = fileName_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _old$[ebp], edx

; 59   : 	fileName_ = strdup(_fileName);

	mov	eax, DWORD PTR __fileName$[ebp]
	push	eax
	call	DWORD PTR __imp__strdup
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 60   : 	//SAFE_FREE(old);
; 61   : 
; 62   : 	fileHandle_ = fopen(fileName_, "rb");

	push	OFFSET $SG64489
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 63   : 	if (fileHandle_ == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN1@open

; 64   : 		return false;

	xor	al, al
	jmp	SHORT $LN2@open
$LN1@open:

; 65   : 
; 66   : 	byteOff_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 67   : 	return true;

	mov	al, 1
$LN2@open:

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?open@DataIn@ozcollide@@QAE_NPBD@Z ENDP			; ozcollide::DataIn::open
_TEXT	ENDS
PUBLIC	?open@DataIn@ozcollide@@QAEXPAXH@Z		; ozcollide::DataIn::open
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__mem$ = 8						; size = 4
__size$ = 12						; size = 4
?open@DataIn@ozcollide@@QAEXPAXH@Z PROC			; ozcollide::DataIn::open
; _this$ = ecx

; 71   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 	input_ = SOURCE_MEMORY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 1

; 73   : 	mem_ = (char*) _mem;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __mem$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 74   : 	memSize_ = _size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __size$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 75   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?open@DataIn@ozcollide@@QAEXPAXH@Z ENDP			; ozcollide::DataIn::open
_TEXT	ENDS
PUBLIC	?getSourceType@DataIn@ozcollide@@QBE?AW4SOURCE_TYPE@12@XZ ; ozcollide::DataIn::getSourceType
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSourceType@DataIn@ozcollide@@QBE?AW4SOURCE_TYPE@12@XZ PROC ; ozcollide::DataIn::getSourceType
; _this$ = ecx

; 78   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 	return input_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 80   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getSourceType@DataIn@ozcollide@@QBE?AW4SOURCE_TYPE@12@XZ ENDP ; ozcollide::DataIn::getSourceType
_TEXT	ENDS
PUBLIC	?close@DataIn@ozcollide@@QAE_NXZ		; ozcollide::DataIn::close
EXTRN	__imp__fclose:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?close@DataIn@ozcollide@@QAE_NXZ PROC			; ozcollide::DataIn::close
; _this$ = ecx

; 83   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 	if (input_ == SOURCE_DISK) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN2@close

; 85   : 		if (fileHandle_ && fclose(fileHandle_) != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN2@close
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@close

; 86   : 			return false;

	xor	al, al
	jmp	SHORT $LN3@close
$LN2@close:

; 87   : 	}
; 88   : 	fileHandle_ = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 89   : 
; 90   : 	return true;

	mov	al, 1
$LN3@close:

; 91   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?close@DataIn@ozcollide@@QAE_NXZ ENDP			; ozcollide::DataIn::close
_TEXT	ENDS
PUBLIC	?isOpen@DataIn@ozcollide@@QBE_NXZ		; ozcollide::DataIn::isOpen
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isOpen@DataIn@ozcollide@@QBE_NXZ PROC			; ozcollide::DataIn::isOpen
; _this$ = ecx

; 94   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 	if (input_ == SOURCE_DISK)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN2@isOpen

; 96   : 		return fileHandle_ ? true : false;

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	setne	al
	jmp	SHORT $LN3@isOpen

; 97   : 	else

	jmp	SHORT $LN3@isOpen
$LN2@isOpen:

; 98   : 		return true;

	mov	al, 1
$LN3@isOpen:

; 99   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isOpen@DataIn@ozcollide@@QBE_NXZ ENDP			; ozcollide::DataIn::isOpen
_TEXT	ENDS
PUBLIC	?getSize@DataIn@ozcollide@@QBEHXZ		; ozcollide::DataIn::getSize
PUBLIC	?eof@DataIn@ozcollide@@QBE_NXZ			; ozcollide::DataIn::eof
EXTRN	__imp__feof:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?eof@DataIn@ozcollide@@QBE_NXZ PROC			; ozcollide::DataIn::eof
; _this$ = ecx

; 102  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 103  : 	if (input_ == SOURCE_DISK)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@eof

; 104  : 		return feof(fileHandle_) == 0 ? false : true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR __imp__feof
	add	esp, 4
	test	eax, eax
	setne	al
	jmp	SHORT $LN2@eof
$LN1@eof:

; 105  : 
; 106  : 	return byteOff_ >= getSize() ? true : false;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getSize@DataIn@ozcollide@@QBEHXZ	; ozcollide::DataIn::getSize
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	setge	al
$LN2@eof:

; 107  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?eof@DataIn@ozcollide@@QBE_NXZ ENDP			; ozcollide::DataIn::eof
_TEXT	ENDS
PUBLIC	?error@DataIn@ozcollide@@QBE_NXZ		; ozcollide::DataIn::error
EXTRN	__imp__ferror:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?error@DataIn@ozcollide@@QBE_NXZ PROC			; ozcollide::DataIn::error
; _this$ = ecx

; 110  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 	if (input_ == SOURCE_DISK)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@error

; 112  : 		return ferror(fileHandle_) == 0 ? false : true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR __imp__ferror
	add	esp, 4
	test	eax, eax
	setne	al
	jmp	SHORT $LN2@error
$LN1@error:

; 113  : 	return false;

	xor	al, al
$LN2@error:

; 114  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?error@DataIn@ozcollide@@QBE_NXZ ENDP			; ozcollide::DataIn::error
_TEXT	ENDS
PUBLIC	?getFileName@DataIn@ozcollide@@QBEPBDXZ		; ozcollide::DataIn::getFileName
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getFileName@DataIn@ozcollide@@QBEPBDXZ PROC		; ozcollide::DataIn::getFileName
; _this$ = ecx

; 117  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 	return fileName_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 119  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getFileName@DataIn@ozcollide@@QBEPBDXZ ENDP		; ozcollide::DataIn::getFileName
_TEXT	ENDS
PUBLIC	?advance@DataIn@ozcollide@@QAE_NH@Z		; ozcollide::DataIn::advance
EXTRN	__imp__fseek:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__n$ = 8						; size = 4
?advance@DataIn@ozcollide@@QAE_NH@Z PROC		; ozcollide::DataIn::advance
; _this$ = ecx

; 122  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 	if (input_ == SOURCE_DISK)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@advance

; 124  : 		return fseek(fileHandle_, _n, SEEK_CUR);

	push	1
	mov	ecx, DWORD PTR __n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	test	eax, eax
	setne	al
	jmp	SHORT $LN2@advance
$LN1@advance:

; 125  : 	byteOff_ += _n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, DWORD PTR __n$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 126  : 	return true;

	mov	al, 1
$LN2@advance:

; 127  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?advance@DataIn@ozcollide@@QAE_NH@Z ENDP		; ozcollide::DataIn::advance
_TEXT	ENDS
PUBLIC	?seek@DataIn@ozcollide@@QAE_NH@Z		; ozcollide::DataIn::seek
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__n$ = 8						; size = 4
?seek@DataIn@ozcollide@@QAE_NH@Z PROC			; ozcollide::DataIn::seek
; _this$ = ecx

; 130  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 131  : 	if (input_ == SOURCE_DISK) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN6@seek

; 132  : 		if (fseek(fileHandle_, _n, SEEK_SET) == 0)

	push	0
	mov	ecx, DWORD PTR __n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@seek

; 133  : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@seek
$LN5@seek:

; 134  : 	}
; 135  : 	else {

	jmp	SHORT $LN4@seek
$LN6@seek:

; 136  : 		if (byteOff_ < 0 || byteOff_ > memSize_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jl	SHORT $LN2@seek
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+16]
	jle	SHORT $LN3@seek
$LN2@seek:

; 137  : 			return false;

	xor	al, al
	jmp	SHORT $LN7@seek

; 138  : 		else {

	jmp	SHORT $LN4@seek
$LN3@seek:

; 139  : 			byteOff_ = _n;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __n$[ebp]
	mov	DWORD PTR [edx+20], eax

; 140  : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@seek
$LN4@seek:

; 141  : 		}
; 142  : 	}
; 143  : 
; 144  : 	return false;

	xor	al, al
$LN7@seek:

; 145  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?seek@DataIn@ozcollide@@QAE_NH@Z ENDP			; ozcollide::DataIn::seek
_TEXT	ENDS
PUBLIC	?tell@DataIn@ozcollide@@QBEHXZ			; ozcollide::DataIn::tell
EXTRN	__imp__ftell:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?tell@DataIn@ozcollide@@QBEHXZ PROC			; ozcollide::DataIn::tell
; _this$ = ecx

; 148  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 	if (input_ == SOURCE_DISK)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@tell

; 150  : 		return ftell( fileHandle_ );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR __imp__ftell
	add	esp, 4
	jmp	SHORT $LN2@tell
$LN1@tell:

; 151  : 	return byteOff_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
$LN2@tell:

; 152  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?tell@DataIn@ozcollide@@QBEHXZ ENDP			; ozcollide::DataIn::tell
; Function compile flags: /Odtp
_this$ = -16						; size = 4
_fileSize$64546 = -12					; size = 4
_savePos$64545 = -8					; size = 4
_res$ = -4						; size = 4
?getSize@DataIn@ozcollide@@QBEHXZ PROC			; ozcollide::DataIn::getSize
; _this$ = ecx

; 155  : {              

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 	int res;
; 157  : 	if (input_ == SOURCE_DISK) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@getSize

; 158  : 		int savePos, fileSize;
; 159  : 		savePos = ftell( fileHandle_ );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR __imp__ftell
	add	esp, 4
	mov	DWORD PTR _savePos$64545[ebp], eax

; 160  : 		res = fseek(fileHandle_, 0L, SEEK_END);

	push	2
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _res$[ebp], eax

; 161  : 		fileSize = ftell( fileHandle_ );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__ftell
	add	esp, 4
	mov	DWORD PTR _fileSize$64546[ebp], eax

; 162  : 		res = fseek(fileHandle_, savePos, SEEK_SET);

	push	0
	mov	ecx, DWORD PTR _savePos$64545[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _res$[ebp], eax

; 163  : 		return fileSize;

	mov	eax, DWORD PTR _fileSize$64546[ebp]
	jmp	SHORT $LN2@getSize
$LN1@getSize:

; 164  : 	}
; 165  : 	return memSize_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
$LN2@getSize:

; 166  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getSize@DataIn@ozcollide@@QBEHXZ ENDP			; ozcollide::DataIn::getSize
_TEXT	ENDS
PUBLIC	?read@DataIn@ozcollide@@QAEHPAXH@Z		; ozcollide::DataIn::read
EXTRN	_memcpy:PROC
EXTRN	__imp__fread:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nbRead$64553 = -8					; size = 4
_toRead$ = -4						; size = 4
__dest$ = 8						; size = 4
__nbBytes$ = 12						; size = 4
?read@DataIn@ozcollide@@QAEHPAXH@Z PROC			; ozcollide::DataIn::read
; _this$ = ecx

; 169  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 	if (input_ == SOURCE_DISK) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN4@read

; 171  : 		size_t nbRead;
; 172  : 		nbRead = fread(_dest, 1, _nbBytes, fileHandle_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __nbBytes$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _nbRead$64553[ebp], eax

; 173  : 		return nbRead;

	mov	eax, DWORD PTR _nbRead$64553[ebp]
	jmp	SHORT $LN5@read
$LN4@read:

; 174  : 	}
; 175  : 
; 176  : 	size_t toRead;
; 177  : 	if (byteOff_ + _nbBytes <= memSize_)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, DWORD PTR __nbBytes$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+16]
	jg	SHORT $LN3@read

; 178  : 		toRead = _nbBytes;

	mov	edx, DWORD PTR __nbBytes$[ebp]
	mov	DWORD PTR _toRead$[ebp], edx

; 179  : 	else

	jmp	SHORT $LN2@read
$LN3@read:

; 180  : 		toRead = memSize_ - byteOff_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	sub	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _toRead$[ebp], edx
$LN2@read:

; 181  : 
; 182  : 	if (toRead == 0)

	cmp	DWORD PTR _toRead$[ebp], 0
	jne	SHORT $LN1@read

; 183  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN5@read
$LN1@read:

; 184  : 	memcpy(_dest, (char*)mem_ + byteOff_, toRead);

	mov	eax, DWORD PTR _toRead$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+20]
	push	edx
	mov	ecx, DWORD PTR __dest$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 185  : 	byteOff_ += toRead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, DWORD PTR _toRead$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 186  : 	return toRead;

	mov	eax, DWORD PTR _toRead$[ebp]
$LN5@read:

; 187  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?read@DataIn@ozcollide@@QAEHPAXH@Z ENDP			; ozcollide::DataIn::read
_TEXT	ENDS
PUBLIC	?readByte@DataIn@ozcollide@@QAEDXZ		; ozcollide::DataIn::readByte
PUBLIC	?readStrZ@DataIn@ozcollide@@QAEHPAD@Z		; ozcollide::DataIn::readStrZ
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_c$64568 = -9						; size = 1
_nb$ = -8						; size = 4
_buf$ = -4						; size = 4
__dest$ = 8						; size = 4
?readStrZ@DataIn@ozcollide@@QAEHPAD@Z PROC		; ozcollide::DataIn::readStrZ
; _this$ = ecx

; 190  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 191  : 	char *buf = _dest;

	mov	eax, DWORD PTR __dest$[ebp]
	mov	DWORD PTR _buf$[ebp], eax

; 192  : 	int nb = 0;

	mov	DWORD PTR _nb$[ebp], 0
$LN3@readStrZ:

; 193  : 	while(!eof() && !ferror(fileHandle_)) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?eof@DataIn@ozcollide@@QBE_NXZ		; ozcollide::DataIn::eof
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@readStrZ
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__ferror
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@readStrZ

; 194  : 		char c = readByte(); nb++;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readByte@DataIn@ozcollide@@QAEDXZ	; ozcollide::DataIn::readByte
	mov	BYTE PTR _c$64568[ebp], al
	mov	ecx, DWORD PTR _nb$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nb$[ebp], ecx

; 195  : 		*buf++ = c;

	mov	edx, DWORD PTR _buf$[ebp]
	mov	al, BYTE PTR _c$64568[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _buf$[ebp]
	add	ecx, 1
	mov	DWORD PTR _buf$[ebp], ecx

; 196  : 		if (!c)

	movsx	edx, BYTE PTR _c$64568[ebp]
	test	edx, edx
	jne	SHORT $LN1@readStrZ

; 197  : 			break;

	jmp	SHORT $LN2@readStrZ
$LN1@readStrZ:

; 198  : 	}

	jmp	SHORT $LN3@readStrZ
$LN2@readStrZ:

; 199  : 	return nb;

	mov	eax, DWORD PTR _nb$[ebp]

; 200  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?readStrZ@DataIn@ozcollide@@QAEHPAD@Z ENDP		; ozcollide::DataIn::readStrZ
; Function compile flags: /Odtp
_this$ = -12						; size = 4
_c$ = -5						; size = 1
_res$ = -4						; size = 4
?readByte@DataIn@ozcollide@@QAEDXZ PROC			; ozcollide::DataIn::readByte
; _this$ = ecx

; 203  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 	char c = 0;

	mov	BYTE PTR _c$[ebp], 0

; 205  : 	int res = read(&c, 1); 

	push	1
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@DataIn@ozcollide@@QAEHPAXH@Z	; ozcollide::DataIn::read
	mov	DWORD PTR _res$[ebp], eax

; 206  : 	return c;

	mov	al, BYTE PTR _c$[ebp]

; 207  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?readByte@DataIn@ozcollide@@QAEDXZ ENDP			; ozcollide::DataIn::readByte
_TEXT	ENDS
PUBLIC	?readWord@DataIn@ozcollide@@QAEFXZ		; ozcollide::DataIn::readWord
EXTRN	_ntohs@4:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_s$ = -8						; size = 2
_res$ = -4						; size = 4
?readWord@DataIn@ozcollide@@QAEFXZ PROC			; ozcollide::DataIn::readWord
; _this$ = ecx

; 210  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 211  : 	short s = 0;

	xor	eax, eax
	mov	WORD PTR _s$[ebp], ax

; 212  : 	int res = read(&s, 2);

	push	2
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@DataIn@ozcollide@@QAEHPAXH@Z	; ozcollide::DataIn::read
	mov	DWORD PTR _res$[ebp], eax

; 213  : 	return ntohs(s);

	movzx	edx, WORD PTR _s$[ebp]
	push	edx
	call	_ntohs@4

; 214  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?readWord@DataIn@ozcollide@@QAEFXZ ENDP			; ozcollide::DataIn::readWord
_TEXT	ENDS
PUBLIC	?readDword@DataIn@ozcollide@@QAEHXZ		; ozcollide::DataIn::readDword
EXTRN	_ntohl@4:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$ = -8						; size = 4
_res$ = -4						; size = 4
?readDword@DataIn@ozcollide@@QAEHXZ PROC		; ozcollide::DataIn::readDword
; _this$ = ecx

; 217  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 218  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 219  : 	int res = read(&i, 4);

	push	4
	lea	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@DataIn@ozcollide@@QAEHPAXH@Z	; ozcollide::DataIn::read
	mov	DWORD PTR _res$[ebp], eax

; 220  : 	return ntohl(i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_ntohl@4

; 221  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?readDword@DataIn@ozcollide@@QAEHXZ ENDP		; ozcollide::DataIn::readDword
_TEXT	ENDS
PUBLIC	?readFloat@DataIn@ozcollide@@QAEMXZ		; ozcollide::DataIn::readFloat
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -20						; size = 4
_f$ = -16						; size = 4
_n$ = -12						; size = 4
_a$ = -8						; size = 4
_res$ = -4						; size = 4
?readFloat@DataIn@ozcollide@@QAEMXZ PROC		; ozcollide::DataIn::readFloat
; _this$ = ecx

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 225  : 	float f;
; 226  : 	int res = read(&f, 4);

	push	4
	lea	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@DataIn@ozcollide@@QAEHPAXH@Z	; ozcollide::DataIn::read
	mov	DWORD PTR _res$[ebp], eax

; 227  : 
; 228  : 	int a = *((int*)&f);

	mov	ecx, DWORD PTR _f$[ebp]
	mov	DWORD PTR _a$[ebp], ecx

; 229  : 	int n = ntohl(a);

	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	call	_ntohl@4
	mov	DWORD PTR _n$[ebp], eax

; 230  : 	*((int*)&f) = n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _f$[ebp], eax

; 231  : 
; 232  : #ifndef FPU_IEEE754
; 233  : 	f = (float) buffer2double((const unsigned char*)&f, 0);
; 234  : #endif
; 235  : 
; 236  : 	return f;

	fld	DWORD PTR _f$[ebp]

; 237  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?readFloat@DataIn@ozcollide@@QAEMXZ ENDP		; ozcollide::DataIn::readFloat
_TEXT	ENDS
PUBLIC	??_7DataOut@ozcollide@@6B@			; ozcollide::DataOut::`vftable'
PUBLIC	??0DataOut@ozcollide@@QAE@XZ			; ozcollide::DataOut::DataOut
PUBLIC	??_R4DataOut@ozcollide@@6B@			; ozcollide::DataOut::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDataOut@ozcollide@@@8			; ozcollide::DataOut `RTTI Type Descriptor'
PUBLIC	??_R3DataOut@ozcollide@@8			; ozcollide::DataOut::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DataOut@ozcollide@@8			; ozcollide::DataOut::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DataOut@ozcollide@@8		; ozcollide::DataOut::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_EDataOut@ozcollide@@UAEPAXI@Z:PROC		; ozcollide::DataOut::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@DataOut@ozcollide@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DataOut@ozcollide@@8 DD FLAT:??_R0?AVDataOut@ozcollide@@@8 ; ozcollide::DataOut::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DataOut@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_R2DataOut@ozcollide@@8
rdata$r	SEGMENT
??_R2DataOut@ozcollide@@8 DD FLAT:??_R1A@?0A@EA@DataOut@ozcollide@@8 ; ozcollide::DataOut::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DataOut@ozcollide@@8
rdata$r	SEGMENT
??_R3DataOut@ozcollide@@8 DD 00H			; ozcollide::DataOut::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DataOut@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDataOut@ozcollide@@@8
_DATA	SEGMENT
??_R0?AVDataOut@ozcollide@@@8 DD FLAT:??_7type_info@@6B@ ; ozcollide::DataOut `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDataOut@ozcollide@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DataOut@ozcollide@@6B@
rdata$r	SEGMENT
??_R4DataOut@ozcollide@@6B@ DD 00H			; ozcollide::DataOut::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDataOut@ozcollide@@@8
	DD	FLAT:??_R3DataOut@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_7DataOut@ozcollide@@6B@
CONST	SEGMENT
??_7DataOut@ozcollide@@6B@ DD FLAT:??_R4DataOut@ozcollide@@6B@ ; ozcollide::DataOut::`vftable'
	DD	FLAT:??_EDataOut@ozcollide@@UAEPAXI@Z
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DataOut@ozcollide@@QAE@XZ PROC			; ozcollide::DataOut::DataOut
; _this$ = ecx

; 242  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataOut@ozcollide@@6B@

; 243  : 	fileHandle_ = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 244  : };

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DataOut@ozcollide@@QAE@XZ ENDP			; ozcollide::DataOut::DataOut
_TEXT	ENDS
PUBLIC	??1DataOut@ozcollide@@UAE@XZ			; ozcollide::DataOut::~DataOut
; Function compile flags: /Odtp
;	COMDAT ??_GDataOut@ozcollide@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDataOut@ozcollide@@UAEPAXI@Z PROC			; ozcollide::DataOut::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataOut@ozcollide@@UAE@XZ		; ozcollide::DataOut::~DataOut
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDataOut@ozcollide@@UAEPAXI@Z ENDP			; ozcollide::DataOut::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DataOut@ozcollide@@UAE@XZ PROC			; ozcollide::DataOut::~DataOut
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataOut@ozcollide@@6B@

; 248  : };

	mov	esp, ebp
	pop	ebp
	ret	0
??1DataOut@ozcollide@@UAE@XZ ENDP			; ozcollide::DataOut::~DataOut
_TEXT	ENDS
PUBLIC	?open@DataOut@ozcollide@@QAE_NPBD@Z		; ozcollide::DataOut::open
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_old$ = -4						; size = 4
__fileName$ = 8						; size = 4
?open@DataOut@ozcollide@@QAE_NPBD@Z PROC		; ozcollide::DataOut::open
; _this$ = ecx

; 251  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 	char *old = fileName_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _old$[ebp], ecx

; 253  : 	fileName_ = strdup(_fileName);

	mov	edx, DWORD PTR __fileName$[ebp]
	push	edx
	call	DWORD PTR __imp__strdup
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 254  : // 	SAFE_FREE(old);
; 255  : 
; 256  : 	fileHandle_ = fopen(fileName_, "wb");

	push	OFFSET $SG64609
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 257  : 	if (fileHandle_ == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN1@open@2

; 258  : 		return false;

	xor	al, al
	jmp	SHORT $LN2@open@2
$LN1@open@2:

; 259  : 
; 260  : 	return true;

	mov	al, 1
$LN2@open@2:

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?open@DataOut@ozcollide@@QAE_NPBD@Z ENDP		; ozcollide::DataOut::open
_TEXT	ENDS
PUBLIC	?close@DataOut@ozcollide@@QAE_NXZ		; ozcollide::DataOut::close
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?close@DataOut@ozcollide@@QAE_NXZ PROC			; ozcollide::DataOut::close
; _this$ = ecx

; 264  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 265  : 	if (fileHandle_ && fclose(fileHandle_) != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@close@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__fclose
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@close@2

; 266  : 		return false;

	xor	al, al
	jmp	SHORT $LN2@close@2
$LN1@close@2:

; 267  : 	fileHandle_ = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 268  : 	return true;

	mov	al, 1
$LN2@close@2:

; 269  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?close@DataOut@ozcollide@@QAE_NXZ ENDP			; ozcollide::DataOut::close
_TEXT	ENDS
PUBLIC	?isOpen@DataOut@ozcollide@@QBE_NXZ		; ozcollide::DataOut::isOpen
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isOpen@DataOut@ozcollide@@QBE_NXZ PROC			; ozcollide::DataOut::isOpen
; _this$ = ecx

; 272  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 273  : 	return fileHandle_ ? true : false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	setne	al

; 274  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isOpen@DataOut@ozcollide@@QBE_NXZ ENDP			; ozcollide::DataOut::isOpen
_TEXT	ENDS
PUBLIC	?eof@DataOut@ozcollide@@QBE_NXZ			; ozcollide::DataOut::eof
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?eof@DataOut@ozcollide@@QBE_NXZ PROC			; ozcollide::DataOut::eof
; _this$ = ecx

; 277  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	return feof(fileHandle_) == 0 ? false : true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__feof
	add	esp, 4
	test	eax, eax
	setne	al

; 279  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?eof@DataOut@ozcollide@@QBE_NXZ ENDP			; ozcollide::DataOut::eof
_TEXT	ENDS
PUBLIC	?getFileName@DataOut@ozcollide@@QBEPBDXZ	; ozcollide::DataOut::getFileName
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getFileName@DataOut@ozcollide@@QBEPBDXZ PROC		; ozcollide::DataOut::getFileName
; _this$ = ecx

; 282  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return fileName_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 284  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getFileName@DataOut@ozcollide@@QBEPBDXZ ENDP		; ozcollide::DataOut::getFileName
_TEXT	ENDS
PUBLIC	?advance@DataOut@ozcollide@@QAE_NH@Z		; ozcollide::DataOut::advance
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_res$ = -4						; size = 4
__n$ = 8						; size = 4
?advance@DataOut@ozcollide@@QAE_NH@Z PROC		; ozcollide::DataOut::advance
; _this$ = ecx

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 	int res = fseek(fileHandle_, _n, SEEK_CUR);

	push	1
	mov	eax, DWORD PTR __n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _res$[ebp], eax

; 289  : 	if (res)

	cmp	DWORD PTR _res$[ebp], 0
	je	SHORT $LN1@advance@2

; 290  : 		return false;

	xor	al, al
	jmp	SHORT $LN2@advance@2
$LN1@advance@2:

; 291  : 	return true;

	mov	al, 1
$LN2@advance@2:

; 292  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?advance@DataOut@ozcollide@@QAE_NH@Z ENDP		; ozcollide::DataOut::advance
_TEXT	ENDS
PUBLIC	?seek@DataOut@ozcollide@@QAE_NH@Z		; ozcollide::DataOut::seek
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_res$ = -4						; size = 4
__n$ = 8						; size = 4
?seek@DataOut@ozcollide@@QAE_NH@Z PROC			; ozcollide::DataOut::seek
; _this$ = ecx

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 296  : 	int res = fseek(fileHandle_, _n, SEEK_SET);

	push	0
	mov	eax, DWORD PTR __n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _res$[ebp], eax

; 297  : 	if (res)

	cmp	DWORD PTR _res$[ebp], 0
	je	SHORT $LN1@seek@2

; 298  : 		return false;

	xor	al, al
	jmp	SHORT $LN2@seek@2
$LN1@seek@2:

; 299  : 	return true;

	mov	al, 1
$LN2@seek@2:

; 300  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?seek@DataOut@ozcollide@@QAE_NH@Z ENDP			; ozcollide::DataOut::seek
_TEXT	ENDS
PUBLIC	?tell@DataOut@ozcollide@@QBEHXZ			; ozcollide::DataOut::tell
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?tell@DataOut@ozcollide@@QBEHXZ PROC			; ozcollide::DataOut::tell
; _this$ = ecx

; 303  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 304  : 	return ftell( fileHandle_ );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__ftell
	add	esp, 4

; 305  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?tell@DataOut@ozcollide@@QBEHXZ ENDP			; ozcollide::DataOut::tell
_TEXT	ENDS
PUBLIC	?write@DataOut@ozcollide@@QAEHPBXH@Z		; ozcollide::DataOut::write
EXTRN	__imp__fwrite:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_res$ = -4						; size = 4
__src$ = 8						; size = 4
__nbBytes$ = 12						; size = 4
?write@DataOut@ozcollide@@QAEHPBXH@Z PROC		; ozcollide::DataOut::write
; _this$ = ecx

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 309  : 	int res = fwrite(_src, 1, _nbBytes, fileHandle_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __nbBytes$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __src$[ebp]
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	mov	DWORD PTR _res$[ebp], eax

; 310  : 	return res;

	mov	eax, DWORD PTR _res$[ebp]

; 311  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?write@DataOut@ozcollide@@QAEHPBXH@Z ENDP		; ozcollide::DataOut::write
_TEXT	ENDS
PUBLIC	?writeStr@DataOut@ozcollide@@QAEHPBD@Z		; ozcollide::DataOut::writeStr
EXTRN	_strlen:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__str$ = 8						; size = 4
?writeStr@DataOut@ozcollide@@QAEHPBD@Z PROC		; ozcollide::DataOut::writeStr
; _this$ = ecx

; 314  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 315  : 	return write((const void*)_str, strlen(_str));

	mov	eax, DWORD PTR __str$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __str$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@DataOut@ozcollide@@QAEHPBXH@Z	; ozcollide::DataOut::write

; 316  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?writeStr@DataOut@ozcollide@@QAEHPBD@Z ENDP		; ozcollide::DataOut::writeStr
_TEXT	ENDS
PUBLIC	?writeStrZ@DataOut@ozcollide@@QAEHPBD@Z		; ozcollide::DataOut::writeStrZ
EXTRN	__imp__fputc:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nb$ = -8						; size = 4
_res$ = -4						; size = 4
__str$ = 8						; size = 4
?writeStrZ@DataOut@ozcollide@@QAEHPBD@Z PROC		; ozcollide::DataOut::writeStrZ
; _this$ = ecx

; 319  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 320  : 	int res = 0;

	mov	DWORD PTR _res$[ebp], 0

; 321  : 	int nb = strlen(_str);

	mov	eax, DWORD PTR __str$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nb$[ebp], eax

; 322  : 	if (nb)

	cmp	DWORD PTR _nb$[ebp], 0
	je	SHORT $LN1@writeStrZ

; 323  : 		res = fwrite(_str, 1, nb, fileHandle_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _nb$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __str$[ebp]
	push	ecx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	mov	DWORD PTR _res$[ebp], eax
$LN1@writeStrZ:

; 324  : 	res = fputc(0, fileHandle_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	call	DWORD PTR __imp__fputc
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 325  : 	res++;

	mov	ecx, DWORD PTR _res$[ebp]
	add	ecx, 1
	mov	DWORD PTR _res$[ebp], ecx

; 326  : 	return res;

	mov	eax, DWORD PTR _res$[ebp]

; 327  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?writeStrZ@DataOut@ozcollide@@QAEHPBD@Z ENDP		; ozcollide::DataOut::writeStrZ
_TEXT	ENDS
PUBLIC	?writeByte@DataOut@ozcollide@@QAEHD@Z		; ozcollide::DataOut::writeByte
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__val$ = 8						; size = 1
?writeByte@DataOut@ozcollide@@QAEHD@Z PROC		; ozcollide::DataOut::writeByte
; _this$ = ecx

; 330  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 	return write(&_val, 1);

	push	1
	lea	eax, DWORD PTR __val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@DataOut@ozcollide@@QAEHPBXH@Z	; ozcollide::DataOut::write

; 332  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?writeByte@DataOut@ozcollide@@QAEHD@Z ENDP		; ozcollide::DataOut::writeByte
_TEXT	ENDS
PUBLIC	?writeWord@DataOut@ozcollide@@QAEHF@Z		; ozcollide::DataOut::writeWord
EXTRN	_htons@4:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_n$ = -4						; size = 2
__val$ = 8						; size = 2
?writeWord@DataOut@ozcollide@@QAEHF@Z PROC		; ozcollide::DataOut::writeWord
; _this$ = ecx

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 336  : 	short n = htons(_val);

	movzx	eax, WORD PTR __val$[ebp]
	push	eax
	call	_htons@4
	mov	WORD PTR _n$[ebp], ax

; 337  : 	return write(&n, 2);

	push	2
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@DataOut@ozcollide@@QAEHPBXH@Z	; ozcollide::DataOut::write

; 338  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?writeWord@DataOut@ozcollide@@QAEHF@Z ENDP		; ozcollide::DataOut::writeWord
_TEXT	ENDS
PUBLIC	?writeDword@DataOut@ozcollide@@QAEHH@Z		; ozcollide::DataOut::writeDword
EXTRN	_htonl@4:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_n$ = -4						; size = 4
__val$ = 8						; size = 4
?writeDword@DataOut@ozcollide@@QAEHH@Z PROC		; ozcollide::DataOut::writeDword
; _this$ = ecx

; 341  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 342  : 	int n = htonl(_val);

	mov	eax, DWORD PTR __val$[ebp]
	push	eax
	call	_htonl@4
	mov	DWORD PTR _n$[ebp], eax

; 343  : 	return write(&n, 4);

	push	4
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@DataOut@ozcollide@@QAEHPBXH@Z	; ozcollide::DataOut::write

; 344  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?writeDword@DataOut@ozcollide@@QAEHH@Z ENDP		; ozcollide::DataOut::writeDword
_TEXT	ENDS
PUBLIC	?writeFloat@DataOut@ozcollide@@QAEHM@Z		; ozcollide::DataOut::writeFloat
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_ptr$ = -12						; size = 4
_i$ = -8						; size = 4
_n$ = -4						; size = 4
__val$ = 8						; size = 4
?writeFloat@DataOut@ozcollide@@QAEHM@Z PROC		; ozcollide::DataOut::writeFloat
; _this$ = ecx

; 347  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 348  : #ifndef FPU_IEEE754
; 349  : 	unsigned char ieee[4];
; 350  : 	double2buffer(_val, ieee, 0);
; 351  : 	return write(ieee, 4);
; 352  : #else
; 353  : 	int *ptr = (int*)&_val;

	lea	eax, DWORD PTR __val$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 354  : 	int i = *ptr;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _i$[ebp], edx

; 355  : 	int n = htonl(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_htonl@4
	mov	DWORD PTR _n$[ebp], eax

; 356  : 	return write(&n, 4);

	push	4
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@DataOut@ozcollide@@QAEHPBXH@Z	; ozcollide::DataOut::write

; 357  : #endif
; 358  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?writeFloat@DataOut@ozcollide@@QAEHM@Z ENDP		; ozcollide::DataOut::writeFloat
_TEXT	ENDS
END

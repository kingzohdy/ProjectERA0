; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\OgreTimer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5713
_DATA	ENDS
CONST	SEGMENT
$SG5713	DB	'bad allocation', 00H
	ORG $+1
$SG116546 DB	'QueryAffinityMask', 00H
CONST	ENDS
PUBLIC	??4Timer@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Timer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Timer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Timer@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Timer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, 10					; 0000000aH
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4Timer@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Timer::operator=
_TEXT	ENDS
PUBLIC	?reset@Timer@Ogre@@QAEXXZ			; Ogre::Timer::reset
PUBLIC	??0Timer@Ogre@@QAE@XZ				; Ogre::Timer::Timer
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogretimer.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Timer@Ogre@@QAE@XZ PROC				; Ogre::Timer::Timer
; _this$ = ecx

; 12   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 13   : 		reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@Timer@Ogre@@QAEXXZ		; Ogre::Timer::reset

; 14   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Timer@Ogre@@QAE@XZ ENDP				; Ogre::Timer::Timer
_TEXT	ENDS
PUBLIC	??1Timer@Ogre@@QAE@XZ				; Ogre::Timer::~Timer
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Timer@Ogre@@QAE@XZ PROC				; Ogre::Timer::~Timer
; _this$ = ecx

; 18   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 19   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1Timer@Ogre@@QAE@XZ ENDP				; Ogre::Timer::~Timer
_TEXT	ENDS
PUBLIC	?getSystemTick@Timer@Ogre@@SAIXZ		; Ogre::Timer::getSystemTick
EXTRN	__imp__timeGetTime@0:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
?getSystemTick@Timer@Ogre@@SAIXZ PROC			; Ogre::Timer::getSystemTick

; 22   : 	{

	push	ebp
	mov	ebp, esp

; 23   : 		return timeGetTime();

	call	DWORD PTR __imp__timeGetTime@0

; 24   : 	}

	pop	ebp
	ret	0
?getSystemTick@Timer@Ogre@@SAIXZ ENDP			; Ogre::Timer::getSystemTick
_TEXT	ENDS
PUBLIC	??$isPO2@K@Bitwise@Ogre@@SA_NK@Z		; Ogre::Bitwise::isPO2<unsigned long>
PUBLIC	?setOption@Timer@Ogre@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBX@Z ; Ogre::Timer::setOption
EXTRN	__imp__GetProcessAffinityMask@12:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_newTimerMask$116547 = -12				; size = 4
_procMask$116549 = -8					; size = 4
_sysMask$116550 = -4					; size = 4
_key$ = 8						; size = 4
_val$ = 12						; size = 4
?setOption@Timer@Ogre@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBX@Z PROC ; Ogre::Timer::setOption
; _this$ = ecx

; 28   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 29   : 		if ( key == "QueryAffinityMask" )

	push	OFFSET $SG116546
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@setOption

; 30   : 		{
; 31   : 			// Telling timer what core to use for a timer read
; 32   : 			DWORD newTimerMask = * static_cast < const DWORD * > ( val );

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _newTimerMask$116547[ebp], eax

; 33   : 
; 34   : 			// Get the current process core mask
; 35   : 			DWORD procMask;
; 36   : 			DWORD sysMask;
; 37   : #if _MSC_VER >= 1400 && defined (_M_X64)
; 38   : 			GetProcessAffinityMask(GetCurrentProcess(), (PDWORD_PTR)&procMask, (PDWORD_PTR)&sysMask);
; 39   : #else
; 40   : 			GetProcessAffinityMask(GetCurrentProcess(), &procMask, &sysMask);

	lea	ecx, DWORD PTR _sysMask$116550[ebp]
	push	ecx
	lea	edx, DWORD PTR _procMask$116549[ebp]
	push	edx
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__GetProcessAffinityMask@12

; 41   : #endif
; 42   : 
; 43   : 			// If new mask is 0, then set to default behavior, otherwise check
; 44   : 			// to make sure new timer core mask overlaps with process core mask
; 45   : 			// and that new timer core mask is a power of 2 (i.e. a single core)
; 46   : 			if( ( newTimerMask == 0 ) ||
; 47   : 				( ( ( newTimerMask & procMask ) != 0 ) && Bitwise::isPO2( newTimerMask ) ) )

	cmp	DWORD PTR _newTimerMask$116547[ebp], 0
	je	SHORT $LN1@setOption
	mov	eax, DWORD PTR _newTimerMask$116547[ebp]
	and	eax, DWORD PTR _procMask$116549[ebp]
	je	SHORT $LN3@setOption
	mov	ecx, DWORD PTR _newTimerMask$116547[ebp]
	push	ecx
	call	??$isPO2@K@Bitwise@Ogre@@SA_NK@Z	; Ogre::Bitwise::isPO2<unsigned long>
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@setOption
$LN1@setOption:

; 48   : 			{
; 49   : 				mTimerMask = newTimerMask;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newTimerMask$116547[ebp]
	mov	DWORD PTR [eax+32], ecx

; 50   : 				return true;

	mov	al, 1
	jmp	SHORT $LN4@setOption
$LN3@setOption:

; 51   : 			}
; 52   : 		}
; 53   : 
; 54   : 		return false;

	xor	al, al
$LN4@setOption:

; 55   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?setOption@Timer@Ogre@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBX@Z ENDP ; Ogre::Timer::setOption
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?reset@Timer@Ogre@@QAEXXZ PROC				; Ogre::Timer::reset
; _this$ = ecx

; 59   : 	{/*

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 		// Get the current process core mask
; 61   : 		DWORD procMask;
; 62   : 		DWORD sysMask;
; 63   : #if _MSC_VER >= 1400 && defined (_M_X64)
; 64   : 		GetProcessAffinityMask(GetCurrentProcess(), (PDWORD_PTR)&procMask, (PDWORD_PTR)&sysMask);
; 65   : #else
; 66   : 		GetProcessAffinityMask(GetCurrentProcess(), &procMask, &sysMask);
; 67   : #endif
; 68   : 
; 69   : 		// Find the lowest core that this process uses
; 70   : 		if( mTimerMask == 0 )
; 71   : 		{
; 72   : 			mTimerMask = 1;
; 73   : 			while( ( mTimerMask & procMask ) == 0 )
; 74   : 			{
; 75   : 				mTimerMask <<= 1;
; 76   : 			}
; 77   : 		}
; 78   : 
; 79   : 		HANDLE thread = GetCurrentThread();
; 80   : 
; 81   : 		// Set affinity to the first core
; 82   : 		DWORD oldMask = (DWORD)SetThreadAffinityMask(thread, mTimerMask);
; 83   : 
; 84   : 		// Get the constant frequency
; 85   : 		QueryPerformanceFrequency((LARGE_INTEGER *)&mFrequency);
; 86   : 
; 87   : 		// Query the timer
; 88   : 		QueryPerformanceCounter((LARGE_INTEGER *)&mStartTime);
; 89   : 		mStartTick = GetTickCount();
; 90   : 
; 91   : 		// Reset affinity
; 92   : 		SetThreadAffinityMask(thread, oldMask);
; 93   : 
; 94   : 		mLastTime = 0;
; 95   : 		mZeroClock = clock();
; 96   : 		*/
; 97   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?reset@Timer@Ogre@@QAEXXZ ENDP				; Ogre::Timer::reset
_TEXT	ENDS
PUBLIC	?getMilliseconds@Timer@Ogre@@QAEIXZ		; Ogre::Timer::getMilliseconds
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMilliseconds@Timer@Ogre@@QAEIXZ PROC		; Ogre::Timer::getMilliseconds
; _this$ = ecx

; 101  : 	{/*

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 		int64 curTime;
; 103  : 
; 104  : 		HANDLE thread = GetCurrentThread();
; 105  : 
; 106  : 		// Set affinity to the first core
; 107  : 		DWORD oldMask = (DWORD)SetThreadAffinityMask(thread, mTimerMask);
; 108  : 
; 109  : 		// Query the timer
; 110  : 		QueryPerformanceCounter((LARGE_INTEGER *)&curTime);
; 111  : 
; 112  : 		// Reset affinity
; 113  : 		SetThreadAffinityMask(thread, oldMask);
; 114  : 
; 115  : 		int64 newTime = curTime - mStartTime;
; 116  : 
; 117  : 		// scale by 1000 for milliseconds
; 118  : 		uint newTicks = (uint) (1000 * newTime / mFrequency);
; 119  : 
; 120  : 		// detect and compensate for performance counter leaps
; 121  : 		// (surprisingly common, see Microsoft KB: Q274323)
; 122  : 		uint check = GetTickCount() - mStartTick;
; 123  : 		signed long msecOff = (signed long)(newTicks - check);
; 124  : 		if (msecOff < -100 || msecOff > 100)
; 125  : 		{
; 126  : 			// We must keep the timer running forward :)
; 127  : 			int64 adjust = (std::min)(msecOff * mFrequency / 1000, newTime - mLastTime);
; 128  : 			mStartTime += adjust;
; 129  : 			newTime -= adjust;
; 130  : 
; 131  : 			// Re-calculate milliseconds
; 132  : 			newTicks = (uint) (1000 * newTime / mFrequency);
; 133  : 		}
; 134  : 
; 135  : 		// Record last time for adjust
; 136  : 		mLastTime = newTime;
; 137  : 
; 138  : 		return newTicks;*/
; 139  : 		return timeGetTime();

	call	DWORD PTR __imp__timeGetTime@0

; 140  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMilliseconds@Timer@Ogre@@QAEIXZ ENDP		; Ogre::Timer::getMilliseconds
_TEXT	ENDS
PUBLIC	??$min@_J@std@@YAAB_JAB_J0@Z			; std::min<__int64>
PUBLIC	?getMicroseconds@Timer@Ogre@@QAEIXZ		; Ogre::Timer::getMicroseconds
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__SetThreadAffinityMask@8:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T120839 = -72						; size = 8
$T120838 = -64						; size = 8
_adjust$116578 = -56					; size = 8
_newTicks$ = -44					; size = 4
_newTime$ = -40						; size = 8
_newMicro$ = -28					; size = 4
_curTime$ = -24						; size = 8
_msecOff$ = -16						; size = 4
_thread$ = -12						; size = 4
_oldMask$ = -8						; size = 4
_check$ = -4						; size = 4
?getMicroseconds@Timer@Ogre@@QAEIXZ PROC		; Ogre::Timer::getMicroseconds
; _this$ = ecx

; 144  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		int64 curTime;
; 146  : 
; 147  : 		HANDLE thread = GetCurrentThread();

	call	DWORD PTR __imp__GetCurrentThread@0
	mov	DWORD PTR _thread$[ebp], eax

; 148  : 
; 149  : 		// Set affinity to the first core
; 150  : 		DWORD oldMask = (DWORD)SetThreadAffinityMask(thread, mTimerMask);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _thread$[ebp]
	push	edx
	call	DWORD PTR __imp__SetThreadAffinityMask@8
	mov	DWORD PTR _oldMask$[ebp], eax

; 151  : 
; 152  : 		// Query the timer
; 153  : 		QueryPerformanceCounter((LARGE_INTEGER *)&curTime);

	lea	eax, DWORD PTR _curTime$[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 154  : 
; 155  : 		// Reset affinity
; 156  : 		SetThreadAffinityMask(thread, oldMask);

	mov	ecx, DWORD PTR _oldMask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _thread$[ebp]
	push	edx
	call	DWORD PTR __imp__SetThreadAffinityMask@8

; 157  : 
; 158  : 		int64 newTime = curTime - mStartTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _curTime$[ebp]
	sub	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _curTime$[ebp+4]
	sbb	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _newTime$[ebp], ecx
	mov	DWORD PTR _newTime$[ebp+4], edx

; 159  : 
; 160  : 		// get milliseconds to check against GetTickCount
; 161  : 		uint newTicks = (uint) (1000 * newTime / mFrequency);

	push	0
	push	1000					; 000003e8H
	mov	eax, DWORD PTR _newTime$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _newTime$[ebp]
	push	ecx
	call	__allmul
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+28]
	push	esi
	mov	ecx, DWORD PTR [ecx+24]
	push	ecx
	push	edx
	push	eax
	call	__alldiv
	mov	DWORD PTR _newTicks$[ebp], eax

; 162  : 
; 163  : 		// detect and compensate for performance counter leaps
; 164  : 		// (surprisingly common, see Microsoft KB: Q274323)
; 165  : 		uint check = GetTickCount() - mStartTick;

	call	DWORD PTR __imp__GetTickCount@0
	mov	edx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _check$[ebp], eax

; 166  : 		signed long msecOff = (signed long)(newTicks - check);

	mov	eax, DWORD PTR _newTicks$[ebp]
	sub	eax, DWORD PTR _check$[ebp]
	mov	DWORD PTR _msecOff$[ebp], eax

; 167  : 		if (msecOff < -100 || msecOff > 100)

	cmp	DWORD PTR _msecOff$[ebp], -100		; ffffff9cH
	jl	SHORT $LN1@getMicrose
	cmp	DWORD PTR _msecOff$[ebp], 100		; 00000064H
	jle	$LN2@getMicrose
$LN1@getMicrose:

; 168  : 		{
; 169  : 			// We must keep the timer running forward :)
; 170  : 			int64 adjust = (std::min)(msecOff * mFrequency / 1000, newTime - mLastTime);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newTime$[ebp]
	sub	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _newTime$[ebp+4]
	sbb	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR $T120838[ebp], edx
	mov	DWORD PTR $T120838[ebp+4], eax
	mov	eax, DWORD PTR _msecOff$[ebp]
	cdq
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+28]
	push	esi
	mov	ecx, DWORD PTR [ecx+24]
	push	ecx
	push	edx
	push	eax
	call	__allmul
	push	0
	push	1000					; 000003e8H
	push	edx
	push	eax
	call	__alldiv
	mov	DWORD PTR $T120839[ebp], eax
	mov	DWORD PTR $T120839[ebp+4], edx
	lea	edx, DWORD PTR $T120838[ebp]
	push	edx
	lea	eax, DWORD PTR $T120839[ebp]
	push	eax
	call	??$min@_J@std@@YAAB_JAB_J0@Z		; std::min<__int64>
	add	esp, 8
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _adjust$116578[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _adjust$116578[ebp+4], edx

; 171  : 			mStartTime += adjust;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _adjust$116578[ebp]
	mov	edx, DWORD PTR [eax+20]
	adc	edx, DWORD PTR _adjust$116578[ebp+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], edx

; 172  : 			newTime -= adjust;

	mov	ecx, DWORD PTR _newTime$[ebp]
	sub	ecx, DWORD PTR _adjust$116578[ebp]
	mov	edx, DWORD PTR _newTime$[ebp+4]
	sbb	edx, DWORD PTR _adjust$116578[ebp+4]
	mov	DWORD PTR _newTime$[ebp], ecx
	mov	DWORD PTR _newTime$[ebp+4], edx
$LN2@getMicrose:

; 173  : 		}
; 174  : 
; 175  : 		// Record last time for adjust
; 176  : 		mLastTime = newTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newTime$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _newTime$[ebp+4]
	mov	DWORD PTR [eax+12], edx

; 177  : 
; 178  : 		// scale by 1000000 for microseconds
; 179  : 		uint newMicro = (uint) (1000000 * newTime / mFrequency);

	push	0
	push	1000000					; 000f4240H
	mov	eax, DWORD PTR _newTime$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _newTime$[ebp]
	push	ecx
	call	__allmul
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+28]
	push	esi
	mov	ecx, DWORD PTR [ecx+24]
	push	ecx
	push	edx
	push	eax
	call	__alldiv
	mov	DWORD PTR _newMicro$[ebp], eax

; 180  : 
; 181  : 		return newMicro;

	mov	eax, DWORD PTR _newMicro$[ebp]

; 182  : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?getMicroseconds@Timer@Ogre@@QAEIXZ ENDP		; Ogre::Timer::getMicroseconds
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	?getMillisecondsCPU@Timer@Ogre@@QAEIXZ		; Ogre::Timer::getMillisecondsCPU
EXTRN	__imp__clock:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
tv81 = -28						; size = 8
tv79 = -20						; size = 4
tv76 = -14						; size = 2
tv74 = -12						; size = 4
_this$ = -8						; size = 4
_newClock$ = -4						; size = 4
?getMillisecondsCPU@Timer@Ogre@@QAEIXZ PROC		; Ogre::Timer::getMillisecondsCPU
; _this$ = ecx

; 186  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 		clock_t newClock = clock();

	call	DWORD PTR __imp__clock
	mov	DWORD PTR _newClock$[ebp], eax

; 188  : 		return (uint)( (float)( newClock - mZeroClock ) / ( (float)CLOCKS_PER_SEC / 1000.0 ) ) ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newClock$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv74[ebp], ecx
	fild	DWORD PTR tv74[ebp]
	fdiv	QWORD PTR __real@3ff0000000000000
	fnstcw	WORD PTR tv76[ebp]
	movzx	eax, WORD PTR tv76[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv79[ebp], eax
	fldcw	WORD PTR tv79[ebp]
	fistp	QWORD PTR tv81[ebp]
	fldcw	WORD PTR tv76[ebp]
	mov	eax, DWORD PTR tv81[ebp]

; 189  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMillisecondsCPU@Timer@Ogre@@QAEIXZ ENDP		; Ogre::Timer::getMillisecondsCPU
_TEXT	ENDS
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	?getMicrosecondsCPU@Timer@Ogre@@QAEIXZ		; Ogre::Timer::getMicrosecondsCPU
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
tv81 = -28						; size = 8
tv79 = -20						; size = 4
tv76 = -14						; size = 2
tv74 = -12						; size = 4
_this$ = -8						; size = 4
_newClock$ = -4						; size = 4
?getMicrosecondsCPU@Timer@Ogre@@QAEIXZ PROC		; Ogre::Timer::getMicrosecondsCPU
; _this$ = ecx

; 193  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 194  : 		clock_t newClock = clock();

	call	DWORD PTR __imp__clock
	mov	DWORD PTR _newClock$[ebp], eax

; 195  : 		return (uint)( (float)( newClock - mZeroClock ) / ( (float)CLOCKS_PER_SEC / 1000000.0 ) ) ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newClock$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv74[ebp], ecx
	fild	DWORD PTR tv74[ebp]
	fdiv	QWORD PTR __real@3f50624dd2f1a9fc
	fnstcw	WORD PTR tv76[ebp]
	movzx	eax, WORD PTR tv76[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv79[ebp], eax
	fldcw	WORD PTR tv79[ebp]
	fistp	QWORD PTR tv81[ebp]
	fldcw	WORD PTR tv76[ebp]
	mov	eax, DWORD PTR tv81[ebp]

; 196  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMicrosecondsCPU@Timer@Ogre@@QAEIXZ ENDP		; Ogre::Timer::getMicrosecondsCPU
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebitwise.h
_TEXT	ENDS
;	COMDAT ??$isPO2@K@Bitwise@Ogre@@SA_NK@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
??$isPO2@K@Bitwise@Ogre@@SA_NK@Z PROC			; Ogre::Bitwise::isPO2<unsigned long>, COMDAT

; 71   : 		{

	push	ebp
	mov	ebp, esp

; 72   : 			return (n & (n-1)) == 0;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	and	eax, DWORD PTR _n$[ebp]
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 73   : 		}

	pop	ebp
	ret	0
??$isPO2@K@Bitwise@Ogre@@SA_NK@Z ENDP			; Ogre::Bitwise::isPO2<unsigned long>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$min@_J@std@@YAAB_JAB_J0@Z
_TEXT	SEGMENT
tv65 = -16						; size = 4
tv69 = -12						; size = 4
tv68 = -8						; size = 4
$T120852 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@_J@std@@YAAB_JAB_J0@Z PROC			; std::min<__int64>, COMDAT

; 3398 : 	{	// return smaller of _Left and _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	DWORD PTR tv69[ebp], ecx
	mov	edx, DWORD PTR tv68[ebp]
	mov	eax, DWORD PTR tv69[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN3@min
	jl	SHORT $LN5@min
	mov	edx, DWORD PTR tv68[ebp]
	mov	eax, DWORD PTR tv69[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN3@min
$LN5@min:
	mov	edx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv65[ebp], edx
	jmp	SHORT $LN4@min
$LN3@min:
	mov	eax, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv65[ebp], eax
$LN4@min:
	mov	ecx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T120852[ebp], ecx
	mov	eax, DWORD PTR $T120852[ebp]

; 3400 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$min@_J@std@@YAAB_JAB_J0@Z ENDP			; std::min<__int64>
_TEXT	ENDS
END

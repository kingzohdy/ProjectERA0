; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\sdk\ozcollide\intr_tribox.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?testIntersectionTriBox@ozcollide@@YA_NPBVVec3f@1@ABVBox@1@@Z ; ozcollide::testIntersectionTriBox
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\intr_tribox.cpp
_TEXT	SEGMENT
_res$ = -4						; size = 4
__pts$ = 8						; size = 4
__box$ = 12						; size = 4
?testIntersectionTriBox@ozcollide@@YA_NPBVVec3f@1@ABVBox@1@@Z PROC ; ozcollide::testIntersectionTriBox

; 221  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 222  : 	//float pt[3][3];
; 223  : /*
; 224  : 	pt[0][0] = _pts[0].x;	pt[0][1] = _pts[0].y;	pt[0][2] = _pts[0].z;
; 225  : 	pt[1][0] = _pts[1].x;	pt[1][1] = _pts[1].y;	pt[1][2] = _pts[1].z;
; 226  : 	pt[2][0] = _pts[2].x;	pt[2][1] = _pts[2].y;	pt[2][2] = _pts[2].z;
; 227  : */
; 228  : 	int res = triBoxOverlap(&_box.center.x, &_box.extent.x, _pts);

	mov	eax, DWORD PTR __pts$[ebp]
	push	eax
	mov	ecx, DWORD PTR __box$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR __box$[ebp]
	push	edx
	call	?triBoxOverlap@ozcollide@@YAHPBM0PBVVec3f@1@@Z ; ozcollide::triBoxOverlap
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _res$[ebp], eax

; 229  : 	if (res == 1)

	cmp	DWORD PTR _res$[ebp], 1
	jne	SHORT $LN1@testInters

; 230  : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@testInters
$LN1@testInters:

; 231  : 
; 232  : 	return false;

	xor	al, al
$LN2@testInters:

; 233  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?testIntersectionTriBox@ozcollide@@YA_NPBVVec3f@1@ABVBox@1@@Z ENDP ; ozcollide::testIntersectionTriBox
_TEXT	ENDS
PUBLIC	_fabsf
PUBLIC	??AVec3f@ozcollide@@QBEMH@Z			; ozcollide::Vec3f::operator[]
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
_TEXT	SEGMENT
_max$ = -124						; size = 4
_v0$ = -120						; size = 12
_fez$ = -108						; size = 4
_d$ = -104						; size = 4
_e1$ = -100						; size = 12
_rad$ = -88						; size = 4
_normal$ = -84						; size = 12
_p1$ = -72						; size = 4
_fey$ = -68						; size = 4
_v2$ = -64						; size = 12
_p2$ = -52						; size = 4
_p0$ = -48						; size = 4
_v1$ = -44						; size = 12
_min$ = -32						; size = 4
_e0$ = -28						; size = 12
_e2$ = -16						; size = 12
_fex$ = -4						; size = 4
_boxcenter$ = 8						; size = 4
_boxhalfsize$ = 12					; size = 4
_triverts$ = 16						; size = 4
?triBoxOverlap@ozcollide@@YAHPBM0PBVVec3f@1@@Z PROC	; ozcollide::triBoxOverlap

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 145  : 
; 146  :   /*    use separating axis theorem to test overlap between triangle and box */
; 147  :   /*    need to test for overlap in these directions: */
; 148  :   /*    1) the {x,y,z}-directions (actually, since we use the AABB of the triangle */
; 149  :   /*       we do not even need to test these) */
; 150  :   /*    2) normal of the triangle */
; 151  :   /*    3) crossproduct(edge from tri, {x,y,z}-directin) */
; 152  :   /*       this gives 3x3=9 more tests */
; 153  :    float v0[3],v1[3],v2[3];
; 154  :    //float axis[3];
; 155  :    float min,max,d,p0,p1,p2,rad,fex,fey,fez;  
; 156  :    float normal[3],e0[3],e1[3],e2[3];
; 157  : 
; 158  :    /* This is the fastest branch on Sun */
; 159  :    /* move everything so that the boxcenter is in (0,0,0) */
; 160  :    SUB(v0,triverts[0],boxcenter);

	push	0
	mov	ecx, DWORD PTR _triverts$[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	eax, DWORD PTR _boxcenter$[ebp]
	fsub	DWORD PTR [eax]
	fstp	DWORD PTR _v0$[ebp]
	push	1
	mov	ecx, DWORD PTR _triverts$[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	ecx, DWORD PTR _boxcenter$[ebp]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _v0$[ebp+4]
	push	2
	mov	ecx, DWORD PTR _triverts$[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	edx, DWORD PTR _boxcenter$[ebp]
	fsub	DWORD PTR [edx+8]
	fstp	DWORD PTR _v0$[ebp+8]

; 161  :    SUB(v1,triverts[1],boxcenter);

	push	0
	mov	ecx, DWORD PTR _triverts$[ebp]
	add	ecx, 12					; 0000000cH
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	eax, DWORD PTR _boxcenter$[ebp]
	fsub	DWORD PTR [eax]
	fstp	DWORD PTR _v1$[ebp]
	push	1
	mov	ecx, DWORD PTR _triverts$[ebp]
	add	ecx, 12					; 0000000cH
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	ecx, DWORD PTR _boxcenter$[ebp]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _v1$[ebp+4]
	push	2
	mov	ecx, DWORD PTR _triverts$[ebp]
	add	ecx, 12					; 0000000cH
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	edx, DWORD PTR _boxcenter$[ebp]
	fsub	DWORD PTR [edx+8]
	fstp	DWORD PTR _v1$[ebp+8]

; 162  :    SUB(v2,triverts[2],boxcenter);

	push	0
	mov	ecx, DWORD PTR _triverts$[ebp]
	add	ecx, 24					; 00000018H
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	eax, DWORD PTR _boxcenter$[ebp]
	fsub	DWORD PTR [eax]
	fstp	DWORD PTR _v2$[ebp]
	push	1
	mov	ecx, DWORD PTR _triverts$[ebp]
	add	ecx, 24					; 00000018H
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	ecx, DWORD PTR _boxcenter$[ebp]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _v2$[ebp+4]
	push	2
	mov	ecx, DWORD PTR _triverts$[ebp]
	add	ecx, 24					; 00000018H
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	edx, DWORD PTR _boxcenter$[ebp]
	fsub	DWORD PTR [edx+8]
	fstp	DWORD PTR _v2$[ebp+8]

; 163  : 
; 164  :    /* compute triangle edges */
; 165  :    SUB(e0,v1,v0);      /* tri edge 0 */

	fld	DWORD PTR _v1$[ebp]
	fsub	DWORD PTR _v0$[ebp]
	fstp	DWORD PTR _e0$[ebp]
	fld	DWORD PTR _v1$[ebp+4]
	fsub	DWORD PTR _v0$[ebp+4]
	fstp	DWORD PTR _e0$[ebp+4]
	fld	DWORD PTR _v1$[ebp+8]
	fsub	DWORD PTR _v0$[ebp+8]
	fstp	DWORD PTR _e0$[ebp+8]

; 166  :    SUB(e1,v2,v1);      /* tri edge 1 */

	fld	DWORD PTR _v2$[ebp]
	fsub	DWORD PTR _v1$[ebp]
	fstp	DWORD PTR _e1$[ebp]
	fld	DWORD PTR _v2$[ebp+4]
	fsub	DWORD PTR _v1$[ebp+4]
	fstp	DWORD PTR _e1$[ebp+4]
	fld	DWORD PTR _v2$[ebp+8]
	fsub	DWORD PTR _v1$[ebp+8]
	fstp	DWORD PTR _e1$[ebp+8]

; 167  :    SUB(e2,v0,v2);      /* tri edge 2 */

	fld	DWORD PTR _v0$[ebp]
	fsub	DWORD PTR _v2$[ebp]
	fstp	DWORD PTR _e2$[ebp]
	fld	DWORD PTR _v0$[ebp+4]
	fsub	DWORD PTR _v2$[ebp+4]
	fstp	DWORD PTR _e2$[ebp+4]
	fld	DWORD PTR _v0$[ebp+8]
	fsub	DWORD PTR _v2$[ebp+8]
	fstp	DWORD PTR _e2$[ebp+8]

; 168  : 
; 169  :    /* Bullet 3:  */
; 170  :    /*  test the 9 tests first (this was faster) */
; 171  :    fex = fabsf(e0[X]);

	push	ecx
	fld	DWORD PTR _e0$[ebp]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fex$[ebp]

; 172  :    fey = fabsf(e0[Y]);

	push	ecx
	fld	DWORD PTR _e0$[ebp+4]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fey$[ebp]

; 173  :    fez = fabsf(e0[Z]);

	push	ecx
	fld	DWORD PTR _e0$[ebp+8]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fez$[ebp]

; 174  :    AXISTEST_X01(e0[Z], e0[Y], fez, fey);

	fld	DWORD PTR _e0$[ebp+8]
	fmul	DWORD PTR _v0$[ebp+4]
	fld	DWORD PTR _e0$[ebp+4]
	fmul	DWORD PTR _v0$[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _p0$[ebp]
	fld	DWORD PTR _e0$[ebp+8]
	fmul	DWORD PTR _v2$[ebp+4]
	fld	DWORD PTR _e0$[ebp+4]
	fmul	DWORD PTR _v2$[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _p2$[ebp]
	fld	DWORD PTR _p0$[ebp]
	fld	DWORD PTR _p2$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN55@triBoxOver
	fld	DWORD PTR _p0$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p2$[ebp]
	fstp	DWORD PTR _max$[ebp]
	jmp	SHORT $LN54@triBoxOver
$LN55@triBoxOver:
	fld	DWORD PTR _p2$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p0$[ebp]
	fstp	DWORD PTR _max$[ebp]
$LN54@triBoxOver:
	fld	DWORD PTR _fez$[ebp]
	mov	eax, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [eax+4]
	fld	DWORD PTR _fey$[ebp]
	mov	ecx, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _rad$[ebp]
	fld	DWORD PTR _min$[ebp]
	fld	DWORD PTR _rad$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN52@triBoxOver
	fld	DWORD PTR _rad$[ebp]
	fchs
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN53@triBoxOver
$LN52@triBoxOver:
	xor	eax, eax
	jmp	$LN56@triBoxOver
$LN53@triBoxOver:

; 175  :    AXISTEST_Y02(e0[Z], e0[X], fez, fex);

	fld	DWORD PTR _e0$[ebp+8]
	fchs
	fmul	DWORD PTR _v0$[ebp]
	fld	DWORD PTR _e0$[ebp]
	fmul	DWORD PTR _v0$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _p0$[ebp]
	fld	DWORD PTR _e0$[ebp+8]
	fchs
	fmul	DWORD PTR _v2$[ebp]
	fld	DWORD PTR _e0$[ebp]
	fmul	DWORD PTR _v2$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _p2$[ebp]
	fld	DWORD PTR _p0$[ebp]
	fld	DWORD PTR _p2$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN51@triBoxOver
	fld	DWORD PTR _p0$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p2$[ebp]
	fstp	DWORD PTR _max$[ebp]
	jmp	SHORT $LN50@triBoxOver
$LN51@triBoxOver:
	fld	DWORD PTR _p2$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p0$[ebp]
	fstp	DWORD PTR _max$[ebp]
$LN50@triBoxOver:
	fld	DWORD PTR _fez$[ebp]
	mov	edx, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [edx]
	fld	DWORD PTR _fex$[ebp]
	mov	eax, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _rad$[ebp]
	fld	DWORD PTR _min$[ebp]
	fld	DWORD PTR _rad$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN48@triBoxOver
	fld	DWORD PTR _rad$[ebp]
	fchs
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN49@triBoxOver
$LN48@triBoxOver:
	xor	eax, eax
	jmp	$LN56@triBoxOver
$LN49@triBoxOver:

; 176  :    AXISTEST_Z12(e0[Y], e0[X], fey, fex);

	fld	DWORD PTR _e0$[ebp+4]
	fmul	DWORD PTR _v1$[ebp]
	fld	DWORD PTR _e0$[ebp]
	fmul	DWORD PTR _v1$[ebp+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _p1$[ebp]
	fld	DWORD PTR _e0$[ebp+4]
	fmul	DWORD PTR _v2$[ebp]
	fld	DWORD PTR _e0$[ebp]
	fmul	DWORD PTR _v2$[ebp+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _p2$[ebp]
	fld	DWORD PTR _p2$[ebp]
	fld	DWORD PTR _p1$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN47@triBoxOver
	fld	DWORD PTR _p2$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p1$[ebp]
	fstp	DWORD PTR _max$[ebp]
	jmp	SHORT $LN46@triBoxOver
$LN47@triBoxOver:
	fld	DWORD PTR _p1$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p2$[ebp]
	fstp	DWORD PTR _max$[ebp]
$LN46@triBoxOver:
	fld	DWORD PTR _fey$[ebp]
	mov	ecx, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [ecx]
	fld	DWORD PTR _fex$[ebp]
	mov	edx, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [edx+4]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _rad$[ebp]
	fld	DWORD PTR _min$[ebp]
	fld	DWORD PTR _rad$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN44@triBoxOver
	fld	DWORD PTR _rad$[ebp]
	fchs
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN45@triBoxOver
$LN44@triBoxOver:
	xor	eax, eax
	jmp	$LN56@triBoxOver
$LN45@triBoxOver:

; 177  : 
; 178  :    fex = fabsf(e1[X]);

	push	ecx
	fld	DWORD PTR _e1$[ebp]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fex$[ebp]

; 179  :    fey = fabsf(e1[Y]);

	push	ecx
	fld	DWORD PTR _e1$[ebp+4]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fey$[ebp]

; 180  :    fez = fabsf(e1[Z]);

	push	ecx
	fld	DWORD PTR _e1$[ebp+8]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fez$[ebp]

; 181  :    AXISTEST_X01(e1[Z], e1[Y], fez, fey);

	fld	DWORD PTR _e1$[ebp+8]
	fmul	DWORD PTR _v0$[ebp+4]
	fld	DWORD PTR _e1$[ebp+4]
	fmul	DWORD PTR _v0$[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _p0$[ebp]
	fld	DWORD PTR _e1$[ebp+8]
	fmul	DWORD PTR _v2$[ebp+4]
	fld	DWORD PTR _e1$[ebp+4]
	fmul	DWORD PTR _v2$[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _p2$[ebp]
	fld	DWORD PTR _p0$[ebp]
	fld	DWORD PTR _p2$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN43@triBoxOver
	fld	DWORD PTR _p0$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p2$[ebp]
	fstp	DWORD PTR _max$[ebp]
	jmp	SHORT $LN42@triBoxOver
$LN43@triBoxOver:
	fld	DWORD PTR _p2$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p0$[ebp]
	fstp	DWORD PTR _max$[ebp]
$LN42@triBoxOver:
	fld	DWORD PTR _fez$[ebp]
	mov	eax, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [eax+4]
	fld	DWORD PTR _fey$[ebp]
	mov	ecx, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _rad$[ebp]
	fld	DWORD PTR _min$[ebp]
	fld	DWORD PTR _rad$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN40@triBoxOver
	fld	DWORD PTR _rad$[ebp]
	fchs
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN41@triBoxOver
$LN40@triBoxOver:
	xor	eax, eax
	jmp	$LN56@triBoxOver
$LN41@triBoxOver:

; 182  :    AXISTEST_Y02(e1[Z], e1[X], fez, fex);

	fld	DWORD PTR _e1$[ebp+8]
	fchs
	fmul	DWORD PTR _v0$[ebp]
	fld	DWORD PTR _e1$[ebp]
	fmul	DWORD PTR _v0$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _p0$[ebp]
	fld	DWORD PTR _e1$[ebp+8]
	fchs
	fmul	DWORD PTR _v2$[ebp]
	fld	DWORD PTR _e1$[ebp]
	fmul	DWORD PTR _v2$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _p2$[ebp]
	fld	DWORD PTR _p0$[ebp]
	fld	DWORD PTR _p2$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN39@triBoxOver
	fld	DWORD PTR _p0$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p2$[ebp]
	fstp	DWORD PTR _max$[ebp]
	jmp	SHORT $LN38@triBoxOver
$LN39@triBoxOver:
	fld	DWORD PTR _p2$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p0$[ebp]
	fstp	DWORD PTR _max$[ebp]
$LN38@triBoxOver:
	fld	DWORD PTR _fez$[ebp]
	mov	edx, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [edx]
	fld	DWORD PTR _fex$[ebp]
	mov	eax, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _rad$[ebp]
	fld	DWORD PTR _min$[ebp]
	fld	DWORD PTR _rad$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN36@triBoxOver
	fld	DWORD PTR _rad$[ebp]
	fchs
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN37@triBoxOver
$LN36@triBoxOver:
	xor	eax, eax
	jmp	$LN56@triBoxOver
$LN37@triBoxOver:

; 183  :    AXISTEST_Z0(e1[Y], e1[X], fey, fex);

	fld	DWORD PTR _e1$[ebp+4]
	fmul	DWORD PTR _v0$[ebp]
	fld	DWORD PTR _e1$[ebp]
	fmul	DWORD PTR _v0$[ebp+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _p0$[ebp]
	fld	DWORD PTR _e1$[ebp+4]
	fmul	DWORD PTR _v1$[ebp]
	fld	DWORD PTR _e1$[ebp]
	fmul	DWORD PTR _v1$[ebp+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _p1$[ebp]
	fld	DWORD PTR _p0$[ebp]
	fld	DWORD PTR _p1$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN35@triBoxOver
	fld	DWORD PTR _p0$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p1$[ebp]
	fstp	DWORD PTR _max$[ebp]
	jmp	SHORT $LN34@triBoxOver
$LN35@triBoxOver:
	fld	DWORD PTR _p1$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p0$[ebp]
	fstp	DWORD PTR _max$[ebp]
$LN34@triBoxOver:
	fld	DWORD PTR _fey$[ebp]
	mov	ecx, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [ecx]
	fld	DWORD PTR _fex$[ebp]
	mov	edx, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [edx+4]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _rad$[ebp]
	fld	DWORD PTR _min$[ebp]
	fld	DWORD PTR _rad$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN32@triBoxOver
	fld	DWORD PTR _rad$[ebp]
	fchs
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN33@triBoxOver
$LN32@triBoxOver:
	xor	eax, eax
	jmp	$LN56@triBoxOver
$LN33@triBoxOver:

; 184  : 
; 185  :    fex = fabsf(e2[X]);

	push	ecx
	fld	DWORD PTR _e2$[ebp]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fex$[ebp]

; 186  :    fey = fabsf(e2[Y]);

	push	ecx
	fld	DWORD PTR _e2$[ebp+4]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fey$[ebp]

; 187  :    fez = fabsf(e2[Z]);

	push	ecx
	fld	DWORD PTR _e2$[ebp+8]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fez$[ebp]

; 188  :    AXISTEST_X2(e2[Z], e2[Y], fez, fey);

	fld	DWORD PTR _e2$[ebp+8]
	fmul	DWORD PTR _v0$[ebp+4]
	fld	DWORD PTR _e2$[ebp+4]
	fmul	DWORD PTR _v0$[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _p0$[ebp]
	fld	DWORD PTR _e2$[ebp+8]
	fmul	DWORD PTR _v1$[ebp+4]
	fld	DWORD PTR _e2$[ebp+4]
	fmul	DWORD PTR _v1$[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _p1$[ebp]
	fld	DWORD PTR _p0$[ebp]
	fld	DWORD PTR _p1$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN31@triBoxOver
	fld	DWORD PTR _p0$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p1$[ebp]
	fstp	DWORD PTR _max$[ebp]
	jmp	SHORT $LN30@triBoxOver
$LN31@triBoxOver:
	fld	DWORD PTR _p1$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p0$[ebp]
	fstp	DWORD PTR _max$[ebp]
$LN30@triBoxOver:
	fld	DWORD PTR _fez$[ebp]
	mov	eax, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [eax+4]
	fld	DWORD PTR _fey$[ebp]
	mov	ecx, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _rad$[ebp]
	fld	DWORD PTR _min$[ebp]
	fld	DWORD PTR _rad$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN28@triBoxOver
	fld	DWORD PTR _rad$[ebp]
	fchs
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN29@triBoxOver
$LN28@triBoxOver:
	xor	eax, eax
	jmp	$LN56@triBoxOver
$LN29@triBoxOver:

; 189  :    AXISTEST_Y1(e2[Z], e2[X], fez, fex);

	fld	DWORD PTR _e2$[ebp+8]
	fchs
	fmul	DWORD PTR _v0$[ebp]
	fld	DWORD PTR _e2$[ebp]
	fmul	DWORD PTR _v0$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _p0$[ebp]
	fld	DWORD PTR _e2$[ebp+8]
	fchs
	fmul	DWORD PTR _v1$[ebp]
	fld	DWORD PTR _e2$[ebp]
	fmul	DWORD PTR _v1$[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _p1$[ebp]
	fld	DWORD PTR _p0$[ebp]
	fld	DWORD PTR _p1$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN27@triBoxOver
	fld	DWORD PTR _p0$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p1$[ebp]
	fstp	DWORD PTR _max$[ebp]
	jmp	SHORT $LN26@triBoxOver
$LN27@triBoxOver:
	fld	DWORD PTR _p1$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p0$[ebp]
	fstp	DWORD PTR _max$[ebp]
$LN26@triBoxOver:
	fld	DWORD PTR _fez$[ebp]
	mov	edx, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [edx]
	fld	DWORD PTR _fex$[ebp]
	mov	eax, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _rad$[ebp]
	fld	DWORD PTR _min$[ebp]
	fld	DWORD PTR _rad$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN24@triBoxOver
	fld	DWORD PTR _rad$[ebp]
	fchs
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN25@triBoxOver
$LN24@triBoxOver:
	xor	eax, eax
	jmp	$LN56@triBoxOver
$LN25@triBoxOver:

; 190  :    AXISTEST_Z12(e2[Y], e2[X], fey, fex);

	fld	DWORD PTR _e2$[ebp+4]
	fmul	DWORD PTR _v1$[ebp]
	fld	DWORD PTR _e2$[ebp]
	fmul	DWORD PTR _v1$[ebp+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _p1$[ebp]
	fld	DWORD PTR _e2$[ebp+4]
	fmul	DWORD PTR _v2$[ebp]
	fld	DWORD PTR _e2$[ebp]
	fmul	DWORD PTR _v2$[ebp+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _p2$[ebp]
	fld	DWORD PTR _p2$[ebp]
	fld	DWORD PTR _p1$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN23@triBoxOver
	fld	DWORD PTR _p2$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p1$[ebp]
	fstp	DWORD PTR _max$[ebp]
	jmp	SHORT $LN22@triBoxOver
$LN23@triBoxOver:
	fld	DWORD PTR _p1$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _p2$[ebp]
	fstp	DWORD PTR _max$[ebp]
$LN22@triBoxOver:
	fld	DWORD PTR _fey$[ebp]
	mov	ecx, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [ecx]
	fld	DWORD PTR _fex$[ebp]
	mov	edx, DWORD PTR _boxhalfsize$[ebp]
	fmul	DWORD PTR [edx+4]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _rad$[ebp]
	fld	DWORD PTR _min$[ebp]
	fld	DWORD PTR _rad$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN20@triBoxOver
	fld	DWORD PTR _rad$[ebp]
	fchs
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN21@triBoxOver
$LN20@triBoxOver:
	xor	eax, eax
	jmp	$LN56@triBoxOver
$LN21@triBoxOver:

; 191  : 
; 192  :    /* Bullet 1: */
; 193  :    /*  first test overlap in the {x,y,z}-directions */
; 194  :    /*  find min, max of the triangle each direction, and test for overlap in */
; 195  :    /*  that direction -- this is equivalent to testing a minimal AABB around */
; 196  :    /*  the triangle against the AABB */
; 197  : 
; 198  :    /* test in X-direction */
; 199  :    FINDMINMAX(v0[X],v1[X],v2[X],min,max);

	fld	DWORD PTR _v0$[ebp]
	fstp	DWORD PTR _max$[ebp]
	fld	DWORD PTR _max$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _v1$[ebp]
	fld	DWORD PTR _min$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN19@triBoxOver
	fld	DWORD PTR _v1$[ebp]
	fstp	DWORD PTR _min$[ebp]
$LN19@triBoxOver:
	fld	DWORD PTR _v1$[ebp]
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN18@triBoxOver
	fld	DWORD PTR _v1$[ebp]
	fstp	DWORD PTR _max$[ebp]
$LN18@triBoxOver:
	fld	DWORD PTR _v2$[ebp]
	fld	DWORD PTR _min$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN17@triBoxOver
	fld	DWORD PTR _v2$[ebp]
	fstp	DWORD PTR _min$[ebp]
$LN17@triBoxOver:
	fld	DWORD PTR _v2$[ebp]
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN16@triBoxOver
	fld	DWORD PTR _v2$[ebp]
	fstp	DWORD PTR _max$[ebp]
$LN16@triBoxOver:

; 200  :    if(min>boxhalfsize[X] || max<-boxhalfsize[X]) return 0;

	fld	DWORD PTR _min$[ebp]
	mov	eax, DWORD PTR _boxhalfsize$[ebp]
	fld	DWORD PTR [eax]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN14@triBoxOver
	mov	ecx, DWORD PTR _boxhalfsize$[ebp]
	fld	DWORD PTR [ecx]
	fchs
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN15@triBoxOver
$LN14@triBoxOver:
	xor	eax, eax
	jmp	$LN56@triBoxOver
$LN15@triBoxOver:

; 201  : 
; 202  :    /* test in Y-direction */
; 203  :    FINDMINMAX(v0[Y],v1[Y],v2[Y],min,max);

	fld	DWORD PTR _v0$[ebp+4]
	fstp	DWORD PTR _max$[ebp]
	fld	DWORD PTR _max$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _v1$[ebp+4]
	fld	DWORD PTR _min$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN13@triBoxOver
	fld	DWORD PTR _v1$[ebp+4]
	fstp	DWORD PTR _min$[ebp]
$LN13@triBoxOver:
	fld	DWORD PTR _v1$[ebp+4]
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN12@triBoxOver
	fld	DWORD PTR _v1$[ebp+4]
	fstp	DWORD PTR _max$[ebp]
$LN12@triBoxOver:
	fld	DWORD PTR _v2$[ebp+4]
	fld	DWORD PTR _min$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN11@triBoxOver
	fld	DWORD PTR _v2$[ebp+4]
	fstp	DWORD PTR _min$[ebp]
$LN11@triBoxOver:
	fld	DWORD PTR _v2$[ebp+4]
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN10@triBoxOver
	fld	DWORD PTR _v2$[ebp+4]
	fstp	DWORD PTR _max$[ebp]
$LN10@triBoxOver:

; 204  :    if(min>boxhalfsize[Y] || max<-boxhalfsize[Y]) return 0;

	fld	DWORD PTR _min$[ebp]
	mov	edx, DWORD PTR _boxhalfsize$[ebp]
	fld	DWORD PTR [edx+4]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN8@triBoxOver
	mov	eax, DWORD PTR _boxhalfsize$[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@triBoxOver
$LN8@triBoxOver:
	xor	eax, eax
	jmp	$LN56@triBoxOver
$LN9@triBoxOver:

; 205  : 
; 206  :    /* test in Z-direction */
; 207  :    FINDMINMAX(v0[Z],v1[Z],v2[Z],min,max);

	fld	DWORD PTR _v0$[ebp+8]
	fstp	DWORD PTR _max$[ebp]
	fld	DWORD PTR _max$[ebp]
	fstp	DWORD PTR _min$[ebp]
	fld	DWORD PTR _v1$[ebp+8]
	fld	DWORD PTR _min$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN7@triBoxOver
	fld	DWORD PTR _v1$[ebp+8]
	fstp	DWORD PTR _min$[ebp]
$LN7@triBoxOver:
	fld	DWORD PTR _v1$[ebp+8]
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@triBoxOver
	fld	DWORD PTR _v1$[ebp+8]
	fstp	DWORD PTR _max$[ebp]
$LN6@triBoxOver:
	fld	DWORD PTR _v2$[ebp+8]
	fld	DWORD PTR _min$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN5@triBoxOver
	fld	DWORD PTR _v2$[ebp+8]
	fstp	DWORD PTR _min$[ebp]
$LN5@triBoxOver:
	fld	DWORD PTR _v2$[ebp+8]
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@triBoxOver
	fld	DWORD PTR _v2$[ebp+8]
	fstp	DWORD PTR _max$[ebp]
$LN4@triBoxOver:

; 208  :    if(min>boxhalfsize[Z] || max<-boxhalfsize[Z]) return 0;

	fld	DWORD PTR _min$[ebp]
	mov	ecx, DWORD PTR _boxhalfsize$[ebp]
	fld	DWORD PTR [ecx+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN2@triBoxOver
	mov	edx, DWORD PTR _boxhalfsize$[ebp]
	fld	DWORD PTR [edx+8]
	fchs
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@triBoxOver
$LN2@triBoxOver:
	xor	eax, eax
	jmp	SHORT $LN56@triBoxOver
$LN3@triBoxOver:

; 209  : 
; 210  :    /* Bullet 2: */
; 211  :    /*  test if the box intersects the plane of the triangle */
; 212  :    /*  compute plane equation of triangle: normal*x+d=0 */
; 213  :    CROSS(normal,e0,e1);

	fld	DWORD PTR _e0$[ebp+4]
	fmul	DWORD PTR _e1$[ebp+8]
	fld	DWORD PTR _e0$[ebp+8]
	fmul	DWORD PTR _e1$[ebp+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _normal$[ebp]
	fld	DWORD PTR _e0$[ebp+8]
	fmul	DWORD PTR _e1$[ebp]
	fld	DWORD PTR _e0$[ebp]
	fmul	DWORD PTR _e1$[ebp+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _normal$[ebp+4]
	fld	DWORD PTR _e0$[ebp]
	fmul	DWORD PTR _e1$[ebp+4]
	fld	DWORD PTR _e0$[ebp+4]
	fmul	DWORD PTR _e1$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _normal$[ebp+8]

; 214  :    d=-DOT(normal,v0);  /* plane eq: normal.x+d=0 */

	fld	DWORD PTR _normal$[ebp]
	fmul	DWORD PTR _v0$[ebp]
	fld	DWORD PTR _normal$[ebp+4]
	fmul	DWORD PTR _v0$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _normal$[ebp+8]
	fmul	DWORD PTR _v0$[ebp+8]
	faddp	ST(1), ST(0)
	fchs
	fstp	DWORD PTR _d$[ebp]

; 215  :    if(!planeBoxOverlap(normal,d,boxhalfsize)) return 0;

	mov	eax, DWORD PTR _boxhalfsize$[ebp]
	push	eax
	push	ecx
	fld	DWORD PTR _d$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _normal$[ebp]
	push	ecx
	call	?planeBoxOverlap@ozcollide@@YAHPBMM0@Z	; ozcollide::planeBoxOverlap
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@triBoxOver
	xor	eax, eax
	jmp	SHORT $LN56@triBoxOver
$LN1@triBoxOver:

; 216  : 
; 217  :    return 1;   /* box and triangle overlaps */

	mov	eax, 1
$LN56@triBoxOver:

; 218  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?triBoxOverlap@ozcollide@@YAHPBM0PBVVec3f@1@@Z ENDP	; ozcollide::triBoxOverlap
_TEXT	ENDS
EXTRN	_fabs:PROC
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 384  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
_TEXT	ENDS
;	COMDAT ??AVec3f@ozcollide@@QBEMH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_val$ = -4						; size = 4
__i$ = 8						; size = 4
??AVec3f@ozcollide@@QBEMH@Z PROC			; ozcollide::Vec3f::operator[], COMDAT
; _this$ = ecx

; 146  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		const float *val = &x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 148  : 		return val[_i];

	mov	ecx, DWORD PTR __i$[ebp]
	mov	edx, DWORD PTR _val$[ebp]
	fld	DWORD PTR [edx+ecx*4]

; 149  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??AVec3f@ozcollide@@QBEMH@Z ENDP			; ozcollide::Vec3f::operator[]
_TEXT	ENDS
PUBLIC	__real@0000000000000000
;	COMDAT __real@0000000000000000
; File i:\svnroot\client\sdk\ozcollide\intr_tribox.cpp
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
_q$ = -28						; size = 4
_vmax$ = -24						; size = 12
_vmin$ = -12						; size = 12
_normal$ = 8						; size = 4
_d$ = 12						; size = 4
_maxbox$ = 16						; size = 4
?planeBoxOverlap@ozcollide@@YAHPBMM0@Z PROC		; ozcollide::planeBoxOverlap

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 75   :   int q;
; 76   :   float vmin[3],vmax[3];
; 77   :   for(q=X;q<=Z;q++)

	mov	DWORD PTR _q$[ebp], 0
	jmp	SHORT $LN7@planeBoxOv
$LN6@planeBoxOv:
	mov	eax, DWORD PTR _q$[ebp]
	add	eax, 1
	mov	DWORD PTR _q$[ebp], eax
$LN7@planeBoxOv:
	cmp	DWORD PTR _q$[ebp], 2
	jg	SHORT $LN5@planeBoxOv

; 78   :   {
; 79   :     if(normal[q]>0.0f)

	mov	ecx, DWORD PTR _q$[ebp]
	mov	edx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [edx+ecx*4]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@planeBoxOv

; 80   :     {
; 81   :       vmin[q]=-maxbox[q];

	mov	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR _maxbox$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	fchs
	mov	edx, DWORD PTR _q$[ebp]
	fstp	DWORD PTR _vmin$[ebp+edx*4]

; 82   :       vmax[q]=maxbox[q];

	mov	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	edx, DWORD PTR _maxbox$[ebp]
	fld	DWORD PTR [edx+ecx*4]
	fstp	DWORD PTR _vmax$[ebp+eax*4]

; 83   :     }
; 84   :     else

	jmp	SHORT $LN3@planeBoxOv
$LN4@planeBoxOv:

; 85   :     {
; 86   :       vmin[q]=maxbox[q];

	mov	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR _q$[ebp]
	mov	edx, DWORD PTR _maxbox$[ebp]
	fld	DWORD PTR [edx+ecx*4]
	fstp	DWORD PTR _vmin$[ebp+eax*4]

; 87   :       vmax[q]=-maxbox[q];

	mov	eax, DWORD PTR _q$[ebp]
	mov	ecx, DWORD PTR _maxbox$[ebp]
	fld	DWORD PTR [ecx+eax*4]
	fchs
	mov	edx, DWORD PTR _q$[ebp]
	fstp	DWORD PTR _vmax$[ebp+edx*4]
$LN3@planeBoxOv:

; 88   :     }
; 89   :   }

	jmp	SHORT $LN6@planeBoxOv
$LN5@planeBoxOv:

; 90   :   if(DOT(normal,vmin)+d>0.0f) return 0;

	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _vmin$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _vmin$[ebp+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR _vmin$[ebp+8]
	faddp	ST(1), ST(0)
	fadd	DWORD PTR _d$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@planeBoxOv
	xor	eax, eax
	jmp	SHORT $LN8@planeBoxOv
$LN2@planeBoxOv:

; 91   :   if(DOT(normal,vmax)+d>=0.0f) return 1;

	mov	eax, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _vmax$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _vmax$[ebp+4]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _normal$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR _vmax$[ebp+8]
	faddp	ST(1), ST(0)
	fadd	DWORD PTR _d$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN1@planeBoxOv
	mov	eax, 1
	jmp	SHORT $LN8@planeBoxOv
$LN1@planeBoxOv:

; 92   :   
; 93   :   return 0;

	xor	eax, eax
$LN8@planeBoxOv:

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?planeBoxOverlap@ozcollide@@YAHPBMM0@Z ENDP		; ozcollide::planeBoxOverlap
_TEXT	ENDS
PUBLIC	?getIndex@Polygon@ozcollide@@QBEHH@Z		; ozcollide::Polygon::getIndex
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0Vec3f@ozcollide@@QAE@XZ			; ozcollide::Vec3f::Vec3f
PUBLIC	?testIntersectionTriBox@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVBox@1@@Z ; ozcollide::testIntersectionTriBox
; Function compile flags: /Odtp
_TEXT	SEGMENT
_ivert$6896 = -44					; size = 4
_i$6892 = -40						; size = 4
_pts$ = -36						; size = 36
__tri$ = 8						; size = 4
__pnts$ = 12						; size = 4
__box$ = 16						; size = 4
?testIntersectionTriBox@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVBox@1@@Z PROC ; ozcollide::testIntersectionTriBox

; 237  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 238  : 	Vec3f pts[3];

	push	OFFSET ??0Vec3f@ozcollide@@QAE@XZ	; ozcollide::Vec3f::Vec3f
	push	3
	push	12					; 0000000cH
	lea	eax, DWORD PTR _pts$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 239  : 	for (int i = 0;  i< 3; i++) {

	mov	DWORD PTR _i$6892[ebp], 0
	jmp	SHORT $LN3@testInters@2
$LN2@testInters@2:
	mov	ecx, DWORD PTR _i$6892[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$6892[ebp], ecx
$LN3@testInters@2:
	cmp	DWORD PTR _i$6892[ebp], 3
	jge	SHORT $LN1@testInters@2

; 240  : 		int ivert = _tri.getIndex(i);

	mov	edx, DWORD PTR _i$6892[ebp]
	push	edx
	mov	ecx, DWORD PTR __tri$[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _ivert$6896[ebp], eax

; 241  : 		pts[i] = _pnts[ivert];

	mov	eax, DWORD PTR _ivert$6896[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __pnts$[ebp]
	mov	ecx, DWORD PTR _i$6892[ebp]
	imul	ecx, 12					; 0000000cH
	lea	edx, DWORD PTR _pts$[ebp+ecx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 242  : 	}

	jmp	SHORT $LN2@testInters@2
$LN1@testInters@2:

; 243  : 	return testIntersectionTriBox(pts, _box);

	mov	ecx, DWORD PTR __box$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pts$[ebp]
	push	edx
	call	?testIntersectionTriBox@ozcollide@@YA_NPBVVec3f@1@ABVBox@1@@Z ; ozcollide::testIntersectionTriBox
	add	esp, 8

; 244  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?testIntersectionTriBox@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVBox@1@@Z ENDP ; ozcollide::testIntersectionTriBox
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
_TEXT	ENDS
;	COMDAT ??0Vec3f@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vec3f@ozcollide@@QAE@XZ PROC				; ozcollide::Vec3f::Vec3f, COMDAT
; _this$ = ecx

; 37   : 	ozinline Vec3f()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 	{
; 39   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vec3f@ozcollide@@QAE@XZ ENDP				; ozcollide::Vec3f::Vec3f
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\polygon.h
_TEXT	ENDS
;	COMDAT ?getIndex@Polygon@ozcollide@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?getIndex@Polygon@ozcollide@@QBEHH@Z PROC		; ozcollide::Polygon::getIndex, COMDAT
; _this$ = ecx

; 58   : 	ozinline int getIndex(int i) const { return indices_[i]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+4]
	mov	esp, ebp
	pop	ebp
	ret	4
?getIndex@Polygon@ozcollide@@QBEHH@Z ENDP		; ozcollide::Polygon::getIndex
_TEXT	ENDS
PUBLIC	??1Box@ozcollide@@QAE@XZ			; ozcollide::Box::~Box
PUBLIC	??0Vec3f@ozcollide@@QAE@MMM@Z			; ozcollide::Vec3f::Vec3f
PUBLIC	__real@00000000
PUBLIC	??0Box@ozcollide@@QAE@XZ			; ozcollide::Box::Box
PUBLIC	?mul@Matrix@ozcollide@@QBE?AVVec3f@2@ABV32@@Z	; ozcollide::Matrix::mul
PUBLIC	??ZVec3f@ozcollide@@QAEXABV01@@Z		; ozcollide::Vec3f::operator-=
PUBLIC	?recopyFrom3x3@Matrix@ozcollide@@QAEXABVMatrix3x3@2@@Z ; ozcollide::Matrix::recopyFrom3x3
PUBLIC	?identity@Matrix@ozcollide@@QAEXXZ		; ozcollide::Matrix::identity
PUBLIC	?testIntersectionTriOBB@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVOBB@1@@Z ; ozcollide::testIntersectionTriOBB
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT __real@00000000
; File i:\svnroot\client\sdk\ozcollide\intr_tribox.cpp
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?testIntersectionTriOBB@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVOBB@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?testIntersectionTriOBB@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVOBB@1@@Z$0
__ehfuncinfo$?testIntersectionTriOBB@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVOBB@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?testIntersectionTriOBB@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVOBB@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
$T7348 = -245						; size = 1
$T7347 = -244						; size = 12
_ivert$6910 = -232					; size = 4
_tr$6912 = -228						; size = 12
_pt$6911 = -216						; size = 12
_i$6906 = -204						; size = 4
_box$ = -200						; size = 24
_pts$ = -176						; size = 36
_mat$ = -140						; size = 64
_invMat$ = -76						; size = 64
__$EHRec$ = -12						; size = 12
__tri$ = 8						; size = 4
__pnts$ = 12						; size = 4
__obb$ = 16						; size = 4
?testIntersectionTriOBB@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVOBB@1@@Z PROC ; ozcollide::testIntersectionTriOBB

; 248  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?testIntersectionTriOBB@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVOBB@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 249  : 	Matrix mat, invMat;
; 250  : //	mat = _obb.matrix;
; 251  : 	mat.identity();

	lea	ecx, DWORD PTR _mat$[ebp]
	call	?identity@Matrix@ozcollide@@QAEXXZ	; ozcollide::Matrix::identity

; 252  : 	mat.recopyFrom3x3(_obb.matrix);

	mov	eax, DWORD PTR __obb$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _mat$[ebp]
	call	?recopyFrom3x3@Matrix@ozcollide@@QAEXABVMatrix3x3@2@@Z ; ozcollide::Matrix::recopyFrom3x3

; 253  : //	D3DXMatrixInverse(&invMat, NULL, &mat);
; 254  : 
; 255  : 
; 256  : 
; 257  : 	Vec3f pts[3];

	push	OFFSET ??0Vec3f@ozcollide@@QAE@XZ	; ozcollide::Vec3f::Vec3f
	push	3
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _pts$[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 258  : 	for (int i = 0; i < 3; i++) {

	mov	DWORD PTR _i$6906[ebp], 0
	jmp	SHORT $LN3@testInters@3
$LN2@testInters@3:
	mov	edx, DWORD PTR _i$6906[ebp]
	add	edx, 1
	mov	DWORD PTR _i$6906[ebp], edx
$LN3@testInters@3:
	cmp	DWORD PTR _i$6906[ebp], 3
	jge	$LN1@testInters@3

; 259  : 		int ivert = _tri.getIndex(i);

	mov	eax, DWORD PTR _i$6906[ebp]
	push	eax
	mov	ecx, DWORD PTR __tri$[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _ivert$6910[ebp], eax

; 260  : 		Vec3f pt = _pnts[ivert];

	mov	ecx, DWORD PTR _ivert$6910[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __pnts$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pt$6911[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _pt$6911[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _pt$6911[ebp+8], ecx

; 261  : 		pt -= _obb.center;

	mov	edx, DWORD PTR __obb$[ebp]
	push	edx
	lea	ecx, DWORD PTR _pt$6911[ebp]
	call	??ZVec3f@ozcollide@@QAEXABV01@@Z	; ozcollide::Vec3f::operator-=

; 262  : 
; 263  : 		Vec3f tr = invMat.mul(pt);

	lea	eax, DWORD PTR _pt$6911[ebp]
	push	eax
	lea	ecx, DWORD PTR _tr$6912[ebp]
	push	ecx
	lea	ecx, DWORD PTR _invMat$[ebp]
	call	?mul@Matrix@ozcollide@@QBE?AVVec3f@2@ABV32@@Z ; ozcollide::Matrix::mul

; 264  : 		pts[i] = tr;

	mov	edx, DWORD PTR _i$6906[ebp]
	imul	edx, 12					; 0000000cH
	lea	eax, DWORD PTR _pts$[ebp+edx]
	mov	ecx, DWORD PTR _tr$6912[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _tr$6912[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _tr$6912[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 265  : 	}

	jmp	$LN2@testInters@3
$LN1@testInters@3:

; 266  : 
; 267  : 	Box box;

	lea	ecx, DWORD PTR _box$[ebp]
	call	??0Box@ozcollide@@QAE@XZ		; ozcollide::Box::Box
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 268  : 	box.center = ZEROVEC3F;

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7347[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _box$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _box$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _box$[ebp+8], edx

; 269  : 	box.extent = _obb.extent;

	mov	eax, DWORD PTR __obb$[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _box$[ebp+12], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _box$[ebp+16], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _box$[ebp+20], eax

; 270  : 
; 271  : 	return testIntersectionTriBox(pts, box);

	lea	ecx, DWORD PTR _box$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pts$[ebp]
	push	edx
	call	?testIntersectionTriBox@ozcollide@@YA_NPBVVec3f@1@ABVBox@1@@Z ; ozcollide::testIntersectionTriBox
	add	esp, 8
	mov	BYTE PTR $T7348[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _box$[ebp]
	call	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
	mov	al, BYTE PTR $T7348[ebp]

; 272  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?testIntersectionTriOBB@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVOBB@1@@Z$0:
	lea	ecx, DWORD PTR _box$[ebp]
	jmp	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
__ehhandler$?testIntersectionTriOBB@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVOBB@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-240]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?testIntersectionTriOBB@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVOBB@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?testIntersectionTriOBB@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVOBB@1@@Z ENDP ; ozcollide::testIntersectionTriOBB
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
;	COMDAT ??0Vec3f@ozcollide@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
??0Vec3f@ozcollide@@QAE@MMM@Z PROC			; ozcollide::Vec3f::Vec3f, COMDAT
; _this$ = ecx

; 42   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR __x$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR __y$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR __z$[ebp]
	fstp	DWORD PTR [edx+8]

; 43   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vec3f@ozcollide@@QAE@MMM@Z ENDP			; ozcollide::Vec3f::Vec3f
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??ZVec3f@ozcollide@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__v$ = 8						; size = 4
??ZVec3f@ozcollide@@QAEXABV01@@Z PROC			; ozcollide::Vec3f::operator-=, COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 		x -= _v.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR __v$[ebp]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 60   : 		y -= _v.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __v$[ebp]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 61   : 		z -= _v.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __v$[ebp]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 62   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZVec3f@ozcollide@@QAEXABV01@@Z ENDP			; ozcollide::Vec3f::operator-=
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\box.h
_TEXT	ENDS
;	COMDAT ??0Box@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Box@ozcollide@@QAE@XZ PROC				; ozcollide::Box::Box, COMDAT
; _this$ = ecx

; 44   : 	ozinline Box()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f

; 45   : 	{
; 46   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Box@ozcollide@@QAE@XZ ENDP				; ozcollide::Box::Box
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1Box@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Box@ozcollide@@QAE@XZ PROC				; ozcollide::Box::~Box, COMDAT
; _this$ = ecx

; 53   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 54   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1Box@ozcollide@@QAE@XZ ENDP				; ozcollide::Box::~Box
_TEXT	ENDS
PUBLIC	__real@3f800000
;	COMDAT __real@3f800000
; File i:\svnroot\client\sdk\ozcollide\matrix.h
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?identity@Matrix@ozcollide@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?identity@Matrix@ozcollide@@QAEXXZ PROC			; ozcollide::Matrix::identity, COMDAT
; _this$ = ecx

; 60   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 		m_[0][0] = 1; m_[0][1] = 0; m_[0][2] = 0; m_[0][3] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+12]

; 62   : 		m_[1][0] = 0; m_[1][1] = 1; m_[1][2] = 0; m_[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+28]

; 63   : 		m_[2][0] = 0; m_[2][1] = 0; m_[2][2] = 1; m_[2][3] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+32]
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [ecx+40]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+44]

; 64   : 		m_[3][0] = 0; m_[3][1] = 0; m_[3][2] = 0; m_[3][3] = 1;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+48]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+56]
	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax+60]

; 65   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?identity@Matrix@ozcollide@@QAEXXZ ENDP			; ozcollide::Matrix::identity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?recopyFrom3x3@Matrix@ozcollide@@QAEXABVMatrix3x3@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$6707 = -8						; size = 4
_j$6703 = -4						; size = 4
__mat$ = 8						; size = 4
?recopyFrom3x3@Matrix@ozcollide@@QAEXABVMatrix3x3@2@@Z PROC ; ozcollide::Matrix::recopyFrom3x3, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 		for (int j = 0; j < 3; j++)

	mov	DWORD PTR _j$6703[ebp], 0
	jmp	SHORT $LN6@recopyFrom
$LN5@recopyFrom:
	mov	eax, DWORD PTR _j$6703[ebp]
	add	eax, 1
	mov	DWORD PTR _j$6703[ebp], eax
$LN6@recopyFrom:
	cmp	DWORD PTR _j$6703[ebp], 3
	jge	SHORT $LN4@recopyFrom

; 70   : 			for (int i = 0; i < 3; i++)

	mov	DWORD PTR _i$6707[ebp], 0
	jmp	SHORT $LN3@recopyFrom
$LN2@recopyFrom:
	mov	ecx, DWORD PTR _i$6707[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$6707[ebp], ecx
$LN3@recopyFrom:
	cmp	DWORD PTR _i$6707[ebp], 3
	jge	SHORT $LN1@recopyFrom

; 71   : 				m_[i][j] = _mat.m_[i][j];

	mov	edx, DWORD PTR _i$6707[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __mat$[ebp]
	mov	eax, DWORD PTR _i$6707[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _j$6703[ebp]
	mov	esi, DWORD PTR _j$6703[ebp]
	fld	DWORD PTR [edx+esi*4]
	fstp	DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN2@recopyFrom
$LN1@recopyFrom:
	jmp	SHORT $LN5@recopyFrom
$LN4@recopyFrom:

; 72   : 
; 73   : 		m_[3][0] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+48]

; 74   : 		m_[3][1] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+52]

; 75   : 		m_[3][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+56]

; 76   : 
; 77   : 		m_[0][3] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+12]

; 78   : 		m_[1][3] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+28]

; 79   : 		m_[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+44]

; 80   : 		m_[3][3] = 1;

	mov	edx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [edx+60]

; 81   : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?recopyFrom3x3@Matrix@ozcollide@@QAEXABVMatrix3x3@2@@Z ENDP ; ozcollide::Matrix::recopyFrom3x3
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?mul@Matrix@ozcollide@@QBE?AVVec3f@2@ABV32@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_p$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__pt$ = 12						; size = 4
?mul@Matrix@ozcollide@@QBE?AVVec3f@2@ABV32@@Z PROC	; ozcollide::Matrix::mul, COMDAT
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		Vec3f p;

	lea	ecx, DWORD PTR _p$[ebp]
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f

; 94   : 		p.x = _pt.x * m_[0][0] + _pt.y * m_[0][1] + _pt.z * m_[0][2] + m_[0][3];

	mov	eax, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+12]
	fstp	DWORD PTR _p$[ebp]

; 95   : 		p.y = _pt.x * m_[1][0] + _pt.y * m_[1][1] + _pt.z * m_[1][2] + m_[1][3];

	mov	ecx, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+16]
	mov	eax, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+20]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+24]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+28]
	fstp	DWORD PTR _p$[ebp+4]

; 96   : 		p.z = _pt.x * m_[2][0] + _pt.y * m_[2][1] + _pt.z * m_[2][2] + m_[2][3];

	mov	edx, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+36]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+40]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+44]
	fstp	DWORD PTR _p$[ebp+8]

; 97   : 		return p;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _p$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _p$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 98   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?mul@Matrix@ozcollide@@QBE?AVVec3f@2@ABV32@@Z ENDP	; ozcollide::Matrix::mul
_TEXT	ENDS
PUBLIC	?ext@Box@ozcollide@@QBEMH@Z			; ozcollide::Box::ext
PUBLIC	?dot@Vec3f@ozcollide@@QBEMABV12@@Z		; ozcollide::Vec3f::dot
PUBLIC	??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z		; ozcollide::Vec3f::operator|
PUBLIC	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z		; ozcollide::Vec3f::operator-
PUBLIC	?magic_testIntersectionTriBox@ozcollide@@YA_NQAPBVVec3f@1@ABVBox@1@@Z ; ozcollide::magic_testIntersectionTriBox
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\intr_tribox.cpp
_TEXT	SEGMENT
$T7390 = -236						; size = 12
$T7389 = -224						; size = 12
$T7388 = -212						; size = 12
$T7387 = -200						; size = 12
$T7386 = -188						; size = 12
$T7385 = -176						; size = 12
$T7384 = -164						; size = 12
$T7383 = -152						; size = 12
$T7382 = -140						; size = 12
$T7381 = -128						; size = 12
$T7380 = -116						; size = 12
$T7379 = -104						; size = 12
$T7378 = -92						; size = 12
_i1$6973 = -80						; size = 4
_i0$6969 = -76						; size = 4
_fDdC$6965 = -72					; size = 4
_i$6954 = -68						; size = 4
_akE$ = -64						; size = 36
_kD$ = -28						; size = 12
_fMax0$ = -16						; size = 4
_fMin0$ = -12						; size = 4
_fMax1$ = -8						; size = 4
_fMin1$ = -4						; size = 4
_apkTri$ = 8						; size = 4
_rkBox$ = 12						; size = 4
?magic_testIntersectionTriBox@ozcollide@@YA_NQAPBVVec3f@1@ABVBox@1@@Z PROC ; ozcollide::magic_testIntersectionTriBox

; 310  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH

; 311  : 	float fMin0, fMax0, fMin1, fMax1;
; 312  : 	Vec3f kD, akE[3];

	lea	ecx, DWORD PTR _kD$[ebp]
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f
	push	OFFSET ??0Vec3f@ozcollide@@QAE@XZ	; ozcollide::Vec3f::Vec3f
	push	3
	push	12					; 0000000cH
	lea	eax, DWORD PTR _akE$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 313  : 
; 314  : 	// test direction of triangle normal
; 315  : 	akE[0] = (*apkTri[1]) - (*apkTri[0]);

	mov	ecx, DWORD PTR _apkTri$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR $T7378[ebp]
	push	eax
	mov	ecx, DWORD PTR _apkTri$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _akE$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _akE$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _akE$[ebp+8], edx

; 316  : 	akE[1] = (*apkTri[2]) - (*apkTri[0]);

	mov	eax, DWORD PTR _apkTri$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T7379[ebp]
	push	edx
	mov	eax, DWORD PTR _apkTri$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _akE$[ebp+12], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _akE$[ebp+16], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _akE$[ebp+20], eax

; 317  : 	kD = akE[0] | akE[1];

	lea	ecx, DWORD PTR _akE$[ebp+12]
	push	ecx
	lea	edx, DWORD PTR $T7380[ebp]
	push	edx
	lea	ecx, DWORD PTR _akE$[ebp]
	call	??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator|
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _kD$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _kD$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _kD$[ebp+8], eax

; 318  : 	fMin0 = kD.dot(*apkTri[0]);

	mov	ecx, DWORD PTR _apkTri$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _kD$[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	fstp	DWORD PTR _fMin0$[ebp]

; 319  : 	fMax0 = fMin0;

	fld	DWORD PTR _fMin0$[ebp]
	fstp	DWORD PTR _fMax0$[ebp]

; 320  : 	projectBox(kD, rkBox, fMin1, fMax1);

	lea	eax, DWORD PTR _fMax1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fMin1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rkBox$[ebp]
	push	edx
	lea	eax, DWORD PTR _kD$[ebp]
	push	eax
	call	?projectBox@ozcollide@@YAXABVVec3f@1@ABVBox@1@AAM2@Z ; ozcollide::projectBox
	add	esp, 16					; 00000010H

; 321  : 	if ( fMax1 < fMin0 || fMax0 < fMin1 )

	fld	DWORD PTR _fMax1$[ebp]
	fld	DWORD PTR _fMin0$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN22@magic_test
	fld	DWORD PTR _fMax0$[ebp]
	fld	DWORD PTR _fMin1$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN23@magic_test
$LN22@magic_test:

; 322  : 		return false;

	xor	al, al
	jmp	$LN24@magic_test
$LN23@magic_test:

; 323  : 
; 324  : 	// test direction of box faces
; 325  : 	for (int i = 0; i < 3; i++) {

	mov	DWORD PTR _i$6954[ebp], 0
	jmp	SHORT $LN21@magic_test
$LN20@magic_test:
	mov	ecx, DWORD PTR _i$6954[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$6954[ebp], ecx
$LN21@magic_test:
	cmp	DWORD PTR _i$6954[ebp], 3
	jge	$LN19@magic_test

; 326  : 		if (i == 0) kD = Vec3f(1, 0, 0);

	cmp	DWORD PTR _i$6954[ebp], 0
	jne	SHORT $LN18@magic_test
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7381[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _kD$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _kD$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _kD$[ebp+8], edx
	jmp	SHORT $LN15@magic_test
$LN18@magic_test:

; 327  : 		else if (i == 1) kD = Vec3f(0, 1, 0);

	cmp	DWORD PTR _i$6954[ebp], 1
	jne	SHORT $LN16@magic_test
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7382[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _kD$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _kD$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _kD$[ebp+8], eax
	jmp	SHORT $LN15@magic_test
$LN16@magic_test:

; 328  : 		else kD = Vec3f(0, 0, 1);

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7383[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _kD$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _kD$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _kD$[ebp+8], eax
$LN15@magic_test:

; 329  : 
; 330  : 		projectTriangle(kD, apkTri, fMin0, fMax0);

	lea	ecx, DWORD PTR _fMax0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _fMin0$[ebp]
	push	edx
	mov	eax, DWORD PTR _apkTri$[ebp]
	push	eax
	lea	ecx, DWORD PTR _kD$[ebp]
	push	ecx
	call	?projectTriangle@ozcollide@@YAXABVVec3f@1@QAPBV21@AAM2@Z ; ozcollide::projectTriangle
	add	esp, 16					; 00000010H

; 331  : 		float fDdC = kD.dot(rkBox.center);

	mov	edx, DWORD PTR _rkBox$[ebp]
	push	edx
	lea	ecx, DWORD PTR _kD$[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	fstp	DWORD PTR _fDdC$6965[ebp]

; 332  : 		fMin1 = fDdC - rkBox.ext(i);

	mov	eax, DWORD PTR _i$6954[ebp]
	push	eax
	mov	ecx, DWORD PTR _rkBox$[ebp]
	call	?ext@Box@ozcollide@@QBEMH@Z		; ozcollide::Box::ext
	fsubr	DWORD PTR _fDdC$6965[ebp]
	fstp	DWORD PTR _fMin1$[ebp]

; 333  : 		fMax1 = fDdC + rkBox.ext(i);

	mov	ecx, DWORD PTR _i$6954[ebp]
	push	ecx
	mov	ecx, DWORD PTR _rkBox$[ebp]
	call	?ext@Box@ozcollide@@QBEMH@Z		; ozcollide::Box::ext
	fadd	DWORD PTR _fDdC$6965[ebp]
	fstp	DWORD PTR _fMax1$[ebp]

; 334  : 		if (fMax1 < fMin0 || fMax0 < fMin1)

	fld	DWORD PTR _fMax1$[ebp]
	fld	DWORD PTR _fMin0$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN13@magic_test
	fld	DWORD PTR _fMax0$[ebp]
	fld	DWORD PTR _fMin1$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN14@magic_test
$LN13@magic_test:

; 335  : 			return false;

	xor	al, al
	jmp	$LN24@magic_test
$LN14@magic_test:

; 336  : 	}

	jmp	$LN20@magic_test
$LN19@magic_test:

; 337  : 
; 338  : 	// test direction of triangle-box edge cross products
; 339  : 	akE[2] = akE[1] - akE[0];

	lea	edx, DWORD PTR _akE$[ebp]
	push	edx
	lea	eax, DWORD PTR $T7384[ebp]
	push	eax
	lea	ecx, DWORD PTR _akE$[ebp+12]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _akE$[ebp+24], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _akE$[ebp+28], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _akE$[ebp+32], eax

; 340  : 	for (int i0 = 0; i0 < 3; i0++) {

	mov	DWORD PTR _i0$6969[ebp], 0
	jmp	SHORT $LN12@magic_test
$LN11@magic_test:
	mov	ecx, DWORD PTR _i0$6969[ebp]
	add	ecx, 1
	mov	DWORD PTR _i0$6969[ebp], ecx
$LN12@magic_test:
	cmp	DWORD PTR _i0$6969[ebp], 3
	jge	$LN10@magic_test

; 341  : 		for (int i1 = 0; i1 < 3; i1++) {

	mov	DWORD PTR _i1$6973[ebp], 0
	jmp	SHORT $LN9@magic_test
$LN8@magic_test:
	mov	edx, DWORD PTR _i1$6973[ebp]
	add	edx, 1
	mov	DWORD PTR _i1$6973[ebp], edx
$LN9@magic_test:
	cmp	DWORD PTR _i1$6973[ebp], 3
	jge	$LN7@magic_test

; 342  : 			if (i1 == 0) kD = akE[i0] | Vec3f(1, 0, 0);

	cmp	DWORD PTR _i1$6973[ebp], 0
	jne	SHORT $LN6@magic_test
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7385[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	lea	eax, DWORD PTR $T7386[ebp]
	push	eax
	mov	ecx, DWORD PTR _i0$6969[ebp]
	imul	ecx, 12					; 0000000cH
	lea	ecx, DWORD PTR _akE$[ebp+ecx]
	call	??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator|
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _kD$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _kD$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _kD$[ebp+8], edx
	jmp	$LN3@magic_test
$LN6@magic_test:

; 343  : 			else if (i1 == 1) kD = akE[i0] | Vec3f(0, 1, 0);

	cmp	DWORD PTR _i1$6973[ebp], 1
	jne	SHORT $LN4@magic_test
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7387[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	lea	eax, DWORD PTR $T7388[ebp]
	push	eax
	mov	ecx, DWORD PTR _i0$6969[ebp]
	imul	ecx, 12					; 0000000cH
	lea	ecx, DWORD PTR _akE$[ebp+ecx]
	call	??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator|
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _kD$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _kD$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _kD$[ebp+8], edx
	jmp	SHORT $LN3@magic_test
$LN4@magic_test:

; 344  : 			else kD = akE[i0] | Vec3f(0, 0, 1);

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7389[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	lea	eax, DWORD PTR $T7390[ebp]
	push	eax
	mov	ecx, DWORD PTR _i0$6969[ebp]
	imul	ecx, 12					; 0000000cH
	lea	ecx, DWORD PTR _akE$[ebp+ecx]
	call	??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator|
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _kD$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _kD$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _kD$[ebp+8], edx
$LN3@magic_test:

; 345  : 			projectTriangle(kD, apkTri, fMin0, fMax0);

	lea	eax, DWORD PTR _fMax0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fMin0$[ebp]
	push	ecx
	mov	edx, DWORD PTR _apkTri$[ebp]
	push	edx
	lea	eax, DWORD PTR _kD$[ebp]
	push	eax
	call	?projectTriangle@ozcollide@@YAXABVVec3f@1@QAPBV21@AAM2@Z ; ozcollide::projectTriangle
	add	esp, 16					; 00000010H

; 346  : 			projectBox(kD, rkBox, fMin1,fMax1);

	lea	ecx, DWORD PTR _fMax1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _fMin1$[ebp]
	push	edx
	mov	eax, DWORD PTR _rkBox$[ebp]
	push	eax
	lea	ecx, DWORD PTR _kD$[ebp]
	push	ecx
	call	?projectBox@ozcollide@@YAXABVVec3f@1@ABVBox@1@AAM2@Z ; ozcollide::projectBox
	add	esp, 16					; 00000010H

; 347  : 			if (fMax1 < fMin0 || fMax0 < fMin1)

	fld	DWORD PTR _fMax1$[ebp]
	fld	DWORD PTR _fMin0$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN1@magic_test
	fld	DWORD PTR _fMax0$[ebp]
	fld	DWORD PTR _fMin1$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@magic_test
$LN1@magic_test:

; 348  : 				return false;

	xor	al, al
	jmp	SHORT $LN24@magic_test
$LN2@magic_test:

; 349  : 		}

	jmp	$LN8@magic_test
$LN7@magic_test:

; 350  : 	}

	jmp	$LN11@magic_test
$LN10@magic_test:

; 351  :     return true;

	mov	al, 1
$LN24@magic_test:

; 352  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?magic_testIntersectionTriBox@ozcollide@@YA_NQAPBVVec3f@1@ABVBox@1@@Z ENDP ; ozcollide::magic_testIntersectionTriBox
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
_TEXT	ENDS
;	COMDAT ??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
tv92 = -16						; size = 4
tv89 = -12						; size = 4
tv86 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__v$ = 12						; size = 4
??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z PROC		; ozcollide::Vec3f::operator-, COMDAT
; _this$ = ecx

; 94   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 		return Vec3f(x - _v.x, y - _v.y, z - _v.z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __v$[ebp]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __v$[ebp]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR __v$[ebp]
	fsub	DWORD PTR [edx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 96   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z ENDP		; ozcollide::Vec3f::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
tv146 = -16						; size = 4
tv141 = -12						; size = 4
tv136 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__d$ = 12						; size = 4
??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z PROC		; ozcollide::Vec3f::operator|, COMDAT
; _this$ = ecx

; 125  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 126  : 		return Vec3f(y * _d.z - z * _d.y,
; 127  : 			z * _d.x - x * _d.z,
; 128  : 			x * _d.y - y * _d.x);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv136[ebp]
	fld	DWORD PTR tv136[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv141[ebp]
	fld	DWORD PTR tv141[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [edx+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv146[ebp]
	fld	DWORD PTR tv146[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 129  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z ENDP		; ozcollide::Vec3f::operator|
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dot@Vec3f@ozcollide@@QBEMABV12@@Z
_TEXT	SEGMENT
tv86 = -8						; size = 4
_this$ = -4						; size = 4
__v$ = 8						; size = 4
?dot@Vec3f@ozcollide@@QBEMABV12@@Z PROC			; ozcollide::Vec3f::dot, COMDAT
; _this$ = ecx

; 163  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 		return x * _v.x + y * _v.y + z * _v.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR __v$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __v$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __v$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]

; 165  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?dot@Vec3f@ozcollide@@QBEMABV12@@Z ENDP			; ozcollide::Vec3f::dot
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\box.h
_TEXT	ENDS
;	COMDAT ?ext@Box@ozcollide@@QBEMH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?ext@Box@ozcollide@@QBEMH@Z PROC			; ozcollide::Box::ext, COMDAT
; _this$ = ecx

; 179  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 		if (i == 0) return extent.x;

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN3@ext
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	jmp	SHORT $LN4@ext
	jmp	SHORT $LN1@ext
$LN3@ext:

; 181  : 		else if (i == 1) return extent.y;

	cmp	DWORD PTR _i$[ebp], 1
	jne	SHORT $LN1@ext
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+16]
	jmp	SHORT $LN4@ext
$LN1@ext:

; 182  : 		return extent.z;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+20]
$LN4@ext:

; 183  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?ext@Box@ozcollide@@QBEMH@Z ENDP			; ozcollide::Box::ext
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\intr_tribox.cpp
_TEXT	ENDS
_TEXT	SEGMENT
_fDot$ = -4						; size = 4
_rkD$ = 8						; size = 4
_apkTri$ = 12						; size = 4
_rfMin$ = 16						; size = 4
_rfMax$ = 20						; size = 4
?projectTriangle@ozcollide@@YAXABVVec3f@1@QAPBV21@AAM2@Z PROC ; ozcollide::projectTriangle

; 278  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 279  : 	rfMin = rkD.dot(*apkTri[0]);

	mov	eax, DWORD PTR _apkTri$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _rkD$[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	mov	edx, DWORD PTR _rfMin$[ebp]
	fstp	DWORD PTR [edx]

; 280  : 	rfMax = rfMin;

	mov	eax, DWORD PTR _rfMax$[ebp]
	mov	ecx, DWORD PTR _rfMin$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 281  : 
; 282  : 	float fDot = rkD.dot(*apkTri[1]);

	mov	edx, DWORD PTR _apkTri$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _rkD$[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	fstp	DWORD PTR _fDot$[ebp]

; 283  : 	if ( fDot < rfMin )

	fld	DWORD PTR _fDot$[ebp]
	mov	ecx, DWORD PTR _rfMin$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN6@projectTri

; 284  : 		rfMin = fDot;

	mov	edx, DWORD PTR _rfMin$[ebp]
	fld	DWORD PTR _fDot$[ebp]
	fstp	DWORD PTR [edx]
	jmp	SHORT $LN4@projectTri
$LN6@projectTri:

; 285  : 	else if ( fDot > rfMax )

	fld	DWORD PTR _fDot$[ebp]
	mov	eax, DWORD PTR _rfMax$[ebp]
	fld	DWORD PTR [eax]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@projectTri

; 286  : 		rfMax = fDot;

	mov	ecx, DWORD PTR _rfMax$[ebp]
	fld	DWORD PTR _fDot$[ebp]
	fstp	DWORD PTR [ecx]
$LN4@projectTri:

; 287  : 
; 288  : 	fDot = rkD.dot(*apkTri[2]);

	mov	edx, DWORD PTR _apkTri$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _rkD$[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	fstp	DWORD PTR _fDot$[ebp]

; 289  : 	if ( fDot < rfMin )

	fld	DWORD PTR _fDot$[ebp]
	mov	ecx, DWORD PTR _rfMin$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@projectTri

; 290  : 		rfMin = fDot;

	mov	edx, DWORD PTR _rfMin$[ebp]
	fld	DWORD PTR _fDot$[ebp]
	fstp	DWORD PTR [edx]
	jmp	SHORT $LN1@projectTri
$LN3@projectTri:

; 291  : 	else if ( fDot > rfMax )

	fld	DWORD PTR _fDot$[ebp]
	mov	eax, DWORD PTR _rfMax$[ebp]
	fld	DWORD PTR [eax]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@projectTri

; 292  : 		rfMax = fDot;

	mov	ecx, DWORD PTR _rfMax$[ebp]
	fld	DWORD PTR _fDot$[ebp]
	fstp	DWORD PTR [ecx]
$LN1@projectTri:

; 293  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?projectTriangle@ozcollide@@YAXABVVec3f@1@QAPBV21@AAM2@Z ENDP ; ozcollide::projectTriangle
; Function compile flags: /Odtp
tv164 = -24						; size = 8
tv162 = -16						; size = 8
_fDdC$ = -8						; size = 4
_fR$ = -4						; size = 4
_rkD$ = 8						; size = 4
_rkBox$ = 12						; size = 4
_rfMin$ = 16						; size = 4
_rfMax$ = 20						; size = 4
?projectBox@ozcollide@@YAXABVVec3f@1@ABVBox@1@AAM2@Z PROC ; ozcollide::projectBox

; 299  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 300  : 	float fDdC = rkD.dot(rkBox.center);

	mov	eax, DWORD PTR _rkBox$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rkD$[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	fstp	DWORD PTR _fDdC$[ebp]

; 301  : 	float fR =
; 302  : 		rkBox.extent.x * fabsf(rkD.x) +
; 303  : 		rkBox.extent.y * fabsf(rkD.y) +
; 304  : 		rkBox.extent.z * fabsf(rkD.z);

	mov	ecx, DWORD PTR _rkD$[ebp]
	push	ecx
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	mov	edx, DWORD PTR _rkBox$[ebp]
	fmul	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _rkD$[ebp]
	push	ecx
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [esp]
	fstp	QWORD PTR tv162[ebp]
	call	_fabsf
	add	esp, 4
	mov	ecx, DWORD PTR _rkBox$[ebp]
	fmul	DWORD PTR [ecx+16]
	fadd	QWORD PTR tv162[ebp]
	mov	edx, DWORD PTR _rkD$[ebp]
	push	ecx
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [esp]
	fstp	QWORD PTR tv164[ebp]
	call	_fabsf
	add	esp, 4
	mov	eax, DWORD PTR _rkBox$[ebp]
	fmul	DWORD PTR [eax+20]
	fadd	QWORD PTR tv164[ebp]
	fstp	DWORD PTR _fR$[ebp]

; 305  : 	rfMin = fDdC - fR;

	fld	DWORD PTR _fDdC$[ebp]
	fsub	DWORD PTR _fR$[ebp]
	mov	ecx, DWORD PTR _rfMin$[ebp]
	fstp	DWORD PTR [ecx]

; 306  : 	rfMax = fDdC + fR;

	fld	DWORD PTR _fDdC$[ebp]
	fadd	DWORD PTR _fR$[ebp]
	mov	edx, DWORD PTR _rfMax$[ebp]
	fstp	DWORD PTR [edx]

; 307  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?projectBox@ozcollide@@YAXABVVec3f@1@ABVBox@1@AAM2@Z ENDP ; ozcollide::projectBox
_TEXT	ENDS
PUBLIC	__real@7f7fffff
PUBLIC	?magic_testIntersectionTriBox@ozcollide@@YA_NQAPBVVec3f@1@ABVBox@1@ABV21@MAAM3@Z ; ozcollide::magic_testIntersectionTriBox
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+038
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
$T7414 = -252						; size = 12
$T7413 = -240						; size = 12
$T7412 = -228						; size = 12
$T7411 = -216						; size = 12
$T7410 = -204						; size = 12
$T7409 = -192						; size = 12
$T7408 = -180						; size = 12
$T7407 = -168						; size = 12
$T7406 = -156						; size = 12
$T7405 = -144						; size = 12
$T7404 = -132						; size = 12
$T7403 = -120						; size = 12
$T7402 = -108						; size = 12
_i1$7061 = -96						; size = 4
_i0$7057 = -92						; size = 4
_fDdC$7054 = -88					; size = 4
_i$7043 = -84						; size = 4
_akE$ = -80						; size = 36
_kD$ = -44						; size = 12
_fMax0$ = -32						; size = 4
_fMin0$ = -28						; size = 4
_fMax1$ = -24						; size = 4
_fSpeed$ = -20						; size = 4
_fMin1$ = -16						; size = 4
_kW$ = -12						; size = 12
_apkTri$ = 8						; size = 4
_rkBox$ = 12						; size = 4
_rkBoxVel$ = 16						; size = 4
_fTMax$ = 20						; size = 4
_rfTFirst$ = 24						; size = 4
_rfTLast$ = 28						; size = 4
?magic_testIntersectionTriBox@ozcollide@@YA_NQAPBVVec3f@1@ABVBox@1@ABV21@MAAM3@Z PROC ; ozcollide::magic_testIntersectionTriBox

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH

; 432  : 	float fMin0, fMax0, fMin1, fMax1, fSpeed;
; 433  : 	Vec3f kD, akE[3];

	lea	ecx, DWORD PTR _kD$[ebp]
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f
	push	OFFSET ??0Vec3f@ozcollide@@QAE@XZ	; ozcollide::Vec3f::Vec3f
	push	3
	push	12					; 0000000cH
	lea	eax, DWORD PTR _akE$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 434  : 
; 435  : 	Vec3f kW = rkBoxVel;

	mov	ecx, DWORD PTR _rkBoxVel$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _kW$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _kW$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _kW$[ebp+8], ecx

; 436  : 	rfTFirst = 0.0f;

	mov	edx, DWORD PTR _rfTFirst$[ebp]
	fldz
	fstp	DWORD PTR [edx]

; 437  : 	rfTLast = FLT_MAX;

	mov	eax, DWORD PTR _rfTLast$[ebp]
	fld	DWORD PTR __real@7f7fffff
	fstp	DWORD PTR [eax]

; 438  : 
; 439  : 	// test direction of triangle normal
; 440  : 	akE[0] = (*apkTri[1]) - (*apkTri[0]);

	mov	ecx, DWORD PTR _apkTri$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR $T7402[ebp]
	push	eax
	mov	ecx, DWORD PTR _apkTri$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _akE$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _akE$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _akE$[ebp+8], edx

; 441  : 	akE[1] = (*apkTri[2]) - (*apkTri[0]);

	mov	eax, DWORD PTR _apkTri$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T7403[ebp]
	push	edx
	mov	eax, DWORD PTR _apkTri$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _akE$[ebp+12], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _akE$[ebp+16], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _akE$[ebp+20], eax

; 442  : 	kD = akE[0] | akE[1];

	lea	ecx, DWORD PTR _akE$[ebp+12]
	push	ecx
	lea	edx, DWORD PTR $T7404[ebp]
	push	edx
	lea	ecx, DWORD PTR _akE$[ebp]
	call	??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator|
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _kD$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _kD$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _kD$[ebp+8], eax

; 443  : 	fMin0 = kD.dot(*apkTri[0]);

	mov	ecx, DWORD PTR _apkTri$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _kD$[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	fstp	DWORD PTR _fMin0$[ebp]

; 444  : 	fMax0 = fMin0;

	fld	DWORD PTR _fMin0$[ebp]
	fstp	DWORD PTR _fMax0$[ebp]

; 445  : 	projectBox(kD, rkBox, fMin1, fMax1);

	lea	eax, DWORD PTR _fMax1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fMin1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rkBox$[ebp]
	push	edx
	lea	eax, DWORD PTR _kD$[ebp]
	push	eax
	call	?projectBox@ozcollide@@YAXABVVec3f@1@ABVBox@1@AAM2@Z ; ozcollide::projectBox
	add	esp, 16					; 00000010H

; 446  : 	fSpeed = kD.dot(kW);

	lea	ecx, DWORD PTR _kW$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _kD$[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	fstp	DWORD PTR _fSpeed$[ebp]

; 447  : 	if (noIntersect(fTMax, fSpeed, fMin0, fMax0, fMin1, fMax1, rfTFirst, rfTLast))

	mov	edx, DWORD PTR _rfTLast$[ebp]
	push	edx
	mov	eax, DWORD PTR _rfTFirst$[ebp]
	push	eax
	push	ecx
	fld	DWORD PTR _fMax1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fMin1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fMax0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fMin0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fSpeed$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fTMax$[ebp]
	fstp	DWORD PTR [esp]
	call	?noIntersect@ozcollide@@YA_NMMMMMMAAM0@Z ; ozcollide::noIntersect
	add	esp, 32					; 00000020H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@magic_test@2

; 448  : 		return false;

	xor	al, al
	jmp	$LN21@magic_test@2
$LN20@magic_test@2:

; 449  : 
; 450  : 	// test direction of box faces
; 451  : 	for (int i = 0; i < 3; i++) {

	mov	DWORD PTR _i$7043[ebp], 0
	jmp	SHORT $LN19@magic_test@2
$LN18@magic_test@2:
	mov	edx, DWORD PTR _i$7043[ebp]
	add	edx, 1
	mov	DWORD PTR _i$7043[ebp], edx
$LN19@magic_test@2:
	cmp	DWORD PTR _i$7043[ebp], 3
	jge	$LN17@magic_test@2

; 452  : 		if (i == 0) kD = Vec3f(1, 0, 0);

	cmp	DWORD PTR _i$7043[ebp], 0
	jne	SHORT $LN16@magic_test@2
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7405[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _kD$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _kD$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _kD$[ebp+8], eax
	jmp	SHORT $LN13@magic_test@2
$LN16@magic_test@2:

; 453  : 		else if (i == 1) kD = Vec3f(0, 1, 0);

	cmp	DWORD PTR _i$7043[ebp], 1
	jne	SHORT $LN14@magic_test@2
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7406[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _kD$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _kD$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _kD$[ebp+8], eax
	jmp	SHORT $LN13@magic_test@2
$LN14@magic_test@2:

; 454  : 		else kD = Vec3f(0, 0, 1);

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7407[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _kD$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _kD$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _kD$[ebp+8], eax
$LN13@magic_test@2:

; 455  : 
; 456  : 		projectTriangle(kD, apkTri, fMin0, fMax0);

	lea	ecx, DWORD PTR _fMax0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _fMin0$[ebp]
	push	edx
	mov	eax, DWORD PTR _apkTri$[ebp]
	push	eax
	lea	ecx, DWORD PTR _kD$[ebp]
	push	ecx
	call	?projectTriangle@ozcollide@@YAXABVVec3f@1@QAPBV21@AAM2@Z ; ozcollide::projectTriangle
	add	esp, 16					; 00000010H

; 457  : 		float fDdC = kD.dot(rkBox.center);

	mov	edx, DWORD PTR _rkBox$[ebp]
	push	edx
	lea	ecx, DWORD PTR _kD$[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	fstp	DWORD PTR _fDdC$7054[ebp]

; 458  : 		fMin1 = fDdC - rkBox.ext(i);

	mov	eax, DWORD PTR _i$7043[ebp]
	push	eax
	mov	ecx, DWORD PTR _rkBox$[ebp]
	call	?ext@Box@ozcollide@@QBEMH@Z		; ozcollide::Box::ext
	fsubr	DWORD PTR _fDdC$7054[ebp]
	fstp	DWORD PTR _fMin1$[ebp]

; 459  : 		fMax1 = fDdC + rkBox.ext(i);

	mov	ecx, DWORD PTR _i$7043[ebp]
	push	ecx
	mov	ecx, DWORD PTR _rkBox$[ebp]
	call	?ext@Box@ozcollide@@QBEMH@Z		; ozcollide::Box::ext
	fadd	DWORD PTR _fDdC$7054[ebp]
	fstp	DWORD PTR _fMax1$[ebp]

; 460  : 		fSpeed = kD.dot(kW);

	lea	edx, DWORD PTR _kW$[ebp]
	push	edx
	lea	ecx, DWORD PTR _kD$[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	fstp	DWORD PTR _fSpeed$[ebp]

; 461  : 		if (noIntersect(fTMax, fSpeed, fMin0, fMax0, fMin1, fMax1, rfTFirst, rfTLast) )

	mov	eax, DWORD PTR _rfTLast$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rfTFirst$[ebp]
	push	ecx
	push	ecx
	fld	DWORD PTR _fMax1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fMin1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fMax0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fMin0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fSpeed$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fTMax$[ebp]
	fstp	DWORD PTR [esp]
	call	?noIntersect@ozcollide@@YA_NMMMMMMAAM0@Z ; ozcollide::noIntersect
	add	esp, 32					; 00000020H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN12@magic_test@2

; 462  :             return false;

	xor	al, al
	jmp	$LN21@magic_test@2
$LN12@magic_test@2:

; 463  :     }

	jmp	$LN18@magic_test@2
$LN17@magic_test@2:

; 464  : 
; 465  : 	// test direction of triangle-box edge cross products
; 466  : 	akE[2] = akE[1] - akE[0];

	lea	eax, DWORD PTR _akE$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T7408[ebp]
	push	ecx
	lea	ecx, DWORD PTR _akE$[ebp+12]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _akE$[ebp+24], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _akE$[ebp+28], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _akE$[ebp+32], edx

; 467  : 	for (int i0 = 0; i0 < 3; i0++) {

	mov	DWORD PTR _i0$7057[ebp], 0
	jmp	SHORT $LN11@magic_test@2
$LN10@magic_test@2:
	mov	eax, DWORD PTR _i0$7057[ebp]
	add	eax, 1
	mov	DWORD PTR _i0$7057[ebp], eax
$LN11@magic_test@2:
	cmp	DWORD PTR _i0$7057[ebp], 3
	jge	$LN9@magic_test@2

; 468  : 		for (int i1 = 0; i1 < 3; i1++) {

	mov	DWORD PTR _i1$7061[ebp], 0
	jmp	SHORT $LN8@magic_test@2
$LN7@magic_test@2:
	mov	ecx, DWORD PTR _i1$7061[ebp]
	add	ecx, 1
	mov	DWORD PTR _i1$7061[ebp], ecx
$LN8@magic_test@2:
	cmp	DWORD PTR _i1$7061[ebp], 3
	jge	$LN6@magic_test@2

; 469  : 			if (i1 == 0) kD = akE[i0] | Vec3f(1, 0, 0);

	cmp	DWORD PTR _i1$7061[ebp], 0
	jne	SHORT $LN5@magic_test@2
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7409[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	lea	edx, DWORD PTR $T7410[ebp]
	push	edx
	mov	eax, DWORD PTR _i0$7057[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _akE$[ebp+eax]
	call	??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator|
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _kD$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _kD$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _kD$[ebp+8], eax
	jmp	$LN2@magic_test@2
$LN5@magic_test@2:

; 470  : 			else if (i1 == 1) kD = akE[i0] | Vec3f(0, 1, 0);

	cmp	DWORD PTR _i1$7061[ebp], 1
	jne	SHORT $LN3@magic_test@2
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7411[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	lea	ecx, DWORD PTR $T7412[ebp]
	push	ecx
	mov	edx, DWORD PTR _i0$7057[ebp]
	imul	edx, 12					; 0000000cH
	lea	ecx, DWORD PTR _akE$[ebp+edx]
	call	??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator|
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _kD$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _kD$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _kD$[ebp+8], eax
	jmp	SHORT $LN2@magic_test@2
$LN3@magic_test@2:

; 471  : 			else kD = akE[i0] | Vec3f(0, 0, 1);

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7413[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	lea	ecx, DWORD PTR $T7414[ebp]
	push	ecx
	mov	edx, DWORD PTR _i0$7057[ebp]
	imul	edx, 12					; 0000000cH
	lea	ecx, DWORD PTR _akE$[ebp+edx]
	call	??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator|
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _kD$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _kD$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _kD$[ebp+8], eax
$LN2@magic_test@2:

; 472  : 
; 473  : 			projectTriangle(kD, apkTri, fMin0, fMax0);

	lea	ecx, DWORD PTR _fMax0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _fMin0$[ebp]
	push	edx
	mov	eax, DWORD PTR _apkTri$[ebp]
	push	eax
	lea	ecx, DWORD PTR _kD$[ebp]
	push	ecx
	call	?projectTriangle@ozcollide@@YAXABVVec3f@1@QAPBV21@AAM2@Z ; ozcollide::projectTriangle
	add	esp, 16					; 00000010H

; 474  : 			projectBox(kD, rkBox, fMin1, fMax1);

	lea	edx, DWORD PTR _fMax1$[ebp]
	push	edx
	lea	eax, DWORD PTR _fMin1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rkBox$[ebp]
	push	ecx
	lea	edx, DWORD PTR _kD$[ebp]
	push	edx
	call	?projectBox@ozcollide@@YAXABVVec3f@1@ABVBox@1@AAM2@Z ; ozcollide::projectBox
	add	esp, 16					; 00000010H

; 475  : 			fSpeed = kD.dot(kW);

	lea	eax, DWORD PTR _kW$[ebp]
	push	eax
	lea	ecx, DWORD PTR _kD$[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	fstp	DWORD PTR _fSpeed$[ebp]

; 476  : 			if (noIntersect(fTMax, fSpeed, fMin0, fMax0, fMin1, fMax1, rfTFirst, rfTLast) )

	mov	ecx, DWORD PTR _rfTLast$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rfTFirst$[ebp]
	push	edx
	push	ecx
	fld	DWORD PTR _fMax1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fMin1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fMax0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fMin0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fSpeed$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fTMax$[ebp]
	fstp	DWORD PTR [esp]
	call	?noIntersect@ozcollide@@YA_NMMMMMMAAM0@Z ; ozcollide::noIntersect
	add	esp, 32					; 00000020H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@magic_test@2

; 477  : 				return false;

	xor	al, al
	jmp	SHORT $LN21@magic_test@2
$LN1@magic_test@2:

; 478  : 		}

	jmp	$LN7@magic_test@2
$LN6@magic_test@2:

; 479  : 	}

	jmp	$LN10@magic_test@2
$LN9@magic_test@2:

; 480  : 
; 481  : 	return true;

	mov	al, 1
$LN21@magic_test@2:

; 482  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?magic_testIntersectionTriBox@ozcollide@@YA_NQAPBVVec3f@1@ABVBox@1@ABV21@MAAM3@Z ENDP ; ozcollide::magic_testIntersectionTriBox
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
_fT$ = -8						; size = 4
_fInvSpeed$ = -4					; size = 4
_fTMax$ = 8						; size = 4
_fSpeed$ = 12						; size = 4
_fMin0$ = 16						; size = 4
_fMax0$ = 20						; size = 4
_fMin1$ = 24						; size = 4
_fMax1$ = 28						; size = 4
_rfTFirst$ = 32						; size = 4
_rfTLast$ = 36						; size = 4
?noIntersect@ozcollide@@YA_NMMMMMMAAM0@Z PROC		; ozcollide::noIntersect

; 362  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 363  : 	float fInvSpeed, fT;
; 364  : 
; 365  : 	if (fMax1 < fMin0) {  // C1 initially on left of C0

	fld	DWORD PTR _fMax1$[ebp]
	fld	DWORD PTR _fMin0$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN21@noIntersec

; 366  : 		if (fSpeed <= 0.0f) {

	fld	DWORD PTR _fSpeed$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN20@noIntersec

; 367  : 			// intervals moving apart
; 368  : 			return true;

	mov	al, 1
	jmp	$LN22@noIntersec
$LN20@noIntersec:

; 369  : 		}
; 370  : 
; 371  : 		fInvSpeed = 1.0f / fSpeed;

	fld	DWORD PTR _fSpeed$[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _fInvSpeed$[ebp]

; 372  : 
; 373  : 		fT = (fMin0 - fMax1) * fInvSpeed;

	fld	DWORD PTR _fMin0$[ebp]
	fsub	DWORD PTR _fMax1$[ebp]
	fmul	DWORD PTR _fInvSpeed$[ebp]
	fstp	DWORD PTR _fT$[ebp]

; 374  : 		if (fT > rfTFirst)

	fld	DWORD PTR _fT$[ebp]
	mov	eax, DWORD PTR _rfTFirst$[ebp]
	fld	DWORD PTR [eax]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN19@noIntersec

; 375  : 			rfTFirst = fT;

	mov	ecx, DWORD PTR _rfTFirst$[ebp]
	fld	DWORD PTR _fT$[ebp]
	fstp	DWORD PTR [ecx]
$LN19@noIntersec:

; 376  : 		if (rfTFirst > fTMax)

	mov	edx, DWORD PTR _rfTFirst$[ebp]
	fld	DWORD PTR [edx]
	fld	DWORD PTR _fTMax$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN18@noIntersec

; 377  : 			return true;

	mov	al, 1
	jmp	$LN22@noIntersec
$LN18@noIntersec:

; 378  : 
; 379  : 		fT = (fMax0 - fMin1) * fInvSpeed;

	fld	DWORD PTR _fMax0$[ebp]
	fsub	DWORD PTR _fMin1$[ebp]
	fmul	DWORD PTR _fInvSpeed$[ebp]
	fstp	DWORD PTR _fT$[ebp]

; 380  : 		if (fT < rfTLast)

	fld	DWORD PTR _fT$[ebp]
	mov	eax, DWORD PTR _rfTLast$[ebp]
	fld	DWORD PTR [eax]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN17@noIntersec

; 381  : 			rfTLast = fT;

	mov	ecx, DWORD PTR _rfTLast$[ebp]
	fld	DWORD PTR _fT$[ebp]
	fstp	DWORD PTR [ecx]
$LN17@noIntersec:

; 382  : 		if (rfTFirst > rfTLast)

	mov	edx, DWORD PTR _rfTFirst$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _rfTLast$[ebp]
	fld	DWORD PTR [eax]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN16@noIntersec

; 383  : 			return true;

	mov	al, 1
	jmp	$LN22@noIntersec
$LN16@noIntersec:

; 384  : 	}

	jmp	$LN1@noIntersec
$LN21@noIntersec:

; 385  : 	else if (fMax0 < fMin1) {  // C1 initially on right of C0

	fld	DWORD PTR _fMax0$[ebp]
	fld	DWORD PTR _fMin1$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN14@noIntersec

; 386  : 		if (fSpeed >= 0.0f) {

	fld	DWORD PTR _fSpeed$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN13@noIntersec

; 387  : 			// intervals moving apart
; 388  :             return true;

	mov	al, 1
	jmp	$LN22@noIntersec
$LN13@noIntersec:

; 389  : 		}
; 390  : 
; 391  : 		fInvSpeed = 1.0f / fSpeed;

	fld	DWORD PTR _fSpeed$[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _fInvSpeed$[ebp]

; 392  : 
; 393  : 		fT = (fMax0 - fMin1) * fInvSpeed;

	fld	DWORD PTR _fMax0$[ebp]
	fsub	DWORD PTR _fMin1$[ebp]
	fmul	DWORD PTR _fInvSpeed$[ebp]
	fstp	DWORD PTR _fT$[ebp]

; 394  : 		if (fT > rfTFirst)

	fld	DWORD PTR _fT$[ebp]
	mov	ecx, DWORD PTR _rfTFirst$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN12@noIntersec

; 395  : 			rfTFirst = fT;

	mov	edx, DWORD PTR _rfTFirst$[ebp]
	fld	DWORD PTR _fT$[ebp]
	fstp	DWORD PTR [edx]
$LN12@noIntersec:

; 396  : 		if (rfTFirst > fTMax)

	mov	eax, DWORD PTR _rfTFirst$[ebp]
	fld	DWORD PTR [eax]
	fld	DWORD PTR _fTMax$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN11@noIntersec

; 397  : 			return true;

	mov	al, 1
	jmp	$LN22@noIntersec
$LN11@noIntersec:

; 398  : 
; 399  : 		fT = (fMin0 - fMax1) * fInvSpeed;

	fld	DWORD PTR _fMin0$[ebp]
	fsub	DWORD PTR _fMax1$[ebp]
	fmul	DWORD PTR _fInvSpeed$[ebp]
	fstp	DWORD PTR _fT$[ebp]

; 400  : 		if (fT < rfTLast)

	fld	DWORD PTR _fT$[ebp]
	mov	ecx, DWORD PTR _rfTLast$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN10@noIntersec

; 401  : 			rfTLast = fT;

	mov	edx, DWORD PTR _rfTLast$[ebp]
	fld	DWORD PTR _fT$[ebp]
	fstp	DWORD PTR [edx]
$LN10@noIntersec:

; 402  : 		if (rfTFirst > rfTLast)

	mov	eax, DWORD PTR _rfTFirst$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rfTLast$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@noIntersec

; 403  : 			return true;

	mov	al, 1
	jmp	$LN22@noIntersec
$LN9@noIntersec:

; 404  : 	}
; 405  : 	else {  // C0 and C1 overlap

	jmp	$LN1@noIntersec
$LN14@noIntersec:

; 406  : 		if (fSpeed > 0.0f) {

	fld	DWORD PTR _fSpeed$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN7@noIntersec

; 407  : 			fT = (fMax0 - fMin1) / fSpeed;

	fld	DWORD PTR _fMax0$[ebp]
	fsub	DWORD PTR _fMin1$[ebp]
	fdiv	DWORD PTR _fSpeed$[ebp]
	fstp	DWORD PTR _fT$[ebp]

; 408  : 			if (fT < rfTLast)

	fld	DWORD PTR _fT$[ebp]
	mov	edx, DWORD PTR _rfTLast$[ebp]
	fld	DWORD PTR [edx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN6@noIntersec

; 409  : 				rfTLast = fT;

	mov	eax, DWORD PTR _rfTLast$[ebp]
	fld	DWORD PTR _fT$[ebp]
	fstp	DWORD PTR [eax]
$LN6@noIntersec:

; 410  : 			if (rfTFirst > rfTLast)

	mov	ecx, DWORD PTR _rfTFirst$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _rfTLast$[ebp]
	fld	DWORD PTR [edx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN5@noIntersec

; 411  : 				return true;

	mov	al, 1
	jmp	SHORT $LN22@noIntersec
$LN5@noIntersec:

; 412  : 		}

	jmp	SHORT $LN1@noIntersec
$LN7@noIntersec:

; 413  : 		else if (fSpeed < 0.0f) {

	fld	DWORD PTR _fSpeed$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@noIntersec

; 414  : 			fT = (fMin0 - fMax1) / fSpeed;

	fld	DWORD PTR _fMin0$[ebp]
	fsub	DWORD PTR _fMax1$[ebp]
	fdiv	DWORD PTR _fSpeed$[ebp]
	fstp	DWORD PTR _fT$[ebp]

; 415  : 			if (fT < rfTLast)

	fld	DWORD PTR _fT$[ebp]
	mov	eax, DWORD PTR _rfTLast$[ebp]
	fld	DWORD PTR [eax]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@noIntersec

; 416  : 				rfTLast = fT;

	mov	ecx, DWORD PTR _rfTLast$[ebp]
	fld	DWORD PTR _fT$[ebp]
	fstp	DWORD PTR [ecx]
$LN2@noIntersec:

; 417  : 			if (rfTFirst > rfTLast)

	mov	edx, DWORD PTR _rfTFirst$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _rfTLast$[ebp]
	fld	DWORD PTR [eax]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@noIntersec

; 418  : 				return true;

	mov	al, 1
	jmp	SHORT $LN22@noIntersec
$LN1@noIntersec:

; 419  : 		}
; 420  : 	}
; 421  : 
; 422  :     return false;

	xor	al, al
$LN22@noIntersec:

; 423  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?noIntersect@ozcollide@@YA_NMMMMMMAAM0@Z ENDP		; ozcollide::noIntersect
_TEXT	ENDS
PUBLIC	??Dozcollide@@YA?AVVec3f@0@MABV10@@Z		; ozcollide::operator*
PUBLIC	?dist@Plane@ozcollide@@QBEMABVVec3f@2@@Z	; ozcollide::Plane::dist
PUBLIC	?getEdge@Box@ozcollide@@QBE?AVBoxEdge@2@H@Z	; ozcollide::Box::getEdge
PUBLIC	?getFaceNormal@Box@ozcollide@@SA?AVVec3f@2@W4PLANE@2@@Z ; ozcollide::Box::getFaceNormal
PUBLIC	??GVec3f@ozcollide@@QBE?AV01@XZ			; ozcollide::Vec3f::operator-
PUBLIC	??DVec3f@ozcollide@@QBE?AV01@M@Z		; ozcollide::Vec3f::operator*
PUBLIC	?intersectWithLine@Plane@ozcollide@@QAE_NABVVec3f@2@0AAM@Z ; ozcollide::Plane::intersectWithLine
PUBLIC	??HVec3f@ozcollide@@QBE?AV01@ABV01@@Z		; ozcollide::Vec3f::operator+
PUBLIC	__real@bfe6a09e60000000
PUBLIC	?getVertexNormal@Box@ozcollide@@SA?AVVec3f@2@H@Z ; ozcollide::Box::getVertexNormal
PUBLIC	?getPoint@Box@ozcollide@@QBE?AVVec3f@2@H@Z	; ozcollide::Box::getPoint
PUBLIC	?normalize@Vec3f@ozcollide@@QAEXXZ		; ozcollide::Vec3f::normalize
PUBLIC	?testIntersectionTriBox@ozcollide@@YA_NQAPBVVec3f@1@ABV21@ABVBox@1@1AAMAAV21@@Z ; ozcollide::testIntersectionTriBox
EXTRN	?fromPoints@Plane@ozcollide@@QAEXABVVec3f@2@00@Z:PROC ; ozcollide::Plane::fromPoints
EXTRN	?intersectRayBox@ozcollide@@YA?AW4PLANE@1@ABVVec3f@1@0ABVBox@1@AAM2@Z:PROC ; ozcollide::intersectRayBox
EXTRN	?isPointInsideTriangle@ozcollide@@YA_NABVVec3f@1@000@Z:PROC ; ozcollide::isPointInsideTriangle
EXTRN	?fromPointAndNormal@Plane@ozcollide@@QAEXABVVec3f@2@0@Z:PROC ; ozcollide::Plane::fromPointAndNormal
EXTRN	??0Plane@ozcollide@@QAE@XZ:PROC			; ozcollide::Plane::Plane
;	COMDAT __real@bfe6a09e60000000
CONST	SEGMENT
__real@bfe6a09e60000000 DQ 0bfe6a09e60000000r	; -0.707107
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
tv680 = -452						; size = 8
tv678 = -444						; size = 8
tv676 = -436						; size = 8
tv674 = -428						; size = 8
tv672 = -420						; size = 8
tv670 = -412						; size = 8
tv668 = -404						; size = 8
tv666 = -396						; size = 8
$T7431 = -388						; size = 12
$T7430 = -376						; size = 12
$T7429 = -364						; size = 12
$T7428 = -352						; size = 12
$T7427 = -340						; size = 12
$T7426 = -328						; size = 12
$T7425 = -316						; size = 12
$T7424 = -304						; size = 12
$T7423 = -292						; size = 12
$T7422 = -280						; size = 12
$T7421 = -268						; size = 12
_a0$7148 = -256						; size = 4
_pl_y$7151 = -252					; size = 4
_dist$7156 = -248					; size = 4
_pl_x$7150 = -244					; size = 4
_r2$7163 = -240						; size = 12
_tpt1$7138 = -228					; size = 4
_v1$7143 = -224						; size = 12
_ipt$7145 = -212					; size = 12
_a1$7149 = -200						; size = 4
_r1$7161 = -196						; size = 12
_tpt0$7137 = -184					; size = 4
_denom$7157 = -180					; size = 4
_pl_z$7152 = -176					; size = 4
_boxEdge$7126 = -172					; size = 24
_v0$7132 = -148						; size = 12
_boxEdgePlane$7128 = -136				; size = 16
_boxEdgeNormal$7130 = -120				; size = 12
_plane$7116 = -108					; size = 4
_tnear$7114 = -104					; size = 4
_tfar$7115 = -100					; size = 4
_t$7102 = -96						; size = 4
_box_vertex_normal$7099 = -92				; size = 12
_inter$7107 = -80					; size = 12
_box_vertex$7097 = -68					; size = 12
_j$ = -56						; size = 4
_d1$ = -52						; size = 4
_t$ = -48						; size = 4
_d0$ = -44						; size = 4
_minDist$ = -40						; size = 4
_n_boxvel$ = -36					; size = 12
_i$ = -24						; size = 4
_tri_plane$ = -20					; size = 16
_col$ = -4						; size = 4
__triPts$ = 8						; size = 4
__triNormal$ = 12					; size = 4
__box$ = 16						; size = 4
__boxVel$ = 20						; size = 4
__distTravel$ = 24					; size = 4
__reaction$ = 28					; size = 4
?testIntersectionTriBox@ozcollide@@YA_NQAPBVVec3f@1@ABV21@ABVBox@1@1AAMAAV21@@Z PROC ; ozcollide::testIntersectionTriBox

; 492  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 452				; 000001c4H

; 493  : 	int i, j;
; 494  : 	float d0, d1;
; 495  : 	float t;
; 496  : 
; 497  : 	Plane tri_plane;

	lea	ecx, DWORD PTR _tri_plane$[ebp]
	call	??0Plane@ozcollide@@QAE@XZ		; ozcollide::Plane::Plane

; 498  : 	tri_plane.fromPointAndNormal(*_triPts[0], _triNormal);

	mov	eax, DWORD PTR __triNormal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __triPts$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _tri_plane$[ebp]
	call	?fromPointAndNormal@Plane@ozcollide@@QAEXABVVec3f@2@0@Z ; ozcollide::Plane::fromPointAndNormal

; 499  : 
; 500  : 	Vec3f n_boxvel = _boxVel;

	mov	eax, DWORD PTR __boxVel$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _n_boxvel$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _n_boxvel$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _n_boxvel$[ebp+8], eax

; 501  : 	n_boxvel.normalize();

	lea	ecx, DWORD PTR _n_boxvel$[ebp]
	call	?normalize@Vec3f@ozcollide@@QAEXXZ	; ozcollide::Vec3f::normalize

; 502  : 
; 503  : 	if (_triNormal.dot(n_boxvel) > 0)

	lea	ecx, DWORD PTR _n_boxvel$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __triNormal$[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN34@testInters@4

; 504  : 		return false;

	xor	al, al
	jmp	$LN35@testInters@4
$LN34@testInters@4:

; 505  : 
; 506  : 	float minDist = FLT_MAX;

	fld	DWORD PTR __real@7f7fffff
	fstp	DWORD PTR _minDist$[ebp]

; 507  : 	int col = -1;

	mov	DWORD PTR _col$[ebp], -1

; 508  : 
; 509  : 	// box vertices VS triangle
; 510  : 	for (i = 0; i < 8; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN33@testInters@4
$LN32@testInters@4:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN33@testInters@4:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN31@testInters@4

; 511  : 		Vec3f box_vertex = _box.getPoint(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	lea	ecx, DWORD PTR _box_vertex$7097[ebp]
	push	ecx
	mov	ecx, DWORD PTR __box$[ebp]
	call	?getPoint@Box@ozcollide@@QBE?AVVec3f@2@H@Z ; ozcollide::Box::getPoint

; 512  : 
; 513  : 		Vec3f box_vertex_normal = _box.getVertexNormal(i);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	lea	eax, DWORD PTR _box_vertex_normal$7099[ebp]
	push	eax
	call	?getVertexNormal@Box@ozcollide@@SA?AVVec3f@2@H@Z ; ozcollide::Box::getVertexNormal
	add	esp, 8

; 514  : 		if (box_vertex_normal.dot(n_boxvel) < -OZ_COS45)

	lea	ecx, DWORD PTR _n_boxvel$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _box_vertex_normal$7099[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	fcomp	QWORD PTR __real@bfe6a09e60000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN30@testInters@4

; 515  : 			continue;

	jmp	SHORT $LN32@testInters@4
$LN30@testInters@4:

; 516  : 
; 517  : 		float t;
; 518  : 		if (!tri_plane.intersectWithLine(box_vertex, box_vertex + n_boxvel, t) )

	lea	edx, DWORD PTR _t$7102[ebp]
	push	edx
	lea	eax, DWORD PTR _n_boxvel$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T7421[ebp]
	push	ecx
	lea	ecx, DWORD PTR _box_vertex$7097[ebp]
	call	??HVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator+
	push	eax
	lea	edx, DWORD PTR _box_vertex$7097[ebp]
	push	edx
	lea	ecx, DWORD PTR _tri_plane$[ebp]
	call	?intersectWithLine@Plane@ozcollide@@QAE_NABVVec3f@2@0AAM@Z ; ozcollide::Plane::intersectWithLine
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN29@testInters@4

; 519  : 			continue;

	jmp	SHORT $LN32@testInters@4
$LN29@testInters@4:

; 520  : 
; 521  : 		if (t >= minDist)

	fld	DWORD PTR _t$7102[ebp]
	fld	DWORD PTR _minDist$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN28@testInters@4

; 522  : 			continue;

	jmp	$LN32@testInters@4
$LN28@testInters@4:

; 523  : 		if (t < 0)

	fld	DWORD PTR _t$7102[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN27@testInters@4

; 524  : 			continue;

	jmp	$LN32@testInters@4
$LN27@testInters@4:

; 525  : 
; 526  : 		Vec3f inter;

	lea	ecx, DWORD PTR _inter$7107[ebp]
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f

; 527  : 		inter = box_vertex + n_boxvel * t;

	push	ecx
	fld	DWORD PTR _t$7102[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7422[ebp]
	push	ecx
	lea	ecx, DWORD PTR _n_boxvel$[ebp]
	call	??DVec3f@ozcollide@@QBE?AV01@M@Z	; ozcollide::Vec3f::operator*
	push	eax
	lea	edx, DWORD PTR $T7423[ebp]
	push	edx
	lea	ecx, DWORD PTR _box_vertex$7097[ebp]
	call	??HVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _inter$7107[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _inter$7107[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _inter$7107[ebp+8], eax

; 528  : 
; 529  : 		if (!isPointInsideTriangle(*_triPts[0], *_triPts[1], *_triPts[2], inter))

	lea	ecx, DWORD PTR _inter$7107[ebp]
	push	ecx
	mov	edx, DWORD PTR __triPts$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR __triPts$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __triPts$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?isPointInsideTriangle@ozcollide@@YA_NABVVec3f@1@000@Z ; ozcollide::isPointInsideTriangle
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN26@testInters@4

; 530  : 			continue;

	jmp	$LN32@testInters@4
$LN26@testInters@4:

; 531  : 
; 532  : 		minDist = t;

	fld	DWORD PTR _t$7102[ebp]
	fstp	DWORD PTR _minDist$[ebp]

; 533  : 		_reaction = _triNormal;

	mov	eax, DWORD PTR __triNormal$[ebp]
	mov	ecx, DWORD PTR __reaction$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 534  : 		col = 0;

	mov	DWORD PTR _col$[ebp], 0

; 535  : 	}

	jmp	$LN32@testInters@4
$LN31@testInters@4:

; 536  : 
; 537  : 	// triangle vertices VS box faces
; 538  : 	for (i = 0; i < 3; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN25@testInters@4
$LN24@testInters@4:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN25@testInters@4:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN23@testInters@4

; 539  : 		float tnear, tfar;
; 540  : 		PLANE plane = intersectRayBox(*_triPts[i], -n_boxvel, _box, tnear, tfar);

	lea	edx, DWORD PTR _tfar$7115[ebp]
	push	edx
	lea	eax, DWORD PTR _tnear$7114[ebp]
	push	eax
	mov	ecx, DWORD PTR __box$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T7424[ebp]
	push	edx
	lea	ecx, DWORD PTR _n_boxvel$[ebp]
	call	??GVec3f@ozcollide@@QBE?AV01@XZ		; ozcollide::Vec3f::operator-
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR __triPts$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	?intersectRayBox@ozcollide@@YA?AW4PLANE@1@ABVVec3f@1@0ABVBox@1@AAM2@Z ; ozcollide::intersectRayBox
	add	esp, 20					; 00000014H
	mov	DWORD PTR _plane$7116[ebp], eax

; 541  : 		if (plane == -1)

	cmp	DWORD PTR _plane$7116[ebp], -1
	jne	SHORT $LN22@testInters@4

; 542  : 			continue;

	jmp	SHORT $LN24@testInters@4
$LN22@testInters@4:

; 543  : 
; 544  : 		if (tnear < 0)

	fld	DWORD PTR _tnear$7114[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN21@testInters@4

; 545  : 			continue;

	jmp	SHORT $LN24@testInters@4
$LN21@testInters@4:

; 546  : 
; 547  : 		if (tnear < minDist) {

	fld	DWORD PTR _tnear$7114[ebp]
	fld	DWORD PTR _minDist$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN20@testInters@4

; 548  : 			minDist = tnear;

	fld	DWORD PTR _tnear$7114[ebp]
	fstp	DWORD PTR _minDist$[ebp]

; 549  : 			_reaction = -_box.getFaceNormal(plane);

	lea	eax, DWORD PTR $T7426[ebp]
	push	eax
	mov	ecx, DWORD PTR _plane$7116[ebp]
	push	ecx
	lea	edx, DWORD PTR $T7425[ebp]
	push	edx
	call	?getFaceNormal@Box@ozcollide@@SA?AVVec3f@2@W4PLANE@2@@Z ; ozcollide::Box::getFaceNormal
	add	esp, 8
	mov	ecx, eax
	call	??GVec3f@ozcollide@@QBE?AV01@XZ		; ozcollide::Vec3f::operator-
	mov	ecx, DWORD PTR __reaction$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 550  : 			col = 1;

	mov	DWORD PTR _col$[ebp], 1
$LN20@testInters@4:

; 551  : 		}
; 552  : 	}

	jmp	$LN24@testInters@4
$LN23@testInters@4:

; 553  : 
; 554  : 	// box edges VS triangle edges
; 555  : 	for (i = 0; i < 12; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN19@testInters@4
$LN18@testInters@4:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN19@testInters@4:
	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jge	$LN17@testInters@4

; 556  : 		BoxEdge boxEdge = _box.getEdge(i);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	lea	eax, DWORD PTR _boxEdge$7126[ebp]
	push	eax
	mov	ecx, DWORD PTR __box$[ebp]
	call	?getEdge@Box@ozcollide@@QBE?AVBoxEdge@2@H@Z ; ozcollide::Box::getEdge

; 557  : 		Plane boxEdgePlane;

	lea	ecx, DWORD PTR _boxEdgePlane$7128[ebp]
	call	??0Plane@ozcollide@@QAE@XZ		; ozcollide::Plane::Plane

; 558  : 		boxEdgePlane.fromPoints(boxEdge.p1, boxEdge.p0, boxEdge.p0 + _boxVel);

	mov	ecx, DWORD PTR __boxVel$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T7427[ebp]
	push	edx
	lea	ecx, DWORD PTR _boxEdge$7126[ebp]
	call	??HVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator+
	push	eax
	lea	eax, DWORD PTR _boxEdge$7126[ebp]
	push	eax
	lea	ecx, DWORD PTR _boxEdge$7126[ebp+12]
	push	ecx
	lea	ecx, DWORD PTR _boxEdgePlane$7128[ebp]
	call	?fromPoints@Plane@ozcollide@@QAEXABVVec3f@2@00@Z ; ozcollide::Plane::fromPoints

; 559  : 
; 560  : 		Vec3f boxEdgeNormal = Vec3f(boxEdgePlane.a, boxEdgePlane.b, boxEdgePlane.c);

	push	ecx
	fld	DWORD PTR _boxEdgePlane$7128[ebp+8]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _boxEdgePlane$7128[ebp+4]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _boxEdgePlane$7128[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _boxEdgeNormal$7130[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f

; 561  : 
; 562  : 		Vec3f v0 = boxEdge.p1 - boxEdge.p0;

	lea	edx, DWORD PTR _boxEdge$7126[ebp]
	push	edx
	lea	eax, DWORD PTR _v0$7132[ebp]
	push	eax
	lea	ecx, DWORD PTR _boxEdge$7126[ebp+12]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-

; 563  : 
; 564  : 		for (j = 0; j < 3; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN16@testInters@4
$LN15@testInters@4:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN16@testInters@4:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN14@testInters@4

; 565  : 			const Vec3f *tpt0;
; 566  : 			const Vec3f *tpt1;
; 567  : 			tpt0 = _triPts[j];

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR __triPts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _tpt0$7137[ebp], ecx

; 568  : 			if (j < 2) tpt1 = _triPts[j + 1];

	cmp	DWORD PTR _j$[ebp], 2
	jge	SHORT $LN13@testInters@4
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR __triPts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	mov	DWORD PTR _tpt1$7138[ebp], ecx
	jmp	SHORT $LN12@testInters@4
$LN13@testInters@4:

; 569  : 			else tpt1 = _triPts[0];

	mov	edx, DWORD PTR __triPts$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _tpt1$7138[ebp], eax
$LN12@testInters@4:

; 570  : 
; 571  : 			d0 = boxEdgePlane.dist(*tpt0);

	mov	ecx, DWORD PTR _tpt0$7137[ebp]
	push	ecx
	lea	ecx, DWORD PTR _boxEdgePlane$7128[ebp]
	call	?dist@Plane@ozcollide@@QBEMABVVec3f@2@@Z ; ozcollide::Plane::dist
	fstp	DWORD PTR _d0$[ebp]

; 572  : 			d1 = boxEdgePlane.dist(*tpt1);

	mov	edx, DWORD PTR _tpt1$7138[ebp]
	push	edx
	lea	ecx, DWORD PTR _boxEdgePlane$7128[ebp]
	call	?dist@Plane@ozcollide@@QBEMABVVec3f@2@@Z ; ozcollide::Plane::dist
	fstp	DWORD PTR _d1$[ebp]

; 573  : 			if (d0 * d1 > 0)

	fld	DWORD PTR _d0$[ebp]
	fmul	DWORD PTR _d1$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN11@testInters@4

; 574  : 				continue;

	jmp	$LN15@testInters@4
$LN11@testInters@4:

; 575  : 
; 576  : 			if (!boxEdgePlane.intersectWithLine(*tpt0, *tpt1, t))

	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tpt1$7138[ebp]
	push	ecx
	mov	edx, DWORD PTR _tpt0$7137[ebp]
	push	edx
	lea	ecx, DWORD PTR _boxEdgePlane$7128[ebp]
	call	?intersectWithLine@Plane@ozcollide@@QAE_NABVVec3f@2@0AAM@Z ; ozcollide::Plane::intersectWithLine
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@testInters@4

; 577  : 				continue;

	jmp	$LN15@testInters@4
$LN10@testInters@4:

; 578  : 
; 579  : 			Vec3f v1 = *tpt1 - *tpt0;

	mov	ecx, DWORD PTR _tpt0$7137[ebp]
	push	ecx
	lea	edx, DWORD PTR _v1$7143[ebp]
	push	edx
	mov	ecx, DWORD PTR _tpt1$7138[ebp]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-

; 580  : 			Vec3f ipt = *tpt0 + v1 * t;

	push	ecx
	fld	DWORD PTR _t$[ebp]
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T7428[ebp]
	push	eax
	lea	ecx, DWORD PTR _v1$7143[ebp]
	call	??DVec3f@ozcollide@@QBE?AV01@M@Z	; ozcollide::Vec3f::operator*
	push	eax
	lea	ecx, DWORD PTR _ipt$7145[ebp]
	push	ecx
	mov	ecx, DWORD PTR _tpt0$7137[ebp]
	call	??HVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator+

; 581  : 
; 582  : 			int a0 = 0, a1 = 1;

	mov	DWORD PTR _a0$7148[ebp], 0
	mov	DWORD PTR _a1$7149[ebp], 1

; 583  : 			float pl_x = fabsf(boxEdgePlane.a);

	push	ecx
	fld	DWORD PTR _boxEdgePlane$7128[ebp]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _pl_x$7150[ebp]

; 584  : 			float pl_y = fabsf(boxEdgePlane.b);

	push	ecx
	fld	DWORD PTR _boxEdgePlane$7128[ebp+4]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _pl_y$7151[ebp]

; 585  : 			float pl_z = fabsf(boxEdgePlane.c);

	push	ecx
	fld	DWORD PTR _boxEdgePlane$7128[ebp+8]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _pl_z$7152[ebp]

; 586  : 			if (pl_x > pl_y && pl_x > pl_z) {

	fld	DWORD PTR _pl_x$7150[ebp]
	fld	DWORD PTR _pl_y$7151[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@testInters@4
	fld	DWORD PTR _pl_x$7150[ebp]
	fld	DWORD PTR _pl_z$7152[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@testInters@4

; 587  : 				a0 = 1;

	mov	DWORD PTR _a0$7148[ebp], 1

; 588  : 				a1 = 2;

	mov	DWORD PTR _a1$7149[ebp], 2

; 589  : 			}
; 590  : 			else {

	jmp	SHORT $LN7@testInters@4
$LN9@testInters@4:

; 591  : 				if (pl_y > pl_z) {

	fld	DWORD PTR _pl_y$7151[ebp]
	fld	DWORD PTR _pl_z$7152[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN7@testInters@4

; 592  : 					a0 = 0;

	mov	DWORD PTR _a0$7148[ebp], 0

; 593  : 					a1 = 2;

	mov	DWORD PTR _a1$7149[ebp], 2
$LN7@testInters@4:

; 594  : 				}
; 595  : 			}
; 596  : 
; 597  : 			float dist = v0[a0] * (ipt[a1] - boxEdge.p0[a1]) - v0[a1] * (ipt[a0] - boxEdge.p0[a0]);

	mov	edx, DWORD PTR _a0$7148[ebp]
	push	edx
	lea	ecx, DWORD PTR _v0$7132[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	eax, DWORD PTR _a1$7149[ebp]
	push	eax
	lea	ecx, DWORD PTR _ipt$7145[ebp]
	fstp	QWORD PTR tv666[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	ecx, DWORD PTR _a1$7149[ebp]
	push	ecx
	lea	ecx, DWORD PTR _boxEdge$7126[ebp]
	fstp	QWORD PTR tv668[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	fsubr	QWORD PTR tv668[ebp]
	fmul	QWORD PTR tv666[ebp]
	mov	edx, DWORD PTR _a1$7149[ebp]
	push	edx
	lea	ecx, DWORD PTR _v0$7132[ebp]
	fstp	QWORD PTR tv670[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	eax, DWORD PTR _a0$7148[ebp]
	push	eax
	lea	ecx, DWORD PTR _ipt$7145[ebp]
	fstp	QWORD PTR tv672[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	ecx, DWORD PTR _a0$7148[ebp]
	push	ecx
	lea	ecx, DWORD PTR _boxEdge$7126[ebp]
	fstp	QWORD PTR tv674[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	fsubr	QWORD PTR tv674[ebp]
	fmul	QWORD PTR tv672[ebp]
	fsubr	QWORD PTR tv670[ebp]
	fstp	DWORD PTR _dist$7156[ebp]

; 598  : 			float denom = v0[a1] * -n_boxvel[a0] - v0[a0] * -n_boxvel[a1];

	mov	edx, DWORD PTR _a1$7149[ebp]
	push	edx
	lea	ecx, DWORD PTR _v0$7132[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	eax, DWORD PTR _a0$7148[ebp]
	push	eax
	lea	ecx, DWORD PTR _n_boxvel$[ebp]
	fstp	QWORD PTR tv676[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	fchs
	fmul	QWORD PTR tv676[ebp]
	mov	ecx, DWORD PTR _a0$7148[ebp]
	push	ecx
	lea	ecx, DWORD PTR _v0$7132[ebp]
	fstp	QWORD PTR tv678[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	edx, DWORD PTR _a1$7149[ebp]
	push	edx
	lea	ecx, DWORD PTR _n_boxvel$[ebp]
	fstp	QWORD PTR tv680[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	fchs
	fmul	QWORD PTR tv680[ebp]
	fsubr	QWORD PTR tv678[ebp]
	fstp	DWORD PTR _denom$7157[ebp]

; 599  : 			if (!denom)

	fld	DWORD PTR _denom$7157[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@testInters@4

; 600  : 				continue;

	jmp	$LN15@testInters@4
$LN6@testInters@4:

; 601  : 			dist /= denom;

	fld	DWORD PTR _dist$7156[ebp]
	fdiv	DWORD PTR _denom$7157[ebp]
	fstp	DWORD PTR _dist$7156[ebp]

; 602  : 
; 603  : 			if (dist < 0)

	fld	DWORD PTR _dist$7156[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN5@testInters@4

; 604  : 				continue;

	jmp	$LN15@testInters@4
$LN5@testInters@4:

; 605  : 
; 606  : 			ipt -= dist * n_boxvel;

	lea	eax, DWORD PTR _n_boxvel$[ebp]
	push	eax
	push	ecx
	fld	DWORD PTR _dist$7156[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7429[ebp]
	push	ecx
	call	??Dozcollide@@YA?AVVec3f@0@MABV10@@Z	; ozcollide::operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _ipt$7145[ebp]
	call	??ZVec3f@ozcollide@@QAEXABV01@@Z	; ozcollide::Vec3f::operator-=

; 607  : 
; 608  : 			Vec3f r1 = boxEdge.p0 - ipt;

	lea	edx, DWORD PTR _ipt$7145[ebp]
	push	edx
	lea	eax, DWORD PTR _r1$7161[ebp]
	push	eax
	lea	ecx, DWORD PTR _boxEdge$7126[ebp]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-

; 609  : 			Vec3f r2 = boxEdge.p1 - ipt;

	lea	ecx, DWORD PTR _ipt$7145[ebp]
	push	ecx
	lea	edx, DWORD PTR _r2$7163[ebp]
	push	edx
	lea	ecx, DWORD PTR _boxEdge$7126[ebp+12]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-

; 610  : 			if (r1.dot(r2) > 0)

	lea	eax, DWORD PTR _r2$7163[ebp]
	push	eax
	lea	ecx, DWORD PTR _r1$7161[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@testInters@4

; 611  : 				continue;

	jmp	$LN15@testInters@4
$LN4@testInters@4:

; 612  : 
; 613  : 			if (dist < minDist) {

	fld	DWORD PTR _dist$7156[ebp]
	fld	DWORD PTR _minDist$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@testInters@4

; 614  : 				minDist = dist;

	fld	DWORD PTR _dist$7156[ebp]
	fstp	DWORD PTR _minDist$[ebp]

; 615  : 				_reaction = v0 | v1;

	lea	ecx, DWORD PTR _v1$7143[ebp]
	push	ecx
	lea	edx, DWORD PTR $T7430[ebp]
	push	edx
	lea	ecx, DWORD PTR _v0$7132[ebp]
	call	??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator|
	mov	ecx, DWORD PTR __reaction$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 616  : 				_reaction.normalize();

	mov	ecx, DWORD PTR __reaction$[ebp]
	call	?normalize@Vec3f@ozcollide@@QAEXXZ	; ozcollide::Vec3f::normalize

; 617  : 				if (_reaction.dot(n_boxvel) > 0)

	lea	ecx, DWORD PTR _n_boxvel$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __reaction$[ebp]
	call	?dot@Vec3f@ozcollide@@QBEMABV12@@Z	; ozcollide::Vec3f::dot
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@testInters@4

; 618  : 					_reaction = -_reaction;

	lea	edx, DWORD PTR $T7431[ebp]
	push	edx
	mov	ecx, DWORD PTR __reaction$[ebp]
	call	??GVec3f@ozcollide@@QBE?AV01@XZ		; ozcollide::Vec3f::operator-
	mov	ecx, DWORD PTR __reaction$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$LN2@testInters@4:

; 619  : 				col = 2;

	mov	DWORD PTR _col$[ebp], 2
$LN3@testInters@4:

; 620  : 			}
; 621  : 		}

	jmp	$LN15@testInters@4
$LN14@testInters@4:

; 622  : 	}

	jmp	$LN18@testInters@4
$LN17@testInters@4:

; 623  : 
; 624  : 	if (col == -1)

	cmp	DWORD PTR _col$[ebp], -1
	jne	SHORT $LN1@testInters@4

; 625  : 		return false;

	xor	al, al
	jmp	SHORT $LN35@testInters@4
$LN1@testInters@4:

; 626  : 
; 627  : 	_distTravel = minDist;

	mov	ecx, DWORD PTR __distTravel$[ebp]
	fld	DWORD PTR _minDist$[ebp]
	fstp	DWORD PTR [ecx]

; 628  : 
; 629  : 	return true;

	mov	al, 1
$LN35@testInters@4:

; 630  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?testIntersectionTriBox@ozcollide@@YA_NQAPBVVec3f@1@ABV21@ABVBox@1@1AAMAAV21@@Z ENDP ; ozcollide::testIntersectionTriBox
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
_TEXT	ENDS
;	COMDAT ??GVec3f@ozcollide@@QBE?AV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??GVec3f@ozcollide@@QBE?AV01@XZ PROC			; ozcollide::Vec3f::operator-, COMDAT
; _this$ = ecx

; 53   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 54   : 		return Vec3f(-x, -y, -z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 55   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??GVec3f@ozcollide@@QBE?AV01@XZ ENDP			; ozcollide::Vec3f::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??HVec3f@ozcollide@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
tv92 = -16						; size = 4
tv89 = -12						; size = 4
tv86 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__v$ = 12						; size = 4
??HVec3f@ozcollide@@QBE?AV01@ABV01@@Z PROC		; ozcollide::Vec3f::operator+, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		return Vec3f(x + _v.x, y + _v.y, z + _v.z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __v$[ebp]
	fadd	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __v$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR __v$[ebp]
	fadd	DWORD PTR [edx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 101  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
??HVec3f@ozcollide@@QBE?AV01@ABV01@@Z ENDP		; ozcollide::Vec3f::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??DVec3f@ozcollide@@QBE?AV01@M@Z
_TEXT	SEGMENT
tv87 = -16						; size = 4
tv85 = -12						; size = 4
tv83 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__m$ = 12						; size = 4
??DVec3f@ozcollide@@QBE?AV01@M@Z PROC			; ozcollide::Vec3f::operator*, COMDAT
; _this$ = ecx

; 109  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 		return Vec3f(x * _m, y * _m, z * _m);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR __m$[ebp]
	fstp	DWORD PTR tv83[ebp]
	fld	DWORD PTR tv83[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR __m$[ebp]
	fstp	DWORD PTR tv85[ebp]
	fld	DWORD PTR tv85[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR __m$[ebp]
	fstp	DWORD PTR tv87[ebp]
	fld	DWORD PTR tv87[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 111  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
??DVec3f@ozcollide@@QBE?AV01@M@Z ENDP			; ozcollide::Vec3f::operator*
_TEXT	ENDS
PUBLIC	?len@Vec3f@ozcollide@@QBEMXZ			; ozcollide::Vec3f::len
; Function compile flags: /Odtp
;	COMDAT ?normalize@Vec3f@ozcollide@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_ln$ = -8						; size = 4
_div$ = -4						; size = 4
?normalize@Vec3f@ozcollide@@QAEXXZ PROC			; ozcollide::Vec3f::normalize, COMDAT
; _this$ = ecx

; 168  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 		float ln = len();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?len@Vec3f@ozcollide@@QBEMXZ		; ozcollide::Vec3f::len
	fstp	DWORD PTR _ln$[ebp]

; 170  : 		if (!ln)

	fld	DWORD PTR _ln$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@normalize

; 171  : 			return;

	jmp	SHORT $LN2@normalize
$LN1@normalize:

; 172  : 		float div = 1.0f / ln;

	fld	DWORD PTR _ln$[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _div$[ebp]

; 173  : 		x *= div;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _div$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 174  : 		y *= div;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _div$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 175  : 		z *= div;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _div$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]
$LN2@normalize:

; 176  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?normalize@Vec3f@ozcollide@@QAEXXZ ENDP			; ozcollide::Vec3f::normalize
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Odtp
;	COMDAT ?len@Vec3f@ozcollide@@QBEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_len$ = -4						; size = 4
?len@Vec3f@ozcollide@@QBEMXZ PROC			; ozcollide::Vec3f::len, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		float len = x * x + y * y + z * z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _len$[ebp]

; 154  : 		return (float) sqrt(len);

	push	ecx
	fld	DWORD PTR _len$[ebp]
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4

; 155  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?len@Vec3f@ozcollide@@QBEMXZ ENDP			; ozcollide::Vec3f::len
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 534  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	fstp	DWORD PTR [esp]
	call	_sqrtf
	add	esp, 4
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 423  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
_TEXT	ENDS
;	COMDAT ??Dozcollide@@YA?AVVec3f@0@MABV10@@Z
_TEXT	SEGMENT
tv87 = -12						; size = 4
tv85 = -8						; size = 4
tv83 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__m$ = 12						; size = 4
__v$ = 16						; size = 4
??Dozcollide@@YA?AVVec3f@0@MABV10@@Z PROC		; ozcollide::operator*, COMDAT

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 190  : 	return Vec3f(_v.x * _m, _v.y * _m, _v.z * _m);

	mov	eax, DWORD PTR __v$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR __m$[ebp]
	fstp	DWORD PTR tv83[ebp]
	fld	DWORD PTR tv83[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __v$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR __m$[ebp]
	fstp	DWORD PTR tv85[ebp]
	fld	DWORD PTR tv85[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR __v$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR __m$[ebp]
	fstp	DWORD PTR tv87[ebp]
	fld	DWORD PTR tv87[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 191  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??Dozcollide@@YA?AVVec3f@0@MABV10@@Z ENDP		; ozcollide::operator*
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\plane.h
_TEXT	ENDS
;	COMDAT ?dist@Plane@ozcollide@@QBEMABVVec3f@2@@Z
_TEXT	SEGMENT
tv90 = -8						; size = 4
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?dist@Plane@ozcollide@@QBEMABVVec3f@2@@Z PROC		; ozcollide::Plane::dist, COMDAT
; _this$ = ecx

; 55   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return a * p.x + b * p.y + c * p.z + d;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _p$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _p$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _p$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+12]
	fstp	DWORD PTR tv90[ebp]
	fld	DWORD PTR tv90[ebp]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?dist@Plane@ozcollide@@QBEMABVVec3f@2@@Z ENDP		; ozcollide::Plane::dist
_TEXT	ENDS
PUBLIC	?dot@Plane@ozcollide@@QBEMABVVec3f@2@@Z		; ozcollide::Plane::dot
; Function compile flags: /Odtp
;	COMDAT ?intersectWithLine@Plane@ozcollide@@QAE_NABVVec3f@2@0AAM@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_dir$ = -16						; size = 12
_div$ = -4						; size = 4
_p0$ = 8						; size = 4
_p1$ = 12						; size = 4
_t$ = 16						; size = 4
?intersectWithLine@Plane@ozcollide@@QAE_NABVVec3f@2@0AAM@Z PROC ; ozcollide::Plane::intersectWithLine, COMDAT
; _this$ = ecx

; 84   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 		Vec3f dir = p1 - p0;

	mov	eax, DWORD PTR _p0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dir$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _p1$[ebp]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-

; 86   : 		float div = dot(dir);

	lea	edx, DWORD PTR _dir$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?dot@Plane@ozcollide@@QBEMABVVec3f@2@@Z	; ozcollide::Plane::dot
	fstp	DWORD PTR _div$[ebp]

; 87   : 		if (div == 0)

	fld	DWORD PTR _div$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@intersectW

; 88   : 			return false;

	xor	al, al
	jmp	SHORT $LN2@intersectW
$LN1@intersectW:

; 89   : 
; 90   : 		t = -dist(p0) / div;

	mov	eax, DWORD PTR _p0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?dist@Plane@ozcollide@@QBEMABVVec3f@2@@Z ; ozcollide::Plane::dist
	fchs
	fdiv	DWORD PTR _div$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	fstp	DWORD PTR [ecx]

; 91   : 		return true;

	mov	al, 1
$LN2@intersectW:

; 92   : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?intersectWithLine@Plane@ozcollide@@QAE_NABVVec3f@2@0AAM@Z ENDP ; ozcollide::Plane::intersectWithLine
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dot@Plane@ozcollide@@QBEMABVVec3f@2@@Z
_TEXT	SEGMENT
tv86 = -8						; size = 4
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?dot@Plane@ozcollide@@QBEMABVVec3f@2@@Z PROC		; ozcollide::Plane::dot, COMDAT
; _this$ = ecx

; 50   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		return a * p.x + b * p.y + c * p.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _p$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _p$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _p$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?dot@Plane@ozcollide@@QBEMABVVec3f@2@@Z ENDP		; ozcollide::Plane::dot
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\box.h
_TEXT	ENDS
;	COMDAT ?getPoint@Box@ozcollide@@QBE?AVVec3f@2@H@Z
_TEXT	SEGMENT
tv416 = -104						; size = 4
tv413 = -100						; size = 4
tv410 = -96						; size = 4
tv400 = -92						; size = 4
tv397 = -88						; size = 4
tv394 = -84						; size = 4
tv384 = -80						; size = 4
tv381 = -76						; size = 4
tv378 = -72						; size = 4
tv368 = -68						; size = 4
tv365 = -64						; size = 4
tv362 = -60						; size = 4
tv352 = -56						; size = 4
tv349 = -52						; size = 4
tv346 = -48						; size = 4
tv336 = -44						; size = 4
tv333 = -40						; size = 4
tv330 = -36						; size = 4
tv320 = -32						; size = 4
tv317 = -28						; size = 4
tv314 = -24						; size = 4
tv304 = -20						; size = 4
tv301 = -16						; size = 4
tv298 = -12						; size = 4
tv64 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__index$ = 12						; size = 4
?getPoint@Box@ozcollide@@QBE?AVVec3f@2@H@Z PROC		; ozcollide::Box::getPoint, COMDAT
; _this$ = ecx

; 188  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 189  : 		switch(_index) {

	mov	eax, DWORD PTR __index$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 7
	ja	$LN1@getPoint
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN14@getPoint[ecx*4]
$LN9@getPoint:

; 190  : 		case 0: return Vec3f(center.x - extent.x, center.y - extent.y, center.z - extent.z);

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [eax+20]
	fstp	DWORD PTR tv298[ebp]
	fld	DWORD PTR tv298[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [edx+16]
	fstp	DWORD PTR tv301[ebp]
	fld	DWORD PTR tv301[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR tv304[ebp]
	fld	DWORD PTR tv304[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN10@getPoint
$LN8@getPoint:

; 191  : 		case 1: return Vec3f(center.x + extent.x, center.y - extent.y, center.z - extent.z);

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [eax+20]
	fstp	DWORD PTR tv314[ebp]
	fld	DWORD PTR tv314[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [edx+16]
	fstp	DWORD PTR tv317[ebp]
	fld	DWORD PTR tv317[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+12]
	fstp	DWORD PTR tv320[ebp]
	fld	DWORD PTR tv320[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN10@getPoint
$LN7@getPoint:

; 192  : 		case 2: return Vec3f(center.x - extent.x, center.y + extent.y, center.z - extent.z);

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [eax+20]
	fstp	DWORD PTR tv330[ebp]
	fld	DWORD PTR tv330[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+16]
	fstp	DWORD PTR tv333[ebp]
	fld	DWORD PTR tv333[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR tv336[ebp]
	fld	DWORD PTR tv336[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN10@getPoint
$LN6@getPoint:

; 193  : 		case 3: return Vec3f(center.x + extent.x, center.y + extent.y, center.z - extent.z);

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [eax+20]
	fstp	DWORD PTR tv346[ebp]
	fld	DWORD PTR tv346[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+16]
	fstp	DWORD PTR tv349[ebp]
	fld	DWORD PTR tv349[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+12]
	fstp	DWORD PTR tv352[ebp]
	fld	DWORD PTR tv352[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN10@getPoint
$LN5@getPoint:

; 194  : 		case 4: return Vec3f(center.x - extent.x, center.y - extent.y, center.z + extent.z);

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+20]
	fstp	DWORD PTR tv362[ebp]
	fld	DWORD PTR tv362[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [edx+16]
	fstp	DWORD PTR tv365[ebp]
	fld	DWORD PTR tv365[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR tv368[ebp]
	fld	DWORD PTR tv368[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN10@getPoint
$LN4@getPoint:

; 195  : 		case 5: return Vec3f(center.x + extent.x, center.y - extent.y, center.z + extent.z);

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+20]
	fstp	DWORD PTR tv378[ebp]
	fld	DWORD PTR tv378[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [edx+16]
	fstp	DWORD PTR tv381[ebp]
	fld	DWORD PTR tv381[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+12]
	fstp	DWORD PTR tv384[ebp]
	fld	DWORD PTR tv384[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN10@getPoint
$LN3@getPoint:

; 196  : 		case 6: return Vec3f(center.x - extent.x, center.y + extent.y, center.z + extent.z);

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+20]
	fstp	DWORD PTR tv394[ebp]
	fld	DWORD PTR tv394[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+16]
	fstp	DWORD PTR tv397[ebp]
	fld	DWORD PTR tv397[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR tv400[ebp]
	fld	DWORD PTR tv400[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN10@getPoint
$LN2@getPoint:

; 197  : 		case 7: return Vec3f(center.x + extent.x, center.y + extent.y, center.z + extent.z);

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+20]
	fstp	DWORD PTR tv410[ebp]
	fld	DWORD PTR tv410[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+16]
	fstp	DWORD PTR tv413[ebp]
	fld	DWORD PTR tv413[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+12]
	fstp	DWORD PTR tv416[ebp]
	fld	DWORD PTR tv416[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN10@getPoint
$LN1@getPoint:

; 198  : 		default: return ZEROVEC3F;

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN10@getPoint:

; 199  : 		}
; 200  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN14@getPoint:
	DD	$LN9@getPoint
	DD	$LN8@getPoint
	DD	$LN7@getPoint
	DD	$LN6@getPoint
	DD	$LN5@getPoint
	DD	$LN4@getPoint
	DD	$LN3@getPoint
	DD	$LN2@getPoint
?getPoint@Box@ozcollide@@QBE?AVVec3f@2@H@Z ENDP		; ozcollide::Box::getPoint
_TEXT	ENDS
PUBLIC	__real@3f13cd3a
PUBLIC	__real@bf13cd3a
;	COMDAT __real@3f13cd3a
CONST	SEGMENT
__real@3f13cd3a DD 03f13cd3ar			; 0.57735
CONST	ENDS
;	COMDAT __real@bf13cd3a
CONST	SEGMENT
__real@bf13cd3a DD 0bf13cd3ar			; -0.57735
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?getVertexNormal@Box@ozcollide@@SA?AVVec3f@2@H@Z
_TEXT	SEGMENT
tv64 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__index$ = 12						; size = 4
?getVertexNormal@Box@ozcollide@@SA?AVVec3f@2@H@Z PROC	; ozcollide::Box::getVertexNormal, COMDAT

; 203  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 204  : 		switch(_index) {

	mov	eax, DWORD PTR __index$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 7
	ja	$LN1@getVertexN
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN14@getVertexN[ecx*4]
$LN9@getVertexN:

; 205  : 		case 0: return Vec3f(-OZ_INVQSQR3, -OZ_INVQSQR3, -OZ_INVQSQR3);

	push	ecx
	fld	DWORD PTR __real@bf13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@bf13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@bf13cd3a
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN10@getVertexN
$LN8@getVertexN:

; 206  : 		case 1: return Vec3f(+OZ_INVQSQR3, -OZ_INVQSQR3, -OZ_INVQSQR3);

	push	ecx
	fld	DWORD PTR __real@bf13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@bf13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3f13cd3a
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN10@getVertexN
$LN7@getVertexN:

; 207  : 		case 2: return Vec3f(-OZ_INVQSQR3, +OZ_INVQSQR3, -OZ_INVQSQR3);

	push	ecx
	fld	DWORD PTR __real@bf13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3f13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@bf13cd3a
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN10@getVertexN
$LN6@getVertexN:

; 208  : 		case 3: return Vec3f(+OZ_INVQSQR3, +OZ_INVQSQR3, -OZ_INVQSQR3);

	push	ecx
	fld	DWORD PTR __real@bf13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3f13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3f13cd3a
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN10@getVertexN
$LN5@getVertexN:

; 209  : 		case 4: return Vec3f(-OZ_INVQSQR3, -OZ_INVQSQR3, +OZ_INVQSQR3);

	push	ecx
	fld	DWORD PTR __real@3f13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@bf13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@bf13cd3a
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN10@getVertexN
$LN4@getVertexN:

; 210  : 		case 5: return Vec3f(+OZ_INVQSQR3, -OZ_INVQSQR3, +OZ_INVQSQR3);

	push	ecx
	fld	DWORD PTR __real@3f13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@bf13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3f13cd3a
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN10@getVertexN
$LN3@getVertexN:

; 211  : 		case 6: return Vec3f(-OZ_INVQSQR3, +OZ_INVQSQR3, +OZ_INVQSQR3);

	push	ecx
	fld	DWORD PTR __real@3f13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3f13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@bf13cd3a
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN10@getVertexN
$LN2@getVertexN:

; 212  : 		case 7: return Vec3f(+OZ_INVQSQR3, +OZ_INVQSQR3, +OZ_INVQSQR3);

	push	ecx
	fld	DWORD PTR __real@3f13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3f13cd3a
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3f13cd3a
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN10@getVertexN
$LN1@getVertexN:

; 213  : 		default: return ZEROVEC3F;

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN10@getVertexN:

; 214  : 		}
; 215  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN14@getVertexN:
	DD	$LN9@getVertexN
	DD	$LN8@getVertexN
	DD	$LN7@getVertexN
	DD	$LN6@getVertexN
	DD	$LN5@getVertexN
	DD	$LN4@getVertexN
	DD	$LN3@getVertexN
	DD	$LN2@getVertexN
?getVertexNormal@Box@ozcollide@@SA?AVVec3f@2@H@Z ENDP	; ozcollide::Box::getVertexNormal
_TEXT	ENDS
PUBLIC	__real@bf800000
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?getFaceNormal@Box@ozcollide@@SA?AVVec3f@2@W4PLANE@2@@Z
_TEXT	SEGMENT
tv64 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__which$ = 12						; size = 4
?getFaceNormal@Box@ozcollide@@SA?AVVec3f@2@W4PLANE@2@@Z PROC ; ozcollide::Box::getFaceNormal, COMDAT

; 218  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 219  : 		switch(_which) {

	mov	eax, DWORD PTR __which$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 5
	ja	$LN1@getFaceNor
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN12@getFaceNor[ecx*4]
$LN7@getFaceNor:

; 220  : 			case 0: return Vec3f(-1,  0,  0);

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@bf800000
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN8@getFaceNor
$LN6@getFaceNor:

; 221  : 			case 1: return Vec3f( 1,  0,  0);

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN8@getFaceNor
$LN5@getFaceNor:

; 222  : 			case 2: return Vec3f( 0, -1,  0);

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@bf800000
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN8@getFaceNor
$LN4@getFaceNor:

; 223  : 			case 3: return Vec3f( 0,  1,  0);

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN8@getFaceNor
$LN3@getFaceNor:

; 224  : 			case 4: return Vec3f( 0,  0, -1);

	push	ecx
	fld	DWORD PTR __real@bf800000
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN8@getFaceNor
$LN2@getFaceNor:

; 225  : 			case 5: return Vec3f( 0,  0,  1);

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN8@getFaceNor
$LN1@getFaceNor:

; 226  : 			default: return ZEROVEC3F;

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN8@getFaceNor:

; 227  : 		}
; 228  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN12@getFaceNor:
	DD	$LN7@getFaceNor
	DD	$LN6@getFaceNor
	DD	$LN5@getFaceNor
	DD	$LN4@getFaceNor
	DD	$LN3@getFaceNor
	DD	$LN2@getFaceNor
?getFaceNormal@Box@ozcollide@@SA?AVVec3f@2@W4PLANE@2@@Z ENDP ; ozcollide::Box::getFaceNormal
_TEXT	ENDS
PUBLIC	??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z	; ozcollide::BoxEdge::BoxEdge
; Function compile flags: /Odtp
;	COMDAT ?getEdge@Box@ozcollide@@QBE?AVBoxEdge@2@H@Z
_TEXT	SEGMENT
tv136 = -344						; size = 4
_this$ = -340						; size = 4
$T7497 = -336						; size = 12
$T7496 = -324						; size = 12
$T7495 = -312						; size = 12
$T7494 = -300						; size = 12
$T7493 = -288						; size = 12
$T7492 = -276						; size = 12
$T7491 = -264						; size = 12
$T7490 = -252						; size = 12
$T7489 = -240						; size = 12
$T7488 = -228						; size = 12
$T7487 = -216						; size = 12
$T7486 = -204						; size = 12
$T7485 = -192						; size = 12
$T7484 = -180						; size = 12
$T7483 = -168						; size = 12
$T7482 = -156						; size = 12
$T7481 = -144						; size = 12
$T7480 = -132						; size = 12
$T7479 = -120						; size = 12
$T7478 = -108						; size = 12
$T7477 = -96						; size = 12
$T7476 = -84						; size = 12
$T7475 = -72						; size = 12
$T7474 = -60						; size = 12
$T7473 = -48						; size = 12
$T7472 = -36						; size = 12
_z1$ = -24						; size = 4
_x0$ = -20						; size = 4
_z0$ = -16						; size = 4
_x1$ = -12						; size = 4
_y1$ = -8						; size = 4
_y0$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__index$ = 12						; size = 4
?getEdge@Box@ozcollide@@QBE?AVBoxEdge@2@H@Z PROC	; ozcollide::Box::getEdge, COMDAT
; _this$ = ecx

; 246  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 		float x0 = center.x - extent.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _x0$[ebp]

; 248  : 		float y0 = center.y - extent.y;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [eax+16]
	fstp	DWORD PTR _y0$[ebp]

; 249  : 		float z0 = center.z - extent.z;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [edx+20]
	fstp	DWORD PTR _z0$[ebp]

; 250  : 		float x1 = center.x + extent.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+12]
	fstp	DWORD PTR _x1$[ebp]

; 251  : 		float y1 = center.y + extent.y;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+16]
	fstp	DWORD PTR _y1$[ebp]

; 252  : 		float z1 = center.z + extent.z;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+20]
	fstp	DWORD PTR _z1$[ebp]

; 253  : 
; 254  : 		switch(_index) {

	mov	eax, DWORD PTR __index$[ebp]
	mov	DWORD PTR tv136[ebp], eax
	cmp	DWORD PTR tv136[ebp], 11		; 0000000bH
	ja	$LN1@getEdge
	mov	ecx, DWORD PTR tv136[ebp]
	jmp	DWORD PTR $LN18@getEdge[ecx*4]
$LN13@getEdge:

; 255  : 			case 0: return BoxEdge(Vec3f(x0, y0, z0), Vec3f(x1, y0, z0));

	push	ecx
	fld	DWORD PTR _z0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7472[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	push	ecx
	fld	DWORD PTR _z0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7473[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z ; ozcollide::BoxEdge::BoxEdge
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN14@getEdge
$LN12@getEdge:

; 256  : 			case 1: return BoxEdge(Vec3f(x1, y0, z0), Vec3f(x1, y1, z0));

	push	ecx
	fld	DWORD PTR _z0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7474[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	push	ecx
	fld	DWORD PTR _z0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7475[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z ; ozcollide::BoxEdge::BoxEdge
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN14@getEdge
$LN11@getEdge:

; 257  : 			case 2: return BoxEdge(Vec3f(x1, y1, z0), Vec3f(x0, y1, z0));

	push	ecx
	fld	DWORD PTR _z0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7476[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	push	ecx
	fld	DWORD PTR _z0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7477[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z ; ozcollide::BoxEdge::BoxEdge
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN14@getEdge
$LN10@getEdge:

; 258  : 			case 3: return BoxEdge(Vec3f(x0, y1, z0), Vec3f(x0, y0, z0));

	push	ecx
	fld	DWORD PTR _z0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7478[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	push	ecx
	fld	DWORD PTR _z0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7479[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z ; ozcollide::BoxEdge::BoxEdge
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN14@getEdge
$LN9@getEdge:

; 259  : 
; 260  : 			case 4: return BoxEdge(Vec3f(x0, y0, z1), Vec3f(x1, y0, z1));

	push	ecx
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7480[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	push	ecx
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7481[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z ; ozcollide::BoxEdge::BoxEdge
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN14@getEdge
$LN8@getEdge:

; 261  : 			case 5: return BoxEdge(Vec3f(x1, y0, z1), Vec3f(x1, y1, z1));

	push	ecx
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7482[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	push	ecx
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7483[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z ; ozcollide::BoxEdge::BoxEdge
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN14@getEdge
$LN7@getEdge:

; 262  : 			case 6: return BoxEdge(Vec3f(x1, y1, z1), Vec3f(x0, y1, z1));

	push	ecx
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7484[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	push	ecx
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7485[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z ; ozcollide::BoxEdge::BoxEdge
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN14@getEdge
$LN6@getEdge:

; 263  : 			case 7: return BoxEdge(Vec3f(x0, y1, z1), Vec3f(x0, y0, z1));

	push	ecx
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7486[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	push	ecx
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7487[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z ; ozcollide::BoxEdge::BoxEdge
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN14@getEdge
$LN5@getEdge:

; 264  : 
; 265  : 			case 8: return BoxEdge(Vec3f(x0, y0, z0), Vec3f(x0, y0, z1));

	push	ecx
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7488[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	push	ecx
	fld	DWORD PTR _z0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7489[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z ; ozcollide::BoxEdge::BoxEdge
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN14@getEdge
$LN4@getEdge:

; 266  : 			case 9: return BoxEdge(Vec3f(x1, y0, z0), Vec3f(x1, y0, z1));

	push	ecx
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7490[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	push	ecx
	fld	DWORD PTR _z0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7491[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z ; ozcollide::BoxEdge::BoxEdge
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN14@getEdge
$LN3@getEdge:

; 267  : 			case 10: return BoxEdge(Vec3f(x1, y1, z0), Vec3f(x1, y1, z1));

	push	ecx
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7492[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	push	ecx
	fld	DWORD PTR _z0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7493[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z ; ozcollide::BoxEdge::BoxEdge
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN14@getEdge
$LN2@getEdge:

; 268  : 			case 11: return BoxEdge(Vec3f(x0, y1, z0), Vec3f(x0, y1, z1));

	push	ecx
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7494[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	push	ecx
	fld	DWORD PTR _z0$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x0$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7495[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z ; ozcollide::BoxEdge::BoxEdge
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN14@getEdge
$LN1@getEdge:

; 269  : 
; 270  : 			default: return BoxEdge(ZEROVEC3F, ZEROVEC3F);

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7496[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7497[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z ; ozcollide::BoxEdge::BoxEdge
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN14@getEdge:

; 271  : 		}
; 272  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN18@getEdge:
	DD	$LN13@getEdge
	DD	$LN12@getEdge
	DD	$LN11@getEdge
	DD	$LN10@getEdge
	DD	$LN9@getEdge
	DD	$LN8@getEdge
	DD	$LN7@getEdge
	DD	$LN6@getEdge
	DD	$LN5@getEdge
	DD	$LN4@getEdge
	DD	$LN3@getEdge
	DD	$LN2@getEdge
?getEdge@Box@ozcollide@@QBE?AVBoxEdge@2@H@Z ENDP	; ozcollide::Box::getEdge
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z PROC		; ozcollide::BoxEdge::BoxEdge, COMDAT
; _this$ = ecx

; 36   : 	BoxEdge(const Vec3f &a, const Vec3f &b) : p0(a) , p1(b) { };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0BoxEdge@ozcollide@@QAE@ABVVec3f@1@0@Z ENDP		; ozcollide::BoxEdge::BoxEdge
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END

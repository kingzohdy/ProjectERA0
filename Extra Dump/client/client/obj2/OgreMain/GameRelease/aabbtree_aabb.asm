; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\sdk\ozcollide\aabbtree_aabb.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG7219	DB	'AABB', 00H
	ORG $+3
$SG7222	DB	'NODS', 00H
	ORG $+3
$SG7241	DB	'LEFS', 00H
CONST	ENDS
PUBLIC	?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z ; ozcollide::AABBTreeAABB::loadBinary
PUBLIC	?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z ; ozcollide::AABBTreeAABB::loadBinary
EXTRN	?close@DataIn@ozcollide@@QAE_NXZ:PROC		; ozcollide::DataIn::close
EXTRN	??1DataIn@ozcollide@@UAE@XZ:PROC		; ozcollide::DataIn::~DataIn
EXTRN	?open@DataIn@ozcollide@@QAE_NPBD@Z:PROC		; ozcollide::DataIn::open
EXTRN	??0DataIn@ozcollide@@QAE@XZ:PROC		; ozcollide::DataIn::DataIn
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
xdata$x	SEGMENT
__unwindtable$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z$0
__ehfuncinfo$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtreeaabb_io.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T7561 = -56						; size = 4
$T7560 = -52						; size = 4
$T7559 = -48						; size = 4
_err$ = -44						; size = 4
_file$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
__fileName$ = 8						; size = 4
__tree$ = 12						; size = 4
?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z PROC ; ozcollide::AABBTreeAABB::loadBinary

; 5    : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 6    : 	DataIn file;

	lea	ecx, DWORD PTR _file$[ebp]
	call	??0DataIn@ozcollide@@QAE@XZ		; ozcollide::DataIn::DataIn
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 7    : 	ERR err;
; 8    : 	
; 9    : 	if (!file.open(_fileName))

	mov	eax, DWORD PTR __fileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?open@DataIn@ozcollide@@QAE_NPBD@Z	; ozcollide::DataIn::open
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@loadBinary

; 10   : 		return ERR_CANNOT_OPEN;

	mov	DWORD PTR $T7559[ebp], 17		; 00000011H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1DataIn@ozcollide@@UAE@XZ		; ozcollide::DataIn::~DataIn
	mov	eax, DWORD PTR $T7559[ebp]
	jmp	SHORT $LN3@loadBinary
$LN2@loadBinary:

; 11   : 
; 12   : 	err  = loadBinary(file, _tree);

	mov	edx, DWORD PTR __tree$[ebp]
	push	edx
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z ; ozcollide::AABBTreeAABB::loadBinary
	add	esp, 8
	mov	DWORD PTR _err$[ebp], eax

; 13   : 	if (err)

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN1@loadBinary

; 14   : 		return err;

	mov	ecx, DWORD PTR _err$[ebp]
	mov	DWORD PTR $T7560[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1DataIn@ozcollide@@UAE@XZ		; ozcollide::DataIn::~DataIn
	mov	eax, DWORD PTR $T7560[ebp]
	jmp	SHORT $LN3@loadBinary
$LN1@loadBinary:

; 15   : 
; 16   : 	file.close();

	lea	ecx, DWORD PTR _file$[ebp]
	call	?close@DataIn@ozcollide@@QAE_NXZ	; ozcollide::DataIn::close

; 17   : 	return NOERR;

	mov	DWORD PTR $T7561[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1DataIn@ozcollide@@UAE@XZ		; ozcollide::DataIn::~DataIn
	mov	eax, DWORD PTR $T7561[ebp]
$LN3@loadBinary:

; 18   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z$0:
	lea	ecx, DWORD PTR _file$[ebp]
	jmp	??1DataIn@ozcollide@@UAE@XZ		; ozcollide::DataIn::~DataIn
__ehhandler$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z ENDP ; ozcollide::AABBTreeAABB::loadBinary
PUBLIC	?readLEFSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z ; ozcollide::AABBTreeAABB::readLEFSchunk
PUBLIC	?readNODSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z ; ozcollide::AABBTreeAABB::readNODSchunk
PUBLIC	??0AABBTreeNode@ozcollide@@QAE@XZ		; ozcollide::AABBTreeNode::AABBTreeNode
PUBLIC	??1AABBTreeNode@ozcollide@@QAE@XZ		; ozcollide::AABBTreeNode::~AABBTreeNode
PUBLIC	??0AABBTreeAABBLeaf@ozcollide@@QAE@XZ		; ozcollide::AABBTreeAABBLeaf::AABBTreeAABBLeaf
PUBLIC	??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ		; ozcollide::AABBTreeAABBLeaf::~AABBTreeAABBLeaf
PUBLIC	??0AABBTreeAABB@ozcollide@@AAE@H@Z		; ozcollide::AABBTreeAABB::AABBTreeAABB
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	?seek@DataIn@ozcollide@@QAE_NH@Z:PROC		; ozcollide::DataIn::seek
EXTRN	?advance@DataIn@ozcollide@@QAE_NH@Z:PROC	; ozcollide::DataIn::advance
EXTRN	?tell@DataIn@ozcollide@@QBEHXZ:PROC		; ozcollide::DataIn::tell
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	?readByte@DataIn@ozcollide@@QAEDXZ:PROC		; ozcollide::DataIn::readByte
EXTRN	?readDword@DataIn@ozcollide@@QAEHXZ:PROC	; ozcollide::DataIn::readDword
EXTRN	?read@DataIn@ozcollide@@QAEHPAXH@Z:PROC		; ozcollide::DataIn::read
xdata$x	SEGMENT
__unwindtable$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z$2
__ehfuncinfo$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv184 = -104						; size = 4
tv157 = -100						; size = 4
tv134 = -96						; size = 4
$T7584 = -92						; size = 4
$T7583 = -88						; size = 4
$T7582 = -84						; size = 4
$T7579 = -80						; size = 4
$T7578 = -76						; size = 4
$T7577 = -72						; size = 4
$T7574 = -68						; size = 4
$T7573 = -64						; size = 4
_sc$7116 = -60						; size = 4
_pos0$7118 = -56					; size = 4
_scSize$7117 = -52					; size = 4
_pos1$7123 = -48					; size = 4
_id$7115 = -44						; size = 4
_chunkSize$ = -40					; size = 4
_t$ = -36						; size = 4
_leafDepth$ = -29					; size = 1
_nbNodes$ = -28						; size = 4
_chunk$ = -24						; size = 4
_nbLeafs$ = -20						; size = 4
_leafType$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
__file$ = 8						; size = 4
__tree$ = 12						; size = 4
?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z PROC ; ozcollide::AABBTreeAABB::loadBinary

; 21   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 22   : 	char chunk[4];
; 23   : 	int chunkSize;
; 24   : 
; 25   : 	_file.read(chunk, 4);

	push	4
	lea	eax, DWORD PTR _chunk$[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?read@DataIn@ozcollide@@QAEHPAXH@Z	; ozcollide::DataIn::read

; 26   : 	if (MID(chunk[0], chunk[1],chunk[2], chunk[3]) != MID('A', 'A', 'B', 'B'))

	movsx	ecx, BYTE PTR _chunk$[ebp+3]
	shl	ecx, 24					; 00000018H
	movsx	edx, BYTE PTR _chunk$[ebp+2]
	shl	edx, 16					; 00000010H
	add	ecx, edx
	movsx	eax, BYTE PTR _chunk$[ebp+1]
	shl	eax, 8
	add	ecx, eax
	movsx	edx, BYTE PTR _chunk$[ebp]
	add	ecx, edx
	cmp	ecx, 1111638337				; 42424141H
	je	SHORT $LN9@loadBinary@2

; 27   : 		return ERR_INVALID_FORMAT;

	mov	eax, 18					; 00000012H
	jmp	$LN10@loadBinary@2
$LN9@loadBinary@2:

; 28   : 
; 29   : 	chunkSize = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _chunkSize$[ebp], eax

; 30   : 
; 31   : 	char leafType = _file.readByte();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readByte@DataIn@ozcollide@@QAEDXZ	; ozcollide::DataIn::readByte
	mov	BYTE PTR _leafType$[ebp], al

; 32   : 
; 33   : 	if (leafType != 2)

	movsx	eax, BYTE PTR _leafType$[ebp]
	cmp	eax, 2
	je	SHORT $LN8@loadBinary@2

; 34   : 		return ERR_INVALID_FORMAT;

	mov	eax, 18					; 00000012H
	jmp	$LN10@loadBinary@2
$LN8@loadBinary@2:

; 35   : 
; 36   : 	char leafDepth = _file.readByte();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readByte@DataIn@ozcollide@@QAEDXZ	; ozcollide::DataIn::readByte
	mov	BYTE PTR _leafDepth$[ebp], al

; 37   : 	int nbNodes = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _nbNodes$[ebp], eax

; 38   : 	int nbLeafs = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _nbLeafs$[ebp], eax

; 39   : 
; 40   : 	AABBTreeAABB *t;
; 41   : 
; 42   : 	t = new AABBTreeAABB(leafDepth);

	push	120					; 00000078H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7574[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7574[ebp], 0
	je	SHORT $LN12@loadBinary@2
	movsx	ecx, BYTE PTR _leafDepth$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T7574[ebp]
	call	??0AABBTreeAABB@ozcollide@@AAE@H@Z	; ozcollide::AABBTreeAABB::AABBTreeAABB
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN13@loadBinary@2
$LN12@loadBinary@2:
	mov	DWORD PTR tv134[ebp], 0
$LN13@loadBinary@2:
	mov	edx, DWORD PTR tv134[ebp]
	mov	DWORD PTR $T7573[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T7573[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 43   : 	t->leafs_ = new AABBTreeAABBLeaf[nbLeafs];

	mov	ecx, DWORD PTR _nbLeafs$[ebp]
	mov	DWORD PTR $T7577[ebp], ecx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T7577[ebp]
	mov	edx, 44					; 0000002cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7579[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T7579[ebp], 0
	je	SHORT $LN14@loadBinary@2
	mov	ecx, DWORD PTR $T7579[ebp]
	mov	edx, DWORD PTR $T7577[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ
	push	OFFSET ??0AABBTreeAABBLeaf@ozcollide@@QAE@XZ ; ozcollide::AABBTreeAABBLeaf::AABBTreeAABBLeaf
	mov	eax, DWORD PTR $T7577[ebp]
	push	eax
	push	44					; 0000002cH
	mov	ecx, DWORD PTR $T7579[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T7579[ebp]
	add	edx, 4
	mov	DWORD PTR tv157[ebp], edx
	jmp	SHORT $LN15@loadBinary@2
$LN14@loadBinary@2:
	mov	DWORD PTR tv157[ebp], 0
$LN15@loadBinary@2:
	mov	eax, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T7578[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR $T7578[ebp]
	mov	DWORD PTR [ecx+36], edx

; 44   : 	t->root_ = new AABBTreeNode[nbNodes];

	mov	eax, DWORD PTR _nbNodes$[ebp]
	mov	DWORD PTR $T7582[ebp], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR $T7582[ebp]
	mov	edx, 32					; 00000020H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7584[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T7584[ebp], 0
	je	SHORT $LN16@loadBinary@2
	mov	ecx, DWORD PTR $T7584[ebp]
	mov	edx, DWORD PTR $T7582[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1AABBTreeNode@ozcollide@@QAE@XZ
	push	OFFSET ??0AABBTreeNode@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR $T7582[ebp]
	push	eax
	push	32					; 00000020H
	mov	ecx, DWORD PTR $T7584[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T7584[ebp]
	add	edx, 4
	mov	DWORD PTR tv184[ebp], edx
	jmp	SHORT $LN17@loadBinary@2
$LN16@loadBinary@2:
	mov	DWORD PTR tv184[ebp], 0
$LN17@loadBinary@2:
	mov	eax, DWORD PTR tv184[ebp]
	mov	DWORD PTR $T7583[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR $T7583[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN7@loadBinary@2:

; 45   : 
; 46   : 	while(chunkSize > 8) {

	cmp	DWORD PTR _chunkSize$[ebp], 8
	jle	$LN6@loadBinary@2

; 47   : 		char id[4];
; 48   : 		_file.read(id, 4);

	push	4
	lea	eax, DWORD PTR _id$7115[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?read@DataIn@ozcollide@@QAEHPAXH@Z	; ozcollide::DataIn::read

; 49   : 		int sc = MID(id[0], id[1], id[2], id[3]);

	movsx	ecx, BYTE PTR _id$7115[ebp+3]
	shl	ecx, 24					; 00000018H
	movsx	edx, BYTE PTR _id$7115[ebp+2]
	shl	edx, 16					; 00000010H
	add	ecx, edx
	movsx	eax, BYTE PTR _id$7115[ebp+1]
	shl	eax, 8
	add	ecx, eax
	movsx	edx, BYTE PTR _id$7115[ebp]
	add	ecx, edx
	mov	DWORD PTR _sc$7116[ebp], ecx

; 50   : 
; 51   : 		int scSize = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _scSize$7117[ebp], eax

; 52   : 		int pos0 = _file.tell();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?tell@DataIn@ozcollide@@QBEHXZ		; ozcollide::DataIn::tell
	mov	DWORD PTR _pos0$7118[ebp], eax

; 53   : 
; 54   : 		if (sc == MID('N','O','D','S'))

	cmp	DWORD PTR _sc$7116[ebp], 1396985678	; 53444f4eH
	jne	SHORT $LN5@loadBinary@2

; 55   : 			t->readNODSchunk(_file, scSize, nbNodes);

	mov	eax, DWORD PTR _nbNodes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _scSize$7117[ebp]
	push	ecx
	mov	edx, DWORD PTR __file$[ebp]
	push	edx
	mov	ecx, DWORD PTR _t$[ebp]
	call	?readNODSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z ; ozcollide::AABBTreeAABB::readNODSchunk
	jmp	SHORT $LN4@loadBinary@2
$LN5@loadBinary@2:

; 56   : 		else if (sc == MID('L','E','F','S'))

	cmp	DWORD PTR _sc$7116[ebp], 1397114188	; 5346454cH
	jne	SHORT $LN3@loadBinary@2

; 57   : 			t->readLEFSchunk(_file, scSize, nbLeafs);

	mov	eax, DWORD PTR _nbLeafs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _scSize$7117[ebp]
	push	ecx
	mov	edx, DWORD PTR __file$[ebp]
	push	edx
	mov	ecx, DWORD PTR _t$[ebp]
	call	?readLEFSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z ; ozcollide::AABBTreeAABB::readLEFSchunk

; 58   : 		else

	jmp	SHORT $LN4@loadBinary@2
$LN3@loadBinary@2:

; 59   : 			_file.advance(scSize);

	mov	eax, DWORD PTR _scSize$7117[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?advance@DataIn@ozcollide@@QAE_NH@Z	; ozcollide::DataIn::advance
$LN4@loadBinary@2:

; 60   : 
; 61   : 		int pos1 = _file.tell();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?tell@DataIn@ozcollide@@QBEHXZ		; ozcollide::DataIn::tell
	mov	DWORD PTR _pos1$7123[ebp], eax

; 62   : 		if (pos1 - pos0 != scSize)

	mov	ecx, DWORD PTR _pos1$7123[ebp]
	sub	ecx, DWORD PTR _pos0$7118[ebp]
	cmp	ecx, DWORD PTR _scSize$7117[ebp]
	je	SHORT $LN1@loadBinary@2

; 63   : 			_file.seek(pos0 + scSize);

	mov	edx, DWORD PTR _pos0$7118[ebp]
	add	edx, DWORD PTR _scSize$7117[ebp]
	push	edx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?seek@DataIn@ozcollide@@QAE_NH@Z	; ozcollide::DataIn::seek
$LN1@loadBinary@2:

; 64   : 		chunkSize -= scSize + 8;

	mov	eax, DWORD PTR _scSize$7117[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _chunkSize$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _chunkSize$[ebp], ecx

; 65   : 	}

	jmp	$LN7@loadBinary@2
$LN6@loadBinary@2:

; 66   : 
; 67   : 	*_tree = t;

	mov	edx, DWORD PTR __tree$[ebp]
	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR [edx], eax

; 68   : 
; 69   : 	return NOERR;

	xor	eax, eax
$LN10@loadBinary@2:

; 70   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z$0:
	mov	eax, DWORD PTR $T7574[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z$1:
	mov	eax, DWORD PTR $T7579[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z$2:
	mov	eax, DWORD PTR $T7584[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?loadBinary@AABBTreeAABB@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z ENDP ; ozcollide::AABBTreeAABB::loadBinary
PUBLIC	??_EAABBTreeAABBLeaf@ozcollide@@QAEPAXI@Z	; ozcollide::AABBTreeAABBLeaf::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_EAABBTreeAABBLeaf@ozcollide@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EAABBTreeAABBLeaf@ozcollide@@QAEPAXI@Z PROC		; ozcollide::AABBTreeAABBLeaf::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EAABBTreeAABBLeaf@ozcollide@@QAEPAXI@Z ENDP		; ozcollide::AABBTreeAABBLeaf::`vector deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ$0
__ehfuncinfo$??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ PROC		; ozcollide::AABBTreeAABBLeaf::~AABBTreeAABBLeaf, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AABBTreeNode@ozcollide@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1AABBTreeNode@ozcollide@@QAE@XZ
__ehhandler$??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AABBTreeAABBLeaf@ozcollide@@QAE@XZ ENDP		; ozcollide::AABBTreeAABBLeaf::~AABBTreeAABBLeaf
PUBLIC	??_EAABBTreeNode@ozcollide@@QAEPAXI@Z		; ozcollide::AABBTreeNode::`vector deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_EAABBTreeNode@ozcollide@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EAABBTreeNode@ozcollide@@QAEPAXI@Z PROC		; ozcollide::AABBTreeNode::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@2
	push	OFFSET ??1AABBTreeNode@ozcollide@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@2
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@2
$LN3@vector@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AABBTreeNode@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EAABBTreeNode@ozcollide@@QAEPAXI@Z ENDP		; ozcollide::AABBTreeNode::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1Box@ozcollide@@QAE@XZ			; ozcollide::Box::~Box
PUBLIC	??0Box@ozcollide@@QAE@XZ			; ozcollide::Box::Box
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0AABBTreeNode@ozcollide@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AABBTreeNode@ozcollide@@QAE@XZ$0
__ehfuncinfo$??0AABBTreeNode@ozcollide@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0AABBTreeNode@ozcollide@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0AABBTreeNode@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0AABBTreeNode@ozcollide@@QAE@XZ PROC			; ozcollide::AABBTreeNode::AABBTreeNode, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AABBTreeNode@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Box@ozcollide@@QAE@XZ		; ozcollide::Box::Box
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0AABBTreeNode@ozcollide@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
__ehhandler$??0AABBTreeNode@ozcollide@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AABBTreeNode@ozcollide@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AABBTreeNode@ozcollide@@QAE@XZ ENDP			; ozcollide::AABBTreeNode::AABBTreeNode
PUBLIC	??0Vec3f@ozcollide@@QAE@XZ			; ozcollide::Vec3f::Vec3f
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\box.h
;	COMDAT ??0Box@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Box@ozcollide@@QAE@XZ PROC				; ozcollide::Box::Box, COMDAT
; _this$ = ecx

; 44   : 	ozinline Box()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f

; 45   : 	{
; 46   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Box@ozcollide@@QAE@XZ ENDP				; ozcollide::Box::Box
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
_TEXT	ENDS
;	COMDAT ??0Vec3f@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vec3f@ozcollide@@QAE@XZ PROC				; ozcollide::Vec3f::Vec3f, COMDAT
; _this$ = ecx

; 37   : 	ozinline Vec3f()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 	{
; 39   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vec3f@ozcollide@@QAE@XZ ENDP				; ozcollide::Vec3f::Vec3f
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\box.h
_TEXT	ENDS
;	COMDAT ??1Box@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Box@ozcollide@@QAE@XZ PROC				; ozcollide::Box::~Box, COMDAT
; _this$ = ecx

; 53   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 54   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1Box@ozcollide@@QAE@XZ ENDP				; ozcollide::Box::~Box
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1AABBTreeNode@ozcollide@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1AABBTreeNode@ozcollide@@QAE@XZ$0
__ehfuncinfo$??1AABBTreeNode@ozcollide@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1AABBTreeNode@ozcollide@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1AABBTreeNode@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1AABBTreeNode@ozcollide@@QAE@XZ PROC			; ozcollide::AABBTreeNode::~AABBTreeNode, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1AABBTreeNode@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1AABBTreeNode@ozcollide@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
__ehhandler$??1AABBTreeNode@ozcollide@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1AABBTreeNode@ozcollide@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AABBTreeNode@ozcollide@@QAE@XZ ENDP			; ozcollide::AABBTreeNode::~AABBTreeNode
EXTRN	?readFloat@DataIn@ozcollide@@QAEMXZ:PROC	; ozcollide::DataIn::readFloat
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtreeaabb_io.cpp
_TEXT	SEGMENT
_this$ = -36						; size = 4
_index$7167 = -32					; size = 4
_isLeaf$7166 = -28					; size = 4
_index$7161 = -24					; size = 4
_isLeaf$7160 = -20					; size = 4
_node$7155 = -16					; size = 4
_leftID$7156 = -12					; size = 4
_rightID$7157 = -8					; size = 4
_i$ = -4						; size = 4
__file$ = 8						; size = 4
__chunkSize$ = 12					; size = 4
__nbNodes$ = 16						; size = 4
?readNODSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z PROC ; ozcollide::AABBTreeAABB::readNODSchunk
; _this$ = ecx

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 74   : 	int i;
; 75   : 
; 76   : 	for (i = 0; i < _nbNodes; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@readNODSch
$LN10@readNODSch:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@readNODSch:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR __nbNodes$[ebp]
	jge	$LN9@readNODSch

; 77   : 		AABBTreeNode &node = root_[i];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _node$7155[ebp], edx

; 78   : 
; 79   : 		node.aabb.center.x = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	ecx, DWORD PTR _node$7155[ebp]
	fstp	DWORD PTR [ecx]

; 80   : 		node.aabb.center.y = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	edx, DWORD PTR _node$7155[ebp]
	fstp	DWORD PTR [edx+4]

; 81   : 		node.aabb.center.z = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	eax, DWORD PTR _node$7155[ebp]
	fstp	DWORD PTR [eax+8]

; 82   : 		node.aabb.extent.x = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	ecx, DWORD PTR _node$7155[ebp]
	fstp	DWORD PTR [ecx+12]

; 83   : 		node.aabb.extent.y = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	edx, DWORD PTR _node$7155[ebp]
	fstp	DWORD PTR [edx+16]

; 84   : 		node.aabb.extent.z = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	eax, DWORD PTR _node$7155[ebp]
	fstp	DWORD PTR [eax+20]

; 85   : 
; 86   : 		int leftID = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _leftID$7156[ebp], eax

; 87   : 		int rightID = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _rightID$7157[ebp], eax

; 88   : 
; 89   : 		if (leftID == -1)

	cmp	DWORD PTR _leftID$7156[ebp], -1
	jne	SHORT $LN8@readNODSch

; 90   : 			node.left = NULL;

	mov	ecx, DWORD PTR _node$7155[ebp]
	mov	DWORD PTR [ecx+24], 0

; 91   : 		else {

	jmp	SHORT $LN5@readNODSch
$LN8@readNODSch:

; 92   : 			int isLeaf = leftID >> 31;

	mov	edx, DWORD PTR _leftID$7156[ebp]
	sar	edx, 31					; 0000001fH
	mov	DWORD PTR _isLeaf$7160[ebp], edx

; 93   : 			int index = leftID & 0x7fffffff;

	mov	eax, DWORD PTR _leftID$7156[ebp]
	and	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _index$7161[ebp], eax

; 94   : 			if (isLeaf)

	cmp	DWORD PTR _isLeaf$7160[ebp], 0
	je	SHORT $LN6@readNODSch

; 95   : 				node.left = &leafs_[index];

	mov	ecx, DWORD PTR _index$7161[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	eax, DWORD PTR _node$7155[ebp]
	mov	DWORD PTR [eax+24], ecx

; 96   : 			else

	jmp	SHORT $LN5@readNODSch
$LN6@readNODSch:

; 97   : 				node.left = &root_[index];

	mov	ecx, DWORD PTR _index$7161[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _node$7155[ebp]
	mov	DWORD PTR [eax+24], ecx
$LN5@readNODSch:

; 98   : 		}
; 99   : 
; 100  : 		if (rightID == -1)

	cmp	DWORD PTR _rightID$7157[ebp], -1
	jne	SHORT $LN4@readNODSch

; 101  : 			node.right = NULL;

	mov	ecx, DWORD PTR _node$7155[ebp]
	mov	DWORD PTR [ecx+28], 0

; 102  : 		else {

	jmp	SHORT $LN1@readNODSch
$LN4@readNODSch:

; 103  : 			int isLeaf = rightID >> 31;

	mov	edx, DWORD PTR _rightID$7157[ebp]
	sar	edx, 31					; 0000001fH
	mov	DWORD PTR _isLeaf$7166[ebp], edx

; 104  : 			int index = rightID & 0x7fffffff;

	mov	eax, DWORD PTR _rightID$7157[ebp]
	and	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _index$7167[ebp], eax

; 105  : 			if (isLeaf)

	cmp	DWORD PTR _isLeaf$7166[ebp], 0
	je	SHORT $LN2@readNODSch

; 106  : 				node.right = &leafs_[index];

	mov	ecx, DWORD PTR _index$7167[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	eax, DWORD PTR _node$7155[ebp]
	mov	DWORD PTR [eax+28], ecx

; 107  : 			else

	jmp	SHORT $LN1@readNODSch
$LN2@readNODSch:

; 108  : 				node.right = &root_[index];

	mov	ecx, DWORD PTR _index$7167[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _node$7155[ebp]
	mov	DWORD PTR [eax+28], ecx
$LN1@readNODSch:

; 109  : 		}

	jmp	$LN10@readNODSch
$LN9@readNODSch:

; 110  : 	}
; 111  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?readNODSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z ENDP ; ozcollide::AABBTreeAABB::readNODSchunk
_TEXT	ENDS
xdata$x	SEGMENT
__unwindtable$?readLEFSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readLEFSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z$0
__ehfuncinfo$?readLEFSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?readLEFSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv187 = -52						; size = 4
_this$ = -48						; size = 4
$T7636 = -44						; size = 4
$T7635 = -40						; size = 4
$T7634 = -36						; size = 4
_b$7193 = -32						; size = 4
_leaf$7181 = -28					; size = 4
_nbBoxes$7182 = -24					; size = 4
_j$ = -20						; size = 4
_i$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__file$ = 8						; size = 4
__chunkSize$ = 12					; size = 4
__nbLeafs$ = 16						; size = 4
?readLEFSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z PROC ; ozcollide::AABBTreeAABB::readLEFSchunk
; _this$ = ecx

; 114  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readLEFSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	int i, j;
; 116  : 
; 117  : 	for (i = 0; i < _nbLeafs; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@readLEFSch
$LN5@readLEFSch:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@readLEFSch:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR __nbLeafs$[ebp]
	jge	$LN4@readLEFSch

; 118  : 		AABBTreeAABBLeaf &leaf = leafs_[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _leaf$7181[ebp], edx

; 119  : 	
; 120  : 		leaf.aabb.center.x = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	ecx, DWORD PTR _leaf$7181[ebp]
	fstp	DWORD PTR [ecx]

; 121  : 		leaf.aabb.center.y = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	edx, DWORD PTR _leaf$7181[ebp]
	fstp	DWORD PTR [edx+4]

; 122  : 		leaf.aabb.center.z = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	eax, DWORD PTR _leaf$7181[ebp]
	fstp	DWORD PTR [eax+8]

; 123  : 		leaf.aabb.extent.x = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	ecx, DWORD PTR _leaf$7181[ebp]
	fstp	DWORD PTR [ecx+12]

; 124  : 		leaf.aabb.extent.y = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	edx, DWORD PTR _leaf$7181[ebp]
	fstp	DWORD PTR [edx+16]

; 125  : 		leaf.aabb.extent.z = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	eax, DWORD PTR _leaf$7181[ebp]
	fstp	DWORD PTR [eax+20]

; 126  : 
; 127  : 		leaf.left = NULL;

	mov	ecx, DWORD PTR _leaf$7181[ebp]
	mov	DWORD PTR [ecx+24], 0

; 128  : 		leaf.right = NULL;

	mov	edx, DWORD PTR _leaf$7181[ebp]
	mov	DWORD PTR [edx+28], 0

; 129  : 
; 130  : 		int nbBoxes = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _nbBoxes$7182[ebp], eax

; 131  : 		leaf.nbBoxes = nbBoxes;

	mov	eax, DWORD PTR _leaf$7181[ebp]
	mov	ecx, DWORD PTR _nbBoxes$7182[ebp]
	mov	DWORD PTR [eax+32], ecx

; 132  : 		leaf.boxes = new Box[nbBoxes];

	mov	edx, DWORD PTR _nbBoxes$7182[ebp]
	mov	DWORD PTR $T7634[ebp], edx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T7634[ebp]
	mov	edx, 24					; 00000018H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7636[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7636[ebp], 0
	je	SHORT $LN9@readLEFSch
	mov	ecx, DWORD PTR $T7636[ebp]
	mov	edx, DWORD PTR $T7634[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
	push	OFFSET ??0Box@ozcollide@@QAE@XZ		; ozcollide::Box::Box
	mov	eax, DWORD PTR $T7634[ebp]
	push	eax
	push	24					; 00000018H
	mov	ecx, DWORD PTR $T7636[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T7636[ebp]
	add	edx, 4
	mov	DWORD PTR tv187[ebp], edx
	jmp	SHORT $LN10@readLEFSch
$LN9@readLEFSch:
	mov	DWORD PTR tv187[ebp], 0
$LN10@readLEFSch:
	mov	eax, DWORD PTR tv187[ebp]
	mov	DWORD PTR $T7635[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _leaf$7181[ebp]
	mov	edx, DWORD PTR $T7635[ebp]
	mov	DWORD PTR [ecx+36], edx

; 133  : 		for (j = 0; j < nbBoxes; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@readLEFSch
$LN2@readLEFSch:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN3@readLEFSch:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _nbBoxes$7182[ebp]
	jge	SHORT $LN1@readLEFSch

; 134  : 			Box &b = (Box &) leaf.boxes[j];

	mov	edx, DWORD PTR _j$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _leaf$7181[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _b$7193[ebp], edx

; 135  : 			b.center.x = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	ecx, DWORD PTR _b$7193[ebp]
	fstp	DWORD PTR [ecx]

; 136  : 			b.center.y = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	edx, DWORD PTR _b$7193[ebp]
	fstp	DWORD PTR [edx+4]

; 137  : 			b.center.z = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	eax, DWORD PTR _b$7193[ebp]
	fstp	DWORD PTR [eax+8]

; 138  : 			b.extent.x = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	ecx, DWORD PTR _b$7193[ebp]
	fstp	DWORD PTR [ecx+12]

; 139  : 			b.extent.y = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	edx, DWORD PTR _b$7193[ebp]
	fstp	DWORD PTR [edx+16]

; 140  : 			b.extent.z = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	eax, DWORD PTR _b$7193[ebp]
	fstp	DWORD PTR [eax+20]

; 141  : 		}

	jmp	SHORT $LN2@readLEFSch
$LN1@readLEFSch:

; 142  : 	}

	jmp	$LN5@readLEFSch
$LN4@readLEFSch:

; 143  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?readLEFSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z$0:
	mov	eax, DWORD PTR $T7636[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?readLEFSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readLEFSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?readLEFSchunk@AABBTreeAABB@ozcollide@@AAEXAAVDataIn@2@HH@Z ENDP ; ozcollide::AABBTreeAABB::readLEFSchunk
PUBLIC	??_EBox@ozcollide@@QAEPAXI@Z			; ozcollide::Box::`vector deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_EBox@ozcollide@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EBox@ozcollide@@QAEPAXI@Z PROC			; ozcollide::Box::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@3
	push	OFFSET ??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@3
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@3
$LN3@vector@3:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@3:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EBox@ozcollide@@QAEPAXI@Z ENDP			; ozcollide::Box::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@PBD@Z ; ozcollide::AABBTreeAABB::saveBinary
EXTRN	?close@DataOut@ozcollide@@QAE_NXZ:PROC		; ozcollide::DataOut::close
EXTRN	??1DataOut@ozcollide@@UAE@XZ:PROC		; ozcollide::DataOut::~DataOut
EXTRN	?open@DataOut@ozcollide@@QAE_NPBD@Z:PROC	; ozcollide::DataOut::open
EXTRN	??0DataOut@ozcollide@@QAE@XZ:PROC		; ozcollide::DataOut::DataOut
xdata$x	SEGMENT
__unwindtable$?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@PBD@Z$0
__ehfuncinfo$?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T7649 = -44						; size = 4
$T7648 = -40						; size = 4
$T7647 = -36						; size = 4
_err$ = -32						; size = 4
_file$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
__fname$ = 8						; size = 4
?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@PBD@Z PROC ; ozcollide::AABBTreeAABB::saveBinary
; _this$ = ecx

; 146  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 	DataOut file;

	lea	ecx, DWORD PTR _file$[ebp]
	call	??0DataOut@ozcollide@@QAE@XZ		; ozcollide::DataOut::DataOut
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 148  : 	ERR err;
; 149  : 
; 150  : 	if (!file.open(_fname))

	mov	eax, DWORD PTR __fname$[ebp]
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?open@DataOut@ozcollide@@QAE_NPBD@Z	; ozcollide::DataOut::open
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@saveBinary

; 151  : 		return ERR_CANNOT_OPEN;

	mov	DWORD PTR $T7647[ebp], 17		; 00000011H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1DataOut@ozcollide@@UAE@XZ		; ozcollide::DataOut::~DataOut
	mov	eax, DWORD PTR $T7647[ebp]
	jmp	SHORT $LN3@saveBinary
$LN2@saveBinary:

; 152  : 
; 153  : 	err = saveBinary(file);

	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR _err$[ebp], eax

; 154  : 	if (err)

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN1@saveBinary

; 155  : 		return err;

	mov	ecx, DWORD PTR _err$[ebp]
	mov	DWORD PTR $T7648[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1DataOut@ozcollide@@UAE@XZ		; ozcollide::DataOut::~DataOut
	mov	eax, DWORD PTR $T7648[ebp]
	jmp	SHORT $LN3@saveBinary
$LN1@saveBinary:

; 156  : 
; 157  : 	file.close();

	lea	ecx, DWORD PTR _file$[ebp]
	call	?close@DataOut@ozcollide@@QAE_NXZ	; ozcollide::DataOut::close

; 158  : 	return NOERR;

	mov	DWORD PTR $T7649[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1DataOut@ozcollide@@UAE@XZ		; ozcollide::DataOut::~DataOut
	mov	eax, DWORD PTR $T7649[ebp]
$LN3@saveBinary:

; 159  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@PBD@Z$0:
	lea	ecx, DWORD PTR _file$[ebp]
	jmp	??1DataOut@ozcollide@@UAE@XZ		; ozcollide::DataOut::~DataOut
__ehhandler$?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@PBD@Z ENDP ; ozcollide::AABBTreeAABB::saveBinary
PUBLIC	?getNbLeafs@AABBTree@ozcollide@@QBEHXZ		; ozcollide::AABBTree::getNbLeafs
PUBLIC	?getNbNodes@AABBTree@ozcollide@@QBEHXZ		; ozcollide::AABBTree::getNbNodes
PUBLIC	?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@AAVDataOut@2@@Z ; ozcollide::AABBTreeAABB::saveBinary
EXTRN	?seek@DataOut@ozcollide@@QAE_NH@Z:PROC		; ozcollide::DataOut::seek
EXTRN	?writeFloat@DataOut@ozcollide@@QAEHM@Z:PROC	; ozcollide::DataOut::writeFloat
EXTRN	?writeDword@DataOut@ozcollide@@QAEHH@Z:PROC	; ozcollide::DataOut::writeDword
EXTRN	?writeByte@DataOut@ozcollide@@QAEHD@Z:PROC	; ozcollide::DataOut::writeByte
EXTRN	?advance@DataOut@ozcollide@@QAE_NH@Z:PROC	; ozcollide::DataOut::advance
EXTRN	?tell@DataOut@ozcollide@@QBEHXZ:PROC		; ozcollide::DataOut::tell
EXTRN	?writeStr@DataOut@ozcollide@@QAEHPBD@Z:PROC	; ozcollide::DataOut::writeStr
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -60						; size = 4
_b$7252 = -56						; size = 4
_leaf$7247 = -52					; size = 4
_nbBoxes$7248 = -48					; size = 4
_diff$7236 = -44					; size = 4
_diff$7230 = -40					; size = 4
_node$7226 = -36					; size = 4
_right$7228 = -32					; size = 4
_left$7227 = -28					; size = 4
_j$ = -24						; size = 4
_size$ = -20						; size = 4
_sizeLEFS$ = -16					; size = 4
_i$ = -12						; size = 4
_posLEFS$ = -8						; size = 4
_posBBT$ = -4						; size = 4
__file$ = 8						; size = 4
?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@AAVDataOut@2@@Z PROC ; ozcollide::AABBTreeAABB::saveBinary
; _this$ = ecx

; 162  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 163  : 	int i, j;
; 164  : 
; 165  : 	_file.writeStr("AABB");

	push	OFFSET $SG7219
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeStr@DataOut@ozcollide@@QAEHPBD@Z	; ozcollide::DataOut::writeStr

; 166  : 	int posBBT = _file.tell();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?tell@DataOut@ozcollide@@QBEHXZ		; ozcollide::DataOut::tell
	mov	DWORD PTR _posBBT$[ebp], eax

; 167  : 	_file.advance(4);

	push	4
	mov	ecx, DWORD PTR __file$[ebp]
	call	?advance@DataOut@ozcollide@@QAE_NH@Z	; ozcollide::DataOut::advance

; 168  : 
; 169  : 	int size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 170  : 
; 171  : 	size += _file.writeByte(2);

	push	2
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeByte@DataOut@ozcollide@@QAEHD@Z	; ozcollide::DataOut::writeByte
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 172  : 
; 173  : 	nbNodes_ = getNbNodes();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNbNodes@AABBTree@ozcollide@@QBEHXZ	; ozcollide::AABBTree::getNbNodes
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 174  : 	nbLeafs_ = getNbLeafs();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNbLeafs@AABBTree@ozcollide@@QBEHXZ	; ozcollide::AABBTree::getNbLeafs
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], eax

; 175  : 
; 176  : 	size += _file.writeByte(leafDepth_);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	push	ecx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeByte@DataOut@ozcollide@@QAEHD@Z	; ozcollide::DataOut::writeByte
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 177  : 	size += _file.writeDword(nbNodes_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 178  : 	size += _file.writeDword(nbLeafs_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 179  : 
; 180  : 	size += _file.writeStr("NODS");

	push	OFFSET $SG7222
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeStr@DataOut@ozcollide@@QAEHPBD@Z	; ozcollide::DataOut::writeStr
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 181  : 	size += _file.writeDword((24 + 8) * nbNodes_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 5
	push	ecx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 182  : 	for (i = 0; i < nbNodes_; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN17@saveBinary@2
$LN16@saveBinary@2:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN17@saveBinary@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	$LN15@saveBinary@2

; 183  : 		AABBTreeNode *node = &root_[i];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _node$7226[ebp], edx

; 184  : 		size += _file.writeFloat(node->aabb.center.x);

	mov	ecx, DWORD PTR _node$7226[ebp]
	push	ecx
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 185  : 		size += _file.writeFloat(node->aabb.center.y);

	mov	edx, DWORD PTR _node$7226[ebp]
	push	ecx
	fld	DWORD PTR [edx+4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 186  : 		size += _file.writeFloat(node->aabb.center.z);

	mov	eax, DWORD PTR _node$7226[ebp]
	push	ecx
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 187  : 		size += _file.writeFloat(node->aabb.extent.x);

	mov	ecx, DWORD PTR _node$7226[ebp]
	push	ecx
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 188  : 		size += _file.writeFloat(node->aabb.extent.y);

	mov	edx, DWORD PTR _node$7226[ebp]
	push	ecx
	fld	DWORD PTR [edx+16]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 189  : 		size += _file.writeFloat(node->aabb.extent.z);

	mov	eax, DWORD PTR _node$7226[ebp]
	push	ecx
	fld	DWORD PTR [eax+20]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 190  : 
; 191  : 		const AABBTreeNode *left = node->left;

	mov	ecx, DWORD PTR _node$7226[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _left$7227[ebp], edx

; 192  : 		const AABBTreeNode *right = node->right;

	mov	eax, DWORD PTR _node$7226[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _right$7228[ebp], ecx

; 193  : 
; 194  : 		if (left) {

	cmp	DWORD PTR _left$7227[ebp], 0
	je	SHORT $LN14@saveBinary@2

; 195  : 			int diff = left - root_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _left$7227[ebp]
	sub	eax, DWORD PTR [edx+8]
	sar	eax, 5
	mov	DWORD PTR _diff$7230[ebp], eax

; 196  : 			if (diff < 0 || diff >= nbNodes_) {

	cmp	DWORD PTR _diff$7230[ebp], 0
	jl	SHORT $LN12@saveBinary@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _diff$7230[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN13@saveBinary@2
$LN12@saveBinary@2:

; 197  : 				diff = ((AABBTreeAABBLeaf*) left) - leafs_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _left$7227[ebp]
	sub	ecx, DWORD PTR [eax+36]
	mov	eax, ecx
	cdq
	mov	ecx, 44					; 0000002cH
	idiv	ecx
	mov	DWORD PTR _diff$7230[ebp], eax

; 198  : 				diff |= 0x80000000;

	mov	edx, DWORD PTR _diff$7230[ebp]
	or	edx, -2147483648			; 80000000H
	mov	DWORD PTR _diff$7230[ebp], edx
$LN13@saveBinary@2:

; 199  : 			}
; 200  : 			size += _file.writeDword(diff);

	mov	eax, DWORD PTR _diff$7230[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 201  : 		}
; 202  : 		else

	jmp	SHORT $LN11@saveBinary@2
$LN14@saveBinary@2:

; 203  : 			size += _file.writeDword(-1);

	push	-1
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax
$LN11@saveBinary@2:

; 204  : 
; 205  : 		if (right) {

	cmp	DWORD PTR _right$7228[ebp], 0
	je	SHORT $LN10@saveBinary@2

; 206  : 			int diff = right - root_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _right$7228[ebp]
	sub	edx, DWORD PTR [ecx+8]
	sar	edx, 5
	mov	DWORD PTR _diff$7236[ebp], edx

; 207  : 			if (diff < 0 || diff >= nbNodes_) {

	cmp	DWORD PTR _diff$7236[ebp], 0
	jl	SHORT $LN8@saveBinary@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _diff$7236[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN9@saveBinary@2
$LN8@saveBinary@2:

; 208  : 				diff = ((AABBTreeAABBLeaf*) right) - leafs_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _right$7228[ebp]
	sub	eax, DWORD PTR [edx+36]
	cdq
	mov	ecx, 44					; 0000002cH
	idiv	ecx
	mov	DWORD PTR _diff$7236[ebp], eax

; 209  : 				diff |= 0x80000000;

	mov	edx, DWORD PTR _diff$7236[ebp]
	or	edx, -2147483648			; 80000000H
	mov	DWORD PTR _diff$7236[ebp], edx
$LN9@saveBinary@2:

; 210  : 			}
; 211  : 			size += _file.writeDword(diff);

	mov	eax, DWORD PTR _diff$7236[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 212  : 		}
; 213  : 		else

	jmp	SHORT $LN7@saveBinary@2
$LN10@saveBinary@2:

; 214  : 			size += _file.writeDword(-1);

	push	-1
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax
$LN7@saveBinary@2:

; 215  : 	}

	jmp	$LN16@saveBinary@2
$LN15@saveBinary@2:

; 216  : 
; 217  : 	size += _file.writeStr("LEFS");

	push	OFFSET $SG7241
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeStr@DataOut@ozcollide@@QAEHPBD@Z	; ozcollide::DataOut::writeStr
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 218  : 	int posLEFS = _file.tell();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?tell@DataOut@ozcollide@@QBEHXZ		; ozcollide::DataOut::tell
	mov	DWORD PTR _posLEFS$[ebp], eax

; 219  : 	_file.advance(4);

	push	4
	mov	ecx, DWORD PTR __file$[ebp]
	call	?advance@DataOut@ozcollide@@QAE_NH@Z	; ozcollide::DataOut::advance

; 220  : 	int sizeLEFS = 0;

	mov	DWORD PTR _sizeLEFS$[ebp], 0

; 221  : 	for (i = 0; i < nbLeafs_; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@saveBinary@2
$LN5@saveBinary@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@saveBinary@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jge	$LN4@saveBinary@2

; 222  : 		AABBTreeAABBLeaf *leaf = &leafs_[i];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR _leaf$7247[ebp], ecx

; 223  : 
; 224  : 		_file.writeFloat(leaf->aabb.center.x);

	mov	eax, DWORD PTR _leaf$7247[ebp]
	push	ecx
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 225  : 		_file.writeFloat(leaf->aabb.center.y);

	mov	ecx, DWORD PTR _leaf$7247[ebp]
	push	ecx
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 226  : 		_file.writeFloat(leaf->aabb.center.z);

	mov	edx, DWORD PTR _leaf$7247[ebp]
	push	ecx
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 227  : 		_file.writeFloat(leaf->aabb.extent.x);

	mov	eax, DWORD PTR _leaf$7247[ebp]
	push	ecx
	fld	DWORD PTR [eax+12]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 228  : 		_file.writeFloat(leaf->aabb.extent.y);

	mov	ecx, DWORD PTR _leaf$7247[ebp]
	push	ecx
	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 229  : 		_file.writeFloat(leaf->aabb.extent.z);

	mov	edx, DWORD PTR _leaf$7247[ebp]
	push	ecx
	fld	DWORD PTR [edx+20]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 230  : 		size += 24;		sizeLEFS += 24;

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR _size$[ebp], eax
	mov	ecx, DWORD PTR _sizeLEFS$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR _sizeLEFS$[ebp], ecx

; 231  : 
; 232  : 		_file.writeDword(leaf->nbBoxes);

	mov	edx, DWORD PTR _leaf$7247[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 233  : 		size += 4;		sizeLEFS += 4;

	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 4
	mov	DWORD PTR _size$[ebp], ecx
	mov	edx, DWORD PTR _sizeLEFS$[ebp]
	add	edx, 4
	mov	DWORD PTR _sizeLEFS$[ebp], edx

; 234  : 
; 235  : 		int nbBoxes = leaf->nbBoxes;

	mov	eax, DWORD PTR _leaf$7247[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _nbBoxes$7248[ebp], ecx

; 236  : 		for (j = 0; j < nbBoxes; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@saveBinary@2
$LN2@saveBinary@2:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN3@saveBinary@2:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _nbBoxes$7248[ebp]
	jge	SHORT $LN1@saveBinary@2

; 237  : 			const Box &b = leaf->boxes[j];

	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _leaf$7247[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR _b$7252[ebp], ecx

; 238  : 			_file.writeFloat(b.center.x);

	mov	eax, DWORD PTR _b$7252[ebp]
	push	ecx
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 239  : 			_file.writeFloat(b.center.y);

	mov	ecx, DWORD PTR _b$7252[ebp]
	push	ecx
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 240  : 			_file.writeFloat(b.center.z);

	mov	edx, DWORD PTR _b$7252[ebp]
	push	ecx
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 241  : 			_file.writeFloat(b.extent.x);

	mov	eax, DWORD PTR _b$7252[ebp]
	push	ecx
	fld	DWORD PTR [eax+12]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 242  : 			_file.writeFloat(b.extent.y);

	mov	ecx, DWORD PTR _b$7252[ebp]
	push	ecx
	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 243  : 			_file.writeFloat(b.extent.z);

	mov	edx, DWORD PTR _b$7252[ebp]
	push	ecx
	fld	DWORD PTR [edx+20]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 244  : 		}

	jmp	$LN2@saveBinary@2
$LN1@saveBinary@2:

; 245  : 		size += nbBoxes * 24;

	mov	eax, DWORD PTR _nbBoxes$7248[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 246  : 		sizeLEFS += nbBoxes * 24;

	mov	ecx, DWORD PTR _nbBoxes$7248[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR _sizeLEFS$[ebp]
	mov	DWORD PTR _sizeLEFS$[ebp], ecx

; 247  : 	}

	jmp	$LN5@saveBinary@2
$LN4@saveBinary@2:

; 248  : 
; 249  : 	_file.seek(posLEFS);

	mov	edx, DWORD PTR _posLEFS$[ebp]
	push	edx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?seek@DataOut@ozcollide@@QAE_NH@Z	; ozcollide::DataOut::seek

; 250  : 	_file.writeDword(sizeLEFS);

	mov	eax, DWORD PTR _sizeLEFS$[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 251  : 
; 252  : 	_file.seek(posBBT);

	mov	ecx, DWORD PTR _posBBT$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?seek@DataOut@ozcollide@@QAE_NH@Z	; ozcollide::DataOut::seek

; 253  : 	_file.writeDword(size);

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 254  : 
; 255  : 	return NOERR;

	xor	eax, eax

; 256  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@AAVDataOut@2@@Z ENDP ; ozcollide::AABBTreeAABB::saveBinary
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtree.h
_TEXT	ENDS
;	COMDAT ?getNbNodes@AABBTree@ozcollide@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNbNodes@AABBTree@ozcollide@@QBEHXZ PROC		; ozcollide::AABBTree::getNbNodes, COMDAT
; _this$ = ecx

; 80   : 	ozinline int getNbNodes() const { return nbNodes_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?getNbNodes@AABBTree@ozcollide@@QBEHXZ ENDP		; ozcollide::AABBTree::getNbNodes
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getNbLeafs@AABBTree@ozcollide@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNbLeafs@AABBTree@ozcollide@@QBEHXZ PROC		; ozcollide::AABBTree::getNbLeafs, COMDAT
; _this$ = ecx

; 81   : 	ozinline int getNbLeafs() const { return nbLeafs_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?getNbLeafs@AABBTree@ozcollide@@QBEHXZ ENDP		; ozcollide::AABBTree::getNbLeafs
_TEXT	ENDS
PUBLIC	??0Sphere@ozcollide@@QAE@XZ			; ozcollide::Sphere::Sphere
PUBLIC	??_7AABBTreeAABB@ozcollide@@6B@			; ozcollide::AABBTreeAABB::`vftable'
PUBLIC	??_R4AABBTreeAABB@ozcollide@@6B@		; ozcollide::AABBTreeAABB::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVAABBTreeAABB@ozcollide@@@8		; ozcollide::AABBTreeAABB `RTTI Type Descriptor'
PUBLIC	??_R3AABBTreeAABB@ozcollide@@8			; ozcollide::AABBTreeAABB::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AABBTreeAABB@ozcollide@@8			; ozcollide::AABBTreeAABB::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@AABBTreeAABB@ozcollide@@8		; ozcollide::AABBTreeAABB::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@AABBTree@ozcollide@@8		; ozcollide::AABBTree::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVAABBTree@ozcollide@@@8			; ozcollide::AABBTree `RTTI Type Descriptor'
PUBLIC	??_R3AABBTree@ozcollide@@8			; ozcollide::AABBTree::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AABBTree@ozcollide@@8			; ozcollide::AABBTree::`RTTI Base Class Array'
PUBLIC	?scale@AABBTreeAABB@ozcollide@@UAEXM@Z		; ozcollide::AABBTreeAABB::scale
PUBLIC	?getMemoryConsumption@AABBTreeAABB@ozcollide@@UBEHXZ ; ozcollide::AABBTreeAABB::getMemoryConsumption
EXTRN	??1AABBTree@ozcollide@@EAE@XZ:PROC		; ozcollide::AABBTree::~AABBTree
EXTRN	??0AABBTree@ozcollide@@AAE@W4AABBTREE_LEAFTYPE@1@H@Z:PROC ; ozcollide::AABBTree::AABBTree
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EAABBTreeAABB@ozcollide@@EAEPAXI@Z:PROC	; ozcollide::AABBTreeAABB::`vector deleting destructor'
;	COMDAT ??_R2AABBTree@ozcollide@@8
; File i:\svnroot\client\sdk\ozcollide\aabbtree_aabb.cpp
rdata$r	SEGMENT
??_R2AABBTree@ozcollide@@8 DD FLAT:??_R1A@?0A@EA@AABBTree@ozcollide@@8 ; ozcollide::AABBTree::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3AABBTree@ozcollide@@8
rdata$r	SEGMENT
??_R3AABBTree@ozcollide@@8 DD 00H			; ozcollide::AABBTree::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2AABBTree@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAABBTree@ozcollide@@@8
_DATA	SEGMENT
??_R0?AVAABBTree@ozcollide@@@8 DD FLAT:??_7type_info@@6B@ ; ozcollide::AABBTree `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAABBTree@ozcollide@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@AABBTree@ozcollide@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AABBTree@ozcollide@@8 DD FLAT:??_R0?AVAABBTree@ozcollide@@@8 ; ozcollide::AABBTree::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AABBTree@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@AABBTreeAABB@ozcollide@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AABBTreeAABB@ozcollide@@8 DD FLAT:??_R0?AVAABBTreeAABB@ozcollide@@@8 ; ozcollide::AABBTreeAABB::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AABBTreeAABB@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_R2AABBTreeAABB@ozcollide@@8
rdata$r	SEGMENT
??_R2AABBTreeAABB@ozcollide@@8 DD FLAT:??_R1A@?0A@EA@AABBTreeAABB@ozcollide@@8 ; ozcollide::AABBTreeAABB::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@AABBTree@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_R3AABBTreeAABB@ozcollide@@8
rdata$r	SEGMENT
??_R3AABBTreeAABB@ozcollide@@8 DD 00H			; ozcollide::AABBTreeAABB::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2AABBTreeAABB@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAABBTreeAABB@ozcollide@@@8
_DATA	SEGMENT
??_R0?AVAABBTreeAABB@ozcollide@@@8 DD FLAT:??_7type_info@@6B@ ; ozcollide::AABBTreeAABB `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAABBTreeAABB@ozcollide@@', 00H
_DATA	ENDS
;	COMDAT ??_R4AABBTreeAABB@ozcollide@@6B@
rdata$r	SEGMENT
??_R4AABBTreeAABB@ozcollide@@6B@ DD 00H			; ozcollide::AABBTreeAABB::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVAABBTreeAABB@ozcollide@@@8
	DD	FLAT:??_R3AABBTreeAABB@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_7AABBTreeAABB@ozcollide@@6B@
CONST	SEGMENT
??_7AABBTreeAABB@ozcollide@@6B@ DD FLAT:??_R4AABBTreeAABB@ozcollide@@6B@ ; ozcollide::AABBTreeAABB::`vftable'
	DD	FLAT:??_EAABBTreeAABB@ozcollide@@EAEPAXI@Z
	DD	FLAT:?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@AAVDataOut@2@@Z
	DD	FLAT:?saveBinary@AABBTreeAABB@ozcollide@@UAE?AW4ERR@2@PBD@Z
	DD	FLAT:?scale@AABBTreeAABB@ozcollide@@UAEXM@Z
	DD	FLAT:?getMemoryConsumption@AABBTreeAABB@ozcollide@@UBEHXZ
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0AABBTreeAABB@ozcollide@@AAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AABBTreeAABB@ozcollide@@AAE@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0AABBTreeAABB@ozcollide@@AAE@H@Z$1
__ehfuncinfo$??0AABBTreeAABB@ozcollide@@AAE@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0AABBTreeAABB@ozcollide@@AAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__leafDepth$ = 8					; size = 4
??0AABBTreeAABB@ozcollide@@AAE@H@Z PROC			; ozcollide::AABBTreeAABB::AABBTreeAABB
; _this$ = ecx

; 34   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AABBTreeAABB@ozcollide@@AAE@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __leafDepth$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0AABBTree@ozcollide@@AAE@W4AABBTREE_LEAFTYPE@1@H@Z ; ozcollide::AABBTree::AABBTree
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7AABBTreeAABB@ozcollide@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	??0Box@ozcollide@@QAE@XZ		; ozcollide::Box::Box
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0Sphere@ozcollide@@QAE@XZ		; ozcollide::Sphere::Sphere

; 35   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0AABBTreeAABB@ozcollide@@AAE@H@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1AABBTree@ozcollide@@EAE@XZ		; ozcollide::AABBTree::~AABBTree
__unwindfunclet$??0AABBTreeAABB@ozcollide@@AAE@H@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	jmp	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
__ehhandler$??0AABBTreeAABB@ozcollide@@AAE@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AABBTreeAABB@ozcollide@@AAE@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AABBTreeAABB@ozcollide@@AAE@H@Z ENDP			; ozcollide::AABBTreeAABB::AABBTreeAABB
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\sphere.h
;	COMDAT ??0Sphere@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Sphere@ozcollide@@QAE@XZ PROC			; ozcollide::Sphere::Sphere, COMDAT
; _this$ = ecx

; 36   : 	Sphere() { };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Sphere@ozcollide@@QAE@XZ ENDP			; ozcollide::Sphere::Sphere
_TEXT	ENDS
PUBLIC	??1AABBTreeAABB@ozcollide@@EAE@XZ		; ozcollide::AABBTreeAABB::~AABBTreeAABB
; Function compile flags: /Odtp
;	COMDAT ??_GAABBTreeAABB@ozcollide@@EAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GAABBTreeAABB@ozcollide@@EAEPAXI@Z PROC		; ozcollide::AABBTreeAABB::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AABBTreeAABB@ozcollide@@EAE@XZ	; ozcollide::AABBTreeAABB::~AABBTreeAABB
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GAABBTreeAABB@ozcollide@@EAEPAXI@Z ENDP		; ozcollide::AABBTreeAABB::`scalar deleting destructor'
_TEXT	ENDS
xdata$x	SEGMENT
__unwindtable$??1AABBTreeAABB@ozcollide@@EAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1AABBTreeAABB@ozcollide@@EAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1AABBTreeAABB@ozcollide@@EAE@XZ$1
__ehfuncinfo$??1AABBTreeAABB@ozcollide@@EAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1AABBTreeAABB@ozcollide@@EAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtree_aabb.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1AABBTreeAABB@ozcollide@@EAE@XZ PROC			; ozcollide::AABBTreeAABB::~AABBTreeAABB
; _this$ = ecx

; 38   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1AABBTreeAABB@ozcollide@@EAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7AABBTreeAABB@ozcollide@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 39   : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AABBTree@ozcollide@@EAE@XZ		; ozcollide::AABBTree::~AABBTree
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1AABBTreeAABB@ozcollide@@EAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1AABBTree@ozcollide@@EAE@XZ		; ozcollide::AABBTree::~AABBTree
__unwindfunclet$??1AABBTreeAABB@ozcollide@@EAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	jmp	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
__ehhandler$??1AABBTreeAABB@ozcollide@@EAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1AABBTreeAABB@ozcollide@@EAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AABBTreeAABB@ozcollide@@EAE@XZ ENDP			; ozcollide::AABBTreeAABB::~AABBTreeAABB
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_size$ = -4						; size = 4
?getMemoryConsumption@AABBTreeAABB@ozcollide@@UBEHXZ PROC ; ozcollide::AABBTreeAABB::getMemoryConsumption
; _this$ = ecx

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 	int size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 44   : 	size += getNbNodes() * sizeof(AABBTreeNode);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNbNodes@AABBTree@ozcollide@@QBEHXZ	; ozcollide::AABBTree::getNbNodes
	shl	eax, 5
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 45   : 	size += getNbLeafs() * sizeof(AABBTreeAABBLeaf);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNbLeafs@AABBTree@ozcollide@@QBEHXZ	; ozcollide::AABBTree::getNbLeafs
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 46   : 
; 47   : 	size += sizeof *this;

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 120				; 00000078H
	mov	DWORD PTR _size$[ebp], eax

; 48   : 
; 49   : 	return size;

	mov	eax, DWORD PTR _size$[ebp]

; 50   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getMemoryConsumption@AABBTreeAABB@ozcollide@@UBEHXZ ENDP ; ozcollide::AABBTreeAABB::getMemoryConsumption
_TEXT	ENDS
PUBLIC	?isCollideWithBox@AABBTreeAABB@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreeAABB::isCollideWithBox
PUBLIC	?isCollideWithBox@AABBTreeAABB@ozcollide@@QAE_NABVBox@2@@Z ; ozcollide::AABBTreeAABB::isCollideWithBox
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__box$ = 8						; size = 4
?isCollideWithBox@AABBTreeAABB@ozcollide@@QAE_NABVBox@2@@Z PROC ; ozcollide::AABBTreeAABB::isCollideWithBox
; _this$ = ecx

; 55   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 	nbColls_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], 0

; 57   : 	box_ = _box;

	mov	ecx, DWORD PTR __box$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 52					; 00000034H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx

; 58   : 	colRes_ = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0

; 59   : 	return isCollideWithBox(*root_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithBox@AABBTreeAABB@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreeAABB::isCollideWithBox

; 60   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isCollideWithBox@AABBTreeAABB@ozcollide@@QAE_NABVBox@2@@Z ENDP ; ozcollide::AABBTreeAABB::isCollideWithBox
_TEXT	ENDS
PUBLIC	?resize@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Box const *>::resize
PUBLIC	?isOverlap@Box@ozcollide@@QBE_NABV12@@Z		; ozcollide::Box::isOverlap
PUBLIC	??A?$Vector@PBVBox@ozcollide@@@ozcollide@@QBEAAPBVBox@1@H@Z ; ozcollide::Vector<ozcollide::Box const *>::operator[]
PUBLIC	?size@?$Vector@PBVBox@ozcollide@@@ozcollide@@QBEHXZ ; ozcollide::Vector<ozcollide::Box const *>::size
PUBLIC	?isCollideWithBox@AABBTreeAABB@ozcollide@@QAE_NABVBox@2@AAVBoxColResult@12@@Z ; ozcollide::AABBTreeAABB::isCollideWithBox
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__box$ = 8						; size = 4
__cr$ = 12						; size = 4
?isCollideWithBox@AABBTreeAABB@ozcollide@@QAE_NABVBox@2@AAVBoxColResult@12@@Z PROC ; ozcollide::AABBTreeAABB::isCollideWithBox
; _this$ = ecx

; 63   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 64   : 	if (bUseTemporalCoherence_ && _cr.boxes_.size() != 0) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN2@isCollideW
	mov	ecx, DWORD PTR __cr$[ebp]
	call	?size@?$Vector@PBVBox@ozcollide@@@ozcollide@@QBEHXZ ; ozcollide::Vector<ozcollide::Box const *>::size
	test	eax, eax
	je	SHORT $LN2@isCollideW

; 65   : 		if (_box.isOverlap(*_cr.boxes_[0])) {

	push	0
	mov	ecx, DWORD PTR __cr$[ebp]
	call	??A?$Vector@PBVBox@ozcollide@@@ozcollide@@QBEAAPBVBox@1@H@Z ; ozcollide::Vector<ozcollide::Box const *>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR __box$[ebp]
	call	?isOverlap@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isOverlap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@isCollideW

; 66   : 			nbColls_ = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+116], 1

; 67   : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@isCollideW
$LN2@isCollideW:

; 68   : 		}
; 69   : 	}
; 70   : 
; 71   : 	colRes_ = &_cr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __cr$[ebp]
	mov	DWORD PTR [edx+48], eax

; 72   : 	colRes_->boxQuery_ = _box;

	mov	ecx, DWORD PTR __box$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	add	eax, 24					; 00000018H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx

; 73   : 	colRes_->boxes_.resize(0);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?resize@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Box const *>::resize

; 74   : 	return isCollideWithBox(*root_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithBox@AABBTreeAABB@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreeAABB::isCollideWithBox
$LN3@isCollideW:

; 75   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?isCollideWithBox@AABBTreeAABB@ozcollide@@QAE_NABVBox@2@AAVBoxColResult@12@@Z ENDP ; ozcollide::AABBTreeAABB::isCollideWithBox
_TEXT	ENDS
PUBLIC	?isOverlapOnZ@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isOverlapOnZ
PUBLIC	?isOverlapOnY@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isOverlapOnY
PUBLIC	?isOverlapOnX@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isOverlapOnX
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\box.h
;	COMDAT ?isOverlap@Box@ozcollide@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__box$ = 8						; size = 4
?isOverlap@Box@ozcollide@@QBE_NABV12@@Z PROC		; ozcollide::Box::isOverlap, COMDAT
; _this$ = ecx

; 85   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 		if (isOverlapOnX(_box) &&
; 87   : 			isOverlapOnY(_box) &&
; 88   : 			isOverlapOnZ(_box))

	mov	eax, DWORD PTR __box$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOverlapOnX@Box@ozcollide@@QBE_NABV12@@Z ; ozcollide::Box::isOverlapOnX
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@isOverlap
	mov	edx, DWORD PTR __box$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOverlapOnY@Box@ozcollide@@QBE_NABV12@@Z ; ozcollide::Box::isOverlapOnY
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@isOverlap
	mov	ecx, DWORD PTR __box$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOverlapOnZ@Box@ozcollide@@QBE_NABV12@@Z ; ozcollide::Box::isOverlapOnZ
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@isOverlap

; 89   : 			return true;

	mov	al, 1
	jmp	SHORT $LN2@isOverlap
$LN1@isOverlap:

; 90   : 
; 91   : 		return false;

	xor	al, al
$LN2@isOverlap:

; 92   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?isOverlap@Box@ozcollide@@QBE_NABV12@@Z ENDP		; ozcollide::Box::isOverlap
_TEXT	ENDS
PUBLIC	__real@0000000000000000
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?isOverlapOnX@Box@ozcollide@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_t$ = -8						; size = 4
_ext$ = -4						; size = 4
__box$ = 8						; size = 4
?isOverlapOnX@Box@ozcollide@@QBE_NABV12@@Z PROC		; ozcollide::Box::isOverlapOnX, COMDAT
; _this$ = ecx

; 96   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 97   : 		float t = _box.center.x - center.x;

	mov	eax, DWORD PTR __box$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _t$[ebp]

; 98   : 		if (t < 0) t = -t;

	fld	DWORD PTR _t$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@isOverlapO
	fld	DWORD PTR _t$[ebp]
	fchs
	fstp	DWORD PTR _t$[ebp]
$LN2@isOverlapO:

; 99   : 
; 100  : 		float ext = _box.extent.x + extent.x;

	mov	edx, DWORD PTR __box$[ebp]
	fld	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+12]
	fstp	DWORD PTR _ext$[ebp]

; 101  : 		if (t <= ext)

	fld	DWORD PTR _t$[ebp]
	fld	DWORD PTR _ext$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN1@isOverlapO

; 102  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@isOverlapO
$LN1@isOverlapO:

; 103  : 		return false;

	xor	al, al
$LN3@isOverlapO:

; 104  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?isOverlapOnX@Box@ozcollide@@QBE_NABV12@@Z ENDP		; ozcollide::Box::isOverlapOnX
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isOverlapOnY@Box@ozcollide@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_t$ = -8						; size = 4
_ext$ = -4						; size = 4
__box$ = 8						; size = 4
?isOverlapOnY@Box@ozcollide@@QBE_NABV12@@Z PROC		; ozcollide::Box::isOverlapOnY, COMDAT
; _this$ = ecx

; 108  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 		float t = _box.center.y - center.y;

	mov	eax, DWORD PTR __box$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _t$[ebp]

; 110  : 		if (t < 0) t = -t;

	fld	DWORD PTR _t$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@isOverlapO@2
	fld	DWORD PTR _t$[ebp]
	fchs
	fstp	DWORD PTR _t$[ebp]
$LN2@isOverlapO@2:

; 111  : 
; 112  : 		float ext = _box.extent.y + extent.y;

	mov	edx, DWORD PTR __box$[ebp]
	fld	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+16]
	fstp	DWORD PTR _ext$[ebp]

; 113  : 		if (t <= ext)

	fld	DWORD PTR _t$[ebp]
	fld	DWORD PTR _ext$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN1@isOverlapO@2

; 114  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@isOverlapO@2
$LN1@isOverlapO@2:

; 115  : 		return false;

	xor	al, al
$LN3@isOverlapO@2:

; 116  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?isOverlapOnY@Box@ozcollide@@QBE_NABV12@@Z ENDP		; ozcollide::Box::isOverlapOnY
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isOverlapOnZ@Box@ozcollide@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_t$ = -8						; size = 4
_ext$ = -4						; size = 4
__box$ = 8						; size = 4
?isOverlapOnZ@Box@ozcollide@@QBE_NABV12@@Z PROC		; ozcollide::Box::isOverlapOnZ, COMDAT
; _this$ = ecx

; 120  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		float t = _box.center.z - center.z;

	mov	eax, DWORD PTR __box$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _t$[ebp]

; 122  : 		if (t < 0) t = -t;

	fld	DWORD PTR _t$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@isOverlapO@3
	fld	DWORD PTR _t$[ebp]
	fchs
	fstp	DWORD PTR _t$[ebp]
$LN2@isOverlapO@3:

; 123  : 
; 124  : 		float ext = _box.extent.z + extent.z;

	mov	edx, DWORD PTR __box$[ebp]
	fld	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+20]
	fstp	DWORD PTR _ext$[ebp]

; 125  : 		if (t <= ext)

	fld	DWORD PTR _t$[ebp]
	fld	DWORD PTR _ext$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN1@isOverlapO@3

; 126  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@isOverlapO@3
$LN1@isOverlapO@3:

; 127  : 		return false;

	xor	al, al
$LN3@isOverlapO@3:

; 128  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?isOverlapOnZ@Box@ozcollide@@QBE_NABV12@@Z ENDP		; ozcollide::Box::isOverlapOnZ
_TEXT	ENDS
PUBLIC	?collideWithBox@AABBTreeAABB@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreeAABB::collideWithBox
PUBLIC	??XVec3f@ozcollide@@QAEXM@Z			; ozcollide::Vec3f::operator*=
PUBLIC	?isInside@Box@ozcollide@@QBE_NABV12@@Z		; ozcollide::Box::isInside
PUBLIC	?collideWithBox@AABBTreeAABB@ozcollide@@QAEXABVBox@2@AAVBoxColResult@12@@Z ; ozcollide::AABBTreeAABB::collideWithBox
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtree_aabb.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__box$ = 8						; size = 4
__cr$ = 12						; size = 4
?collideWithBox@AABBTreeAABB@ozcollide@@QAEXABVBox@2@AAVBoxColResult@12@@Z PROC ; ozcollide::AABBTreeAABB::collideWithBox
; _this$ = ecx

; 78   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 	if (bUseTemporalCoherence_ == true) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	cmp	ecx, 1
	jne	SHORT $LN3@collideWit

; 80   : 		if (_box.isInside(_cr.boxQuery_)) {

	mov	edx, DWORD PTR __cr$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR __box$[ebp]
	call	?isInside@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isInside
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@collideWit

; 81   : 			nbColls_ = _cr.boxes_.size();

	mov	ecx, DWORD PTR __cr$[ebp]
	call	?size@?$Vector@PBVBox@ozcollide@@@ozcollide@@QBEHXZ ; ozcollide::Vector<ozcollide::Box const *>::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+116], eax

; 82   : 			return;

	jmp	$LN4@collideWit
$LN2@collideWit:

; 83   : 		}
; 84   : 
; 85   : 		// Too bad, will do normal query with an inflated volume
; 86   : 		box_ = _box;

	mov	edx, DWORD PTR __box$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 52					; 00000034H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], edx

; 87   : 		box_.extent *= coefVolInflater_;

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+28]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??XVec3f@ozcollide@@QAEXM@Z		; ozcollide::Vec3f::operator*=

; 88   : 	}
; 89   : 	else {

	jmp	SHORT $LN1@collideWit
$LN3@collideWit:

; 90   : 		box_ = _box;

	mov	ecx, DWORD PTR __box$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 52					; 00000034H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx
$LN1@collideWit:

; 91   : 	}
; 92   : 
; 93   : 	_cr.boxQuery_ = box_;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 52					; 00000034H
	mov	eax, DWORD PTR __cr$[ebp]
	add	eax, 24					; 00000018H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], edx

; 94   : 	callback_ = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 95   : 	colRes_ = &_cr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __cr$[ebp]
	mov	DWORD PTR [ecx+48], edx

; 96   : 	_cr.boxes_.resize(0);

	push	0
	mov	ecx, DWORD PTR __cr$[ebp]
	call	?resize@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Box const *>::resize

; 97   : 	nbColls_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], 0

; 98   : 
; 99   : 	collideWithBox(*root_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithBox@AABBTreeAABB@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreeAABB::collideWithBox
$LN4@collideWit:

; 100  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?collideWithBox@AABBTreeAABB@ozcollide@@QAEXABVBox@2@AAVBoxColResult@12@@Z ENDP ; ozcollide::AABBTreeAABB::collideWithBox
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
_TEXT	ENDS
;	COMDAT ??XVec3f@ozcollide@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__mul$ = 8						; size = 4
??XVec3f@ozcollide@@QAEXM@Z PROC			; ozcollide::Vec3f::operator*=, COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 73   : 		x *= _mul;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR __mul$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 74   : 		y *= _mul;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR __mul$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 75   : 		z *= _mul;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR __mul$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 76   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??XVec3f@ozcollide@@QAEXM@Z ENDP			; ozcollide::Vec3f::operator*=
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\box.h
_TEXT	ENDS
;	COMDAT ?isInside@Box@ozcollide@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__box$ = 8						; size = 4
?isInside@Box@ozcollide@@QBE_NABV12@@Z PROC		; ozcollide::Box::isInside, COMDAT
; _this$ = ecx

; 132  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 133  : 		if (center.x - extent.x > _box.center.x - _box.extent.x &&
; 134  : 			center.x + extent.x < _box.center.x + _box.extent.x &&
; 135  : 			center.y - extent.y > _box.center.y - _box.extent.y &&
; 136  : 			center.y + extent.y < _box.center.y + _box.extent.z &&
; 137  : 			center.z - extent.z > _box.center.z - _box.extent.z &&
; 138  : 			center.z + extent.z < _box.center.z + _box.extent.z)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR __box$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR __box$[ebp]
	fsub	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	$LN1@isInside
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+12]
	mov	eax, DWORD PTR __box$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR __box$[ebp]
	fadd	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN1@isInside
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR __box$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __box$[ebp]
	fsub	DWORD PTR [edx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@isInside
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR __box$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __box$[ebp]
	fadd	DWORD PTR [eax+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@isInside
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [edx+20]
	mov	eax, DWORD PTR __box$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __box$[ebp]
	fsub	DWORD PTR [ecx+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@isInside
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR __box$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __box$[ebp]
	fadd	DWORD PTR [edx+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@isInside

; 139  : 			return true;

	mov	al, 1
	jmp	SHORT $LN2@isInside
$LN1@isInside:

; 140  : 		
; 141  : 		return false;

	xor	al, al
$LN2@isInside:

; 142  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?isInside@Box@ozcollide@@QBE_NABV12@@Z ENDP		; ozcollide::Box::isInside
_TEXT	ENDS
PUBLIC	?collideWithBox@AABBTreeAABB@ozcollide@@QAEXABVBox@2@P6AXABV12@00PAX@Z2@Z ; ozcollide::AABBTreeAABB::collideWithBox
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtree_aabb.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__box$ = 8						; size = 4
__callback$ = 12					; size = 4
__userCallback$ = 16					; size = 4
?collideWithBox@AABBTreeAABB@ozcollide@@QAEXABVBox@2@P6AXABV12@00PAX@Z2@Z PROC ; ozcollide::AABBTreeAABB::collideWithBox
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 	if (!_callback)

	cmp	DWORD PTR __callback$[ebp], 0
	jne	SHORT $LN1@collideWit@2

; 105  : 		return;

	jmp	SHORT $LN2@collideWit@2
$LN1@collideWit@2:

; 106  : 	callback_ = _callback;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __callback$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 107  : 	userCallback_ = _userCallback;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __userCallback$[ebp]
	mov	DWORD PTR [edx+44], eax

; 108  : 	colRes_ = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 109  : 	nbColls_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], 0

; 110  : 	box_ = _box;

	mov	eax, DWORD PTR __box$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax

; 111  : 	collideWithBox(*root_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithBox@AABBTreeAABB@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreeAABB::collideWithBox
$LN2@collideWit@2:

; 112  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?collideWithBox@AABBTreeAABB@ozcollide@@QAEXABVBox@2@P6AXABV12@00PAX@Z2@Z ENDP ; ozcollide::AABBTreeAABB::collideWithBox
_TEXT	ENDS
PUBLIC	?add@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXABQBVBox@2@@Z ; ozcollide::Vector<ozcollide::Box const *>::add
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T7698 = -24						; size = 4
_b$7309 = -20						; size = 4
_res$7310 = -13						; size = 1
_i$7305 = -12						; size = 4
_bl$7302 = -8						; size = 4
_nbBoxes$7304 = -4					; size = 4
__node$ = 8						; size = 4
?isCollideWithBox@AABBTreeAABB@ozcollide@@AAE_NABVAABBTreeNode@2@@Z PROC ; ozcollide::AABBTreeAABB::isCollideWithBox
; _this$ = ecx

; 117  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 	if (_node.aabb.isOverlap(box_) == true) {

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR __node$[ebp]
	call	?isOverlap@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isOverlap
	movzx	ecx, al
	cmp	ecx, 1
	jne	$LN12@isCollideW@2

; 119  : 		if (!_node.left && !_node.right) {

	mov	edx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	$LN11@isCollideW@2
	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	$LN11@isCollideW@2

; 120  : 			// reach a leaf
; 121  : 			const AABBTreeAABBLeaf &bl = (AABBTreeAABBLeaf&) _node;

	mov	ecx, DWORD PTR __node$[ebp]
	mov	DWORD PTR _bl$7302[ebp], ecx

; 122  : 			int nbBoxes = bl.nbBoxes;

	mov	edx, DWORD PTR _bl$7302[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _nbBoxes$7304[ebp], eax

; 123  : 			for (int i = 0; i < nbBoxes; i++) {

	mov	DWORD PTR _i$7305[ebp], 0
	jmp	SHORT $LN10@isCollideW@2
$LN9@isCollideW@2:
	mov	ecx, DWORD PTR _i$7305[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$7305[ebp], ecx
$LN10@isCollideW@2:
	mov	edx, DWORD PTR _i$7305[ebp]
	cmp	edx, DWORD PTR _nbBoxes$7304[ebp]
	jge	SHORT $LN8@isCollideW@2

; 124  : 				const Box &b = bl.boxes[i];

	mov	eax, DWORD PTR _i$7305[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _bl$7302[ebp]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _b$7309[ebp], eax

; 125  : 				bool res = box_.isOverlap(b);

	mov	edx, DWORD PTR _b$7309[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	?isOverlap@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isOverlap
	mov	BYTE PTR _res$7310[ebp], al

; 126  : 				if (res == true) {

	movzx	eax, BYTE PTR _res$7310[ebp]
	cmp	eax, 1
	jne	SHORT $LN7@isCollideW@2

; 127  : 					nbColls_++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], edx

; 128  : 					if (colRes_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN7@isCollideW@2

; 129  : 						colRes_->boxes_.add(&b);

	mov	edx, DWORD PTR _b$7309[ebp]
	mov	DWORD PTR $T7698[ebp], edx
	lea	eax, DWORD PTR $T7698[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?add@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXABQBVBox@2@@Z ; ozcollide::Vector<ozcollide::Box const *>::add
$LN7@isCollideW@2:

; 130  : 				}
; 131  : 				return res;

	mov	al, BYTE PTR _res$7310[ebp]
	jmp	SHORT $LN13@isCollideW@2

; 132  : 			}

	jmp	SHORT $LN9@isCollideW@2
$LN8@isCollideW@2:

; 133  : 		}
; 134  : 		else {

	jmp	SHORT $LN12@isCollideW@2
$LN11@isCollideW@2:

; 135  : 			if (_node.left) {

	mov	edx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN4@isCollideW@2

; 136  : 				if (isCollideWithBox(*_node.left) == true)

	mov	eax, DWORD PTR __node$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithBox@AABBTreeAABB@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreeAABB::isCollideWithBox
	movzx	edx, al
	cmp	edx, 1
	jne	SHORT $LN4@isCollideW@2

; 137  : 					return true;

	mov	al, 1
	jmp	SHORT $LN13@isCollideW@2
$LN4@isCollideW@2:

; 138  : 			}
; 139  : 			if (_node.right) {

	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN12@isCollideW@2

; 140  : 				if (isCollideWithBox(*_node.right) == true)

	mov	ecx, DWORD PTR __node$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithBox@AABBTreeAABB@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreeAABB::isCollideWithBox
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN12@isCollideW@2

; 141  : 					return true;

	mov	al, 1
	jmp	SHORT $LN13@isCollideW@2
$LN12@isCollideW@2:

; 142  : 			}
; 143  : 		}
; 144  : 	}
; 145  : 	return false;

	xor	al, al
$LN13@isCollideW@2:

; 146  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isCollideWithBox@AABBTreeAABB@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ENDP ; ozcollide::AABBTreeAABB::isCollideWithBox
; Function compile flags: /Odtp
_this$ = -28						; size = 4
$T7700 = -24						; size = 4
_b$7332 = -20						; size = 4
_res$7333 = -13						; size = 1
_i$7328 = -12						; size = 4
_bl$7325 = -8						; size = 4
_nbBoxes$7327 = -4					; size = 4
__node$ = 8						; size = 4
?collideWithBox@AABBTreeAABB@ozcollide@@AAEXABVAABBTreeNode@2@@Z PROC ; ozcollide::AABBTreeAABB::collideWithBox
; _this$ = ecx

; 149  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 150  : 	if (_node.aabb.isOverlap(box_) == true) {

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR __node$[ebp]
	call	?isOverlap@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isOverlap
	movzx	ecx, al
	cmp	ecx, 1
	jne	$LN12@collideWit@3

; 151  : 		if (!_node.left && !_node.right) {

	mov	edx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	$LN10@collideWit@3
	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	$LN10@collideWit@3

; 152  : 			// reach a leaf
; 153  : 			const AABBTreeAABBLeaf &bl = (AABBTreeAABBLeaf&) _node;

	mov	ecx, DWORD PTR __node$[ebp]
	mov	DWORD PTR _bl$7325[ebp], ecx

; 154  : 			int nbBoxes = bl.nbBoxes;

	mov	edx, DWORD PTR _bl$7325[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _nbBoxes$7327[ebp], eax

; 155  : 			for (int i = 0; i < nbBoxes; i++) {

	mov	DWORD PTR _i$7328[ebp], 0
	jmp	SHORT $LN9@collideWit@3
$LN8@collideWit@3:
	mov	ecx, DWORD PTR _i$7328[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$7328[ebp], ecx
$LN9@collideWit@3:
	mov	edx, DWORD PTR _i$7328[ebp]
	cmp	edx, DWORD PTR _nbBoxes$7327[ebp]
	jge	SHORT $LN7@collideWit@3

; 156  : 				const Box &b = bl.boxes[i];

	mov	eax, DWORD PTR _i$7328[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _bl$7325[ebp]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _b$7332[ebp], eax

; 157  : 				bool res = box_.isOverlap(b);

	mov	edx, DWORD PTR _b$7332[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	?isOverlap@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isOverlap
	mov	BYTE PTR _res$7333[ebp], al

; 158  : 				if (res == true) {

	movzx	eax, BYTE PTR _res$7333[ebp]
	cmp	eax, 1
	jne	SHORT $LN6@collideWit@3

; 159  : 					nbColls_++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], edx

; 160  : 					if (callback_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN5@collideWit@3

; 161  : 						callback_(*this, b, _node.aabb, userCallback_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR __node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _b$7332[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	add	esp, 16					; 00000010H

; 162  : 					else

	jmp	SHORT $LN6@collideWit@3
$LN5@collideWit@3:

; 163  : 						colRes_->boxes_.add(&b);

	mov	eax, DWORD PTR _b$7332[ebp]
	mov	DWORD PTR $T7700[ebp], eax
	lea	ecx, DWORD PTR $T7700[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	call	?add@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXABQBVBox@2@@Z ; ozcollide::Vector<ozcollide::Box const *>::add
$LN6@collideWit@3:

; 164  : 				}
; 165  : 			}

	jmp	$LN8@collideWit@3
$LN7@collideWit@3:

; 166  : 		}
; 167  : 		else {

	jmp	SHORT $LN12@collideWit@3
$LN10@collideWit@3:

; 168  : 			if (_node.left)

	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN2@collideWit@3

; 169  : 				collideWithBox(*_node.left);

	mov	ecx, DWORD PTR __node$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithBox@AABBTreeAABB@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreeAABB::collideWithBox
$LN2@collideWit@3:

; 170  : 			if (_node.right)

	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN12@collideWit@3

; 171  : 				collideWithBox(*_node.right);

	mov	ecx, DWORD PTR __node$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithBox@AABBTreeAABB@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreeAABB::collideWithBox
$LN12@collideWit@3:

; 172  : 		}
; 173  : 	}
; 174  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?collideWithBox@AABBTreeAABB@ozcollide@@AAEXABVAABBTreeNode@2@@Z ENDP ; ozcollide::AABBTreeAABB::collideWithBox
; Function compile flags: /Odtp
_this$ = -44						; size = 4
$T7703 = -40						; size = 12
$T7702 = -28						; size = 12
_leaf$7354 = -16					; size = 4
_node$7350 = -12					; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
__scale$ = 8						; size = 4
?scale@AABBTreeAABB@ozcollide@@UAEXM@Z PROC		; ozcollide::AABBTreeAABB::scale
; _this$ = ecx

; 177  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 178  : 	int i, j;
; 179  : 
; 180  : 	for (i = 0; i < nbNodes_; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@scale
$LN8@scale:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@scale:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN7@scale

; 181  : 		AABBTreeNode *node = &root_[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _node$7350[ebp], eax

; 182  : 		node->aabb.center *= _scale;

	push	ecx
	fld	DWORD PTR __scale$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _node$7350[ebp]
	call	??XVec3f@ozcollide@@QAEXM@Z		; ozcollide::Vec3f::operator*=

; 183  : 		node->aabb.extent *= _scale;

	push	ecx
	fld	DWORD PTR __scale$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _node$7350[ebp]
	add	ecx, 12					; 0000000cH
	call	??XVec3f@ozcollide@@QAEXM@Z		; ozcollide::Vec3f::operator*=

; 184  : 	}

	jmp	SHORT $LN8@scale
$LN7@scale:

; 185  : 	
; 186  : 	for (i = 0; i < nbLeafs_; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@scale
$LN5@scale:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@scale:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	$LN4@scale

; 187  : 		AABBTreeAABBLeaf *leaf = &leafs_[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _leaf$7354[ebp], edx

; 188  : 		leaf->aabb.center *= _scale;

	push	ecx
	fld	DWORD PTR __scale$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _leaf$7354[ebp]
	call	??XVec3f@ozcollide@@QAEXM@Z		; ozcollide::Vec3f::operator*=

; 189  : 		leaf->aabb.extent *= _scale;

	push	ecx
	fld	DWORD PTR __scale$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _leaf$7354[ebp]
	add	ecx, 12					; 0000000cH
	call	??XVec3f@ozcollide@@QAEXM@Z		; ozcollide::Vec3f::operator*=

; 190  : 		for (j = 0; j < leaf->nbBoxes; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@scale
$LN2@scale:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN3@scale:
	mov	edx, DWORD PTR _leaf$7354[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jge	SHORT $LN1@scale

; 191  : 			((Vec3f) leaf->boxes[j].center) *= _scale;

	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _leaf$7354[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T7702[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T7702[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR $T7702[ebp+8], eax
	push	ecx
	fld	DWORD PTR __scale$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7702[ebp]
	call	??XVec3f@ozcollide@@QAEXM@Z		; ozcollide::Vec3f::operator*=

; 192  : 			((Vec3f) leaf->boxes[j].extent) *= _scale;

	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _leaf$7354[ebp]
	mov	eax, DWORD PTR [edx+36]
	lea	ecx, DWORD PTR [eax+ecx+12]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T7703[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T7703[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T7703[ebp+8], ecx
	push	ecx
	fld	DWORD PTR __scale$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T7703[ebp]
	call	??XVec3f@ozcollide@@QAEXM@Z		; ozcollide::Vec3f::operator*=

; 193  : 		}

	jmp	SHORT $LN2@scale
$LN1@scale:

; 194  : 	}

	jmp	$LN5@scale
$LN4@scale:

; 195  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?scale@AABBTreeAABB@ozcollide@@UAEXM@Z ENDP		; ozcollide::AABBTreeAABB::scale
_TEXT	ENDS
xdata$x	SEGMENT
__unwindtable$??0AABBTreeAABBLeaf@ozcollide@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AABBTreeAABBLeaf@ozcollide@@QAE@XZ$0
__ehfuncinfo$??0AABBTreeAABBLeaf@ozcollide@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0AABBTreeAABBLeaf@ozcollide@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0AABBTreeAABBLeaf@ozcollide@@QAE@XZ PROC		; ozcollide::AABBTreeAABBLeaf::AABBTreeAABBLeaf
; _this$ = ecx

; 198  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AABBTreeAABBLeaf@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0AABBTreeNode@ozcollide@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 199  : 	nbBoxes = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 200  : 	boxes = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 201  : 	users = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0

; 202  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0AABBTreeAABBLeaf@ozcollide@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1AABBTreeNode@ozcollide@@QAE@XZ
__ehhandler$??0AABBTreeAABBLeaf@ozcollide@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AABBTreeAABBLeaf@ozcollide@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AABBTreeAABBLeaf@ozcollide@@QAE@XZ ENDP		; ozcollide::AABBTreeAABBLeaf::AABBTreeAABBLeaf
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vector.h
;	COMDAT ?add@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXABQBVBox@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__t$ = 8						; size = 4
?add@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXABQBVBox@2@@Z PROC ; ozcollide::Vector<ozcollide::Box const *>::add, COMDAT
; _this$ = ecx

; 48   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 		if (size_ < capacity_) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN1@add

; 50   : 			mem_[size_] = _t;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR __t$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 51   : 			size_++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 52   : 			return;

	jmp	SHORT $LN2@add
$LN1@add:

; 53   : 		}
; 54   : 
; 55   : 		resize(size_ + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Box const *>::resize

; 56   : 		mem_[size_ - 1] = _t;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __t$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax*4-4], ecx
$LN2@add:

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?add@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXABQBVBox@2@@Z ENDP ; ozcollide::Vector<ozcollide::Box const *>::add
_TEXT	ENDS
PUBLIC	?reserve@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Box const *>::reserve
; Function compile flags: /Odtp
;	COMDAT ?resize@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__size$ = 8						; size = 4
?resize@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXH@Z PROC ; ozcollide::Vector<ozcollide::Box const *>::resize, COMDAT
; _this$ = ecx

; 122  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 		if (_size > capacity_)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __size$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	SHORT $LN1@resize

; 124  : 			reserve(_size * 2);

	mov	edx, DWORD PTR __size$[ebp]
	shl	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reserve@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Box const *>::reserve
$LN1@resize:

; 125  : 		size_ = _size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __size$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 126  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXH@Z ENDP ; ozcollide::Vector<ozcollide::Box const *>::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$Vector@PBVBox@ozcollide@@@ozcollide@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$Vector@PBVBox@ozcollide@@@ozcollide@@QBEHXZ PROC ; ozcollide::Vector<ozcollide::Box const *>::size, COMDAT
; _this$ = ecx

; 160  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		return size_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$Vector@PBVBox@ozcollide@@@ozcollide@@QBEHXZ ENDP ; ozcollide::Vector<ozcollide::Box const *>::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$Vector@PBVBox@ozcollide@@@ozcollide@@QBEAAPBVBox@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Vector@PBVBox@ozcollide@@@ozcollide@@QBEAAPBVBox@1@H@Z PROC ; ozcollide::Vector<ozcollide::Box const *>::operator[], COMDAT
; _this$ = ecx

; 198  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 199  : 		return mem_[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 200  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Vector@PBVBox@ozcollide@@@ozcollide@@QBEAAPBVBox@1@H@Z ENDP ; ozcollide::Vector<ozcollide::Box const *>::operator[]
_TEXT	ENDS
EXTRN	__imp__free:PROC
EXTRN	_memcpy:PROC
EXTRN	__imp__malloc:PROC
; Function compile flags: /Odtp
;	COMDAT ?reserve@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXH@Z
_TEXT	SEGMENT
tv70 = -16						; size = 4
_this$ = -12						; size = 4
_toCopy$ = -8						; size = 4
_old$ = -4						; size = 4
__capacity$ = 8						; size = 4
?reserve@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXH@Z PROC ; ozcollide::Vector<ozcollide::Box const *>::reserve, COMDAT
; _this$ = ecx

; 129  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 130  : 		T *old = mem_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _old$[ebp], ecx

; 131  : 		mem_ = (T*) malloc(_capacity * sizeof(T));

	mov	edx, DWORD PTR __capacity$[ebp]
	shl	edx, 2
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 132  : 		int toCopy = _capacity > capacity_ ? capacity_ : _capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __capacity$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jle	SHORT $LN4@reserve
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $LN5@reserve
$LN4@reserve:
	mov	eax, DWORD PTR __capacity$[ebp]
	mov	DWORD PTR tv70[ebp], eax
$LN5@reserve:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _toCopy$[ebp], ecx

; 133  : 		memcpy(mem_, old, toCopy * sizeof(T));

	mov	edx, DWORD PTR _toCopy$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _old$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 134  : 		if (old)

	cmp	DWORD PTR _old$[ebp], 0
	je	SHORT $LN1@reserve

; 135  : 			free(old);

	mov	eax, DWORD PTR _old$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN1@reserve:

; 136  : 		capacity_ = _capacity;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __capacity$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 137  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?reserve@?$Vector@PBVBox@ozcollide@@@ozcollide@@QAEXH@Z ENDP ; ozcollide::Vector<ozcollide::Box const *>::reserve
_TEXT	ENDS
END

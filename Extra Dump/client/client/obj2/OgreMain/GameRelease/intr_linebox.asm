; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\sdk\ozcollide\intr_linebox.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z		; ozcollide::Vec3f::operator|
PUBLIC	_fabsf
PUBLIC	??HVec3f@ozcollide@@QBE?AV01@ABV01@@Z		; ozcollide::Vec3f::operator+
PUBLIC	??Dozcollide@@YA?AVVec3f@0@MABV10@@Z		; ozcollide::operator*
PUBLIC	__real@3f000000
PUBLIC	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z		; ozcollide::Vec3f::operator-
PUBLIC	?isInside@Box@ozcollide@@QBE_NABVVec3f@2@@Z	; ozcollide::Box::isInside
PUBLIC	?testIntersectionSegmentBox@ozcollide@@YA_NABVVec3f@1@0ABVBox@1@@Z ; ozcollide::testIntersectionSegmentBox
EXTRN	__fltused:DWORD
;	COMDAT __real@3f000000
; File i:\svnroot\client\sdk\ozcollide\intr_linebox.cpp
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
$T6818 = -100						; size = 12
_fAWxDdU$ = -88						; size = 12
_kSDir$ = -76						; size = 12
_kSCen$ = -64						; size = 12
_fADdU$ = -52						; size = 12
_fAWdU$ = -40						; size = 12
_fRhs$ = -28						; size = 4
_kDiff$ = -24						; size = 12
_kWxD$ = -12						; size = 12
_segment_pt0$ = 8					; size = 4
_segment_pt1$ = 12					; size = 4
_box$ = 16						; size = 4
?testIntersectionSegmentBox@ozcollide@@YA_NABVVec3f@1@0ABVBox@1@@Z PROC ; ozcollide::testIntersectionSegmentBox

; 33   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 34   : 	if (box.isInside(segment_pt0) && box.isInside(segment_pt1))

	mov	eax, DWORD PTR _segment_pt0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _box$[ebp]
	call	?isInside@Box@ozcollide@@QBE_NABVVec3f@2@@Z ; ozcollide::Box::isInside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@testInters
	mov	edx, DWORD PTR _segment_pt1$[ebp]
	push	edx
	mov	ecx, DWORD PTR _box$[ebp]
	call	?isInside@Box@ozcollide@@QBE_NABVVec3f@2@@Z ; ozcollide::Box::isInside
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@testInters

; 35   : 		return true;

	mov	al, 1
	jmp	$LN8@testInters
$LN7@testInters:

; 36   : 
; 37   : 	float fAWdU[3], fADdU[3], fAWxDdU[3], fRhs;
; 38   : 	Vec3f kSDir = 0.5f * (segment_pt1 - segment_pt0);

	mov	ecx, DWORD PTR _segment_pt0$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T6818[ebp]
	push	edx
	mov	ecx, DWORD PTR _segment_pt1$[ebp]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-
	push	eax
	push	ecx
	fld	DWORD PTR __real@3f000000
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _kSDir$[ebp]
	push	eax
	call	??Dozcollide@@YA?AVVec3f@0@MABV10@@Z	; ozcollide::operator*
	add	esp, 12					; 0000000cH

; 39   : 	Vec3f kSCen = segment_pt0 + kSDir;

	lea	ecx, DWORD PTR _kSDir$[ebp]
	push	ecx
	lea	edx, DWORD PTR _kSCen$[ebp]
	push	edx
	mov	ecx, DWORD PTR _segment_pt0$[ebp]
	call	??HVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator+

; 40   : 
; 41   : 	Vec3f kDiff = kSCen - box.center;

	mov	eax, DWORD PTR _box$[ebp]
	push	eax
	lea	ecx, DWORD PTR _kDiff$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _kSCen$[ebp]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-

; 42   : 
; 43   : 	fAWdU[0] = fabsf(kSDir.x);

	push	ecx
	fld	DWORD PTR _kSDir$[ebp]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fAWdU$[ebp]

; 44   : 	fADdU[0] = fabsf(kDiff.x);

	push	ecx
	fld	DWORD PTR _kDiff$[ebp]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fADdU$[ebp]

; 45   : 	fRhs = box.extent.x + fAWdU[0];

	mov	edx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [edx+12]
	fadd	DWORD PTR _fAWdU$[ebp]
	fstp	DWORD PTR _fRhs$[ebp]

; 46   : 	if (fADdU[0] > fRhs)

	fld	DWORD PTR _fADdU$[ebp]
	fld	DWORD PTR _fRhs$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@testInters

; 47   : 		return false;

	xor	al, al
	jmp	$LN8@testInters
$LN6@testInters:

; 48   : 
; 49   : 	fAWdU[1] = fabsf(kSDir.y);

	push	ecx
	fld	DWORD PTR _kSDir$[ebp+4]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fAWdU$[ebp+4]

; 50   : 	fADdU[1] = fabsf(kDiff.y);

	push	ecx
	fld	DWORD PTR _kDiff$[ebp+4]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fADdU$[ebp+4]

; 51   : 	fRhs = box.extent.y + fAWdU[1];

	mov	eax, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax+16]
	fadd	DWORD PTR _fAWdU$[ebp+4]
	fstp	DWORD PTR _fRhs$[ebp]

; 52   : 	if (fADdU[1] > fRhs)

	fld	DWORD PTR _fADdU$[ebp+4]
	fld	DWORD PTR _fRhs$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN5@testInters

; 53   : 		return false;

	xor	al, al
	jmp	$LN8@testInters
$LN5@testInters:

; 54   : 
; 55   : 	fAWdU[2] = fabsf(kSDir.z);

	push	ecx
	fld	DWORD PTR _kSDir$[ebp+8]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fAWdU$[ebp+8]

; 56   : 	fADdU[2] = fabsf(kDiff.z);

	push	ecx
	fld	DWORD PTR _kDiff$[ebp+8]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fADdU$[ebp+8]

; 57   : 	fRhs = box.extent.z + fAWdU[2];

	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [ecx+20]
	fadd	DWORD PTR _fAWdU$[ebp+8]
	fstp	DWORD PTR _fRhs$[ebp]

; 58   : 	if (fADdU[2] > fRhs)

	fld	DWORD PTR _fADdU$[ebp+8]
	fld	DWORD PTR _fRhs$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@testInters

; 59   : 		return false;

	xor	al, al
	jmp	$LN8@testInters
$LN4@testInters:

; 60   : 
; 61   : 	Vec3f kWxD = kSDir | kDiff;

	lea	edx, DWORD PTR _kDiff$[ebp]
	push	edx
	lea	eax, DWORD PTR _kWxD$[ebp]
	push	eax
	lea	ecx, DWORD PTR _kSDir$[ebp]
	call	??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator|

; 62   : 
; 63   : 	fAWxDdU[0] = fabsf(kWxD.x);

	push	ecx
	fld	DWORD PTR _kWxD$[ebp]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fAWxDdU$[ebp]

; 64   : 	fRhs = box.extent.y * fAWdU[2] + box.extent.z * fAWdU[1];

	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [ecx+16]
	fmul	DWORD PTR _fAWdU$[ebp+8]
	mov	edx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [edx+20]
	fmul	DWORD PTR _fAWdU$[ebp+4]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _fRhs$[ebp]

; 65   : 	if (fAWxDdU[0] > fRhs)

	fld	DWORD PTR _fAWxDdU$[ebp]
	fld	DWORD PTR _fRhs$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@testInters

; 66   : 		return false;

	xor	al, al
	jmp	SHORT $LN8@testInters
$LN3@testInters:

; 67   : 
; 68   : 	fAWxDdU[1] = fabsf(kWxD.y);

	push	ecx
	fld	DWORD PTR _kWxD$[ebp+4]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fAWxDdU$[ebp+4]

; 69   : 	fRhs = box.extent.x * fAWdU[2] + box.extent.z * fAWdU[0];

	mov	eax, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _fAWdU$[ebp+8]
	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [ecx+20]
	fmul	DWORD PTR _fAWdU$[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _fRhs$[ebp]

; 70   : 	if (fAWxDdU[1] > fRhs)

	fld	DWORD PTR _fAWxDdU$[ebp+4]
	fld	DWORD PTR _fRhs$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@testInters

; 71   : 		return false;

	xor	al, al
	jmp	SHORT $LN8@testInters
$LN2@testInters:

; 72   : 
; 73   : 	fAWxDdU[2] = fabsf(kWxD.z);

	push	ecx
	fld	DWORD PTR _kWxD$[ebp+8]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR _fAWxDdU$[ebp+8]

; 74   : 	fRhs = box.extent.x * fAWdU[1] + box.extent.y * fAWdU[0];

	mov	edx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [edx+12]
	fmul	DWORD PTR _fAWdU$[ebp+4]
	mov	eax, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax+16]
	fmul	DWORD PTR _fAWdU$[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _fRhs$[ebp]

; 75   : 	if (fAWxDdU[2] > fRhs)

	fld	DWORD PTR _fAWxDdU$[ebp+8]
	fld	DWORD PTR _fRhs$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@testInters

; 76   : 		return false;

	xor	al, al
	jmp	SHORT $LN8@testInters
$LN1@testInters:

; 77   : 
; 78   :     return true;

	mov	al, 1
$LN8@testInters:

; 79   : 
; 80   : 
; 81   : /*
; 82   : 	Vec3f min = box.center - box.extent;
; 83   : 	Vec3f max = box.center + box.extent;
; 84   : 
; 85   : 	Vec3f deltaSeg = segment_pt1 - segment_pt0;
; 86   : 
; 87   : 	// left plane
; 88   : 	if ( (segment_pt0.x <= min.x && segment_pt1.x >= min.x) || (segment_pt1.x <= min.x && segment_pt0.x >= min.x) ) {
; 89   : 		float denom = deltaSeg.x;
; 90   : 		if (denom != 0.0f) {
; 91   : 			float t = (min.x - segment_pt0.x) / denom;
; 92   : 			float y = deltaSeg.y * t + segment_pt0.y;
; 93   : 			float z = deltaSeg.z * t + segment_pt0.z;
; 94   : 			if (y >= min.y && y <= max.y && z >= min.z && z <= max.z)
; 95   : 				return true;
; 96   : 		}
; 97   : 	}
; 98   : 
; 99   : 	// right plane
; 100  : 	if ( (segment_pt0.x <= max.x && segment_pt1.x >= max.x) || (segment_pt1.x <= max.x && segment_pt0.x >= max.x) ) {
; 101  : 		float denom = deltaSeg.x;
; 102  : 		if (denom != 0.0f) {
; 103  : 			float t = (max.x - segment_pt0.x) / denom;
; 104  : 			float y = deltaSeg.y * t + segment_pt0.y;
; 105  : 			float z = deltaSeg.z * t + segment_pt0.z;
; 106  : 			if (y >= min.y && y <= max.y && z >= min.z && z <= max.z)
; 107  : 				return true;
; 108  : 		}
; 109  : 	}
; 110  : 
; 111  : 	// bottom plane
; 112  : 	if ( (segment_pt0.y <= min.y && segment_pt1.y >= min.y) || (segment_pt1.y <= min.y && segment_pt0.y >= min.y) ) {
; 113  : 		float denom = deltaSeg.y;
; 114  : 		if (denom != 0.0f) {
; 115  : 			float t = (min.y - segment_pt0.y) / denom;
; 116  : 			float x = deltaSeg.x * t + segment_pt0.x;
; 117  : 			float z = deltaSeg.z * t + segment_pt0.z;
; 118  : 			if (x >= min.x && x <= max.x && z >= min.z && z <= max.z)
; 119  : 				return true;
; 120  : 		}
; 121  : 	}
; 122  : 
; 123  : 	// top plane
; 124  : 	if ( (segment_pt0.y <= max.y && segment_pt1.y >= max.y) || (segment_pt1.y <= max.y && segment_pt0.y >= max.y) ) {
; 125  : 		float denom = deltaSeg.y;
; 126  : 		if (denom != 0.0f) {
; 127  : 			float t = (max.y - segment_pt0.y) / denom;
; 128  : 			float x = deltaSeg.x * t + segment_pt0.x;
; 129  : 			float z = deltaSeg.z * t + segment_pt0.z;
; 130  : 			if (x >= min.x && x <= max.x && z >= min.z && z <= max.z)
; 131  : 				return true;
; 132  : 		}
; 133  : 	}
; 134  : 
; 135  : 	// near plane
; 136  : 	if ( (segment_pt0.z <= min.z && segment_pt1.z >= min.z) || (segment_pt1.z <= min.z && segment_pt0.z >= min.z) ) {
; 137  : 		float denom = deltaSeg.z;
; 138  : 		if (denom != 0.0f) {
; 139  : 			float t = (min.y - segment_pt0.z) / denom;
; 140  : 			float x = deltaSeg.x * t + segment_pt0.x;
; 141  : 			float y = deltaSeg.y * t + segment_pt0.y;
; 142  : 			if (x >= min.x && x <= max.x && y >= min.y && y <= max.y)
; 143  : 				return true;
; 144  : 		}
; 145  : 	}
; 146  : 
; 147  : 	// far plane
; 148  : 	if ( (segment_pt0.z <= max.z && segment_pt1.z >= max.z) || (segment_pt1.z <= max.z && segment_pt0.z >= max.z) ) {
; 149  : 		float denom = deltaSeg.z;
; 150  : 		if (denom != 0.0f) {
; 151  : 			float t = (max.z - segment_pt0.z) / denom;
; 152  : 			float x = deltaSeg.x * t + segment_pt0.x;
; 153  : 			float y = deltaSeg.y * t + segment_pt0.y;
; 154  : 			if (x >= min.x && x <= max.x && y >= min.y && y <= max.y)
; 155  : 				return true;
; 156  : 		}
; 157  : 	}
; 158  : 
; 159  : 	if (box.isInside(segment_pt0) && box.isInside(segment_pt1))
; 160  : 		return true;
; 161  : 
; 162  : 	return false;
; 163  : */
; 164  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?testIntersectionSegmentBox@ozcollide@@YA_NABVVec3f@1@0ABVBox@1@@Z ENDP ; ozcollide::testIntersectionSegmentBox
_TEXT	ENDS
EXTRN	_fabs:PROC
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 384  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
PUBLIC	??0Vec3f@ozcollide@@QAE@MMM@Z			; ozcollide::Vec3f::Vec3f
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
;	COMDAT ??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
tv92 = -16						; size = 4
tv89 = -12						; size = 4
tv86 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__v$ = 12						; size = 4
??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z PROC		; ozcollide::Vec3f::operator-, COMDAT
; _this$ = ecx

; 94   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 		return Vec3f(x - _v.x, y - _v.y, z - _v.z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __v$[ebp]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __v$[ebp]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR __v$[ebp]
	fsub	DWORD PTR [edx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 96   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z ENDP		; ozcollide::Vec3f::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0Vec3f@ozcollide@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
??0Vec3f@ozcollide@@QAE@MMM@Z PROC			; ozcollide::Vec3f::Vec3f, COMDAT
; _this$ = ecx

; 42   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR __x$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR __y$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR __z$[ebp]
	fstp	DWORD PTR [edx+8]

; 43   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vec3f@ozcollide@@QAE@MMM@Z ENDP			; ozcollide::Vec3f::Vec3f
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??HVec3f@ozcollide@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
tv92 = -16						; size = 4
tv89 = -12						; size = 4
tv86 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__v$ = 12						; size = 4
??HVec3f@ozcollide@@QBE?AV01@ABV01@@Z PROC		; ozcollide::Vec3f::operator+, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		return Vec3f(x + _v.x, y + _v.y, z + _v.z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __v$[ebp]
	fadd	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __v$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR __v$[ebp]
	fadd	DWORD PTR [edx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 101  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
??HVec3f@ozcollide@@QBE?AV01@ABV01@@Z ENDP		; ozcollide::Vec3f::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
tv146 = -16						; size = 4
tv141 = -12						; size = 4
tv136 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__d$ = 12						; size = 4
??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z PROC		; ozcollide::Vec3f::operator|, COMDAT
; _this$ = ecx

; 125  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 126  : 		return Vec3f(y * _d.z - z * _d.y,
; 127  : 			z * _d.x - x * _d.z,
; 128  : 			x * _d.y - y * _d.x);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv136[ebp]
	fld	DWORD PTR tv136[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv141[ebp]
	fld	DWORD PTR tv141[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [edx+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv146[ebp]
	fld	DWORD PTR tv146[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 129  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z ENDP		; ozcollide::Vec3f::operator|
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Dozcollide@@YA?AVVec3f@0@MABV10@@Z
_TEXT	SEGMENT
tv87 = -12						; size = 4
tv85 = -8						; size = 4
tv83 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__m$ = 12						; size = 4
__v$ = 16						; size = 4
??Dozcollide@@YA?AVVec3f@0@MABV10@@Z PROC		; ozcollide::operator*, COMDAT

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 190  : 	return Vec3f(_v.x * _m, _v.y * _m, _v.z * _m);

	mov	eax, DWORD PTR __v$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR __m$[ebp]
	fstp	DWORD PTR tv83[ebp]
	fld	DWORD PTR tv83[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __v$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR __m$[ebp]
	fstp	DWORD PTR tv85[ebp]
	fld	DWORD PTR tv85[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR __v$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR __m$[ebp]
	fstp	DWORD PTR tv87[ebp]
	fld	DWORD PTR tv87[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 191  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??Dozcollide@@YA?AVVec3f@0@MABV10@@Z ENDP		; ozcollide::operator*
_TEXT	ENDS
PUBLIC	?getMax@Box@ozcollide@@QBE?AVVec3f@2@XZ		; ozcollide::Box::getMax
PUBLIC	?getMin@Box@ozcollide@@QBE?AVVec3f@2@XZ		; ozcollide::Box::getMin
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\box.h
;	COMDAT ?isInside@Box@ozcollide@@QBE_NABVVec3f@2@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_max$ = -24						; size = 12
_min$ = -12						; size = 12
__pt$ = 8						; size = 4
?isInside@Box@ozcollide@@QBE_NABVVec3f@2@@Z PROC	; ozcollide::Box::isInside, COMDAT
; _this$ = ecx

; 146  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		Vec3f min = getMin();

	lea	eax, DWORD PTR _min$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getMin@Box@ozcollide@@QBE?AVVec3f@2@XZ	; ozcollide::Box::getMin

; 148  : 		Vec3f max = getMax();

	lea	ecx, DWORD PTR _max$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getMax@Box@ozcollide@@QBE?AVVec3f@2@XZ	; ozcollide::Box::getMax

; 149  : 
; 150  : 		if (_pt.x < min.x || _pt.x > max.x ||
; 151  : 			_pt.y < min.y || _pt.y > max.y ||
; 152  : 			_pt.z < min.z || _pt.z > max.z)

	mov	edx, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [edx]
	fld	DWORD PTR _min$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN1@isInside
	mov	eax, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [eax]
	fld	DWORD PTR _max$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@isInside
	mov	ecx, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [ecx+4]
	fld	DWORD PTR _min$[ebp+4]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN1@isInside
	mov	edx, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [edx+4]
	fld	DWORD PTR _max$[ebp+4]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@isInside
	mov	eax, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [eax+8]
	fld	DWORD PTR _min$[ebp+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN1@isInside
	mov	ecx, DWORD PTR __pt$[ebp]
	fld	DWORD PTR [ecx+8]
	fld	DWORD PTR _max$[ebp+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@isInside
$LN1@isInside:

; 153  : 			return false;

	xor	al, al
	jmp	SHORT $LN3@isInside
$LN2@isInside:

; 154  : 
; 155  : 		return true;

	mov	al, 1
$LN3@isInside:

; 156  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?isInside@Box@ozcollide@@QBE_NABVVec3f@2@@Z ENDP	; ozcollide::Box::isInside
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getMin@Box@ozcollide@@QBE?AVVec3f@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getMin@Box@ozcollide@@QBE?AVVec3f@2@XZ PROC		; ozcollide::Box::getMin, COMDAT
; _this$ = ecx

; 66   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 		return center - extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 68   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?getMin@Box@ozcollide@@QBE?AVVec3f@2@XZ ENDP		; ozcollide::Box::getMin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getMax@Box@ozcollide@@QBE?AVVec3f@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getMax@Box@ozcollide@@QBE?AVVec3f@2@XZ PROC		; ozcollide::Box::getMax, COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 73   : 		return center + extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??HVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 74   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?getMax@Box@ozcollide@@QBE?AVVec3f@2@XZ ENDP		; ozcollide::Box::getMax
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3f50624de0000000
PUBLIC	__real@bf50624de0000000
PUBLIC	??AVec3f@ozcollide@@QBEMH@Z			; ozcollide::Vec3f::operator[]
PUBLIC	__real@7f7fffff
PUBLIC	__real@ff7fffff
PUBLIC	?intersectRayBox@ozcollide@@YA?AW4PLANE@1@ABVVec3f@1@0ABVBox@1@AAM2@Z ; ozcollide::intersectRayBox
;	COMDAT __real@3ff0000000000000
; File i:\svnroot\client\sdk\ozcollide\intr_linebox.cpp
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f50624de0000000
CONST	SEGMENT
__real@3f50624de0000000 DQ 03f50624de0000000r	; 0.001
CONST	ENDS
;	COMDAT __real@bf50624de0000000
CONST	SEGMENT
__real@bf50624de0000000 DQ 0bf50624de0000000r	; -0.001
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+038
CONST	ENDS
;	COMDAT __real@ff7fffff
CONST	SEGMENT
__real@ff7fffff DD 0ff7fffffr			; -3.40282e+038
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
tv302 = -84						; size = 8
tv300 = -76						; size = 8
tv298 = -68						; size = 8
tv296 = -60						; size = 8
_t$6672 = -52						; size = 4
_inv$6670 = -48						; size = 4
_max$ = -44						; size = 12
_t1$ = -32						; size = 4
_ret$ = -28						; size = 4
_b$ = -24						; size = 4
_t2$ = -20						; size = 4
_min$ = -16						; size = 12
_a$ = -4						; size = 4
_rayOrg$ = 8						; size = 4
_rayDir$ = 12						; size = 4
_box$ = 16						; size = 4
_tnear$ = 20						; size = 4
_tfar$ = 24						; size = 4
?intersectRayBox@ozcollide@@YA?AW4PLANE@1@ABVVec3f@1@0ABVBox@1@AAM2@Z PROC ; ozcollide::intersectRayBox

; 173  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 174  : 	float t1, t2;
; 175  : 	int ret = -1;

	mov	DWORD PTR _ret$[ebp], -1

; 176  : 
; 177  : 	tnear = -FLT_MAX;

	mov	eax, DWORD PTR _tnear$[ebp]
	fld	DWORD PTR __real@ff7fffff
	fstp	DWORD PTR [eax]

; 178  : 	tfar = FLT_MAX;

	mov	ecx, DWORD PTR _tfar$[ebp]
	fld	DWORD PTR __real@7f7fffff
	fstp	DWORD PTR [ecx]

; 179  : 
; 180  : 	Vec3f min = box.getMin();

	lea	edx, DWORD PTR _min$[ebp]
	push	edx
	mov	ecx, DWORD PTR _box$[ebp]
	call	?getMin@Box@ozcollide@@QBE?AVVec3f@2@XZ	; ozcollide::Box::getMin

; 181  : 	Vec3f max = box.getMax();

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	mov	ecx, DWORD PTR _box$[ebp]
	call	?getMax@Box@ozcollide@@QBE?AVVec3f@2@XZ	; ozcollide::Box::getMax

; 182  : 
; 183  : 	int a, b;
; 184  : 	for (a = 0; a < 3; a++) {

	mov	DWORD PTR _a$[ebp], 0
	jmp	SHORT $LN15@intersectR
$LN14@intersectR:
	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 1
	mov	DWORD PTR _a$[ebp], ecx
$LN15@intersectR:
	cmp	DWORD PTR _a$[ebp], 3
	jge	$LN13@intersectR

; 185  : 		if (rayDir[a] > -0.001f && rayDir[a] < 0.001f) {

	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _rayDir$[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	fcomp	QWORD PTR __real@bf50624de0000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN12@intersectR
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rayDir$[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	fcomp	QWORD PTR __real@3f50624de0000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN12@intersectR

; 186  : 			if (rayOrg[a] < min[a] || rayOrg[a] > max[a])

	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _rayOrg$[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	lea	ecx, DWORD PTR _min$[ebp]
	fstp	QWORD PTR tv296[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	fcomp	QWORD PTR tv296[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN10@intersectR
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rayOrg$[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _max$[ebp]
	fstp	QWORD PTR tv298[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	fcomp	QWORD PTR tv298[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN11@intersectR
$LN10@intersectR:

; 187  : 				return (PLANE) -1;

	mov	eax, -1
	jmp	$LN16@intersectR
$LN11@intersectR:

; 188  : 		}
; 189  : 		else {

	jmp	$LN4@intersectR
$LN12@intersectR:

; 190  : 			float inv = 1.0f / rayDir[a];

	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	ecx, DWORD PTR _rayDir$[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _inv$6670[ebp]

; 191  : 			t1 = (min[a] - rayOrg[a]) * inv;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _min$[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _rayOrg$[ebp]
	fstp	QWORD PTR tv300[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	fsubr	QWORD PTR tv300[ebp]
	fmul	DWORD PTR _inv$6670[ebp]
	fstp	DWORD PTR _t1$[ebp]

; 192  : 			t2 = (max[a] - rayOrg[a]) * inv;

	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	lea	ecx, DWORD PTR _max$[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rayOrg$[ebp]
	fstp	QWORD PTR tv302[ebp]
	call	??AVec3f@ozcollide@@QBEMH@Z		; ozcollide::Vec3f::operator[]
	fsubr	QWORD PTR tv302[ebp]
	fmul	DWORD PTR _inv$6670[ebp]
	fstp	DWORD PTR _t2$[ebp]

; 193  : 			if (t1 > t2) {

	fld	DWORD PTR _t1$[ebp]
	fld	DWORD PTR _t2$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN8@intersectR

; 194  : 				float t = t1; t1 = t2; t2 = t;

	fld	DWORD PTR _t1$[ebp]
	fstp	DWORD PTR _t$6672[ebp]
	fld	DWORD PTR _t2$[ebp]
	fstp	DWORD PTR _t1$[ebp]
	fld	DWORD PTR _t$6672[ebp]
	fstp	DWORD PTR _t2$[ebp]

; 195  : 				b = a * 2 + 1;

	mov	ecx, DWORD PTR _a$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+1]
	mov	DWORD PTR _b$[ebp], edx

; 196  : 			}
; 197  : 			else

	jmp	SHORT $LN7@intersectR
$LN8@intersectR:

; 198  : 				b = a * 2;

	mov	eax, DWORD PTR _a$[ebp]
	shl	eax, 1
	mov	DWORD PTR _b$[ebp], eax
$LN7@intersectR:

; 199  : 
; 200  : 			if (t1 > tnear) {

	fld	DWORD PTR _t1$[ebp]
	mov	ecx, DWORD PTR _tnear$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@intersectR

; 201  : 				tnear = t1;

	mov	edx, DWORD PTR _tnear$[ebp]
	fld	DWORD PTR _t1$[ebp]
	fstp	DWORD PTR [edx]

; 202  : 				ret = b;

	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN6@intersectR:

; 203  : 			}
; 204  : 			if (t2 < tfar)

	fld	DWORD PTR _t2$[ebp]
	mov	ecx, DWORD PTR _tfar$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN5@intersectR

; 205  : 				tfar = t2;

	mov	edx, DWORD PTR _tfar$[ebp]
	fld	DWORD PTR _t2$[ebp]
	fstp	DWORD PTR [edx]
$LN5@intersectR:

; 206  : 			if (tnear > tfar || tfar < 0.001f)

	mov	eax, DWORD PTR _tnear$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _tfar$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN3@intersectR
	mov	edx, DWORD PTR _tfar$[ebp]
	fld	DWORD PTR [edx]
	fcomp	QWORD PTR __real@3f50624de0000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@intersectR
$LN3@intersectR:

; 207  : 				return (PLANE) -1;

	mov	eax, -1
	jmp	SHORT $LN16@intersectR
$LN4@intersectR:

; 208  : 		}
; 209  : 	}

	jmp	$LN14@intersectR
$LN13@intersectR:

; 210  : 
; 211  : 	if (tnear > tfar || tfar < 0.001f)

	mov	eax, DWORD PTR _tnear$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _tfar$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@intersectR
	mov	edx, DWORD PTR _tfar$[ebp]
	fld	DWORD PTR [edx]
	fcomp	QWORD PTR __real@3f50624de0000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@intersectR
$LN1@intersectR:

; 212  : 		return (PLANE) -1;

	mov	eax, -1
	jmp	SHORT $LN16@intersectR
$LN2@intersectR:

; 213  : 
; 214  : 	return (PLANE) ret;

	mov	eax, DWORD PTR _ret$[ebp]
$LN16@intersectR:

; 215  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?intersectRayBox@ozcollide@@YA?AW4PLANE@1@ABVVec3f@1@0ABVBox@1@AAM2@Z ENDP ; ozcollide::intersectRayBox
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
_TEXT	ENDS
;	COMDAT ??AVec3f@ozcollide@@QBEMH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_val$ = -4						; size = 4
__i$ = 8						; size = 4
??AVec3f@ozcollide@@QBEMH@Z PROC			; ozcollide::Vec3f::operator[], COMDAT
; _this$ = ecx

; 146  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		const float *val = &x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 148  : 		return val[_i];

	mov	ecx, DWORD PTR __i$[ebp]
	mov	edx, DWORD PTR _val$[ebp]
	fld	DWORD PTR [edx+ecx*4]

; 149  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??AVec3f@ozcollide@@QBEMH@Z ENDP			; ozcollide::Vec3f::operator[]
_TEXT	ENDS
END
